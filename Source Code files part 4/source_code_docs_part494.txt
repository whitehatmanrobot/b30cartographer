lar address.</summary>
 <param name="target">The target expression.</param>
 <param name="value">The value to set at the address.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressOf(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents getting the address of a value.</summary>
 <param name="target">The target expression.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr">
 <summary>Quoted expressions annotated with System.Type values. </summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Type">
 <summary>The type associated with the variable</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Name">
 <summary>The declared name of the variable</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.IsMutable">
 <summary>Indicates if the variable represents a mutable storage location</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.Global(System.String,System.Type)">
 <summary>Fetches or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type</summary>
 <param name="name">The name of the variable.</param>
 <param name="typ">The type associated with the variable.</param>
 <returns>The retrieved or created variable.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.#ctor(System.String,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Creates a new variable with the given name, type and mutability</summary>
 <param name="name">The declared name of the variable.</param>
 <param name="typ">The type associated with the variable.</param>
 <param name="isMutable">Indicates if the variable represents a mutable storage location. Default is false.</param>
 <returns>The created variable.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpVar">
 <summary>Information at the binding site of a variable</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Re-build combination expressions. The first parameter should be an object
 returned by the <c>ShapeCombination</c> case of the active pattern in this module.</summary>
 <param name="shape">The input shape.</param>
 <param name="arguments">The list of arguments.</param>
 <returns>The rebuilt expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.ShapePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern that performs a complete decomposition viewing the expression tree as a binding structure</summary>
 <param name="input">The input expression.</param>
 <returns>The decomposed Var, Lambda, or ConstApp.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShapeModule">
 <summary>Active patterns for traversing, visiting, rebuilding and tranforming expressions in a generic way</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertySetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>An active pattern to recognize property setters that have an associated ReflectedDefinition</summary>
 <param name="propertyInfo">The description of the property.</param>
 <returns>The expression of the method definition if found, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertyGetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>An active pattern to recognize property getters or values in modules that have an associated ReflectedDefinition</summary>
 <param name="propertyInfo">The description of the property.</param>
 <returns>The expression of the method definition if found, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.MethodWithReflectedDefinitionPattern(System.Reflection.MethodBase)">
 <summary>An active pattern to recognize methods that have an associated ReflectedDefinition</summary>
 <param name="methodBase">The description of the method.</param>
 <returns>The expression of the method definition if found, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SpecificCallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>A parameterized active pattern to recognize calls to a specified function or method.
 The returned elements are the optional target object (present if the target is an 
 instance method), the generic type instantation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.</summary>
 <param name="templateParameter">The input template expression to specify the method to call.</param>
 <returns>The optional target object (present if the target is an 
 instance method), the generic type instantation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int64 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>uint64 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int64 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>int64 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int32 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>uint32 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int32 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>int32 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int16 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>uint16 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int16 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>int16 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant byte expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>byte option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SBytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant signed byte expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>sbyte option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.CharPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unicode character expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>char  option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.DoublePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant 64-bit floating point number expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>float option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SinglePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant 32-bit floating point number expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>float32 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.StringPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant string expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>string option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BoolPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant boolean expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>bool option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UnitPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize <c>()</c> constant expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>unit option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.OrElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions of the form <c>a || b</c> </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.AndAlsoPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions of the form <c>a &amp;&amp; b</c> </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.ApplicationsPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the application of a (possibly curried or tupled) first class function value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr list list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.LambdasPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a (possibly curried or tupled) first class function value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var list list * Expr) option</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatternsModule">
 <summary>Contains a set of derived F# active patterns to analyze F# expression objects</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a mutable variable</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a variable</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Var option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a constant value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(obj * Type) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.UnionCaseTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a test if a value is of a particular union case</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * UnionCaseInfo) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TypeTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a dynamic type test</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Type) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TupleGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting a tuple field</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * int) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryFinallyPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a try/finally construct </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryWithPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a try/with construct for exception filtering and catching </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Var * Expr * Var * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.SequentialPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent sequential exeuction of one expression followed by another</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuotePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a nested quotation literal</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Expr option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertySetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a static or instance property, or a non-function value declared in a module</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * PropertyInfo * Expr list * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertyGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the read of a static or instance property, or a non-function value declared in a module</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * PropertyInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewTuplePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of tuple values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewUnionCasePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of particular union case values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(UnionCaseInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewRecordPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of record values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Type * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewObjectPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent invocation of object constructors</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(ConstructorInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewDelegatePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of delegate values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Type * Var list * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.DefaultValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent invocations of a default constructor of a struct</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Type option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewArrayPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the construction of arrays </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Type * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetRecursivePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent recursive let bindings of one or more variables</summary>
 <param name="input">The input expression to match against.</param>
 <returns>((Var * Expr) list * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent let bindings</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LambdaPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent first class function values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.IfThenElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent conditionals</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.WhileLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent while loops </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ForIntegerRangeLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent loops over integer ranges</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr * Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a static or instance field </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * FieldInfo * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting a static or instance field </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * FieldInfo) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CoercePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent coercions from one type to another</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Type) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * MethodInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ApplicationPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent applications of first class function values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting the value held at an address </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressOfPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting the address of a value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Expr option</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.PatternsModule">
 <summary>Contains a set of primitive F# active patterns to analyze F# expression objects</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[])">
 <summary>Returns a <c>System.Type</c> representing an F# tuple type with the given element types</summary>
 <param name="types">An array of types for the tuple elements.</param>
 <returns>The type representing the tuple containing the input elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
 <summary>Returns a <c>System.Type</c> representing the F# function type with the given domain and range</summary>
 <param name="domain">The input type of the function.</param>
 <param name="range">The output type of the function.</param>
 <returns>The function type with the given domain and range.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# union type or the runtime type of a value of that type</summary>
 <param name="typ">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
 <summary>Return true if the <c>typ</c> is a representation of an F# tuple type </summary>
 <param name="typ">The type to check.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Return true if the <c>typ</c> is a representation of an F# record type </summary>
 <param name="typ">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
 <summary>Return true if the <c>typ</c> is a <c>System.Type</c> value corresponding to the compiled form of an F# module </summary>
 <param name="typ">The type to check.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
 <summary>Return true if the <c>typ</c> is a representation of an F# function type or the runtime type of a closure implementing an F# function type</summary>
 <param name="typ">The type to check.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsExceptionRepresentation(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# exception declaration</summary>
 <param name="exceptionType">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>True if the type check is an F# exception.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Gets the cases of a union type.</summary>

 <remarks>Assumes the given type is a union type. If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="unionType">The input union type.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a union type.</exception>
 <returns>An array of descriptions of the cases of the given union type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
 <summary>Gets the tuple elements from the representation of an F# tuple type.</summary>
 <param name="tupleType">The input tuple type.</param>
 <returns>An array of the types contained in the given tuple type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a record value, in declaration order</summary>

 <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
 <param name="recordType">The input record type.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>An array of descriptions of the properties of the record type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
 <summary>Gets the domain and range types from an F# function type  or from the runtime type of a closure implementing an F# type</summary>
 <param name="functionType">The input function type.</param>
 <returns>A tuple of the domain and range types of the input function.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetExceptionFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from an F# exception declaration, in declaration order</summary>

 <remarks>Assumes <c>exceptionType</c> is an exception representation type. If not, ArgumentException is raised.</remarks>
 <param name="exceptionType">The exception type to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown if the given type is not an exception.</exception>
 <returns>An array containing the PropertyInfo of each field in the exception.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">
 <summary>Contains operations associated with constructing and analyzing F# types such as records, unions and tuples</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.</summary>

 <remarks>Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
 <param name="unionType">The type of union to optimize reading.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>An optimized function to read the tags of the given union type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a property or static method for reading an integer representing the case tag of a union type.</summary>
 <param name="unionType">The type of union to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>The description of the union case reader.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precomputes a function for reading all the fields for a particular discriminator case of a union type</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to GetFields</remarks>
 <param name="unionCase">The description of the union case to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>A function to for reading the fields of the given union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>A method that constructs objects of the given case</summary>
 <param name="unionCase">The description of the union case.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>The description of the constructor of the given union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precomputes a function for constructing a discriminated union value for a particular union case. </summary>
 <param name="unionCase">The description of the union case.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>A function for constructing values of the given union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)">
 <summary>Precomputes a function for reading the values of a particular tuple type</summary>

 <remarks>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="tupleType">The tuple type to read.</param>
 <exception cref="System.ArgumentException">Thrown when the given type is not a tuple type.</exception>
 <returns>A function to read values of the given tuple type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)">
 <summary>Gets information that indicates how to read a field of a tuple</summary>
 <param name="tupleType">The input tuple type.</param>
 <param name="index">The index of the tuple element to describe.</param>
 <returns>The description of the tuple element and an optional type and index if the tuple is big.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)">
 <summary>Gets a method that constructs objects of the given tuple type. 
 For small tuples, no additional type will be returned.</summary>
 
 <remarks>For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.</remarks>
 <param name="tupleType">The input tuple type.</param>
 <returns>The description of the tuple type constructor and an optional extra type
 for large tuples.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)">
 <summary>Precomputes a function for reading the values of a particular tuple type</summary>

 <remarks>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="tupleType">The type of tuple to read.</param>
 <exception cref="System.ArgumentException">Thrown when the given type is not a tuple type.</exception>
 <returns>A function to read a particular tuple type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.</summary>

 <remarks>Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
 <param name="recordType">The type of record to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>An optimized reader for the given record type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)">
 <summary>Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
 <param name="info">The PropertyInfo of the field to read.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>A function to read the specified field from the record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Get a ConstructorInfo for a record type</summary>
 <param name="recordType">The record type.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>A ConstructorInfo for the given record type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for constructing a record value. </summary>

 <remarks>Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="recordType">The type of record to construct.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>A function to construct records of the given type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Create a union case value.</summary>
 <param name="unionCase">The description of the union case to create.</param>
 <param name="args">The array of arguments to construct the given case.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>The constructed union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[],System.Type)">
 <summary>Creates an instance of a tuple type</summary>

 <remarks>Assumes at least one element is given. If not, ArgumentException is raised.</remarks>
 <param name="tupleElements">The array of tuple fields.</param>
 <param name="tupleType">The tuple type to create.</param>
 <exception cref="System.ArgumentException">Thrown if no elements are given.</exception>
 <returns>An instance of the tuple type with the given elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Creates an instance of a record type.</summary>

 <remarks>Assumes the given input is a record type.</remarks>
 <param name="recordType">The type of record to make.</param>
 <param name="values">The array of values to initialize the record.</param>
 <param name="bindingFlags">Optional binding flags for the record.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>The created record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FSharpFunc`2{System.Object,System.Object})">
 <summary>Builds a typed function from object from a dynamic function implementation</summary>
 <param name="functionType">The function type of the implementation.</param>
 <param name="implementation">The untyped lambda of the function implementation.</param>
 <returns>A typed function from the given dynamic implementation.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Identify the union case and its fields for an object</summary>

 <remarks>Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the 'null'.</remarks>
 <param name="value">The input union case.</param>
 <param name="unionType">The union type containing the value.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a union case value.</exception>
 <returns>The description of the union case and its fields.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">
 <summary>Reads all fields from a tuple.</summary>

 <remarks>Assumes the given input is a tuple value. If not, ArgumentException is raised.</remarks>
 <param name="tuple">The input tuple.</param>
 <exception cref="System.ArgumentException">Thrown when the input is not a tuple value.</exception>
 <returns>An array of the fields from the given tuple.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">
 <summary>Reads a field from a tuple value.</summary>

 <remarks>Assumes the given input is a tuple value. If not, ArgumentException is raised.</remarks>
 <param name="tuple">The input tuple.</param>
 <param name="index">The index of the field to read.</param>
 <returns>The value of the field.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
 <param name="record">The record object.</param>
 <param name="bindingFlags">Optional binding flags for the record.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>The array of fields from the record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
 <summary>Reads a field from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
 <param name="record">The record object.</param>
 <param name="info">The PropertyInfo describing the field to read.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>The field from the record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a value built using an instance of an F# exception declaration</summary>

 <remarks>Assumes the given input is an F# exception value. If not, ArgumentException is raised.</remarks>
 <param name="exn">The exception instance.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not an F# exception.</exception>
 <returns>The fields from the given exception.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">
 <summary>Contains operations associated with constructing and analyzing values associated with F# types
 such as records, unions and tuples.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
 <summary>The integer tag for the case.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
 <summary>The name of the case.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
 <summary>The type in which the case occurs.</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
 <summary>The fields associated with the case, represented by a PropertyInfo.</summary>
 <returns>The fields associated with the case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes(System.Type)">
 <summary>Returns the custom attributes associated with the case matching the given attribute type.</summary>
 <param name="attributeType">The type of attributes to return.</param>
 <returns>An array of custom attributes.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes">
 <summary>Returns the custom attributes associated with the case.</summary>
 <returns>An array of custom attributes.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
 <summary>Represents a case of a discriminated union type</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 &lt;example&gt;
 From F# Interactive the default settings can be adjusted using, for example, 
 &lt;pre&gt;
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 &lt;/pre&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Layout">
<summary>
 Data representing structured layouts of terms.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.layout_to_string(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the &quot;[1;2]&quot; notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_HatHat(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
</members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\fxcop\1.36\x86\Repository\Compatibility\Desktop2.0SP1.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<CompatibilityEntry Name=".NET Framework 2.0 Service Pack 1"
                    Platform="Desktop" 
                    Version="2.0.1" 
                    Priority="3001">

  <Member>Microsoft.IE.SecureFactory.#CreateInstanceWithSecurity2(System.Int32,System.Int32,System.String,System.String,System.String,System.String,System.String)</Member>
  <Type>Microsoft.IE.ISecureFactory2</Type>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#get_AllowedRelatedFileExtensions()</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#set_AllowedRelatedFileExtensions(System.String[])</Member>
  <Type>Microsoft.Build.Tasks.ConvertToAbsolutePath</Type>
  <Member>Microsoft.Build.Tasks.GenerateTrustInfo.#get_ApplicationDependencies()</Member>
  <Member>Microsoft.Build.Tasks.GenerateTrustInfo.#set_ApplicationDependencies(Microsoft.Build.Framework.ITaskItem[])</Member>
  <Member>Microsoft.Build.Tasks.FindUnderPath.#get_UpdateToAbsolutePaths()</Member>
  <Member>Microsoft.Build.Tasks.FindUnderPath.#set_UpdateToAbsolutePaths(System.Boolean)</Member>
  <Member>Microsoft.Build.Tasks.VCBuild.#get_AdditionalLinkLibraryPaths()</Member>
  <Member>Microsoft.Build.Tasks.VCBuild.#set_AdditionalLinkLibraryPaths(Microsoft.Build.Framework.ITaskItem[])</Member>
  <Member>Microsoft.Build.Tasks.VCBuild.#get_UseEnvironment()</Member>
  <Member>Microsoft.Build.Tasks.VCBuild.#set_UseEnvironment(System.Boolean)</Member>
  <Member>Microsoft.Build.Utilities.TaskLoggingHelper.#LogErrorFromException(System.Exception,System.Boolean,System.Boolean,System.String)</Member>
  <Member>Microsoft.Build.Utilities.ToolTask.#DeleteTempFile(System.String)</Member>
  <Type>System.DateTimeOffset</Type>
  <Member>System.AppDomain.#DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable`1&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;)</Member>
  <Member>System.AppDomain.#DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable`1&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;)</Member>
  <Member>System.AppDomainSetup.#get_SandboxInterop()</Member>
  <Member>System.AppDomainSetup.#set_SandboxInterop(System.Boolean)</Member>
  <Member>System.ActivationContext.#get_ApplicationManifestBytes()</Member>
  <Member>System.ActivationContext.#get_DeploymentManifestBytes()</Member>
  <Member>System.Deployment.Internal.InternalActivationContextHelper.#GetApplicationManifestBytes(System.ActivationContext)</Member>
  <Member>System.Deployment.Internal.InternalActivationContextHelper.#GetDeploymentManifestBytes(System.ActivationContext)</Member>
  <Type>System.GCCollectionMode</Type>
  <Member>System.GC.#Collect(System.Int32,System.GCCollectionMode)</Member>
  <Member>System.Reflection.Assembly.#Equals(System.Object)</Member>
  <Member>System.Reflection.Assembly.#GetHashCode()</Member>
  <Member>System.Reflection.Module.#Equals(System.Object)</Member>
  <Member>System.Reflection.Module.#GetHashCode()</Member>
  <Member>System.Runtime.Serialization.FormatterServices.#GetSurrogateForCyclicalReference(System.Runtime.Serialization.ISerializationSurrogate)</Member>
  <Type>System.Runtime.GCLatencyMode</Type>
  <Member>System.Runtime.GCSettings.#get_LatencyMode()</Member>
  <Member>System.Runtime.GCSettings.#set_LatencyMode(System.Runtime.GCLatencyMode)</Member>
  <Member>System.Security.Permissions.ReflectionPermissionAttribute.#get_RestrictedMemberAccess()</Member>
  <Member>System.Security.Permissions.ReflectionPermissionAttribute.#set_RestrictedMemberAccess(System.Boolean)</Member>
  <Member>System.Security.Permissions.ReflectionPermissionFlag.#RestrictedMemberAccess</Member>
  <Member>System.Reflection.Emit.DynamicMethod.#.ctor(System.String,System.Type,System.Type[])</Member>
  <Member>System.Reflection.Emit.DynamicMethod.#.ctor(System.String,System.Type,System.Type[],System.Boolean)</Member>
  <Member>System.Reflection.Emit.SignatureHelper.#GetPropertySigHelper(System.Reflection.Module,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])</Member>
  <Member>System.Reflection.Emit.TypeBuilder.#DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])</Member>
  <Member>System.Security.Cryptography.HMACSHA384.#get_ProduceLegacyHmacValues()</Member>
  <Member>System.Security.Cryptography.HMACSHA384.#set_ProduceLegacyHmacValues(System.Boolean)</Member>
  <Member>System.Security.Cryptography.HMACSHA512.#get_ProduceLegacyHmacValues()</Member>
  <Member>System.Security.Cryptography.HMACSHA512.#set_ProduceLegacyHmacValues(System.Boolean)</Member>
  <Type>System.Configuration.OverrideMode</Type>
  <Member>System.Configuration.SectionInformation.#get_OverrideModeDefault()</Member>
  <Member>System.Configuration.SectionInformation.#set_OverrideModeDefault(System.Configuration.OverrideMode)</Member>
  <Member>System.Configuration.SectionInformation.#get_OverrideMode()</Member>
  <Member>System.Configuration.SectionInformation.#set_OverrideMode(System.Configuration.OverrideMode)</Member>
  <Member>System.Configuration.SectionInformation.#get_OverrideModeEffective()</Member>
  <Member>Microsoft.SqlServer.Server.SqlDataRecord.#GetDateTimeOffset(System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlDataRecord.#GetTimeSpan(System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlDataRecord.#SetTimeSpan(System.Int32,System.TimeSpan)</Member>
  <Member>Microsoft.SqlServer.Server.SqlDataRecord.#SetDateTimeOffset(System.Int32,System.DateTimeOffset)</Member>
  <Member>Microsoft.SqlServer.Server.SqlDataRecord.#SetDBNull(System.Int32)</Member>
  <Member>System.Data.DbType.#DateTime2</Member>
  <Member>System.Data.DbType.#DateTimeOffset</Member>
  <Member>System.Data.SqlDbType.#Structured</Member>
  <Member>System.Data.SqlDbType.#Date</Member>
  <Member>System.Data.SqlDbType.#Time</Member>
  <Member>System.Data.SqlDbType.#DateTime2</Member>
  <Member>System.Data.SqlDbType.#DateTimeOffset</Member>
  <Member>System.Data.Common.DbDataRecord.#.ctor()</Member>
  <Member>System.Data.Common.DbDataRecord.#GetDbDataReader(System.Int32)</Member>
  <Member>System.Data.Common.DbConnection.#get_DbProviderFactory()</Member>
  <Member>System.Data.Common.DbDataAdapter.#GetBatchedRecordsAffected(System.Int32,System.Int32&amp;,System.Exception&amp;)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Int64,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Type,System.String)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Type,System.String,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Byte,System.Byte,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Int64,System.Int64,System.Data.SqlTypes.SqlCompareOptions,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#.ctor(System.String,System.Data.SqlDbType,System.Int64,System.Byte,System.Byte,System.Int64,System.Data.SqlTypes.SqlCompareOptions,System.Type,System.Boolean,System.Boolean,System.Data.SqlClient.SortOrder,System.Int32)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#get_IsUniqueKey()</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#get_SortOrder()</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#get_SortOrdinal()</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#get_UseServerDefault()</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#Adjust(System.TimeSpan)</Member>
  <Member>Microsoft.SqlServer.Server.SqlMetaData.#Adjust(System.DateTimeOffset)</Member>
  <Type>System.Data.SqlClient.SortOrder</Type>
  <Member>System.Data.SqlClient.SqlClientFactory.#System.IServiceProvider.GetService(System.Type)</Member>
  <Member>System.Data.SqlClient.SqlConnection.#get_DbProviderFactory()</Member>
  <Member>System.Data.SqlClient.SqlConnectionStringBuilder.#get_TransactionBinding()</Member>
  <Member>System.Data.SqlClient.SqlConnectionStringBuilder.#set_TransactionBinding(System.String)</Member>
  <Member>System.Data.SqlClient.SqlDataAdapter.#GetBatchedRecordsAffected(System.Int32,System.Int32&amp;,System.Exception&amp;)</Member>
  <Member>System.Data.SqlClient.SqlDataReader.#GetTimeSpan(System.Int32)</Member>
  <Member>System.Data.SqlClient.SqlDataReader.#GetDateTimeOffset(System.Int32)</Member>
  <Member>System.Data.SqlClient.SqlNotificationInfo.#Merge</Member>
  <Member>System.Data.SqlClient.SqlParameter.#get_TypeName()</Member>
  <Member>System.Data.SqlClient.SqlParameter.#set_TypeName(System.String)</Member>
  <Member>System.Data.OracleClient.OracleDataAdapter.#GetBatchedRecordsAffected(System.Int32,System.Int32&amp;,System.Exception&amp;)</Member>
  <Member>System.Xml.Xsl.Runtime.XmlCollation.#Equals(System.Object)</Member>
  <Member>System.Xml.Xsl.Runtime.XmlCollation.#GetHashCode()</Member>
  <Member>System.Xml.Xsl.Runtime.XmlQueryContext.#OnXsltMessageEncountered(System.String)</Member>
  <Member>System.Xml.Xsl.Runtime.XmlQueryRuntime.#OnCurrentNodeChanged(System.Xml.XPath.XPathNavigator)</Member>
  <Member>System.Deployment.Application.DeploymentServiceCom.#ActivateApplicationExtension(System.String,System.String,System.String)</Member>
  <Member>System.Deployment.Application.InPlaceHostingManager.#UninstallCustomAddIn(System.String)</Member>
  <Member>System.Deployment.Application.GetManifestCompletedEventArgs.#get_ActivationContext()</Member>
  <Member>System.Deployment.Application.GetManifestCompletedEventArgs.#get_SubscriptionIdentity()</Member>
  <Type>System.Data.Design.TypedDataSetGenerator+GenerateOption</Type>
  <Member>System.Data.Design.TypedDataSetGenerator.#Generate(System.String,System.CodeDom.CodeCompileUnit,System.CodeDom.CodeNamespace,System.CodeDom.Compiler.CodeDomProvider,System.Collections.Hashtable,System.Data.Design.TypedDataSetGenerator+GenerateOption)</Member>
  <Member>System.Data.Design.TypedDataSetGenerator.#Generate(System.String,System.CodeDom.CodeCompileUnit,System.CodeDom.CodeNamespace,System.CodeDom.Compiler.CodeDomProvider,System.Collections.Hashtable,System.Data.Design.TypedDataSetGenerator+GenerateOption,System.String)</Member>
  <Member>System.Data.Design.TypedDataSetGenerator.#Generate(System.String,System.CodeDom.CodeCompileUnit,System.CodeDom.CodeNamespace,System.CodeDom.Compiler.CodeDomProvider,System.Data.Design.TypedDataSetGenerator+GenerateOption)</Member>
  <Member>System.Data.Design.TypedDataSetGenerator.#Generate(System.String,System.CodeDom.CodeCompileUnit,System.CodeDom.CodeNamespace,System.CodeDom.Compiler.CodeDomProvider,System.Data.Design.TypedDataSetGenerator+GenerateOption,System.String)</Member>
  <Member>System.Data.Design.TypedDataSetSchemaImporterExtension.#.ctor(System.Data.Design.TypedDataSetGenerator+GenerateOption)</Member>
  <Type>System.Data.Design.TypedDataSetSchemaImporterExtensionFx35</Type>
  <Member>System.Web.UI.Design.ControlDesigner.#get_Visible()</Member>
  <Member>System.Web.UI.Design.ViewRendering.#.ctor(System.String,System.Web.UI.Design.DesignerRegionCollection,System.Boolean)</Member>
  <Member>System.Web.UI.Design.ViewRendering.#get_Visible()</Member>
  <Member>System.DirectoryServices.ActiveDirectory.DomainMode.#Windows2008Domain</Member>
  <Member>System.DirectoryServices.ActiveDirectory.ForestMode.#Windows2008Forest</Member>
  <Member>System.DirectoryServices.ActiveDirectory.LocatorOptions.#WriteableRequired</Member>
  <Member>System.DirectoryServices.Protocols.LdapDirectoryIdentifier.#.ctor(System.String,System.Int32)</Member>
  <Member>System.DirectoryServices.Protocols.LdapDirectoryIdentifier.#.ctor(System.String,System.Int32,System.Boolean,System.Boolean)</Member>
  <Member>System.DirectoryServices.Protocols.LdapDirectoryIdentifier.#.ctor(System.String[],System.Int32,System.Boolean,System.Boolean)</Member>
  <Member>System.DirectoryServices.Protocols.LdapDirectoryIdentifier.#get_PortNumber()</Member>
  <Member>System.DirectoryServices.Protocols.LdapException.#.ctor(System.Int32,System.String,System.String)</Member>
  <Member>System.DirectoryServices.Protocols.LdapException.#get_ServerErrorMessage()</Member>
  <Type>System.ComponentModel.INotifyPropertyChanging</Type>
  <Type>System.ComponentModel.PropertyChangingEventArgs</Type>
  <Type>System.ComponentModel.PropertyChangingEventHandler</Type>
  <Type>System.ComponentModel.Design.IDesignerHostTransactionState</Type>
  <Type>System.ComponentModel.Design.Serialization.IDesignerLoaderHost2</Type>
  <Member>Microsoft.CSharp.CSharpCodeProvider.#.ctor(System.Collections.Generic.IDictionary`2&lt;System.String,System.String&gt;)</Member>
  <Member>Microsoft.VisualBasic.VBCodeProvider.#.ctor(System.Collections.Generic.IDictionary`2&lt;System.String,System.String&gt;)</Member>
  <Type>System.UriIdnScope</Type>
  <Member>System.GenericUriParserOptions.#Idn</Member>
  <Member>System.GenericUriParserOptions.#IriParsing</Member>
  <Member>System.Net.Sockets.SocketException.#get_Message()</Member>
  <Member>System.Net.Sockets.Socket.#AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#SendAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Member>System.Net.Sockets.Socket.#SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)</Member>
  <Type>System.Net.Sockets.SocketAsyncOperation</Type>
  <Type>System.Net.Sockets.SendPacketsElement</Type>
  <Type>System.Net.Sockets.SocketAsyncEventArgs</Type>
  <Type>System.Configuration.UriSection</Type>
  <Type>System.Configuration.IriParsingElement</Type>
  <Type>System.Configuration.IdnElement</Type>
  <Member>System.Drawing.SystemIcons.#get_Shield()</Member>
  <Member>System.Drawing.Font.#get_OriginalFontName()</Member>
  <Member>System.Management.ManagementBaseObject.#Dispose()</Member>
  <Member>System.Management.ManagementObject.#Dispose()</Member>
  <Member>System.Management.ConnectionOptions.#set_SecurePassword(System.Security.SecureString)</Member>
  <Member>System.Management.ConnectionOptions.#.ctor(System.String,System.String,System.Security.SecureString,System.String,System.Management.ImpersonationLevel,System.Management.AuthenticationLevel,System.Boolean,System.Management.ManagementNamedValueCollection,System.TimeSpan)</Member>
  <Member>System.Web.HttpApplication.#add_MapRequestHandler(System.EventHandler)</Member>
  <Member>System.Web.HttpApplication.#remove_MapRequestHandler(System.EventHandler)</Member>
  <Member>System.Web.HttpApplication.#add_LogRequest(System.EventHandler)</Member>
  <Member>System.Web.HttpApplication.#remove_LogRequest(System.EventHandler)</Member>
  <Member>System.Web.HttpApplication.#add_PostLogRequest(System.EventHandler)</Member>
  <Member>System.Web.HttpApplication.#remove_PostLogRequest(System.EventHandler)</Member>
  <Member>System.Web.HttpApplication.#AddOnMapRequestHandlerAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)</Member>
  <Member>System.Web.HttpApplication.#AddOnMapRequestHandlerAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)</Member>
  <Member>System.Web.HttpApplication.#AddOnLogRequestAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)</Member>
  <Member>System.Web.HttpApplication.#AddOnLogRequestAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)</Member>
  <Member>System.Web.HttpApplication.#AddOnPostLogRequestAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)</Member>
  <Member>System.Web.HttpApplication.#AddOnPostLogRequestAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)</Member>
  <Member>System.Web.HttpCachePolicy.#get_VaryByContentEncodings()</Member>
  <Type>System.Web.HttpCacheVaryByContentEncodings</Type>
  <Member>System.Web.HttpContext.#get_CurrentNotification()</Member>
  <Member>System.Web.HttpContext.#get_IsPostNotification()</Member>
  <Member>System.Web.HttpResponse.#DisableKernelCache()</Member>
  <Member>System.Web.HttpResponse.#get_Headers()</Member>
  <Member>System.Web.HttpResponse.#get_SubStatusCode()</Member>
  <Member>System.Web.HttpResponse.#set_SubStatusCode(System.Int32)</Member>
  <Member>System.Web.HttpResponse.#get_TrySkipIisCustomErrors()</Member>
  <Member>System.Web.HttpResponse.#set_TrySkipIisCustomErrors(System.Boolean)</Member>
  <Member>System.Web.HttpResponse.#TransmitFile(System.String,System.Int64,System.Int64)</Member>
  <Member>System.Web.HttpRuntime.#GetNamedPermissionSet()</Member>
  <Member>System.Web.ApplicationShutdownReason.#BuildManagerChange</Member>
  <Member>System.Web.HttpServerUtility.#TransferRequest(System.String)</Member>
  <Member>System.Web.HttpServerUtility.#TransferRequest(System.String,System.Boolean)</Member>
  <Member>System.Web.HttpServerUtility.#TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)</Member>
  <Type>System.Web.IisTraceListener</Type>
  <Type>System.Web.RequestNotification</Type>
  <Type>System.Web.RequestNotificationStatus</Type>
  <Member>System.Web.HttpWorkerRequest.#SendCalculatedContentLength(System.Int64)</Member>
  <Member>System.Web.Caching.Cache.#get_EffectivePercentagePhysicalMemoryLimit()</Member>
  <Member>System.Web.Compilation.BuildProvider.#GetCodeCompileUnit(System.Collections.IDictionary&amp;)</Member>
  <Member>System.Web.Compilation.BuildManager.#GetReferencedAssemblies()</Member>
  <Member>System.Web.Compilation.LinePragmaCodeInfo.#.ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)</Member>
  <Type>System.Web.Configuration.IConfigMapPath</Type>
  <Type>System.Web.Configuration.IConfigMapPathFactory</Type>
  <Member>System.Web.Configuration.OutputCacheProfile.#get_VaryByContentEncoding()</Member>
  <Member>System.Web.Configuration.OutputCacheProfile.#set_VaryByContentEncoding(System.String)</Member>
  <Member>System.Web.Configuration.OutputCacheSection.#get_EnableKernelCacheForVaryByStar()</Member>
  <Member>System.Web.Configuration.OutputCacheSection.#set_EnableKernelCacheForVaryByStar(System.Boolean)</Member>
  <Type>System.Web.Configuration.ProtocolsConfigurationHandler</Type>
  <Type>System.Web.Configuration.ProtocolsSection</Type>
  <Type>System.Web.Configuration.ProtocolCollection</Type>
  <Type>System.Web.Configuration.ProtocolElement</Type>
  <Member>System.Web.Configuration.WebContext.#.ctor(System.Web.Configuration.WebApplicationLevel,System.String,System.String,System.String,System.String,System.String)</Member>
  <Member>System.Web.Configuration.WebContext.#ToString()</Member>
  <Type>System.Web.Hosting.AppDomainProtocolHandler</Type>
  <Member>System.Web.Hosting.ApplicationManager.#CreateObject(System.Web.Hosting.IApplicationHost,System.Type)</Member>
  <Member>System.Web.Hosting.HostingEnvironment.#MessageReceived()</Member>
  <Member>System.Web.Hosting.HostingEnvironment.#get_ApplicationHost()</Member>
  <Type>System.Web.Hosting.IApplicationHost</Type>
  <Type>System.Web.Hosting.IProcessHostSupportFunctions</Type>
  <Type>System.Web.Hosting.IProcessPingCallback</Type>
  <Type>System.Web.Hosting.IListenerChannelCallback</Type>
  <Type>System.Web.Hosting.IProcessHost</Type>
  <Type>System.Web.Hosting.IAdphManager</Type>
  <Type>System.Web.Hosting.IPphManager</Type>
  <Type>System.Web.Hosting.IProcessHostIdleAndHealthCheck</Type>
  <Type>System.Web.Hosting.IAppDomainInfo</Type>
  <Type>System.Web.Hosting.IAppDomainInfoEnum</Type>
  <Type>System.Web.Hosting.AppDomainInfoEnum</Type>
  <Type>System.Web.Hosting.AppDomainInfo</Type>
  <Type>System.Web.Hosting.ProcessHost</Type>
  <Type>System.Web.Hosting.IProcessHostFactoryHelper</Type>
  <Type>System.Web.Hosting.ProcessHostFactoryHelper</Type>
  <Type>System.Web.Hosting.ProcessProtocolHandler</Type>
  <Type>System.Web.Management.IisTraceWebEventProvider</Type>
  <Member>System.Web.Management.WebEventCodes.#ApplicationShutdownBuildManagerChange</Member>
  <Member>System.Web.UI.ControlBuilder.#ProcessGeneratedCode(System.CodeDom.CodeCompileUnit,System.CodeDom.CodeTypeDeclaration,System.CodeDom.CodeTypeDeclaration,System.CodeDom.CodeMemberMethod,System.CodeDom.CodeMemberMethod)</Member>
  <Type>System.Web.UI.CssClassPropertyAttribute</Type>
  <Member>System.Web.UI.TemplateControl.#ParseControl(System.String,System.Boolean)</Member>
  <Member>System.Web.UI.Page.#InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)</Member>
  <Member>System.Web.UI.OutputCacheParameters.#get_VaryByContentEncoding()</Member>
  <Member>System.Web.UI.OutputCacheParameters.#set_VaryByContentEncoding(System.String)</Member>
  <Member>System.Web.UI.PageParserFilter.#get_Line()</Member>
  <Member>System.Web.UI.PageParserFilter.#ProcessCodeConstruct(System.Web.UI.CodeConstructType,System.String)</Member>
  <Member>System.Web.UI.PageParserFilter.#ProcessDataBindingAttribute(System.String,System.String,System.String)</Member>
  <Member>System.Web.UI.PageParserFilter.#ProcessEventHookup(System.String,System.String,System.String)</Member>
  <Member>System.Web.UI.PageParserFilter.#GetNoCompileUserControlType()</Member>
  <Member>System.Web.UI.PageParserFilter.#AddControl(System.Type,System.Collections.IDictionary)</Member>
  <Member>System.Web.UI.PageParserFilter.#SetPageProperty(System.String,System.String,System.String)</Member>
  <Type>System.Web.UI.CodeConstructType</Type>
  <Member>System.Web.UI.WebControls.BoundField.#get_HtmlEncodeFormatString()</Member>
  <Member>System.Web.UI.WebControls.BoundField.#set_HtmlEncodeFormatString(System.Boolean)</Member>
  <Member>System.Web.UI.WebControls.CheckBoxField.#get_HtmlEncodeFormatString()</Member>
  <Member>System.Web.UI.WebControls.CheckBoxField.#set_HtmlEncodeFormatString(System.Boolean)</Member>
  <Member>System.Web.UI.WebControls.WebParts.WebZone.#get_PartChromePadding()</Member>
  <Member>System.Web.UI.WebControls.WebParts.WebZone.#set_PartChromePadding(System.Web.UI.WebControls.Unit)</Member>
  <Member>System.Web.UI.MobileControls.MobilePage.#InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)</Member>
  <Member>System.Windows.Forms.Control.#get_CanEnableIme()</Member>
  <Member>System.Windows.Forms.ContainerControl.#get_CanEnableIme()</Member>
  <Member>System.Windows.Forms.TextBoxBase.#get_CanEnableIme()</Member>
  <Member>System.Windows.Forms.DataGridView.#get_CanEnableIme()</Member>
  <Member>System.Windows.Forms.FileDialog.#get_CustomPlaces()</Member>
  <Member>System.Windows.Forms.FileDialog.#get_AutoUpgradeEnabled()</Member>
  <Member>System.Windows.Forms.FileDialog.#set_AutoUpgradeEnabled(System.Boolean)</Member>
  <Type>System.Windows.Forms.FileDialogCustomPlace</Type>
  <Type>System.Windows.Forms.FileDialogCustomPlacesCollection</Type>
  <Member>System.Windows.Forms.ImeMode.#OnHalf</Member>
  <Member>System.Windows.Forms.OpenFileDialog.#get_SafeFileName()</Member>
  <Member>System.Windows.Forms.OpenFileDialog.#get_SafeFileNames()</Member>
  <Member>System.Xml.XmlConvert.#ToString(System.DateTimeOffset)</Member>
  <Member>System.Xml.XmlConvert.#ToString(System.DateTimeOffset,System.String)</Member>
  <Member>System.Xml.XmlConvert.#ToDateTimeOffset(System.String)</Member>
  <Member>System.Xml.XmlConvert.#ToDateTimeOffset(System.String,System.String)</Member>
  <Member>System.Xml.XmlConvert.#ToDateTimeOffset(System.String,System.String[])</Member>
  <Member>System.Xml.XmlReaderSettings.#get_MaxCharactersInDocument()</Member>
  <Member>System.Xml.XmlReaderSettings.#set_MaxCharactersInDocument(System.Int64)</Member>
  <Member>System.Xml.XmlReaderSettings.#get_MaxCharactersFromEntities()</Member>
  <Member>System.Xml.XmlReaderSettings.#set_MaxCharactersFromEntities(System.Int64)</Member>
  <Member>System.Xml.Xsl.XslCompiledTransform.#CompileToType(System.Xml.XmlReader,System.Xml.Xsl.XsltSettings,System.Xml.XmlResolver,System.Boolean,System.Reflection.Emit.TypeBuilder,System.String)</Member>
  <Member>System.Xml.Xsl.XslCompiledTransform.#Load(System.Type)</Member>
  <Member>System.Xml.Xsl.XslCompiledTransform.#Load(System.Reflection.MethodInfo,System.Byte[],System.Type[])</Member>
  <Member>System.Xml.Serialization.XmlSerializationReader.#ReadSerializable(System.Xml.Serialization.IXmlSerializable,System.Boolean)</Member>
  <Member>System.Xml.Serialization.Configuration.XmlSerializerSection.#get_TempFilesLocation()</Member>
  <Member>System.Xml.Serialization.Configuration.XmlSerializerSection.#set_TempFilesLocation(System.String)</Member>
  <Type>System.Xml.Serialization.Configuration.RootedPathValidator</Type>
</CompatibilityEntry>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\iCatcher\defectViewer\bin\modules\version.txt ===
3377
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\fxcop\1.36\x86\Repository\Compatibility\Desktop3.5SP1.xml ===
<?xml version="1.0" encoding="utf-8"?>
<CompatibilityEntry Name=".NET Framework 3.5 Service Pack 1"
                    Platform="Desktop" 
                    Version="3.5.1" 
                    Priority="3510">

  <Assembly>Microsoft.Data.Entity.Build.Tasks, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>Sentinel.v3.5Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>System.ComponentModel.DataAnnotations, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Data.Entity.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Data.Services.Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Data.Services.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Data.Services, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Web.Abstractions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Web.DynamicData.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Web.DynamicData, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Web.Entity.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Web.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Web.Routing, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffYear(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffYear(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMonth(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMonth(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffDay(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffDay(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffHour(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffHour(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMinute(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMinute(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffSecond(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffSecond(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMillisecond(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMillisecond(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMicrosecond(System.DateTime,System.DateTime)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMicrosecond(System.Nullable`1&lt;System.DateTime&gt;,System.Nullable`1&lt;System.DateTime&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMicrosecond(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffMicrosecond(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffNanosecond(System.DateTime,System.DateTime)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffNanosecond(System.Nullable`1&lt;System.DateTime&gt;,System.Nullable`1&lt;System.DateTime&gt;)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffNanosecond(System.DateTimeOffset,System.DateTimeOffset)</Member>
  <Member>System.Data.Linq.SqlClient.SqlMethods.#DateDiffNanosecond(System.Nullable`1&lt;System.DateTimeOffset&gt;,System.Nullable`1&lt;System.DateTimeOffset&gt;)</Member>
  <Type>System.Data.Linq.SqlClient.Sql2008Provider</Type>
  <Member>System.ServiceModel.Description.WebHttpBehavior.#ValidateBinding(System.ServiceModel.Description.ServiceEndpoint)</Member>
  <Type>System.ServiceModel.Syndication.ServiceDocument</Type>
  <Type>System.ServiceModel.Syndication.Workspace</Type>
  <Type>System.ServiceModel.Syndication.ResourceCollectionInfo</Type>
  <Type>System.ServiceModel.Syndication.CategoriesDocument</Type>
  <Type>System.ServiceModel.Syndication.InlineCategoriesDocument</Type>
  <Type>System.ServiceModel.Syndication.ReferencedCategoriesDocument</Type>
  <Type>System.ServiceModel.Syndication.ServiceDocumentFormatter</Type>
  <Type>System.ServiceModel.Syndication.AtomPub10ServiceDocumentFormatter</Type>
  <Type>System.ServiceModel.Syndication.AtomPub10ServiceDocumentFormatter`1</Type>
  <Type>System.ServiceModel.Syndication.CategoriesDocumentFormatter</Type>
  <Type>System.ServiceModel.Syndication.AtomPub10CategoriesDocumentFormatter</Type>
  <Member>System.UriTemplate.#.ctor(System.String,System.Boolean)</Member>
  <Member>System.UriTemplate.#.ctor(System.String,System.Collections.Generic.IDictionary`2&lt;System.String,System.String&gt;)</Member>
  <Member>System.UriTemplate.#.ctor(System.String,System.Boolean,System.Collections.Generic.IDictionary`2&lt;System.String,System.String&gt;)</Member>
  <Member>System.UriTemplate.#get_Defaults()</Member>
  <Member>System.UriTemplate.#get_IgnoreTrailingSlash()</Member>
  <Member>System.UriTemplate.#BindByName(System.Uri,System.Collections.Generic.IDictionary`2&lt;System.String,System.String&gt;)</Member>
  <Member>System.UriTemplate.#BindByName(System.Uri,System.Collections.Generic.IDictionary`2&lt;System.String,System.String&gt;,System.Boolean)</Member>
  <Member>System.UriTemplate.#BindByName(System.Uri,System.Collections.Specialized.NameValueCollection,System.Boolean)</Member>
  <Member>System.Web.ClientServices.ClientFormsIdentity.#Dispose(System.Boolean)</Member>
  <Type>System.Web.DynamicData.IDynamicDataSource</Type>
  <Member>System.Web.UI.WebControls.LinqDataSource.#get_EnableObjectTracking()</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#set_EnableObjectTracking(System.Boolean)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#CreateView()</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#System.Web.DynamicData.IDynamicDataSource.get_ContextType()</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#System.Web.DynamicData.IDynamicDataSource.set_ContextType(System.Type)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#System.Web.DynamicData.IDynamicDataSource.get_EntitySetName()</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#System.Web.DynamicData.IDynamicDataSource.set_EntitySetName(System.String)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#System.Web.DynamicData.IDynamicDataSource.add_Exception(System.EventHandler`1&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSource.#System.Web.DynamicData.IDynamicDataSource.remove_Exception(System.EventHandler`1&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSourceContextEventArgs.#.ctor(System.Web.UI.DataSourceOperation)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSourceContextEventArgs.#get_Operation()</Member>
  <Member>System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.#.ctor(System.Object,System.Int32)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.#get_TotalRowCount()</Member>
  <Type>System.Web.DynamicData.IDynamicValidatorException</Type>
  <Member>System.Web.UI.WebControls.LinqDataSourceView.#get_EnableObjectTracking()</Member>
  <Member>System.Web.UI.WebControls.LinqDataSourceView.#set_EnableObjectTracking(System.Boolean)</Member>
  <Member>System.Web.UI.WebControls.LinqDataSourceView.#OnException(System.Web.DynamicData.DynamicValidatorEventArgs)</Member>
  <Member>System.Web.UI.WebControls.ListView.#get_EnableModelValidation()</Member>
  <Member>System.Web.UI.WebControls.ListView.#set_EnableModelValidation(System.Boolean)</Member>
  <Member>System.Web.UI.WebControls.ListView.#get_SelectedPersistedDataKey()</Member>
  <Member>System.Web.UI.WebControls.ListView.#set_SelectedPersistedDataKey(System.Web.UI.WebControls.DataKey)</Member>
  <Member>System.Web.UI.WebControls.ListView.#System.Web.UI.WebControls.IPersistedSelector.get_DataKey()</Member>
  <Member>System.Web.UI.WebControls.ListView.#System.Web.UI.WebControls.IPersistedSelector.set_DataKey(System.Web.UI.WebControls.DataKey)</Member>
  <Type>System.Web.DynamicData.DynamicDataSourceOperation</Type>
  <Type>System.Web.DynamicData.DynamicValidatorEventArgs</Type>
  <Type>System.Web.UI.ScriptReferenceBase</Type>
  <Type>System.Web.UI.CompositeScriptReference</Type>
  <Type>System.Web.UI.CompositeScriptReferenceEventArgs</Type>
  <Type>System.Web.UI.HistoryEventArgs</Type>
  <Member>System.Web.UI.ScriptManager.#get_ClientNavigateHandler()</Member>
  <Member>System.Web.UI.ScriptManager.#set_ClientNavigateHandler(System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#get_CompositeScript()</Member>
  <Member>System.Web.UI.ScriptManager.#get_EmptyPageUrl()</Member>
  <Member>System.Web.UI.ScriptManager.#set_EmptyPageUrl(System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#get_EnableHistory()</Member>
  <Member>System.Web.UI.ScriptManager.#set_EnableHistory(System.Boolean)</Member>
  <Member>System.Web.UI.ScriptManager.#get_EnableSecureHistoryState()</Member>
  <Member>System.Web.UI.ScriptManager.#set_EnableSecureHistoryState(System.Boolean)</Member>
  <Member>System.Web.UI.ScriptManager.#get_IsNavigating()</Member>
  <Member>System.Web.UI.ScriptManager.#add_Navigate(System.EventHandler`1&lt;System.Web.UI.HistoryEventArgs&gt;)</Member>
  <Member>System.Web.UI.ScriptManager.#remove_Navigate(System.EventHandler`1&lt;System.Web.UI.HistoryEventArgs&gt;)</Member>
  <Member>System.Web.UI.ScriptManager.#add_ResolveCompositeScriptReference(System.EventHandler`1&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;)</Member>
  <Member>System.Web.UI.ScriptManager.#remove_ResolveCompositeScriptReference(System.EventHandler`1&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;)</Member>
  <Member>System.Web.UI.ScriptManager.#AddHistoryPoint(System.String,System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#AddHistoryPoint(System.String,System.String,System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#GetStateString()</Member>
  <Member>System.Web.UI.ScriptManager.#OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)</Member>
  <Member>System.Web.UI.ScriptManager.#RaisePostBackEvent(System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</Member>
  <Member>System.Web.UI.ScriptManager.#System.Web.UI.IClientUrlResolver.get_AppRelativeTemplateSourceDirectory()</Member>
  <Member>System.Web.UI.ScriptManagerProxy.#get_CompositeScript()</Member>
  <Member>System.Web.UI.ScriptManagerProxy.#add_Navigate(System.EventHandler`1&lt;System.Web.UI.HistoryEventArgs&gt;)</Member>
  <Member>System.Web.UI.ScriptManagerProxy.#remove_Navigate(System.EventHandler`1&lt;System.Web.UI.HistoryEventArgs&gt;)</Member>
  <Member>System.Web.UI.ScriptManagerProxy.#System.Web.UI.IClientUrlResolver.get_AppRelativeTemplateSourceDirectory()</Member>
  <Member>System.Web.UI.ScriptReference.#GetUrl(System.Web.UI.ScriptManager,System.Boolean)</Member>
  <Member>System.Web.UI.ScriptReference.#IsFromSystemWebExtensions()</Member>
  <Member>System.Web.UI.UpdateProgress.#get_Controls()</Member>
  <Member>System.Web.UI.UpdateProgress.#CreateChildControls()</Member>
  <Member>System.Web.UI.UpdateProgress.#DataBind()</Member>
  <Type>System.Windows.Threading.DispatcherExtensions</Type>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#get_TargetFrameworkSubsets()</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#set_TargetFrameworkSubsets(System.String[])</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#get_InstalledAssemblySubsetTables()</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#set_InstalledAssemblySubsetTables(Microsoft.Build.Framework.ITaskItem[])</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#get_IgnoreDefaultInstalledAssemblySubsetTables()</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#set_IgnoreDefaultInstalledAssemblySubsetTables(System.Boolean)</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#get_FullTargetFrameworkSubsetNames()</Member>
  <Member>Microsoft.Build.Tasks.ResolveAssemblyReference.#set_FullTargetFrameworkSubsetNames(System.String[])</Member>
  <Member>Microsoft.Build.Tasks.GenerateManifestBase.#get_TargetFrameworkVersion()</Member>
  <Member>Microsoft.Build.Tasks.GenerateManifestBase.#set_TargetFrameworkVersion(System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateManifestBase.#ConvertFrameworkVersionToString(System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateManifestBase.#CompareFrameworkVersions(System.String,System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#get_ErrorReportUrl()</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#set_ErrorReportUrl(System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#get_FileAssociations()</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#set_FileAssociations(Microsoft.Build.Framework.ITaskItem[])</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#get_RequiresMinimumFramework35SP1()</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#set_RequiresMinimumFramework35SP1(System.Boolean)</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#get_SuiteName()</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#set_SuiteName(System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#get_TargetFrameworkSubset()</Member>
  <Member>Microsoft.Build.Tasks.GenerateApplicationManifest.#set_TargetFrameworkSubset(System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateDeploymentManifest.#get_CreateDesktopShortcut()</Member>
  <Member>Microsoft.Build.Tasks.GenerateDeploymentManifest.#set_CreateDesktopShortcut(System.Boolean)</Member>
  <Member>Microsoft.Build.Tasks.GenerateDeploymentManifest.#get_ErrorReportUrl()</Member>
  <Member>Microsoft.Build.Tasks.GenerateDeploymentManifest.#set_ErrorReportUrl(System.String)</Member>
  <Member>Microsoft.Build.Tasks.GenerateDeploymentManifest.#get_SuiteName()</Member>
  <Member>Microsoft.Build.Tasks.GenerateDeploymentManifest.#set_SuiteName(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#get_ErrorReportUrl()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#set_ErrorReportUrl(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#get_FileAssociations()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#get_SuiteName()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#set_SuiteName(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#get_XmlErrorReportUrl()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#set_XmlErrorReportUrl(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#get_XmlFileAssociations()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#set_XmlFileAssociations(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[])</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#get_XmlSuiteName()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#set_XmlSuiteName(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#get_CreateDesktopShortcut()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#set_CreateDesktopShortcut(System.Boolean)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#get_ErrorReportUrl()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#set_ErrorReportUrl(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#get_SuiteName()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#set_SuiteName(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#get_XmlCreateDesktopShortcut()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#set_XmlCreateDesktopShortcut(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#get_XmlErrorReportUrl()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#set_XmlErrorReportUrl(System.String)</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#get_XmlSuiteName()</Member>
  <Member>Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#set_XmlSuiteName(System.String)</Member>
  <Type>Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation</Type>
  <Type>Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection</Type>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#get_DeploymentManifestEntryPoint()</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#set_DeploymentManifestEntryPoint(Microsoft.Build.Framework.ITaskItem)</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#get_OutputDeploymentManifestEntryPoint()</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#set_OutputDeploymentManifestEntryPoint(Microsoft.Build.Framework.ITaskItem)</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#get_OutputEntryPoint()</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#set_OutputEntryPoint(Microsoft.Build.Framework.ITaskItem)</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#get_SigningManifests()</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#set_SigningManifests(System.Boolean)</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#get_TargetFrameworkVersion()</Member>
  <Member>Microsoft.Build.Tasks.ResolveManifestFiles.#set_TargetFrameworkVersion(System.String)</Member>
  <Type>Microsoft.Build.Tasks.RequiresFramework35SP1Assembly</Type>
</CompatibilityEntry>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\fxcop\1.36\x86\Repository\Compatibility\Desktop3.5.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<CompatibilityEntry Name=".NET Framework 3.5"
                    Platform="Desktop" 
                    Version="3.5" 
                    Priority="3500">

  <Assembly>Microsoft.Build.Conversion.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>Microsoft.Build.Engine, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>Microsoft.Build.Framework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>Microsoft.Build.Utilities.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>Microsoft.VisualC.STLCLR, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>System.AddIn.Contract, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>System.AddIn, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Data.DataSetExtensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.DirectoryServices.AccountManagement, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Management.Instrumentation, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.Net, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Assembly>
  <Assembly>System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Windows.Presentation, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35</Assembly>
  <Assembly>System.Xml.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Assembly>
  <Assembly>Microsoft.ServiceModel.Channels.Mail, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35</Assembly>
  <Assembly>Microsoft.ServiceModel.Channels.Mail.ExchangeWebService, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35</Assembly>

</CompatibilityEntry>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\iCatcher\defectViewer\scripts\defectui\DefectVersion.txt ===
3377
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\fxcop\1.36\x86\Repository\Compatibility\Desktop3.0SP1.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<CompatibilityEntry Name=".NET Framework 3.0 Service Pack 1"
                    Platform="Desktop"
                    Version="3.0.1"
                    Priority="3010">

  <Member>System.Windows.Media.Visual.#TransformToAncestor(System.Windows.Media.Media3D.Visual3D)</Member>
  <Type>System.Windows.Media.Media3D.GeneralTransform3D</Type>
  <Member>System.Windows.FreezableCollection`1.#System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventHandler)</Member>
  <Member>System.Windows.FreezableCollection`1.#System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventHandler)</Member>
  <Member>System.Windows.FreezableCollection`1.#System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(System.ComponentModel.PropertyChangedEventHandler)</Member>
  <Member>System.Windows.FreezableCollection`1.#System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(System.ComponentModel.PropertyChangedEventHandler)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#TransformProperty</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#get_Transform()</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#set_Transform(System.Windows.Media.Media3D.Transform3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#AddVisual3DChild(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#RemoveVisual3DChild(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#get_Visual3DModel()</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#set_Visual3DModel(System.Windows.Media.Media3D.Model3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#OnVisualParentChanged(System.Windows.DependencyObject)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.VerifyAPIReadOnly()</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.VerifyAPIReadOnly(System.Windows.DependencyObject)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.VerifyAPIReadWrite()</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.VerifyAPIReadWrite(System.Windows.DependencyObject)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#get_Visual3DChildrenCount()</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#GetVisual3DChild(System.Int32)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.AddChild(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.RemoveChild(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.GetChildrenCount()</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#MS.Internal.IVisual3DContainer.GetChild(System.Int32)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#TransformToAncestor(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#TransformToDescendant(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Visual3D.#TransformToAncestor(System.Windows.Media.Visual)</Member>
  <Type>System.Windows.UIElement3D</Type>
  <Type>System.Windows.Interop.RenderMode</Type>
  <Member>System.Windows.Interop.HwndTarget.#get_RenderMode()</Member>
  <Member>System.Windows.Interop.HwndTarget.#set_RenderMode(System.Windows.Interop.RenderMode)</Member>
  <Member>System.Windows.PresentationSource.#FromDependencyObject(System.Windows.DependencyObject)</Member>
  <Member>System.Windows.Media.Imaging.BitmapDecoder.#Create(System.Uri,System.Windows.Media.Imaging.BitmapCreateOptions,System.Windows.Media.Imaging.BitmapCacheOption,System.Net.Cache.RequestCachePolicy)</Member>
  <Member>System.Windows.Media.Imaging.BitmapSource.#add_DecodeFailed(System.EventHandler`1&lt;System.Windows.Media.ExceptionEventArgs&gt;)</Member>
  <Member>System.Windows.Media.Imaging.BitmapSource.#remove_DecodeFailed(System.EventHandler`1&lt;System.Windows.Media.ExceptionEventArgs&gt;)</Member>
  <Member>System.Windows.Media.Imaging.BitmapFrame.#Create(System.Uri,System.Net.Cache.RequestCachePolicy)</Member>
  <Member>System.Windows.Media.Imaging.BitmapFrame.#Create(System.Uri,System.Windows.Media.Imaging.BitmapCreateOptions,System.Windows.Media.Imaging.BitmapCacheOption,System.Net.Cache.RequestCachePolicy)</Member>
  <Member>System.Windows.Media.Imaging.BitmapImage.#UriCachePolicyProperty</Member>
  <Member>System.Windows.Media.Imaging.BitmapImage.#.ctor(System.Uri,System.Net.Cache.RequestCachePolicy)</Member>
  <Member>System.Windows.Media.Imaging.BitmapImage.#get_UriCachePolicy()</Member>
  <Member>System.Windows.Media.Imaging.BitmapImage.#set_UriCachePolicy(System.Net.Cache.RequestCachePolicy)</Member>
  <Type>System.Windows.Interop.InteropBitmap</Type>
  <Type>System.Windows.Media.RequestCachePolicyConverter</Type>
  <Member>System.Windows.Media.Media3D.Transform3D.#TryTransform(System.Windows.Media.Media3D.Point3D,System.Windows.Media.Media3D.Point3D&amp;)</Member>
  <Member>System.Windows.Media.Media3D.Transform3D.#TransformBounds(System.Windows.Media.Media3D.Rect3D)</Member>
  <Member>System.Windows.Media.Media3D.Transform3D.#get_Inverse()</Member>
  <Type>System.Windows.Media.Media3D.ContainerUIElement3D</Type>
  <Type>System.Windows.Media.Media3D.GeneralTransform3DGroup</Type>
  <Type>System.Windows.Media.Media3D.GeneralTransform3DTo2D</Type>
  <Type>System.Windows.Media.Media3D.GeneralTransform2DTo3D</Type>
  <Type>System.Windows.Media.Media3D.ModelUIElement3D</Type>
  <Member>System.Windows.Media.Media3D.ModelVisual3D.#GetVisual3DChild(System.Int32)</Member>
  <Member>System.Windows.Media.Media3D.ModelVisual3D.#get_Visual3DChildrenCount()</Member>
  <Type>System.Windows.Media.Media3D.Viewport2DVisual3D</Type>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.VerifyAPIReadOnly()</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.VerifyAPIReadOnly(System.Windows.DependencyObject)</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.VerifyAPIReadWrite()</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.VerifyAPIReadWrite(System.Windows.DependencyObject)</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.AddChild(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.RemoveChild(System.Windows.Media.Media3D.Visual3D)</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.GetChildrenCount()</Member>
  <Member>System.Windows.Media.Media3D.Viewport3DVisual.#MS.Internal.IVisual3DContainer.GetChild(System.Int32)</Member>
  <Type>System.Windows.Media.Media3D.GeneralTransform3DCollection</Type>
  <Type>System.Windows.Automation.Peers.UIElement3DAutomationPeer</Type>
  <Type>System.Windows.Annotations.IAnchorInfo</Type>
  <Type>System.Windows.Annotations.TextAnchor</Type>
  <Member>System.Windows.Navigation.NavigationWindow.#get_NavigationService()</Member>
  <Member>System.Windows.Application.#get_ResourceAssembly()</Member>
  <Member>System.Windows.Application.#set_ResourceAssembly(System.Reflection.Assembly)</Member>
  <Member>System.Windows.Data.CollectionView.#SetCurrent(System.Object,System.Int32,System.Int32)</Member>
  <Member>System.Windows.Controls.StickyNoteControl.#get_AnchorInfo()</Member>
  <Member>System.Windows.Controls.MenuItem.#set_IsPressed(System.Boolean)</Member>
  <Member>System.Windows.Controls.MenuItem.#set_IsHighlighted(System.Boolean)</Member>
  <Member>System.Windows.Controls.FlowDocumentScrollViewer.#get_Selection()</Member>
  <Member>System.Windows.Controls.FlowDocumentPageViewer.#get_Selection()</Member>
  <Member>System.Windows.Annotations.AnnotationHelper.#GetAnchorInfo(System.Windows.Annotations.AnnotationService,System.Windows.Annotations.Annotation)</Member>
  <Member>System.Windows.Controls.Primitives.ButtonBase.#set_IsPressed(System.Boolean)</Member>
  <Member>System.Windows.Controls.ComboBoxItem.#set_IsHighlighted(System.Boolean)</Member>
  <Type>System.Windows.Controls.DataErrorValidationRule</Type>
  <Member>System.Windows.Controls.FlowDocumentReader.#get_Selection()</Member>
  <Member>System.Windows.Controls.Primitives.Thumb.#set_IsDragging(System.Boolean)</Member>
  <Member>System.Windows.Controls.Primitives.TextBoxBase.#UndoLimitProperty</Member>
  <Member>System.Windows.Controls.Primitives.TextBoxBase.#get_UndoLimit()</Member>
  <Member>System.Windows.Controls.Primitives.TextBoxBase.#set_UndoLimit(System.Int32)</Member>
  <Member>System.Windows.Controls.RichTextBox.#IsDocumentEnabledProperty</Member>
  <Member>System.Windows.Controls.RichTextBox.#get_IsDocumentEnabled()</Member>
  <Member>System.Windows.Controls.RichTextBox.#set_IsDocumentEnabled(System.Boolean)</Member>
  <Member>System.Windows.Controls.SoundPlayerAction.#SourceProperty</Member>
  <Member>System.Windows.Controls.SoundPlayerAction.#Dispose()</Member>
  <Type>System.Windows.Controls.TextChange</Type>
  <Member>System.Windows.Controls.TextChangedEventArgs.#.ctor(System.Windows.RoutedEvent,System.Windows.Controls.UndoAction,System.Collections.Generic.ICollection`1&lt;System.Windows.Controls.TextChange&gt;)</Member>
  <Member>System.Windows.Controls.TextChangedEventArgs.#get_Changes()</Member>
  <Member>System.Windows.Data.Binding.#get_ValidatesOnExceptions()</Member>
  <Member>System.Windows.Data.Binding.#set_ValidatesOnExceptions(System.Boolean)</Member>
  <Member>System.Windows.Data.Binding.#get_ValidatesOnDataErrors()</Member>
  <Member>System.Windows.Data.Binding.#set_ValidatesOnDataErrors(System.Boolean)</Member>
  <Member>System.Windows.Data.MultiBinding.#get_ValidatesOnExceptions()</Member>
  <Member>System.Windows.Data.MultiBinding.#set_ValidatesOnExceptions(System.Boolean)</Member>
  <Member>System.Windows.Data.MultiBinding.#get_ValidatesOnDataErrors()</Member>
  <Member>System.Windows.Data.MultiBinding.#set_ValidatesOnDataErrors(System.Boolean)</Member>
  <Member>System.Windows.Documents.FrameworkTextComposition.#get_ResultOffset()</Member>
  <Member>System.Windows.Documents.FrameworkTextComposition.#get_ResultLength()</Member>
  <Member>System.Windows.Documents.FrameworkTextComposition.#get_CompositionOffset()</Member>
  <Member>System.Windows.Documents.FrameworkTextComposition.#get_CompositionLength()</Member>
  <Type>System.Windows.Documents.TextElementEditingBehaviorAttribute</Type>
  <Member>System.Windows.Documents.TextRange.#System.Windows.Documents.ITextRange.Save(System.IO.Stream,System.String,System.Boolean)</Member>
  <Member>System.Windows.Documents.TextRange.#System.Windows.Documents.ITextRange.EndChange(System.Boolean,System.Boolean)</Member>
  <Member>System.Windows.Documents.TextRange.#System.Windows.Documents.ITextRange.NotifyChanged(System.Boolean,System.Boolean)</Member>
  <Member>System.Windows.Documents.TextRange.#System.Windows.Documents.ITextRange.get_IgnoreTextUnitBoundaries()</Member>
  <Member>System.Windows.Documents.TextRange.#Save(System.IO.Stream,System.String,System.Boolean)</Member>
  <Member>System.Windows.Documents.TextSelection.#System.Windows.Documents.ITextRange.get__IsChanged()</Member>
  <Member>System.Windows.Documents.TextSelection.#System.Windows.Documents.ITextRange.set__IsChanged(System.Boolean)</Member>
  <Member>System.Windows.Documents.TextSelection.#System.Windows.Documents.ITextRange.NotifyChanged(System.Boolean,System.Boolean)</Member>
  <Member>System.Windows.Interop.DocObjHost.#MS.Internal.AppModel.IBrowserHostServices.Run(System.String,System.String,System.String,System.String,System.String,MS.Internal.AppModel.MimeType,System.Object,System.Object,System.String,System.Boolean,System.String,System.String,System.String,System.String)</Member>
  <Type>System.IdentityModel.Selectors.AudienceUriMode</Type>
  <Type>System.IdentityModel.Selectors.AudienceUriModeValidationHelper</Type>
  <Member>System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator.#get_AudienceUriMode()</Member>
  <Member>System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator.#set_AudienceUriMode(System.IdentityModel.Selectors.AudienceUriMode)</Member>
  <Member>System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator.#get_AllowedAudienceUris()</Member>
  <Member>System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator.#ValidateAudienceRestriction(System.IdentityModel.Tokens.SamlAudienceRestrictionCondition)</Member>
  <Member>System.IdentityModel.Tokens.KerberosReceiverSecurityToken.#get_ValidFrom()</Member>
  <Member>System.IdentityModel.Tokens.KerberosReceiverSecurityToken.#get_ValidTo()</Member>
  <Member>System.IdentityModel.Tokens.KerberosReceiverSecurityToken.#get_WindowsIdentity()</Member>
  <Member>System.IdentityModel.Tokens.SecurityAlgorithms.#Psha1KeyDerivationDec2005</Member>
  <Member>System.IdentityModel.Tokens.SecurityKeyType.#BearerKey</Member>
  <Member>System.Runtime.Serialization.Configuration.DeclaredTypeElement.#PostDeserialize()</Member>
  <Type>System.ServiceModel.Channels.RemoteEndpointMessageProperty</Type>
  <Type>System.ServiceModel.Channels.SupportedAddressingMode</Type>
  <Type>System.ServiceModel.Configuration.AllowedAudienceUriElement</Type>
  <Type>System.ServiceModel.Configuration.AllowedAudienceUriElementCollection</Type>
  <Type>System.ServiceModel.Configuration.BaseAddressPrefixFilterElement</Type>
  <Type>System.ServiceModel.Configuration.BaseAddressPrefixFilterElementCollection</Type>
  <Member>System.ServiceModel.Configuration.StandardBindingElement.#Reset(System.Configuration.ConfigurationElement)</Member>
  <Member>System.ServiceModel.Configuration.StandardBindingElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.StandardBindingElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.BindingCollectionElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.BindingCollectionElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceModelExtensionElement.#Reset(System.Configuration.ConfigurationElement)</Member>
  <Member>System.ServiceModel.Configuration.ServiceModelExtensionElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceModelExtensionElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.BindingsSection.#get_WS2007FederationHttpBinding()</Member>
  <Member>System.ServiceModel.Configuration.BindingsSection.#get_WS2007HttpBinding()</Member>
  <Member>System.ServiceModel.Configuration.BindingsSection.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.BindingsSection.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ChannelEndpointElement.#Reset(System.Configuration.ConfigurationElement)</Member>
  <Member>System.ServiceModel.Configuration.ChannelEndpointElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ChannelEndpointElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ClientSection.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ClientSection.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceModelExtensionCollectionElement`1.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceModelExtensionCollectionElement`1.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#get_AllowedAudienceUris()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#get_AudienceUriMode()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#set_AudienceUriMode(System.IdentityModel.Selectors.AudienceUriMode)</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#get_CustomCertificateValidatorType()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#set_CustomCertificateValidatorType(System.String)</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#get_CertificateValidationMode()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#set_CertificateValidationMode(System.ServiceModel.Security.X509CertificateValidationMode)</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#get_RevocationMode()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#set_RevocationMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#get_TrustedStoreLocation()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenServiceElement.#set_TrustedStoreLocation(System.Security.Cryptography.X509Certificates.StoreLocation)</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenParametersElement.#get_DefaultMessageSecurityVersion()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenParametersElement.#set_DefaultMessageSecurityVersion(System.ServiceModel.MessageSecurityVersion)</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenParametersEndpointAddressElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.IssuedTokenParametersEndpointAddressElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ReliableSessionElement.#get_ReliableMessagingVersion()</Member>
  <Member>System.ServiceModel.Configuration.ReliableSessionElement.#set_ReliableMessagingVersion(System.ServiceModel.ReliableMessagingVersion)</Member>
  <Member>System.ServiceModel.Configuration.ServiceCredentialsElement.#ApplyConfiguration(System.ServiceModel.Description.ServiceCredentials)</Member>
  <Member>System.ServiceModel.Configuration.ServiceElement.#Reset(System.Configuration.ConfigurationElement)</Member>
  <Member>System.ServiceModel.Configuration.ServiceElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceEndpointElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceEndpointElement.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServiceHostingEnvironmentSection.#PostDeserialize()</Member>
  <Member>System.ServiceModel.Configuration.ServiceHostingEnvironmentSection.#get_BaseAddressPrefixFilters()</Member>
  <Member>System.ServiceModel.Configuration.ServiceMetadataPublishingElement.#get_PolicyVersion()</Member>
  <Member>System.ServiceModel.Configuration.ServiceMetadataPublishingElement.#set_PolicyVersion(System.ServiceModel.Description.PolicyVersion)</Member>
  <Member>System.ServiceModel.Configuration.ServicesSection.#Reset(System.Configuration.ConfigurationElement)</Member>
  <Member>System.ServiceModel.Configuration.ServicesSection.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetEvaluationContext()</Member>
  <Member>System.ServiceModel.Configuration.ServicesSection.#System.ServiceModel.Configuration.IConfigurationContextProviderInternal.GetOriginalEvaluationContext()</Member>
  <Type>System.ServiceModel.Configuration.WS2007FederationHttpBindingElement</Type>
  <Type>System.ServiceModel.Configuration.WS2007FederationHttpBindingCollectionElement</Type>
  <Type>System.ServiceModel.Configuration.WS2007HttpBindingElement</Type>
  <Type>System.ServiceModel.Configuration.WS2007HttpBindingCollectionElement</Type>
  <Member>System.ServiceModel.Diagnostics.PerformanceCounterScope.#Default</Member>
  <Member>System.ServiceModel.Channels.ReliableSessionBindingElement.#get_ReliableMessagingVersion()</Member>
  <Member>System.ServiceModel.Channels.ReliableSessionBindingElement.#set_ReliableMessagingVersion(System.ServiceModel.ReliableMessagingVersion)</Member>
  <Type>System.ServiceModel.ReliableMessagingVersion</Type>
  <Member>System.ServiceModel.Security.WSSecurityTokenSerializer.#.ctor(System.ServiceModel.Security.SecurityVersion,System.ServiceModel.Security.TrustVersion,System.ServiceModel.Security.SecureConversationVersion,System.Boolean,System.IdentityModel.Tokens.SamlSerializer,System.ServiceModel.Security.SecurityStateEncoder,System.Collections.Generic.IEnumerable`1&lt;System.Type&gt;)</Member>
  <Member>System.ServiceModel.Security.WSSecurityTokenSerializer.#.ctor(System.ServiceModel.Security.SecurityVersion,System.ServiceModel.Security.TrustVersion,System.ServiceModel.Security.SecureConversationVersion,System.Boolean,System.IdentityModel.Tokens.SamlSerializer,System.ServiceModel.Security.SecurityStateEncoder,System.Collections.Generic.IEnumerable`1&lt;System.Type&gt;,System.Int32,System.Int32,System.Int32)</Member>
  <Type>System.ServiceModel.Security.SecureConversationVersion</Type>
  <Type>System.ServiceModel.Security.SecurityPolicyVersion</Type>
  <Type>System.ServiceModel.Security.TrustVersion</Type>
  <Member>System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.#get_DefaultMessageSecurityVersion()</Member>
  <Member>System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.#set_DefaultMessageSecurityVersion(System.ServiceModel.MessageSecurityVersion)</Member>
  <Member>System.ServiceModel.MessageSecurityVersion.#get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12()</Member>
  <Member>System.ServiceModel.MessageSecurityVersion.#get_WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10()</Member>
  <Member>System.ServiceModel.MessageSecurityVersion.#get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10()</Member>
  <Member>System.ServiceModel.MessageSecurityVersion.#get_TrustVersion()</Member>
  <Member>System.ServiceModel.MessageSecurityVersion.#get_SecureConversationVersion()</Member>
  <Member>System.ServiceModel.MessageSecurityVersion.#get_SecurityPolicyVersion()</Member>
  <Member>System.ServiceModel.Security.IssuedTokenServiceCredential.#get_AllowedAudienceUris()</Member>
  <Member>System.ServiceModel.Security.IssuedTokenServiceCredential.#get_AudienceUriMode()</Member>
  <Member>System.ServiceModel.Security.IssuedTokenServiceCredential.#set_AudienceUriMode(System.IdentityModel.Selectors.AudienceUriMode)</Member>
  <Member>System.ServiceModel.ServiceAuthorizationManager.#CheckAccess(System.ServiceModel.OperationContext,System.ServiceModel.Channels.Message&amp;)</Member>
  <Type>System.ServiceModel.ClientBase`1+BeginOperationDelegate</Type>
  <Type>System.ServiceModel.ClientBase`1+EndOperationDelegate</Type>
  <Type>System.ServiceModel.ClientBase`1+InvokeAsyncCompletedEventArgs</Type>
  <Member>System.ServiceModel.ClientBase`1.#GetDefaultValueForInitialization`1()</Member>
  <Member>System.ServiceModel.ClientBase`1.#InvokeAsync(System.ServiceModel.ClientBase`1&lt;!0&gt;+BeginOperationDelegate,System.Object[],System.ServiceModel.ClientBase`1&lt;!0&gt;+EndOperationDelegate,System.Threading.SendOrPostCallback,System.Object)</Member>
  <Member>System.ServiceModel.Description.MetadataExporter.#get_PolicyVersion()</Member>
  <Member>System.ServiceModel.Description.MetadataExporter.#set_PolicyVersion(System.ServiceModel.Description.PolicyVersion)</Member>
  <Type>System.ServiceModel.Description.PolicyVersion</Type>
  <Member>System.ServiceModel.Description.ServiceContractGenerationOptions.#EventBasedAsynchronousMethods</Member>
  <Type>System.ServiceModel.WS2007FederationHttpBinding</Type>
  <Type>System.ServiceModel.WS2007HttpBinding</Type>
  <Member>System.ServiceModel.TransactionProtocol.#get_WSAtomicTransaction11()</Member>
  <Member>System.Workflow.ComponentModel.Compiler.CompileWorkflowTask.#get_CompilationOptions()</Member>
  <Member>System.Workflow.ComponentModel.Compiler.CompileWorkflowTask.#set_CompilationOptions(Microsoft.Build.Framework.ITaskItem[])</Member>
  <Member>System.Workflow.ComponentModel.Design.SequentialWorkflowRootDesigner.#get_ImageRectangle()</Member>
  <Member>System.Diagnostics.PresentationTraceSources.#TraceLevelProperty</Member>
  <Member>System.Diagnostics.PresentationTraceSources.#get_HwndHostSource()</Member>
  <Member>System.Diagnostics.PresentationTraceSources.#GetTraceLevel(System.Object)</Member>
  <Member>System.Diagnostics.PresentationTraceSources.#SetTraceLevel(System.Object,System.Diagnostics.PresentationTraceLevel)</Member>
  <Type>System.Diagnostics.PresentationTraceLevel</Type>
</CompatibilityEntry>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\hcw\x86\license.txt ===
HTML Help
END-USER LICENSE AGREEMENT FOR MICROSOFT SOFTWARE

IMPORTANT-READ CAREFULLY: This Microsoft End-User License
Agreement ("EULA") is a legal agreement between you (either an
individual or a single entity) and Microsoft Corporation for the
Microsoft software product identified above, which includes
computer software and associated media and printed materials,
and may include "online" or electronic documentation ("SOFTWARE
PRODUCT" or "SOFTWARE"). By installing, copying, or otherwise
using the SOFTWARE PRODUCT, you agree to be bound by the terms
of this EULA. If you do not agree to the terms of this EULA, do
not install, copy, or use the SOFTWARE PRODUCT.

SOFTWARE PRODUCT LICENSE
The SOFTWARE PRODUCT is protected by copyright laws and
international copyright treaties, as well as other intellectual
property laws and treaties. The SOFTWARE PRODUCT is licensed,
not sold.

1. GRANT OF LICENSE. This EULA grants you the following
non-exclusive rights:

    * Software Product. You may install and use the enclosed
      SOFTWARE PRODUCT on your computers to design, develop, and
      test help systems and Internet content ("Help").

    * Sample Code. You may modify the sample source code
      located in the SOFTWARE PRODUCT's online help files to
      design, develop, and test your Help. You may also
      reproduce and distribute the Sample Code in object code
      form along with any modifications you make to the Sample
      Code, provided that you comply with the Distribution
      Requirements described below. For purposes of this
      section, "modifications" shall mean enhancements to the
      functionality of the Sample Code.

    * Redistributable Code. The portions of the SOFTWARE
      PRODUCT identified as "hhupd.exe" is designated as
      "Redistributable Code." The Redistributable Code has been
      designed, developed and tested to run on Windows 95 and
      Windows NT and is intended to provide you with a way to
      redistribute Microsoft Internet Explorer services such as HTML Help
      functionality. You may redistribute the Redistributable
      Code subject to the Distribution Requirements listed below
      and the following additional provisions: you may only
      permit installation of the Redistributable Code in the
      "passive mode" without making it the default browser and
      without adding the Internet icon to the desktop. If your
      redistribution and installation of the Redistibutable Code
      requires that you use the Internet icon on the desktop, or
      to use Microsoft Internet Explorer as the default browser, you must
      sign up and accept the terms of the Microsoft Internet Explorer
      License and Distribution Agreement located at:
      http://ieak.microsoft.com/release2/licenseProducts.asp.

    * Distribution Requirements. You may copy and
      redistribute the Sample Code and/or Redistributable Code
      (collectively "REDISTRIBUTABLE COMPONENTS") as described
      above, provided that (a) you distribute the
      REDISTRIBUTABLE COMPONENTS only in conjunction with, and
      as a part of, your Application; (b) your Application adds
      significant and primary functionality to the
      REDISTRIBUTABLE COMPONENTS; (c) you do not use Microsoft's
      name, logo, or trademarks to market your Application,
      except as expressly authorized by Microsoft in any other
      agreement; (d) you include a valid copyright notice on
      your Application; and (g) you agree to indemnify, hold
      harmless, and defend Microsoft from and against any claims
      or lawsuits, including attorneys' fees, that arise or
      result from the use or distribution of your Application.
      Microsoft reserves all rights not expressly granted to
      you.

2. COPYRIGHT. All rights, title, and copyrights in and to the
SOFTWARE PRODUCT (including, but not limited to, any images,
photographs, animations, video, audio, music, text, and
"applets" incorporated into the SOFTWARE PRODUCT) and any copies
of the SOFTWARE PRODUCT are owned by Microsoft or its suppliers.
You may not copy the printed materials, if any, accompanying the
SOFTWARE PRODUCT.

3.  DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.
    * Limitations on Reverse-Engineering, Decompilation, and
      Disassembly. You may not reverse- engineer, decompile, or
      disassemble the SOFTWARE PRODUCT, except and only to the
      extent that such activity is expressly permitted by
      applicable law notwithstanding this limitation.

    * Rental. You may not rent or lease the SOFTWARE PRODUCT.

    * Software Transfer. You may permanently transfer all of
      your rights under this EULA, provided you retain no
      copies, you transfer all of the SOFTWARE PRODUCT
      (including all component parts, the media and printed
      materials, any upgrades, this EULA, and, if applicable,
      the Certificate of Authenticity), and the recipient agrees
      to the terms of this EULA. If the SOFTWARE PRODUCT is an
      upgrade, any transfer must include all prior versions of
      the SOFTWARE PRODUCT.

    * Termination. Without prejudice to any other rights,
      Microsoft may terminate this EULA if you fail to comply
      with the terms and conditions of this EULA. In such event,
      you must destroy all copies of the SOFTWARE PRODUCT and
      all of its component parts.

5. EXPORT RESTRICTIONS. You agree that neither you nor your
customers intend to or will, directly or indirectly, export or
transmit (a) the SOFTWARE PRODUCT or related documentation and
technical data, or (b) your Application as described in Section
1 of this EULA (or any part thereof), or process, or service
that is the direct product of the SOFTWARE PRODUCT to any
country to which such export or transmission is restricted by
any applicable U.S. regulation or statute, without the prior
written consent, if required, of the Bureau of Export
Administration of the U.S. Department of Commerce, or such other
governmental entity as may have jurisdiction over such export
or transmission.

6. U.S. GOVERNMENT RESTRICTED RIGHTS. The SOFTWARE PRODUCT and
documentation are provided with RESTRICTED RIGHTS. Use,
duplication, or disclosure by the Government is subject to
restrictions as set forth in subparagraph (c)(1)(ii) of The
Rights in Technical Data and Computer Software clause at DFARS
252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial
Computer Software - Restricted Rights at 48 CFR 52.227-19, as
applicable. Manufacturer is Microsoft Corporation/One Microsoft
Way/ Redmond, WA 98052-6399. MISCELLANEOUS

If you acquired this product in the United States, this EULA is
governed by the laws of the State of Washington.

If you acquired this product in Canada, this EULA is governed by
the laws of the Province of Ontario, Canada. Each of the parties
hereto irrevocably attorns to the jurisdiction of the courts of
the Province of Ontario and further agrees to commence any
litigation that may arise hereunder in the courts located in the
Judicial District of York, Province of Ontario.

If this product was acquired outside the United States, local
law may apply.

Should you have any questions concerning this EULA, or if you
desire to contact Microsoft for any reason, please contact the
Microsoft subsidiary serving your country, or write: Microsoft
Customer Sales and Service/One Microsoft Way/Redmond, WA
98052-6399.

NO WARRANTIES. To the maximum extent permitted by applicable
law, Microsoft expressly disclaims any warranty for the SOFTWARE
PRODUCT. The SOFTWARE PRODUCT and any related documentation are
provided "as is" without warranty of any kind, either express or
implied, including, without limitation, the implied warranties
of merchantability or fitness for a particular purpose. The
entire risk arising out of use or performance of the SOFTWARE
PRODUCT remains with you.

LIMITATION OF LIABILITY. Microsoft's entire liability and your
exclusive remedy under this EULA shall not exceed five dollars
(US$5.00).

NO LIABILITY FOR CONSEQUENTIAL DAMAGES. To the maximum extent
permitted by applicable law, in no event shall Microsoft or its
suppliers be liable for any damages whatsoever (including,
without limitation, damages for loss of business profit,
business interruption, loss of business information, or any
other pecuniary loss) arising out of the use of, or inability to
use, this Microsoft product, even if Microsoft has been advised
of the possibility of such damages. Because some
states/jurisdictions do not allow the exclusion or limitation of
liability for consequential or incidental damages, the above
limitation may not apply to you.

Si vous avez acquis votre produit Microsoft au CANADA, la
garantie limite suivante vous concerne:

GARANTIE LIMITE
EXCLUSION DE GARANTIES. Microsoft renonce entirement  toute
garantie pour le LOGICIEL. Le LOGICIEL et toute autre
documentation s'y rapportant sont fournis  comme tels  sans
aucune garantie quelle qu'elle soit, expresse ou implicite, y
compris, mais ne se limitant pas aux garanties implicites de la
qualit marchande ou un usage particulier. Le risque total
dcoulant de l'utilisation ou de la performance du LOGICIEL est
entre vos mains.

RESPONSABILIT LIMITE. La seule obligation de Microsoft et votre
recours exclusif concernant ce contrat n'excderont (US$5.00).

ABSENCE DE RESPONSABILIT POUR LES DOMMAGES INDIRECTS. Microsoft
ou ses fournisseurs ne pourront tre tenus responsables en
aucune circonstance de tout dommage quel qu'il soit (y compris
mais non de faon limitative les dommages directs ou indirects
causs par la perte de bnfices commerciaux, l'interruption des
affaires, la perte d'information commerciale ou toute autre
perte pcuniaire) rsultant de l'utilisation ou de
l'impossibilit d'utilisation de ce produit, et ce, mme si la
socit Microsoft a t avise de l'ventualit de tels
dommages. Certains tats/juridictions ne permettent pas
l'exclusion ou la limitation de responsabilit relative aux
dommages indirects ou conscutifs, et la limitation ci-dessus
peut ne pas s'appliquer  votre gard. La prsente Convention
est rgie par les lois de la province d'Ontario, Canada. Chacune
des parties  la Convention reconnat irrvocablement la
comptence des tribunaux de la province d'Ontario et consent 
instituer tout litige qui pourrait dcouler de la Convention
auprs des tribunaux situs dans le district judiciaire de York,
province d'Ontario.

Au cas o vous auriez des questions concernant cette licence ou
que vous dsiriez vous mettre en rapport avec Microsoft pour
quelque raison que ce soit, veuillez contacter la succursale
Microsoft desservant votre pays, dont l'adresse est fournie dans
ce produit, ou crire : Microsoft Customer Sales and Service,
One Microsoft Way, Redmond, Washington 98052-6399.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\iCatcher\defectViewer\scripts\defectui\filters.xml ===
<?xml version='1.0'?>
<DefectFilters>

<preset name="(Recommended)">
   <excludeWarnings>80007;80198;80199</excludeWarnings>
 </preset>

<preset name="(all defects)">
</preset>

<preset name="(no defects)" invert="1">
</preset>

<preset name="OACR level 0 (compile errors)" invert="1">
   <excludeWarnings></excludeWarnings>
</preset>

<preset name="OACR level 1 (must fix)" invert="1">
   <excludeWarnings>80002;80004;80005;80006;80101;80201</excludeWarnings>
</preset>

<preset name="OACR level 2 (should fix)" invert="1">
   <excludeWarnings>80001;80020</excludeWarnings>
</preset>

<preset name="OACR level 3 (strive for perfection)" invert="1">
   <excludeWarnings>80003</excludeWarnings>
</preset>

<preset name="OACR level 4 (off by default)" invert="1">
   <excludeWarnings>80007;80198;80199</excludeWarnings>
</preset>

</DefectFilters>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\IIS\RewriteModule\README.txt ===
Homepage: http://www.iis.net/download/URLRewrite
v2.0 docs: http://learn.iis.net/page.aspx/737/url-rewrite-module-2/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\iCatcher\defectViewer\scripts\defectui\defectdefs.xml ===
<?xml version='1.0'?>
<DefectDefs>

	<DefectDefGroup guid="023B3DCE-24F9-4696-865C-9C3BE4B3893B"
		id="80000"
		name="iCatcher">
		
		<display>iCatcher Patterns</display>
		
		<doc>
			<P>This program is a collection of defective code checks for web-based attacks.
			</P>
		</doc>
		
		<ownerURL>http://winweb/cse</ownerURL>
		<ownerContact>csesec</ownerContact>

		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80001 -->
		<DefectDef guid="A157CF5D-5BA7-4358-9147-B9679E2DC2D8"
			id="80001"
			name="SOURCE_DESTINATION_NO_VALIDATION">

			<description>
				<format>
				No validation between data source %source% and sink %sink%.
				The program is vulnerable to data-driven web
				attacks such as Cross-Site Scripting (XSS), HTTP Request/Response Splitting, and SQL injection.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>

		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80002 -->
		<DefectDef guid="AB4FC643-220D-4373-A9B8-781ABBA11A38"
			id="80002"
			name="HTTPREQUEST_HTTPREPSONSE_NO_VALIDATION">

			<description>
				<format>
				No validation between data source %source% and sink %sink%. The data source is
				an HTTP request, which may contain an attack script. The data sink is part of the HTTP response page.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>

		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80003 -->
		<DefectDef guid="551C8744-0E2C-476a-B7A8-0937971576AF"
			id="80003"
			name="HTTPREQUEST_REDIRECT_TRANSFER_NO_VALIDATION">

			<description>
				<format>
				No validation between data source %source% and sink %sink%. The data source is
				an HTTP request, which may contain an attack script. Without sanitation, the data is
				used in the header of a Response.Redirect or Response.Transfer packet.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>
	<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>

		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80004 -->
		<DefectDef guid="2A4D7280-3692-47a0-A4B3-5ED20FCED1A9"
			id="80004"
		name="HTTPREQUEST_ERRORMESSAGE_NO_VALIDATION">

			<description>
				<format>
				No validation between data source %source% and sink %sink%. The data source
				is an HTTP request and the sink is an error message. Do not
				include the original data in the error message; or encode the data using the
				Microsoft Anti-XSS library before consumption.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80005 -->
		<DefectDef guid="C4972FEF-095D-4369-9A7B-FCE101E37371"
			id="80005"
			name="SQL_COMMAND_INJECTION">

			<description>
				<format>
				SQL injection vulnerability. No validation between data source %source% and sink
				%sink%,	part of a SQL command. Use a parameterized stored procedure instead.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/iCatcher/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
	
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80006 -->
		<DefectDef guid="82023D95-210C-4230-8079-1C2EDF7B4539"
			id="80006"
			name="XPATH_INJECTION">
			<description>
				<format>
				XPath injection vulnerability. No validation between data source %source% and sink
				%sink%,	part of an XPath expression.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/iCatcher/userguide/warning_%id%.htm</helpURL>
		</DefectDef>

		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80007 -->
		<DefectDef guid="50A9C1B2-1C9B-4adf-AD23-C469D0FBF49A"
			id="80007"
			name="VIEWSTATE_SINK_NO_VALIDATION">
			<description>
				<format>
				No validation between data source %source% and sink %sink%.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/iCatcher/userguide/warning_%id%.htm</helpURL>
		</DefectDef>

		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80020 -->
		<DefectDef guid="18FC5B61-5E02-46eb-8039-9A940CA1554A"
			id="80020"
			name="ANYSOURCE_SETVALUETEXT_NO_VALIDATION">
			<description>
				<format>
				No validation between data source %source% and sink %sink%. The sink is a set
				property of an object. If the object is used in a web page, then attackers may
				inject malicious script to the page.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/iCatcher/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- ////////// Insufficient Validations  801xx ///////// -->
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 80101 -->
		<DefectDef guid="A8F7F262-2A73-4a29-8ED9-462D72FDADDA"
			id="80101"
			name="DOUBLE_DECODE">

			<description>
				<format>
				Data double decode between data source %source% and sink %sink%. Double decode
				allows attack slip through most input validations.
				</format>
				<param name="source" format="'%1!s!'" />
				<param name="sink" format="'%2!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- //////////  Identify sources and sinks  //////////// -->
		<!-- //////////////////////////////////////////////////////////////// -->

		<!-- 80198 -->
		<DefectDef guid="C5CB421B-B793-4329-9A66-95A7CA998E15"
			id="80198"
			name="DATA_SINK">

			<description>
				<format>
				Data sink %sink%.
				</format>
				<param name="sink" format="'%1!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>

		<!-- 80199 -->
		<DefectDef guid="8D16A566-EC30-4546-9BAC-64676C521A0C"
			id="80199"
			name="DATA_SOURCE">

			<description>
				<format>
				Data source %source%.
				</format>
				<param name="source" format="'%1!s!'" />
			</description>

			<helpURL>http://winweb/cse/tools/prefast/userguide/warning_%id%.htm</helpURL>
		</DefectDef>		

	</DefectDefGroup>

</DefectDefs>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\HELIUM.NON_ERROR.xml ===
<?xml version="1.0" encoding="utf-8" ?>
<non_error xmlns="http://msn.com/mlp">
	<pattern value=".*Update is complete.*" />
</non_error>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\Edb2LspkgDefinition.xml ===
﻿<?xml version="1.0" encoding="utf-8" ?>
<!--
    Action types
        Convert: Convert existing element. The element must exist.
        Create: Create if not exist. If exists, same as Convert.
        CreateOnResx2Xml: Create if not exist and if Resx2Xml. if exists, same as Convert.
        Remove: Remove the element.
        
    Note: the defaultValue in the Job element is used for the default id when creating.
-->
<LbaJobs>
    <!--
        "MlpRegisterBuildEdb" | "MlpRegisterBuildEdbMultipleHandoff" : Rename to "MlpRegisterBuildLspkg"
    -->
    <Job action="Convert" edbJobType="MlpRegisterBuildEdb|MlpRegisterBuildEdbMultipleHandoff" lskpgJobType="MlpRegisterBuildLspkg">
        <ParameterList action="CreateOnResx2Xml" edbName="Bin2LcxParameterList" lskpgName="Bin2LcxParameterList">
            <Parameter action="CreateOnResx2Xml" edbName="HandleResxConversion" lskpgName="HandleResxConversion" defaultValue="true"/>
        </ParameterList>
    </Job>

    <!--
        "DailyBuildLocalizationEdb" | "DailyBuildLocalizationCustomEdbEnv" | "DailyBuildLocalizationCustomEdb" : Rename to "DailyBuildLocalizationCustomLspkgEnv"
    -->
    <Job action="Convert" edbJobType="DailyBuildLocalizationEdb|DailyBuildLocalizationCustomEdbEnv|DailyBuildLocalizationCustomEdb" lskpgJobType="DailyBuildLocalizationCustomLspkgEnv" customScriptWarning="true" >
        <CommandList action="Convert">
          <Command action="Convert" edbName="Edb2Bin" lskpgName="Lspkg2Bin" edbPlugin="Edb2Bin" lspkgPlugin="Lspkg" edbParameterListId="Edb2BinParameterList" lspkgParameterListId="Lspkg2BinParameterList"></Command>
          <Command action="Convert" edbName="PostEdb2BinAction" lskpgName="PostBinAction" edbPlugin="CustomScript" lspkgPlugin="CustomScript" edbParameterListId="PostEdb2BinActionParameterList" lspkgParameterListId="PostBinActionParameterList"></Command>
        </CommandList>
        <ParameterList action="CreateOnResx2Xml" edbName="Edb2BinParameterList" lskpgName="Lspkg2BinParameterList">
            <Parameter action="CreateOnResx2Xml" edbName="HandleResxConversion" lskpgName="HandleResxConversion" defaultValue="true"/>
            <Parameter action="Remove" edbName="PerformEdbAnalysis"/>
            <Parameter action="Remove" edbName="FailOnEdbAnalysisErrors"/>
            <Parameter action="Remove" edbName="EdbValidationActions"/>
            <Parameter action="Remove" edbName="EdbValidationErrorActions"/>
            <Parameter action="Remove" edbName="UseCommentsForGeneration"/>
            <Parameter action="Convert" edbName="PerformEdbValidation" lskpgName="PerformValidation"/>
            <Parameter action="Convert" edbName="FailOnEdbValidationErrors" lskpgName="FailOnValidationErrors"/>
            <Parameter action="Convert" edbName="PerformEdbLanguageCheck" lskpgName="PerformLanguageCheck"/>
        </ParameterList>
        <ParameterList action="Import" edbName="PostEdb2BinActionParameterList" lskpgName="PostBinActionParameterList">
          <Parameter action="Import" edbName="path" lskpgName="path" defaultValue=""/>
          <Parameter action="Import" edbName="AllowMultithread" lskpgName="AllowMultithread" defaultValue="false"/>
        </ParameterList>
      <CustomScriptWarning edbJobType="DailyBuildLocalizationCustomEdbEnv|DailyBuildLocalizationCustomEdb">
        <![CDATA[Warning: edb2lspkg migrated the custom script setting for the LocBuild job. Please check the custom script to make sure that it works with LocStudio 6.x.]]>
        </CustomScriptWarning>
    </Job>

    <!--
        "MlpPrepHandoffEdb" : Rename to "MlpPrepHandoffLspkg"
    -->
    <Job action="Convert" edbJobType="MlpPrepHandoffEdb" lskpgJobType="MlpPrepHandoffLspkg">
        <CommandList action="Convert">
          <Command action="Convert" edbName="BuildEdb" lskpgName="BuildLspkg" edbPlugin="BuildEdb" lspkgPlugin="BuildLspkg" edbParameterListId="BuildEdbParameterList" lspkgParameterListId="BuildLspkgParameterList"></Command>
          <Command action="Remove" edbName="Edb2Lcl"></Command>
        </CommandList>
        <ParameterList action="CreateOnResx2Xml" edbName="BuildEdbParameterList" lskpgName="CreateLspkgParameterList">
            <Parameter action="Convert" edbName="PerformEdbAutoTranslation" lskpgName="PerformAutoTranslation"/>
            <Parameter action="Convert" edbName="FailOnEdbAutoTranslationErrors" lskpgName="FailOnAutoTranslationErrors"/>
            <Parameter action="Remove" edbName="PerformEdbAnalysis"/>
            <Parameter action="Remove" edbName="FailOnEdbAnalysisErrors"/>
            <Parameter action="Remove" edbName="PerformEdbValidation"/>
            <Parameter action="Remove" edbName="FailOnEdbValidationErrors"/>
            <Parameter action="Remove" edbName="EdbValidationActions"/>
            <Parameter action="Remove" edbName="EdbValidationErrorActions"/>
            <Parameter action="Convert" edbName="PerformEdbLanguageCheck" lskpgName="PerformLanguageCheck"/>
            <Parameter action="CreateOnResx2Xml" edbName="HandleResxConversion" lskpgName="HandleResxConversion" defaultValue="true"/>
            <Parameter action="Remove" edbName="ImportSourceLocks"/>
        </ParameterList>
        <ParameterList action="Remove" edbName="Edb2LclParameterList" />
    </Job>
    
    <!--
        "MlpHandbackEdb" | "MlpHandbackEdbEnv" : Rename to "MlpHandbackLspkgEnv"
    -->
    <Job action="Convert" edbJobType="MlpHandbackEdb|MlpHandbackEdbEnv" lskpgJobType="MlpHandbackLspkgEnv" customScriptWarning="true" >
        <CommandList action="Convert">
          <Command action="Convert" edbName="Edb2Bin" lskpgName="Lspkg2Bin" edbPlugin="Edb2Bin" lspkgPlugin="Lspkg" edbParameterListId="Edb2BinParameterList" lspkgParameterListId="Lspkg2BinParameterList"></Command>
          <Command action="Convert" edbName="PostEdb2BinAction" lskpgName="PostBinAction" edbPlugin="CustomScript" lspkgPlugin="CustomScript" edbParameterListId="PostEdb2BinActionParameterList" lspkgParameterListId="PostBinActionParameterList"></Command>
        </CommandList>
        <ParameterList action="CreateOnResx2Xml" edbName="Edb2BinParameterList" lskpgName="Lspkg2BinParameterList">
            <Parameter action="CreateOnResx2Xml" edbName="HandleResxConversion" lskpgName="HandleResxConversion" defaultValue="true"/>
            <Parameter action="Remove" edbName="PerformEdbAnalysis"/>
            <Parameter action="Remove" edbName="FailOnEdbAnalysisErrors"/>
            <Parameter action="Remove" edbName="EdbValidationActions"/>
            <Parameter action="Remove" edbName="EdbValidationErrorActions"/>
            <Parameter action="Remove" edbName="UseCommentsForGeneration"/>
            <Parameter action="Convert" edbName="PerformEdbValidation" lskpgName="PerformValidation"/>
            <Parameter action="Convert" edbName="FailOnEdbValidationErrors" lskpgName="FailOnValidationErrors"/>
            <Parameter action="Convert" edbName="PerformEdbLanguageCheck" lskpgName="PerformLanguageCheck"/>
        </ParameterList>
      <ParameterList action="Import" edbName="PostEdb2BinActionParameterList" lskpgName="PostBinActionParameterList">
        <Parameter action="Import" edbName="path" lskpgName="path" defaultValue=""/>
        <Parameter action="Import" edbName="AllowMultithread" lskpgName="AllowMultithread" defaultValue="false"/>
      </ParameterList>
        <CustomScriptWarning edbJobType="MlpHandbackEdb|MlpHandbackEdbEnv">
          <![CDATA[Warning: edb2lspkg migrated the custom script setting for the Handback job. Please check the custom script to make sure that it works with LocStudio 6.x.]]>
        </CustomScriptWarning>
    </Job>

    <!--
        "MlpHandbackRemoteEdb1" | "MlpHandbackRemoteEdb1Env" : Rename to "MlpHandbackRemoteLspkg1Env"
    -->
    <Job action="Convert" edbJobType="MlpHandbackRemoteEdb1|MlpHandbackRemoteEdb1Env" lskpgJobType="MlpHandbackRemoteLspkg1Env" customScriptWarning="true">
        <CommandList action="Convert">
          <Command action="Convert" edbName="Edb2Bin" lskpgName="Lspkg2Bin" edbPlugin="Edb2Bin" lspkgPlugin="Lspkg" edbParameterListId="Edb2BinParameterList" lspkgParameterListId="Lspkg2BinParameterList"></Command>
          <Command action="Convert" edbName="PostEdb2BinAction" lskpgName="PostBinAction" edbPlugin="CustomScript" lspkgPlugin="CustomScript" edbParameterListId="PostEdb2BinActionParameterList" lspkgParameterListId="PostBinActionParameterList"></Command>
        </CommandList>
        <ParameterList action="CreateOnResx2Xml" edbName="Edb2BinParameterList" lskpgName="Lspkg2BinParameterList">
            <Parameter action="CreateOnResx2Xml" edbName="HandleResxConversion" lskpgName="HandleResxConversion" defaultValue="true"/>
            <Parameter action="Remove" edbName="PerformEdbAnalysis"/>
            <Parameter action="Remove" edbName="FailOnEdbAnalysisErrors"/>
            <Parameter action="Remove" edbName="EdbValidationActions"/>
            <Parameter action="Remove" edbName="EdbValidationErrorActions"/>
            <Parameter action="Remove" edbName="UseCommentsForGeneration"/>
            <Parameter action="Convert" edbName="PerformEdbValidation" lskpgName="PerformValidation"/>
            <Parameter action="Convert" edbName="FailOnEdbValidationErrors" lskpgName="FailOnValidationErrors"/>
            <Parameter action="Convert" edbName="PerformEdbLanguageCheck" lskpgName="PerformLanguageCheck"/>
        </ParameterList>
        <ParameterList action="Import" edbName="PostEdb2BinActionParameterList" lskpgName="PostBinActionParameterList">
          <Parameter action="Import" edbName="path" lskpgName="path" defaultValue=""/>
          <Parameter action="Import" edbName="AllowMultithread" lskpgName="AllowMultithread" defaultValue="false"/>
        </ParameterList>
        <CustomScriptWarning edbJobType="MlpHandbackRemoteEdb1|MlpHandbackRemoteEdb1Env">
          <![CDATA[Warning: edb2lspkg migrated the custom script setting for the HandbackRemote1 job. Please check the custom script to make sure that it works with LocStudio 6.x.]]>
        </CustomScriptWarning>
    </Job>
    
    <!--
        "MlpHandbackRemoteEdb2" : Rename to "MlpHandbackRemoteLspkg2"
    -->
    <Job action="Convert" edbJobType="MlpHandbackRemoteEdb2" lskpgJobType="MlpHandbackRemoteLspkg2"/>

    <!--
          "MlpCheckinEdb" | "MlpCheckinCustomEdb" | "MlpCheckinCustomEdbEnv | MlpCheckinEdbTfs" : Rename to "MlpCheckinLspkg|MlpCheckinCustomLspkg|MlpCheckinCustomLspkgEnv|MlpCheckinLspkgTfs"
      -->
    <Job action="Convert" edbJobType="MlpCheckinEdb|MlpCheckinCustomEdb|MlpCheckinCustomEdbEnv|MlpCheckinEdbTfs" lskpgJobType="MlpCheckinLspkg|MlpCheckinCustomLspkgEnv|MlpCheckinCustomLspkgEnv|MlpCheckinLspkgTfs" customScriptWarning="true">
      <CommandList action="Convert">
        <Command action="Convert" edbName="Edb2Bin" lskpgName="Lspkg2Bin" edbPlugin="Edb2Bin" lspkgPlugin="Lspkg" edbParameterListId="Edb2BinParameterList" lspkgParameterListId="Lspkg2BinParameterList"></Command>
        <Command action="Convert" edbName="Edb2Lcl" lskpgName="Lspkg2Lcl" edbPlugin="Edb2Lcl" lspkgPlugin="Lspkg" edbParameterListId="Edb2LclParameterList" lspkgParameterListId="Lspkg2LclParameterList"></Command>
      </CommandList>
      <ParameterList action="Convert" edbName="Edb2BinParameterList" lskpgName="Lspkg2BinParameterList">
        <Parameter action="Remove" edbName="PerformEdbAnalysis"/>
        <Parameter action="Remove" edbName="FailOnEdbAnalysisErrors"/>
        <Parameter action="Convert" edbName="PerformEdbValidation" lskpgName="PerformValidation"/>
        <Parameter action="Convert" edbName="FailOnEdbValidationErrors" lskpgName="FailOnValidationErrors"/>
        <Parameter action="Remove" edbName="EdbValidationActions"/>
        <Parameter action="Remove" edbName="EdbValidationErrorActions"/>
        <Parameter action="Convert" edbName="PerformEdbLanguageCheck" lskpgName="PerformLanguageCheck"/>
        <Parameter action="Remove" edbName="UseCommentsForGeneration"/>
        <Parameter action="Create" edbName="Action" lskpgName="Action" defaultValue="Lspkg2Bin"/>
      </ParameterList>
      <ParameterList action="Convert" edbName="Edb2LclParameterList" lskpgName="Lspkg2LclParameterList">
        <Parameter action="Convert" edbName="PerformEdbValidation" lskpgName="PerformValidation"/>
        <Parameter action="Convert" edbName="FailOnEdbValidationErrors" lskpgName="FailOnValidationErrors"/>
        <Parameter action="Remove" edbName="EdbValidationActions"/>
        <Parameter action="Remove" edbName="EdbValidationErrorActions"/>
        <Parameter action="Convert" edbName="PerformEdbLanguageCheck" lskpgName="PerformLanguageCheck"/>
      </ParameterList>
      <ParameterList action="Import" edbName="CustomCheckinScriptParameterList" lskpgName="CustomCheckinScriptParameterList">
        <Parameter action="Import" edbName="path" lskpgName="path" defaultValue=""/>
        <Parameter action="Import" edbName="AllowMultithread" lskpgName="AllowMultithread" defaultValue="false"/>
      </ParameterList>
      <CustomScriptWarning edbJobType="MlpCheckinCustomEdbEnv">
        <![CDATA[Warning: edb2lspkg migrated the custom script setting for the Checkin job. Please check the custom script to make sure that it works with LocStudio 6.x.]]>
      </CustomScriptWarning>
    </Job>
    
    <!--
        "CheckinLcl" : Rename to "CheckinLspkgLcl"
    -->
    <Job action="Convert" edbJobType="CheckinLcl" lskpgJobType="CheckinLspkgLcl">
        <CommandList action="Remove">
          <Command action="Remove" edbName="SDCreateChangeList"></Command>
          <Command action="Remove" edbName="Edb2Lcl"></Command>
          <Command action="Remove" edbName="SDCheckin"></Command>
          <Command action="Remove" edbName="SDSubmitChangelist"></Command>
        </CommandList>
        <ParameterList action="Remove" edbName="SDCreateChangelistParameterList" />
        <ParameterList action="Remove" edbName="Edb2LclParameterList" />
        <ParameterList action="Remove" edbName="SDCheckinParameterList" />
        <ParameterList action="Remove" edbName="SDSubmitChangelistParameterList" />
    </Job>
    
    <!--
        "PolicheckEdb" : Rename to "PolicheckLspkg"
    -->
    <Job action="Convert" edbJobType="PolicheckEdb" lskpgJobType="PolicheckLspkg">
        <ParameterList action="Remove" edbName="PolicheckScanParameterList" />
    </Job>
    
    <!--
          "MlpRegisterBranchContent" : Just remove
      -->
    <Job action="Remove" edbJobType="MlpRegisterBranchContent" lskpgJobType="MlpRegisterBranchContent"/>

    <!--
        ValidateEdb : Convert
    -->
    <Job action="Convert" edbJobType="ValidateEdb" lskpgJobType="ValidateLspkg" newID="ValidateLspkg">
      <CommandList action="Remove"></CommandList>
      <ParameterList action="Remove" edbName="ValidateLanguageParameterList" />
      <ParameterList action="Remove" edbName="ValidateEdbParameterList" />
    </Job>
    
    <PluginPropertyList action="Convert">
      <Property action="Remove" edbName="ProductName"/>
      <Property action="Remove" edbName="EdbVersion"/>
    </PluginPropertyList>

</LbaJobs>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\FCL\Libraries\CTFCore.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CTFCore</name>
    </assembly>
    <members>
        <member name="T:MS.Swi.FCLCoreComponentAttribute">
            <summary>
            This marks the component as part of the FCL core. This should NOT be used by anyone except
            SWI. For everyone else, use the MS.Swi.InstallationManagementAttribute
            </summary>
        </member>
        <member name="T:MS.Swi.Reflection">
            <summary>
            General reflection helper functions, grouped to prevent code duplication
            </summary>
        </member>
        <member name="M:MS.Swi.Reflection.#cctor">
            <summary>
            Add bridging support for loaded assemblies in the LoadFrom() domain being called by Assemblies in the
            Load() domain.
            </summary>
        </member>
        <member name="M:MS.Swi.Reflection.ResolveMissingAssembly(System.Object,System.ResolveEventArgs)">
            <summary>
            Bridge the LoadFrom and Load contexts by searching the whole set of loaded assemblies looking for
            the assembly to resolve
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Reflection.#ctor">
            <summary>
            There are no valid Reflection objects
            </summary>
        </member>
        <member name="M:MS.Swi.Reflection.LoadAssembliesFromDirectory(System.String)">
            <summary>
            Load all valid managed assemblies in the specified directory
            </summary>
            <param name="directoryPath">The specified directory</param>
            <returns>True if we loaded any assemblies, false if not</returns>
        </member>
        <member name="M:MS.Swi.Reflection.FindClass(System.String)">
            <summary>
            Search all loaded assemblies for the specified classname
            </summary>
            <param name="className">The full, case sensitive name</param>
            <returns>The matching type, or null</returns>
        </member>
        <member name="M:MS.Swi.Reflection.FindClass(System.String,System.String)">
            <summary>
            Search all loaded assemblies for the specified classname. Note that this does NOT
            limit itself to public classes, because we are asking for the class by name.
            </summary>
            <param name="className">The full, case sensitive name</param>
            <param name="requiredInterface">The required interface, or null, if no interface is required</param>
            <returns>The matching type, or null</returns>
        </member>
        <member name="M:MS.Swi.Reflection.FindClasses(System.String,System.Type)">
            <summary>
            Find the set of all public classes which are non-abstract, and implement the
            specified interface and the specified attribute (if provided)
            </summary>
            <param name="requiredInterface">The required interface</param>
            <param name="requiredAttribute">The required attribute, or null</param>
            <returns>A list of Type objects</returns>
        </member>
        <member name="M:MS.Swi.Reflection.CacheFclAssembly(System.Reflection.Assembly)">
            <summary>
            Cache the assembly into the FCL lookaside cache if it matches
            </summary>
            <param name="loadedAssembly">The loaded assembly</param>
        </member>
        <member name="M:MS.Swi.Reflection.LoadReferencedAssembly(System.String)">
            <summary>
            Load an assembly (which must be referenced by another assembly already loaded) into
            the AppDomain. Note that we will return success if the desired assembly has already been
            loaded, and that we may load more than one assembly with the same simple name.
            </summary>
            <param name="assemblyName">The symbolic name of the assembly we want to load</param>
            <returns>True if the assembly can be loaded, false if not</returns>
        </member>
        <member name="M:MS.Swi.Reflection.FindMethod(System.String,System.Type[])">
            <summary>
            Find a specific method, ignoring privacy 
            </summary>
            <param name="methodFullName">The full (i.e. namespace.class.method) name of the method</param>
            <param name="arguments">The method argument signature to look for or null if there are no arguments</param>
            <returns>The matching method, or null if no method was found</returns>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstArray`1">
            <summary>
            An uneditable view of an array of objects or value types
            </summary>
            <typeparam name="ContentsType">The underlying array</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstArray`1.#ctor(`0[])">
            <summary>
            Construct a const view of an underlying array
            </summary>
            <param name="underlyingArray">The underlying array</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstArray`1.Extract(System.Int32,System.Int32)">
            <summary>
            Extract a subset of the source array 
            </summary>
            <param name="startIndex">The start index in the source array</param>
            <param name="length">The length of the subset</param>
            <returns>The newly constructed array</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstArray`1.Copy(System.Int32,System.Int32,System.Int32,`0[])">
            <summary>
            Copy a subset of the contents of the array into another array
            </summary>
            <param name="startIndex">The start index in the source array</param>
            <param name="length">The length of the subset</param>
            <param name="destIndex">The start index in the destination array</param>
            <param name="destination">The destination array</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstArray`1.ToArray">
            <summary>
            Create a clone of the underlying array and return it
            </summary>
            <returns>The shallow clone of the underlying array</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstArray`1.GetEnumerator">
            <summary>
            The enumerator for iteration
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstArray`1.Length">
            <summary>
            The length of the array
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstArray`1.Item(System.Int32)">
            <summary>
            The contents at any particular index
            </summary>
            <param name="index">The index into the array</param>
            <returns>The value at that location</returns>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstList`1">
            <summary>								
            An uneditable view of a list of objects
            </summary>
            <typeparam name="ContentsType">The underlying type</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`1.#ctor(MS.Swi.Data.Generic.ConstList{`0})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`1.#ctor(`0[])">
            <summary>
            Construct a read-only view of an array as a list
            </summary>
            <param name="underlyingArray">The underlying array</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`1.GetEnumerator">
            <summary>
            The enumerator for iteration
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstList`1.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstList`1.Item(System.Int32)">
            <summary>
            The element at the indicated list
            </summary>
            <param name="index">The index</param>
            <returns>The element</returns>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstList`2">
            <summary>
            An uneditable view of a list of objects which also have const interfaces that can be exposed
            </summary>
            <typeparam name="IConstContentsType">The const interface (should be an IConst...)</typeparam>
            <typeparam name="ContentsType">The underlying implementation (should be an IConst...)</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`2.#ctor(System.Collections.Generic.List{`1})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`2.#ctor(MS.Swi.Data.Generic.ConstList{`1})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`2.#ctor(MS.Swi.Data.Generic.ConstList{`0,`1})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`2.#ctor(`1[])">
            <summary>
            Construct a read-only view of an array as a list
            </summary>
            <param name="underlyingArray">The underlying array</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstList`2.GetEnumerator">
            <summary>
            The enumerator for iteration
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstList`2.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstList`2.Item(System.Int32)">
            <summary>
            The element at the indicated list
            </summary>
            <param name="index">The index</param>
            <returns>The element</returns>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstSortedList`2">
            <summary>
            An uneditable view of a sorted list of objects
            </summary>
            <typeparam name="KeyType">The key of the sorted list</typeparam>
            <typeparam name="ContentsType">The underlying implementation (should be an IConst...)</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`2.#ctor(System.Collections.Generic.SortedList{`0,`1})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingSortedList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`2.#ctor(MS.Swi.Data.Generic.ConstSortedList{`0,`1})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingSortedList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`2.IndexOfKey(`0)">
            <summary>
            The index of the given key
            </summary>
            <param name="key">The key</param>
            <returns>The index</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`2.GetByIndex(System.Int32)">
            <summary>
            Get the value based on an index
            </summary>
            <param name="index">The index</param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`2.ContainsKey(`0)">
            <summary>
            Does the list contain the given key
            </summary>
            <param name="key">The key</param>
            <returns>True if it contains the key, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`2.GetEnumerator">
            <summary>
            The enumerator for iteration
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstSortedList`2.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstSortedList`2.Item(`0)">
            <summary>
            The element at the indicated list
            </summary>
            <param name="index">The index</param>
            <returns>The element</returns>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstSortedList`3">
            <summary>
            An uneditable view of a sorted list of objects which also have const interfaces that can be exposed
            </summary>
            <typeparam name="KeyType">The key of the sorted list</typeparam>
            <typeparam name="IConstContentsType">The const interface (should be an IConst...)</typeparam>
            <typeparam name="ContentsType">The underlying implementation (should be an IConst...)</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.#ctor(System.Collections.Generic.SortedList{`0,`2})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingSortedList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.#ctor(MS.Swi.Data.Generic.ConstSortedList{`0,`2})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingSortedList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.#ctor(MS.Swi.Data.Generic.ConstSortedList{`0,`1,`2})">
            <summary>
            Construct a read-only view of an existing list
            </summary>
            <param name="underlyingSortedList"></param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.IndexOfKey(`0)">
            <summary>
            The index of the given key
            </summary>
            <param name="key">The key</param>
            <returns>The index</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.GetByIndex(System.Int32)">
            <summary>
            Get the value based on an index
            </summary>
            <param name="index">The index</param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.ContainsKey(`0)">
            <summary>
            Does the list contain the given key
            </summary>
            <param name="key">The key</param>
            <returns>True if it contains the key, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstSortedList`3.GetEnumerator">
            <summary>
            The enumerator for iteration
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstSortedList`3.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstSortedList`3.Item(`0)">
            <summary>
            The element at the indicated list
            </summary>
            <param name="index">The index</param>
            <returns>The element</returns>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstDictionary`2">
            <summary>
            An uneditable view of a dictionary
            </summary>
            <typeparam name="KeyType">The key type</typeparam>
            <typeparam name="ContentsType">The contents type</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`2.#ctor(System.Collections.Generic.Dictionary{`0,`1})">
            <summary>
            Construct the view of the underlying dictionary
            </summary>
            <param name="underlyingDictionary">The underlying dictionary</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`2.#ctor(MS.Swi.Data.Generic.ConstDictionary{`0,`1})">
            <summary>
            Construct the view of the underlying dictionary
            </summary>
            <param name="underlyingDictionary">The underlying dictionary</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`2.ContainsKey(`0)">
            <summary>
            Does the dictionary contain the given key
            </summary>
            <param name="key">The key</param>
            <returns>True if it contains the key, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`2.GetEnumerator">
            <summary>
            Provide an enumeration of the contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`2.Item(`0)">
            <summary>
            Provide access to the specified element
            </summary>
            <param name="index">The index to use</param>
            <returns>The specified element</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`2.Values">
            <summary>
            Provide direct access to all of the values
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`2.Keys">
            <summary>
            Provide direct access to all of the keys
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`2.Count">
            <summary>
            The number of elements in the dictionary
            </summary>
        </member>
        <member name="T:MS.Swi.Data.Generic.ConstDictionary`3">
            <summary>
            An uneditable view of the const forms of a dictionary
            </summary>
            <typeparam name="KeyType">The key type</typeparam>
            <typeparam name="IConstContentsType">The const interface type</typeparam>
            <typeparam name="ContentsType">The contents type</typeparam>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`3.#ctor(System.Collections.Generic.Dictionary{`0,`2})">
            <summary>
            Construct the view of the underlying dictionary
            </summary>
            <param name="underlyingDictionary">The underlying dictionary</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`3.#ctor(MS.Swi.Data.Generic.ConstDictionary{`0,`2})">
            <summary>
            Construct the view of the underlying dictionary
            </summary>
            <param name="underlyingDictionary">The underlying dictionary</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`3.#ctor(MS.Swi.Data.Generic.ConstDictionary{`0,`1,`2})">
            <summary>
            Construct the view of the underlying dictionary
            </summary>
            <param name="underlyingDictionary">The underlying dictionary</param>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`3.ContainsKey(`0)">
            <summary>
            Does the dictionary contain the given key
            </summary>
            <param name="key">The key</param>
            <returns>True if it contains the key, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.Generic.ConstDictionary`3.GetEnumerator">
            <summary>
            Provide an enumeration of the contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`3.Item(`0)">
            <summary>
            Provide access to the specified element
            </summary>
            <param name="index">The index to use</param>
            <returns>The element specified as the Const interface</returns>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`3.Values">
            <summary>
            Provide direct access to all of the values
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`3.Keys">
            <summary>
            Provide direct access to all of the keys
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Generic.ConstDictionary`3.Count">
            <summary>
            The number of elements in the dictionary
            </summary>
        </member>
        <member name="T:MS.Swi.Utilities">
            <summary>
            General system or utility functions, grouped to prevent code duplication
            </summary>
        </member>
        <member name="M:MS.Swi.Utilities.#ctor">
            <summary>
            There are no valid Utilities objects
            </summary>
        </member>
        <member name="F:MS.Swi.Utilities.ArchitectureIs64Bit">
            <summary>
            Whether or not we are running in a 64 bit CLR
            </summary>
        </member>
        <member name="M:MS.Swi.Utilities.AddToPath(System.String)">
            <summary>
            Add the specified directory to the end of the path, IF it doesn't already exist
            somewhere with in the path
            </summary>
            <param name="directory">The directory to add</param>
        </member>
        <member name="M:MS.Swi.Utilities.AddFclPaths">
            <summary>
            Add the FCL file paths to the path environment variable for this process
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstToken">
            <summary>
            The read-only interfaces to the Token object
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstToken.GetValidDefinitions">
            <summary>
            Get the complete set of valid definitions we could apply
            </summary>
            <returns>The set</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstToken.GetContents(System.String)">
            <summary>
            Get the associated contents object given an FCL definition name and a 
            native representation. Note that this will NOT go past a split contents if the
            transformation requires all the data to be available before it can be transformed.
            </summary>
            <param name="fclDefinition">The definition to look for or null if the definition should not be checked</param>
            <returns>The matching parent data contents, or null if one could not be found</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstToken.CalculateSignature">
            <summary>
            Calculate a hashed signature for this token
            </summary>
            <returns>The token signature</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstToken.TrimSplitPoints(System.Collections.IEnumerable)">
            <summary>
            Trim out zero length split points from the specified set (including split points at the ends)
            </summary>
            <param name="splitPoints">The split points to analyzer</param>
            <returns>The new set of split points</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.Contents">
            <summary>
            The contents object of the token. Note that for reference types, this will invoke
            a Clone() operation.
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.ContentsNativeType">
            <summary>
            The native type of the token object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.IsStatic">
            <summary>
            Whether or not this is a static token (i.e. not dependent on other tokens)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.IsDerived">
            <summary>
            Whether or not this is a derived token (i.e. dependent on one or more other tokens)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.Definition">
            <summary>
            The definition of the token type
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.Identifier">
            <summary>
            The identifier associated with the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.Position">
            <summary>
            The position of the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.References">
            <summary>
            The token references associated with the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstToken.IsImmutable">
            <summary>
            Whether or not the contents of this token have been defined as being IsImmutable
            </summary>
        </member>
        <member name="T:MS.Swi.Data.Token">
            <summary>
            The representation of data in the DataMap
            </summary>
        </member>
        <member name="M:MS.Swi.Data.Token.#ctor(MS.Swi.Data.ElementDefinition,System.String,MS.Swi.Data.TokenPosition,MS.Swi.Data.DataContents,MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Construct a token based on a definition, position, and contents. 
            </summary>
            <param name="definition">The type of the token</param>
            <param name="identifier">The identifier for the token (null will be silently changed to an empty string)</param>
            <param name="position">The position of the token in the DataMap</param>
            <param name="contents">The contents of the token</param>
            <param name="restrictions">The restrictions that apply to the token (or null).</param>
            <param name="references">The reference table for the token (or null). If there are references, there must be a delegate, and visa versa</param>
            <param name="calculationDelegate">The calculation delegate for the token (or null). If there are references, there must be a delegate, and visa versa</param>
        </member>
        <member name="M:MS.Swi.Data.Token.#ctor(MS.Swi.Data.TokenPosition,MS.Swi.Data.Token)">
            <summary>
            Copy constructor for the Token class, to create a duplicate token with the specified position
            </summary>
            <param name="position">The position of the new token</param>
            <param name="sourceToken">The source token</param>
        </member>
        <member name="M:MS.Swi.Data.Token.GetValidDefinitions">
            <summary>
            Get the complete set of valid definitions we could apply
            </summary>
            <returns>The set</returns>
        </member>
        <member name="M:MS.Swi.Data.Token.MS#Swi#Data#IConstToken#GetContents(System.String)">
            <summary>
            Get the associated contents object given an FCL definition name and a 
            native representation. Note that this will NOT go past a split contents if the
            transformation requires all the data to be available before it can be transformed.
            </summary>
            <param name="fclDefinition">The definition to look for or null if the definition should not be checked</param>
            <returns>The matching parent data contents, or null if one could not be found</returns>
        </member>
        <member name="M:MS.Swi.Data.Token.GetContents(System.String)">
            <summary>
            Get the associated contents object given an FCL definition name and a 
            native representation. Note that this will NOT go past a split contents if the
            transformation requires all the data to be available before it can be transformed.
            </summary>
            <param name="fclDefinition">The definition to look for or null if the definition should not be checked</param>
            <returns>The matching parent data contents, or null if one could not be found</returns>
        </member>
        <member name="M:MS.Swi.Data.Token.CalculateSignature">
            <summary>
            Calculate a hashed signature for this token
            </summary>
            <returns>The token signature</returns>
        </member>
        <member name="M:MS.Swi.Data.Token.TrimSplitPoints(System.Collections.IEnumerable)">
            <summary>
            Trim out zero length split points from the specified set (including split points at the ends)
            </summary>
            <param name="splitPoints">The split points to analyzer</param>
            <returns>The new set of split points</returns>
        </member>
        <member name="M:MS.Swi.Data.Token.AddRestrictions(MS.Swi.Data.IConstTokenRestrictions)">
            <summary>
            Add the new restrictions to the existing restrictions. 
            </summary>
            <param name="newRestrictions">The new restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.Token.AddReferences(System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference})">
            <summary>
            Add the new references to the existing reference set. Note that the new references
            must not contradict an existing reference in the existing table
            </summary>
            <param name="newReferences">The new references</param>
        </member>
        <member name="P:MS.Swi.Data.Token.Position">
            <summary>
            The position of the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.Definition">
            <summary>
            The definition of the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.Identifier">
            <summary>
            The value associated with the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.Contents">
            <summary>
            Provide a copy of the contents of the token. Note that for reference types, this will
            invoke a Clone() operation.
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.ContentsNativeType">
            <summary>
            The native type of the contents object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.IsStatic">
            <summary>
            Whether or not this is a static token (i.e. not dependent on other tokens)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.IsDerived">
            <summary>
            Whether or not this is a derived token (i.e. dependent on one or more other tokens)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.IsImmutable">
            <summary>
            Whether or not the contents of this token have been defined as being IsImmutable
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.IsValid">
            <summary>
            Whether or not this token has valid contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.AssociatedContents">
            <summary>
            The associated contents object. This is tightly coupled to the 
            contents object (which has a paired associated token)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.MS#Swi#Data#IConstToken#References">
            <summary>
            The read-only view of the const form of the references
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.References">
            <summary>
            The read-only view of the references
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Token.CalculationDelegate">
            <summary>
            The calculation delegate
            </summary>
        </member>
        <member name="T:MS.Swi.Data.Token.CalculateContentsDelegate">
            <summary>
            Calculate the contents of an element given the references that the contents are based on
            </summary>
            <param name="informationSource">The contents information source</param>
            <param name="targetContents">The contents object that is being calculated</param>
            <param name="references">The references</param>
            <returns>The new contents</returns>
        </member>
        <member name="T:MS.Swi.Data.IConstDataMap">
            <summary>
            A const (i.e. true Read Only) access interface to a DataMap
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstDataMap.TokenIsInMap(MS.Swi.Data.IConstToken)">
            <summary>
            Whether or not the specified token is in the map at its alledged location
            </summary>
            <param name="token">The token</param>
            <returns>True if it is in the map, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataMap.FirstToken">
            <summary>
            The first token in the DataMap
            </summary>
            <returns>The first token in the DataMap, or null if the DataMap has no tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataMap.NextToken(MS.Swi.Data.IConstToken,System.Boolean)">
            <summary>
            The next token in the DataMap
            </summary>
            <param name="referenceToken">The token this is in reference to</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The next token, or null if there is no matching next token</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataMap.PreviousToken(MS.Swi.Data.IConstToken,System.Boolean)">
            <summary>
            The previous token in the DataMap
            </summary>
            <param name="referenceToken">The token this is in reference to</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The previous token, or null if there is no matching previous token</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataMap.NextToken(MS.Swi.Data.TokenPosition,System.Boolean)">
            <summary>
            The next token in the DataMap. If there is no token at the reference position, the 
            spanRootElements argument will be ignored, and the next token will be returned.
            </summary>
            <param name="referencePosition">The reference position</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The next token, or null if there is no matching next token</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataMap.PreviousToken(MS.Swi.Data.TokenPosition,System.Boolean)">
            <summary>
            The previous token in the DataMap. If there is no token at the reference position, the 
            spanRootElements argument will be ignored, and the previous token will be returned.
            </summary>
            <param name="referencePosition">The reference position</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The previous token, or null if there is no matching previous token</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstDataMap.Definitions">
            <summary>
            Access to the definitions used by the DataMap
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataMap.Transformations">
            <summary>
            Access to the transformations used by the DataMap
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataMap.Tokens">
            <summary>
            Access to the data tokens found
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataMap.Encapsulations">
            <summary>
            Access to the encapsulations found
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataMap">
            <summary>
            A DataMap is a mapping of data both according to type, and based on the original DataBuffers
            that it was derived from. The DataMap contains the type definitions, as well as the complete data
            set stored in ordinal order, along with the information as far as the amount of data remaining indexed
            by the original buffer count. 
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataMap.#ctor(MS.Swi.Data.IConstDataTransformations,MS.Swi.Data.IConstElementDefinitions)">
            <summary>
            Create an empty data map
            </summary>
            <param name="transformations">The valid transformations</param>
            <param name="definitions">The valid definitions</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.#ctor(MS.Swi.Data.IConstDataTransformations,MS.Swi.Data.IConstElementDefinitions,MS.Swi.Data.Generic.ConstList{MS.Swi.Data.IConstDataBuffer,MS.Swi.Data.DataBuffer})">
            <summary>
            Create a data map with simple byte array buffers. Note that this automatically applies 
            size restrictions to the buffers limiting them to the maximum size of the source DataBuffer
            (for all manipulations that conform to size restrictions)
            </summary>
            <param name="transformations">The valid transformations</param>
            <param name="definitions">The valid definitions</param>
            <param name="buffers">The raw data buffers to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.#ctor(System.String,System.String)">
            <summary>
            Create an empty data map
            </summary>
            <param name="transformationFileName">The file name for the valid transformation table</param>
            <param name="definitionFileName">The file name for the valid definitions</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.FindTransformations(System.String[])">
            <summary>
            Find the set of transformations defined by name. If a transformation
            cannot be found, this will throw an exception. If the array of names is empty or null,
            it will return a null array.
            </summary>
            <param name="transformationNames">The transformation names</param>
            <returns>The transformation names</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CreateReferences(System.Object[])">
            <summary>
            Create references, based on a variable string of arguments.
            
            The argument sequence is:
            
            	String: A reference name - Note that this MUST end in a ':'
            	TokenReference.TokenReferenceType: A reference type
            
            	Followed by one or more of any of the following (note that the order IS important):
            	TokenPosition or IConstToken: A reference to the contents of the specified token
            	String (ElementDefinition name),TokenPosition: A reference to the first contents of the specified token of the given type
            
            	OR
            
            	String: A reference name - Note that this MUST end in a ':'
            	Followed by one or more TokenReference objects
            
            Note that MULTIPLE labels can be defined (i.e. the entire sequence can repeat)
            </summary>
            <param name="arguments">The list of arguments for the reference creation</param>
            <returns>The reference table</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CreateAnonymousReference(MS.Swi.Data.TokenReference.TokenReferenceType,System.Object[])">
            <summary>
            Create references, based on a variable string of arguments.
            
            The argument sequence is:
            
            	One or more of any of the following (note that the order IS important):
            	TokenPosition or IConstToken: A reference to the contents of the specified token
            	String (ElementDefinition name),TokenPosition or IConstToken: A reference to the first contents of the specified token of the given type
            
            An ArgumentException will be thrown if there are no references specified
            </summary>
            <param name="referenceType">The type of reference</param>
            <param name="arguments">The list of arguments for the reference creation</param>
            <returns>The unnamed reference</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CreateToken(MS.Swi.Data.TokenPosition,MS.Swi.Data.ElementDefinition,System.String,MS.Swi.Data.DataContents,MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Create a token that is not attached to any existing root token in the DataMap
            </summary>
            <param name="position">The token position</param>
            <param name="definition">The token definition</param>
            <param name="identifier">The identifier for the token (null will be silently turned into an empty string)</param>
            <param name="contents">The contents</param>
            <param name="restrictions">The restrictions which apply to the token</param>
            <param name="references">The references which apply to the token</param>
            <param name="calculationDelegate">The calculation delegate to use with the token</param>
            <returns>The constructed token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CreateToken(MS.Swi.Data.TokenPosition,System.Object,System.String,System.String,System.String[],MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Create a token that is not attached to any existing root token in the DataMap
            </summary>
            <param name="position">The token position</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The definition to apply</param>
            <param name="identifier">The identifier for the token (null will be silently turned into an empty string)</param>
            <param name="transformationNames">The transformations to apply</param>
            <param name="restrictions">The restrictions which apply to the token</param>
            <param name="references">The references which apply to the token</param>
            <param name="calculationDelegate">The calculation delegate to use with the token</param>
            <returns>The constructed token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Insert(MS.Swi.Data.TokenPosition,MS.Swi.Data.Token)">
            <summary>
            Use the AttemptToAdd method to try to add a token to the DataMap, throwing an invalid operation
            exception if the token could not be added
            </summary>
            <param name="position">The position</param>
            <param name="token">The token</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CanInsertToken(MS.Swi.Data.TokenPosition,MS.Swi.Data.Token,MS.Swi.Data.DataContents@,MS.Swi.Data.DataContents@)">
            <summary>
            Determine if we can insert a token at the given position, and if we can, whether or not we will need
            to change the ancestry of the token to make it work
            </summary>
            <param name="position">The selected position</param>
            <param name="token">The token to be inserted</param>
            <param name="selectedChild">The child contents that should be modified for the insertion, or null if no change is needed</param>
            <param name="selectedParent">The parent that should be modified for the insertion, or null if no change is needed</param>
            <returns>True if the token can be inserted in that position, False if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AttemptToInsert(MS.Swi.Data.TokenPosition,MS.Swi.Data.Token)">
            <summary>
            Given a token, insert it into the TokenList.
            </summary>
            <param name="position">The position</param>
            <param name="token">The token</param>
            <returns>True if it could be integrated in, false if there is a conflict</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AttemptToAdoptSiblingTokenContents(MS.Swi.Data.Token,MS.Swi.Data.Token)">
            <summary>
            Attempt to adopt the token into a common ancestor with its prospective sibling
            </summary>
            <param name="prospectiveSibling">The prospective sibling token</param>
            <param name="token">The token being adopted</param>
            <returns>True if it was adopted, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CanAdoptSiblingTokenContents(MS.Swi.Data.Token,MS.Swi.Data.Token,MS.Swi.Data.DataContents@,MS.Swi.Data.DataContents@)">
            <summary>
            Determine if a token can descend from an ancestor of its prospective sibling, and if so, where it 
            should descend from
            </summary>
            <param name="prospectiveSibling">The prospective sibling token</param>
            <param name="token">The token being adopted</param>
            <param name="selectedChild">The child that can be adopted, or null if there is no need for adoption. Note that it is possible for null to be returned when we return true.</param>
            <param name="selectedParent">The parent adoption point, or null if there is no need for adoption. Note that it is possible for null to be returned when we return true</param>
            <returns>True if it can be adopted, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.CanAdoptTokenContents(MS.Swi.Data.DataContents,MS.Swi.Data.Token,MS.Swi.Data.DataContents@)">
            <summary>
            Determine if it is possible to adopt the Token to the prospective parent, and if it is possible,
            return the DataContents that should be adopted in to the prospective parent
            </summary>
            <param name="prospectiveParent">The prospective parent</param>
            <param name="token">The token</param>
            <param name="selectedChild">The child that can be adopted, or null if there is no need for adoption. Note that it is possible for null to be returned when we return true.</param>
            <returns>True if the Token can be adopted, False if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AttemptToAdoptTokenContents(MS.Swi.Data.DataContents,MS.Swi.Data.Token)">
            <summary>
            Add the contents of a specific token into a prospective parent token, if we can. We attempt to move
            as much of the parent tree of this token as we can
            </summary>
            <param name="prospectiveParent">The prospective parent</param>
            <param name="token">The token</param>
            <returns>True if the inheritance chain of the token now goes through the prospective parent, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Append(System.Object,System.String,System.String[])">
            <summary>
            Append a token to the end of the DataMap. This is used only in the simple case where we are
            creating a DataMap with a single root node, and are appending onto it.
            </summary>
            <param name="contents">The contents object</param>
            <param name="tokenDefinition">The token definition</param>
            <param name="transformations">The transformations to apply</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Append(System.Object,System.String,System.String[],MS.Swi.Data.TokenRestrictions)">
            <summary>
            Append a token to the end of the DataMap. This is used only in the simple case where we are
            creating a DataMap with a single root node, and are appending onto it.
            </summary>
            <param name="contents">The contents object</param>
            <param name="tokenDefinition">The token definition</param>
            <param name="transformations">The transformations to apply</param>
            <param name="restrictions">The restrictions to apply</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AppendRootToken(System.Object,System.String,System.String[])">
            <summary>
            Append a new root token (i.e. a new root element) to the end of the DataMap
            </summary>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AppendRootToken(System.Object,System.String,System.String[],MS.Swi.Data.TokenRestrictions)">
            <summary>
            Append a new root token (i.e. a new root element) to the end of the DataMap
            </summary>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use (or null)</param>
            <param name="restrictions">The restrictions to apply to the new token (or null)</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Append(MS.Swi.Data.TokenPosition,System.Object,System.String,System.String[])">
            <summary>
            Append a token after the token at the position given. Note that this may result
            in the renumber of tokens (for example, if we want to append after 0.1.1 and there is 
            already a 0.1.2, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the position does not have a corresponding token, we will throw an exception
            </summary>
            <param name="position">The position</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Append(MS.Swi.Data.TokenPosition,System.Object,System.String,System.String[],MS.Swi.Data.TokenRestrictions)">
            <summary>
            Append a token after the token at the position given. Note that this may result
            in the renumber of tokens (for example, if we want to append after 0.1.1 and there is 
            already a 0.1.2, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the position does not have a corresponding token, we will throw an exception
            </summary>
            <param name="position">The position</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <param name="restrictions">The restrictions to apply</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Append(MS.Swi.Data.IConstToken,System.Object,System.String,System.String[])">
            <summary>
            Append a token after the token given. Note that this may result
            in the renumber of tokens (for example, if we want to append after 0.1.1 and there is 
            already a 0.1.2, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the current token is not part of the DataMap, we will throw an exception
            </summary>
            <param name="currentToken">The corresponding token</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Append(MS.Swi.Data.IConstToken,System.Object,System.String,System.String[],MS.Swi.Data.TokenRestrictions)">
            <summary>
            Append a token after the token given. Note that this may result
            in the renumber of tokens (for example, if we want to append after 0.1.1 and there is 
            already a 0.1.2, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the current token is not part of the DataMap, we will throw an exception
            </summary>
            <param name="currentToken">The corresponding token</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <param name="restrictions">The restrictions to apply</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Insert(MS.Swi.Data.TokenPosition,System.Object,System.String,System.String[])">
            <summary>
            Insert a token before the specified position. Note that this may result
            in the renumber of tokens (for example, if we want to insert before 0.1.1 and there is 
            already a 0.1.0, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the position does not have a corresponding token, we will throw an exception
            </summary>
            <param name="position">The position</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <returns>The inserted token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Insert(MS.Swi.Data.TokenPosition,System.Object,System.String,System.String[],MS.Swi.Data.TokenRestrictions)">
            <summary>
            Insert a token before the specified position. Note that this may result
            in the renumber of tokens (for example, if we want to insert before 0.1.1 and there is 
            already a 0.1.0, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the position does not have a corresponding token, we will throw an exception
            </summary>
            <param name="position">The position</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <param name="restrictions">The restrictions to apply</param>
            <returns>The inserted token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Insert(MS.Swi.Data.IConstToken,System.Object,System.String,System.String[])">
            <summary>
            Insert a token before the token given. Note that this may result
            in the renumber of tokens (for example, if we want to append after 0.1.1 and there is 
            already a 0.1.2, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the current token is not part of the DataMap, we will throw an exception
            </summary>
            <param name="currentToken">The corresponding token</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Insert(MS.Swi.Data.IConstToken,System.Object,System.String,System.String[],MS.Swi.Data.TokenRestrictions)">
            <summary>
            Insert a token before the token given. Note that this may result
            in the renumber of tokens (for example, if we want to append after 0.1.1 and there is 
            already a 0.1.2, we would end up with 0.1.1.0, and 0.1.1.1 for our two tokens).
            
            If the current token is not part of the DataMap, we will throw an exception
            </summary>
            <param name="currentToken">The corresponding token</param>
            <param name="contents">The contents</param>
            <param name="tokenDefinition">The token definition to use</param>
            <param name="transformations">The transformations to use</param>
            <param name="restrictions">The restrictions to apply</param>
            <returns>The appended token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Protect(MS.Swi.Data.IConstToken)">
            <summary>
            Mark the specified token contents as immutable, protecting them from any change
            </summary>
            <param name="token">The token being marked immutable</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Protect(MS.Swi.Data.TokenPosition)">
            <summary>
            Mark the specified token contents as immutable, protecting them from any change
            </summary>
            <param name="tokenPosition">The the position of the token being marked immutable</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.ProtectRoot(MS.Swi.Data.IConstToken)">
            <summary>
            Mark the entire root element that the specified token belongs to as immutable
            protecting all tokens with the same RootPosition from modification
            </summary>
            <param name="token">The token whose root element is to be marked as immutable</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.ProtectRoot(MS.Swi.Data.TokenPosition)">
            <summary>
            Mark the entire root element that the specified token position belongs to as immutable
            protecting all tokens with the same RootPosition from modification
            </summary>
            <param name="tokenPosition">The position of the token whose root element is to be marked as immutable</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.ProtectRoot(System.UInt32)">
            <summary>
            Mark the entire root element as immutable protecting all tokens with the same RootPosition
            from modification.
            </summary>
            <param name="rootPosition">The root position</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Duplicate(MS.Swi.Data.IConstToken)">
            <summary>
            Duplicate the specified token, placing the duplicate token after the existing token
            </summary>
            <param name="currentToken">The token to duplicate</param>
            <returns>The constructed token or null if it could not be duplicated</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Duplicate(MS.Swi.Data.TokenPosition)">
            <summary>
            Duplicate the specified token, placing the duplicate token after the existing token
            </summary>
            <param name="position">The position of the token to duplicate</param>
            <returns>The constructed token or null if it could not be duplicated</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Encapsulate(System.String,System.String,System.Object[])">
            <summary>
            Construct an encapsulation given a set of references
            
            The format of the arguments is:
            	Label (String) - Note that this MUST end in a ':'
            	[Optional] Element name for the first contents of the reference that is of the specified definition (String)
            	TokenPosition of the reference (TokenPosition)
                [Repeat as desired]
            </summary>
            <param name="definitionName">The encapsulation definition to use</param>
            <param name="identifier">The identifier for the encapsulation, or null if there is no identifier</param>
            <param name="references">The reference definition as described above</param>
            <returns>The constructed encapsulation, or null if an equivalent encapsulation already existed</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AddEncapsulationReference(System.Collections.Generic.List{MS.Swi.Data.DataContents},MS.Swi.Data.TokenPosition@,System.String@)">
            <summary>
            Add an encapsulation reference to the list
            </summary>
            <param name="referenceList">The reference list</param>
            <param name="position">The position of the reference</param>
            <param name="definitionName">The target definition, or null if the default should be used</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Split(MS.Swi.Data.TokenPosition,System.UInt32[])">
            <summary>
            Split the existing token up according to the split points, and create the new tokens.
            
            Notes:
            If the token cannot be found at the position given, we will throw an exception.
            This does NOT enforce the Severable attribute of tokens, because the split often occurs before refinements
            Type is preserved to the child tokens
            Restrictions are preserved to the child tokens
            If there is a split point provided which is also the length of the parent contents, it will not
            create a token
            </summary>
            <param name="position">The position of the token to split</param>
            <param name="splitPoints">The split points</param>
            <returns>The list of child tokens in order by split points</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Split(MS.Swi.Data.TokenPosition,System.Collections.IEnumerable)">
            <summary>
            Split the existing token up according to the split points, and create the new tokens.
            
            Notes:
            If the token cannot be found at the position given, we will throw an exception.
            This does NOT enforce the Severable attribute of tokens, because the split often occurs before refinements
            However, it DOES enforce the Singleton attribute
            Type is preserved to the child tokens
            Restrictions are preserved to the child tokens
            </summary>
            <param name="position">The position of the token to split</param>
            <param name="splitPoints">The split points</param>
            <returns>The list of child tokens in order by split points</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Split(MS.Swi.Data.IConstToken,System.UInt32[])">
            <summary>
            Split the existing token up according to the split points, and create the new tokens.
            
            Notes:
            If the token cannot be found at the position given, we will throw an exception.
            This does NOT enforce the Severable attribute of tokens, because the split often occurs before refinements
            However, it DOES enforce the Singleton attribute
            Type is preserved to the child tokens
            Restrictions are preserved to the child tokens
            If there is a split point provided which is also the length of the parent contents, it will not
            create a token
            </summary>
            <param name="token">The token to split</param>
            <param name="splitPoints">The split points</param>
            <returns>The list of child tokens in order by split points</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Split(MS.Swi.Data.IConstToken,System.Collections.IEnumerable)">
            <summary>
            Split the existing token up according to the split points, and create the new tokens.
            
            Notes:
            If the token cannot be found at the position given, we will throw an exception.
            This does NOT enforce the Severable attribute of tokens, because the split often occurs before refinements
            However, it DOES enforce the Singleton attribute
            Type is preserved to the child tokens
            Restrictions are preserved to the child tokens
            </summary>
            <param name="token">The token to split</param>
            <param name="splitPoints">The split points</param>
            <returns>The list of child tokens in order by split points</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Split(MS.Swi.Data.IConstToken)">
            <summary>
            Split the existing token into equally (and minimally) sized sub-tokens.
            
            Notes:
            If the token cannot be found at the position given, we will throw an exception.
            This does NOT enforce the Severable attribute of tokens, because the split often occurs before refinements
            However, it DOES enforce the Singleton attribute
            Type is preserved to the child tokens
            </summary>
            <param name="token">The token to split</param>
            <returns>The list of child tokens in order by split points</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Split(MS.Swi.Data.TokenPosition)">
            <summary>
            Split the existing token into equally (and minimally) sized sub-tokens.
            
            Notes:
            If the token cannot be found at the position given, we will throw an exception.
            This does NOT enforce the Severable attribute of tokens, because the split often occurs before refinements
            However, it DOES enforce the Singleton attribute
            Type is preserved to the child tokens.  
            </summary>
            <param name="position">The position of the token to split</param>
            <returns>The list of child tokens in order by split points</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.TokenPosition,System.String,System.String[])">
            <summary>
            Change the definition and encoding of the token at the given position
            </summary>
            <param name="position">The position of the token</param>
            <param name="definitionName">The name of the new definition</param>
            <param name="transformationNames">The transformation names to apply</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.TokenPosition,MS.Swi.Data.TokenRestrictions)">
            <summary>
            Apply additional restrictions to an existing token
            </summary>
            <param name="position">The position of the token</param>
            <param name="restrictions">The new restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.TokenPosition,System.String,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Apply a new type and derivation rules to an existing token
            </summary>
            <param name="position">The position of the token</param>
            <param name="definitionName">The name of the new definition</param>
            <param name="references">The references to use</param>
            <param name="calculationDelegate">The calculation delegate to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.TokenPosition,System.String,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},System.String)">
            <summary>
            Apply a new type and derivation rules to an existing token
            </summary>
            <param name="position">The position of the token</param>
            <param name="definitionName">The name of the new definition</param>
            <param name="references">The references to use</param>
            <param name="calculationDelegateName">The calculation delegate to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.TokenPosition,System.String,System.String[],MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},System.String)">
            <summary>
            Change the definition of a token at a given position. 
            </summary>
            <param name="position">The position of the token</param>
            <param name="definitionName">The name of the new definition (or null if it is unchanged)</param>
            <param name="transformationNames">The transformation name to apply (or null if it is unchanged) </param>
            <param name="restrictions">Additional restrictions to apply to the token (or null if it is unchanged)</param>
            <param name="references">References to apply to the token (or null if it is unchanged)</param>
            <param name="calculationDelegateName">Calculation delegate to apply to the token (or null if it is unchanged)</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.TokenPosition,System.String,System.String[],MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Change the definition of a token at a given position. 
            </summary>
            <param name="position">The position of the token</param>
            <param name="definitionName">The name of the new definition (or null if it is unchanged)</param>
            <param name="transformationNames">The transformation name to apply (or null if it is unchanged) </param>
            <param name="restrictions">Additional restrictions to apply to the token (or null if it is unchanged)</param>
            <param name="references">References to apply to the token (or null if it is unchanged)</param>
            <param name="calculationDelegate">Calculation delegate to apply to the token (or null if it is unchanged)</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstEncapsulation,System.String,System.String)">
            <summary>
            Refine the definition of an existing encapsulation OR its equivalent. Note that the refinement
            will only be applied if the identifier is a refinement of the existing encapsulation. If the 
            encapsulation has already been refined past that point, this will be ignored.
            </summary>
            <param name="encapsulation">The encapsulation to refine</param>
            <param name="identifier">The new identifier for the encapsulation, or null if the previous identifier should be preserved</param>
            <param name="definitionName">The updated definition</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstToken,System.String,System.String[])">
            <summary>
            Change the definition and encoding of the token
            </summary>
            <param name="token">The token to refine</param>
            <param name="definitionName">The name of the new definition</param>
            <param name="transformationNames">The transformation names to apply</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstToken,MS.Swi.Data.TokenRestrictions)">
            <summary>
            Apply additional restrictions to an existing token
            </summary>
            <param name="token">The token to refine</param>
            <param name="restrictions">The new restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstToken,System.String,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Apply a new type and derivation rules to an existing token
            </summary>
            <param name="token">The token to refine</param>
            <param name="definitionName">The name of the new definition</param>
            <param name="references">The references to use</param>
            <param name="calculationDelegate">The calculation delegate to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstToken,System.String,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},System.String)">
            <summary>
            Apply a new type and derivation rules to an existing token
            </summary>
            <param name="token">The token to refine</param>
            <param name="definitionName">The name of the new definition</param>
            <param name="references">The references to use</param>
            <param name="calculationDelegateName">The calculation delegate to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstToken,System.String,System.String[],MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},System.String)">
            <summary>
            Change the definition of a token at a given position. 
            </summary>
            <param name="token">The token to refine</param>
            <param name="definitionName">The name of the new definition (or null if it is unchanged)</param>
            <param name="transformationNames">The transformation name to apply (or null if it is unchanged) </param>
            <param name="restrictions">Additional restrictions to apply to the token (or null if it is unchanged)</param>
            <param name="references">References to apply to the token (or null if it is unchanged)</param>
            <param name="calculationDelegateName">Calculation delegate to apply to the token (or null if it is unchanged)</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Refine(MS.Swi.Data.IConstToken,System.String,System.String[],MS.Swi.Data.TokenRestrictions,System.Collections.Generic.Dictionary{System.String,MS.Swi.Data.TokenReference},MS.Swi.Data.Token.CalculateContentsDelegate)">
            <summary>
            Change the definition of a token. 
            </summary>
            <param name="token">The token to refine</param>
            <param name="definitionName">The name of the new definition (or null if it is unchanged)</param>
            <param name="transformationNames">The transformation name to apply (or null if it is unchanged) </param>
            <param name="restrictions">Additional restrictions to apply to the token (or null if it is unchanged)</param>
            <param name="references">References to apply to the token (or null if it is unchanged)</param>
            <param name="calculationDelegate">Calculation delegate to apply to the token (or null if it is unchanged)</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Extract(MS.Swi.Data.IConstToken,System.String)">
            <summary>
            Transform data into an FCL Container and then extract the results
            </summary>
            <param name="token">The source for the container token</param>
            <param name="transformationName">The transformation to apply</param>
            <returns>The list of extracted tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Extract(MS.Swi.Data.IConstToken)">
            <summary>
            Extract the contents of the FCL Container from the container itself
            </summary>
            <param name="token">The container token</param>
            <returns>The list of extracted tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Extract(MS.Swi.Data.TokenPosition,System.String)">
            <summary>
            Transform data into an FCL Container and then extract the results
            </summary>
            <param name="position">The position of the source for the container token</param>
            <param name="transformationName">The transformation to apply</param>
            <returns>The list of extracted tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.Extract(MS.Swi.Data.TokenPosition)">
            <summary>
            Extract the contents of the FCL Container from the container itself
            </summary>
            <param name="position">The position of the container token</param>
            <returns>The list of extracted tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.ApplyIdentifier(MS.Swi.Data.IConstToken,System.String)">
            <summary>
            Set the identifier for the specified token
            </summary>
            <param name="token">The token</param>
            <param name="identifier">The identifier string (null values will be silently changed to empty strings)</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.ApplyIdentifier(MS.Swi.Data.TokenPosition,System.String)">
            <summary>
            Set the identifier for the token at the specified position
            </summary>
            <param name="tokenPosition">The token position</param>
            <param name="identifier">The identifier string (null values will be silently changed to empty strings)</param>
        </member>
        <member name="M:MS.Swi.Data.DataMap.SwapTokens(MS.Swi.Data.TokenPosition,MS.Swi.Data.TokenPosition)">
            <summary>
            Swap two tokens
            </summary>
            <param name="firstTokenPosition">The position of the first token</param>
            <param name="secondTokenPosition">The position of the second token</param>
            <returns>True if they could be swapped, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.SwapTokens(MS.Swi.Data.IConstToken,MS.Swi.Data.IConstToken)">
            <summary>
            Swap two tokens
            </summary>
            <param name="firstToken">The first token</param>
            <param name="secondToken">The second token</param>
            <returns>True if they could be swapped, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.MoveToken(MS.Swi.Data.TokenPosition,MS.Swi.Data.TokenPosition)">
            <summary>
            Attempt to move a token from one position to another. If the token cannot be found at the
            specified position, then we will throw an exception
            </summary>
            <param name="oldPosition">The old position</param>
            <param name="newPosition">The new position</param>
            <returns>True if it worked, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.MoveToken(MS.Swi.Data.IConstToken,MS.Swi.Data.TokenPosition)">
            <summary>
            Attempt to move a token from one position to another
            </summary>
            <param name="token">The token to move</param>
            <param name="newPosition">The new position</param>
            <returns>True if it worked, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AddDefinition(MS.Swi.Data.ElementDefinition)">
            <summary>
            Add a definition to the DataMap
            </summary>
            <param name="definition">The definition to be included</param>
            <returns>True if it was added or already exists, False if a conflicting definition of the same name already exists</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.AddTransformation(MS.Swi.Data.DataTransformation)">
            <summary>
            Add a definition to the DataMap
            </summary>
            <param name="transformation"></param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.RemoveOrphanedDefinitions">
            <summary>
            Trim out any definitions in the table which are "orphaned" (i.e. are descendents of
            definitions that don't exist). This should be done after adding a set of definitions if they
            are added dynamically.
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataMap.TokenIsInMap(MS.Swi.Data.IConstToken)">
            <summary>
            Whether or not the specified token is in the map at its alledged location
            </summary>
            <param name="token">The token</param>
            <returns>True if it is in the map, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.EquivalentEncapsulationIsInMap(MS.Swi.Data.IConstEncapsulation)">
            <summary>
            Whether or not the encapsulation is in the map
            </summary>
            <param name="encapsulation">The encapsulation</param>
            <returns>True if it is in the map, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.EquivalentEncapsulationIsInMap(MS.Swi.Data.Encapsulation)">
            <summary>
            Whether or not the encapsulation is in the map
            </summary>
            <param name="encapsulation">The encapsulation</param>
            <returns>True if it is in the map, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.FindEquivalentEncapsulation(MS.Swi.Data.IConstEncapsulation)">
            <summary>
            Find the equivalent encapsulation in the DataMap to this encapsulation
            </summary>
            <param name="encapsulation">The encapsulation to look for</param>
            <returns>The equivalent encapsulation, or null if none exists</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.FindEquivalentEncapsulation(MS.Swi.Data.Encapsulation)">
            <summary>
            Find the equivalent encapsulation in the DataMap to this encapsulation
            </summary>
            <param name="encapsulation">The encapsulation to look for</param>
            <returns>The equivalent encapsulation, or null if none exists</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.FindTokens(MS.Swi.Data.TokenPosition)">
            <summary>
            Get the sorted sublist of tokens which are "beneath" the given position (i.e.
            a position of 0.0 would include tokens at 0.0.0, 0.0.1, 0.0.2.0, and 0.0.2.1)
            </summary>
            <param name="position">The position</param>
            <returns>The list of descendents</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.FirstToken">
            <summary>
            The first token in the DataMap
            </summary>
            <returns>The first token in the DataMap, or null if the DataMap has no tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.NextToken(MS.Swi.Data.IConstToken,System.Boolean)">
            <summary>
            The next token in the DataMap
            </summary>
            <param name="referenceToken">The token this is in reference to</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The next token, or null if there is no matching next token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.PreviousToken(MS.Swi.Data.IConstToken,System.Boolean)">
            <summary>
            The previous token in the DataMap
            </summary>
            <param name="referenceToken">The token this is in reference to</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The previous token, or null if there is no matching previous token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.NextToken(MS.Swi.Data.TokenPosition,System.Boolean)">
            <summary>
            The next token in the DataMap. If there is no token at the reference position, the 
            spanRootElements argument will be ignored, and the next token will be returned.
            </summary>
            <param name="referencePosition">The reference position</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The next token, or null if there is no matching next token</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMap.PreviousToken(MS.Swi.Data.TokenPosition,System.Boolean)">
            <summary>
            The previous token in the DataMap. If there is no token at the reference position, the 
            spanRootElements argument will be ignored, and the previous token will be returned.
            </summary>
            <param name="referencePosition">The reference position</param>
            <param name="spanRootElements">Whether or not to cross root elements</param>
            <returns>The previous token, or null if there is no matching previous token</returns>
        </member>
        <member name="P:MS.Swi.Data.DataMap.Transformations">
            <summary>
            Access to the available transformations
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.Definitions">
            <summary>
            Access to the token definitions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.TokenList">
            <summary>
            The actual data token set
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.Tokens">
            <summary>
            Access to the data tokens found
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.EncapsulationList">
            <summary>
            Access to the encapsulations found
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.Encapsulations">
            <summary>
            Access to the encapsulations found
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.MS#Swi#Data#IConstDataMap#Encapsulations">
            <summary>
            Access to the encapsulations found
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataMap.MS#Swi#Data#IConstDataMap#Tokens">
            <summary>
            Access to read-only versions of the data tokens found
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstDataBuffer">
            <summary>
            A public constant interface to the DataBuffer, that can be used to
            provide read only access to internal data members
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstDataBuffer.CopyTo(System.Byte[],System.UInt32)">
            <summary>
            Copy the entire contents to the specified destination. Note that this requires that
            there is sufficient room
            </summary>
            <param name="destination">The destination buffer</param>
            <param name="position">The position in the destination buffer</param>
        </member>
        <member name="M:MS.Swi.Data.IConstDataBuffer.Clone">
            <summary>
            A clone of the buffer. As all the elements are simple types, this is actually a deep copy.
            </summary>
            <returns>A DataBuffer</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstDataBuffer.Contents">
            <summary>
            A constant copy of the contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataBuffer.SizeUsed">
            <summary>
            The amount of the buffer currently used
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataBuffer.Size">
            <summary>
            The current maximum size of the buffer
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataBuffer.Item(System.UInt32)">
            <summary>
            The value at a specific location in the buffer
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataBuffer">
            <summary>
            Buffer
            	An arbitrary chunk of data, with an implicit maximum size and an explicit size
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.#ctor(System.UInt32)">
            <summary>
            Constructor to create an empty buffer with the specified maximum size
            </summary>
            <param name="maximumSize">The maximum size of the buffer</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.#ctor(System.Byte[],System.UInt32)">
            <summary>
            Constructor to create a buffer based on an existing byte array and the
            amount of that array already in use. Note that the maximum size of the DataBuffer
            is derived in this case from the size of the array.
            </summary>
            <param name="data">The existing byte array (note that null is explicitly handled)</param>
            <param name="sizeUsed">The size of the byte array used.</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.#ctor(System.Byte[],System.UInt32,System.UInt32)">
            <summary>
            Constructor to create a buffer based on an existing byte array and the
            amount of that array already in use.
            </summary>
            <param name="data">The existing byte array (note that null is explicitly handled)</param>
            <param name="sizeUsed">The size of the byte array used.</param>
            <param name="maximumSize">The maximum size of the buffer</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.#ctor(MS.Swi.Data.IConstDataBuffer,System.UInt32,System.UInt32)">
            <summary>
            Constructor to create a buffer based on a fragment of an existing data buffer
            </summary>
            <param name="source">The source buffer</param>
            <param name="startPosition">The start position of the fragment</param>
            <param name="sizeUsed">The size of the fragment</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.#ctor(System.Byte[],System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor to create a buffer based on a fragment of an existing byte array
            </summary>
            <param name="data">The source buffer</param>
            <param name="startPosition">The start position of the fragment</param>
            <param name="sizeUsed">The size of the byte array used.</param>
            <param name="maximumSize">The maximum size of the buffer</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.ReplaceWithOwnership(System.Byte[])">
            <summary>
            Replace the contents of this DataBuffer by taking ownership of the provided contents. This version
            does NOT change the maximum size of the Buffer, so it allows for auto-truncation.
            </summary>
            <param name="data">The data to adopt</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.ReplaceWithOwnership(System.Byte[],System.UInt32)">
            <summary>
            Replace the contents of this DataBuffer by taking ownership of the provided contents
            </summary>
            <param name="data">The data to adopt</param>
            <param name="maximumSize">The maximum size</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.Replace(MS.Swi.Data.IConstDataBuffer,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Modifier to set the buffer based on an existing data buffer and the
            amount of that array already in use.
            </summary>
            <param name="data">The existing data buffer</param>
            <param name="index">The starting index into the buffer</param>
            <param name="bufferSize">The size of the buffer being created</param>
            <param name="sizeUsed">The size of the byte array used</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.Append(MS.Swi.Data.IConstDataBuffer)">
            <summary>
            Append one DataBuffer onto another
            </summary>
            <param name="data">The data buffer to append</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.Replace(System.Byte[],System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Modifier to set the buffer based on an existing byte array and the
            amount of that array already in use.
            </summary>
            <param name="data">The existing byte array (note that null is explicitly handled)</param>
            <param name="index">The starting index into the buffer</param>
            <param name="bufferSize">The size of the buffer being created</param>
            <param name="sizeUsed">The size of the byte array used</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.AdjustInternalBuffer(System.UInt32)">
            <summary>
            Adjust the internal buffer to match the size needed
            </summary>
            <param name="sizeNeeded">The size the new buffer should be</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.CopyTo(System.Byte[],System.UInt32)">
            <summary>
            Copy the entire contents to the specified destination. Note that this requires that
            there is sufficient room
            </summary>
            <param name="destination">The destination buffer</param>
            <param name="position">The position in the destination buffer</param>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.ToString">
            <summary>
            Return a string description of the contents of the DataBuffer
            </summary>
            <returns>A string including the contents</returns>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.System#ICloneable#Clone">
            <summary>
            A clone of the buffer. As all the elements are simple types, this is actually a deep copy.
            </summary>
            <returns>A new buffer expressed as an object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataBuffer.Clone">
            <summary>
            A clone of the buffer. As all the elements are simple types, this is actually a deep copy.
            </summary>
            <returns>A DataBuffer</returns>
        </member>
        <member name="P:MS.Swi.Data.DataBuffer.Contents">
            <summary>
            Access to deep copy of the contents of the buffer
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataBuffer.SizeUsed">
            <summary>
            The amount of the buffer used
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataBuffer.Size">
            <summary>
            The maximum size of the buffer
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataBuffer.Item(System.UInt32)">
            <summary>
            Access to individual bytes of the buffer (Set and Get). If the location is beyond the
            current size used, the size used will be extended
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstDataTransformations">
            <summary>
            A const interface to a DataTransformations
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstDataTransformations.Contains(System.String)">
            <summary>
            Whether or not the set of transformations contains the given transformation
            </summary>
            <param name="name">The transformation name to check</param>
            <returns>True if it contains the transformation, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataTransformations.Clone">
            <summary>
            Clone the IConstDataTransformations into a new DataTransformations
            </summary>
            <returns>The new DataTransformations</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataTransformations.ToXml(System.Xml.XmlDocument)">
            <summary>
            Create an Xml serialization of the object, owned by the specified document
            </summary>
            <param name="owningDocument">The owning document</param>
            <returns>The new XmlElement</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstDataTransformations.Item(System.String)">
            <summary>
            The transformation associated with the name
            </summary>
            <param name="name">The transformation name</param>
            <returns>The transformation</returns>
        </member>
        <member name="T:MS.Swi.Data.DataTransformations">
            <summary>
            The DataTransformations is a mapping of logical names for transformations to
            transformation objects. It is designed to be loaded via Xml, and used in type definitions
            (which are also loaded via Xml)
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.FromXml(MS.Swi.Data.IConstElementDefinitions,System.Xml.XmlElement)">
            <summary>
            Load the Xml serialization into the object, replacing any pre-existing settings.
            </summary>
            <param name="definitions">The token definitions to use in creating the table</param>
            <param name="sourceElement">The XmlElement that contains the object</param>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.ToXml(System.Xml.XmlDocument)">
            <summary>
            Create an Xml serialization of the object, owned by the specified document
            </summary>
            <param name="owningDocument">The owning document</param>
            <returns>The new XmlElement</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.LoadFromXml(MS.Swi.Data.IConstElementDefinitions,System.Xml.XmlElement)">
            <summary>
            Add the specified data into the DataTransformation table, generating an exception if
            there are duplicate entries
            </summary>
            <param name="definitions">The token definitions to use in creating the table</param>
            <param name="sourceElement">The XML element</param>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.LoadTransformations(System.String,MS.Swi.Data.IConstElementDefinitions)">
            <summary>
            Load a set of transformations.  The filename will be searched for first as given,
            then in the local directory, and then in the FCL installation directory.
            </summary>
            <param name="fileName">The filename for the Xml file containing the definitions</param>
            <param name="definitions">The token definitions to use</param>
            <returns>The transformation set</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.#ctor">
            <summary>
            Default constructors
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.#ctor(MS.Swi.Data.DataTransformations)">
            <summary>
            A private copy constructor used to facilitate the Clone() operation
            </summary>
            <param name="source">The source transformations</param>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.Contains(System.String)">
            <summary>
            Whether or not the set of transformations contains the given transformation
            </summary>
            <param name="name">The transformation name to check</param>
            <returns>True if it contains the transformation, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.Add(MS.Swi.Data.IConstDataTransformations)">
            <summary>
            Add another set of DataTransformations into this set
            </summary>
            <param name="transformations">The source transformations</param>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.Add(MS.Swi.Data.DataTransformations)">
            <summary>
            Add another set of DataTransformations into this set
            </summary>
            <param name="transformations">The source transformations</param>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.Add(MS.Swi.Data.DataTransformation)">
            <summary>
            Add an individual DataTransformation into this set
            </summary>
            <param name="transformation">The transformation</param>
            <returns>True if it was added, false if a transformation of the same name was already present</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.Clone">
            <summary>
            The default clone operation
            </summary>
            <returns>The new DataTransformations as an object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformations.MS#Swi#Data#IConstDataTransformations#Clone">
            <summary>
            An explicit clone operation
            </summary>
            <returns>The cloned transformations as a DataTransformations</returns>
        </member>
        <member name="P:MS.Swi.Data.DataTransformations.Item(System.String)">
            <summary>
            The transformation associated with the name
            </summary>
            <param name="name">The transformation name</param>
            <returns>The transformation</returns>
        </member>
        <member name="T:MS.Swi.Data.ContainerElement">
            <summary>
            The ContainerElement class encapsulates the following data about the transformation
            	The output FCL type name
            	The actual output value
            It is used to define the output of a container transformation
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ContainerElement.#ctor(System.String,System.Object)">
            <summary>
            Construct a ContainerElement given the underlying definition and contents. Note that this will
            leave any Identifier associated with the parent token unchanged
            </summary>
            <param name="definitionName">The name of the FCL type definition for the element</param>
            <param name="contents">The actual contents</param>
        </member>
        <member name="M:MS.Swi.Data.ContainerElement.#ctor(System.String,System.Object,System.String)">
            <summary>
            Construct a ContainerElement given the underlying definition and contents, and apply the
            specified Identifier to it when it is extracted. Note that an identifier of null will clear
            any inherited identifier from the parent Token.
            </summary>
            <param name="definitionName">The name of the FCL type definition for the element</param>
            <param name="contents">The actual contents</param>
            <param name="identifier">The identifier, or null if it should be cleared</param>
        </member>
        <member name="P:MS.Swi.Data.ContainerElement.DefinitionName">
            <summary>
            The name of the FCL Definition of the container element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerElement.Contents">
            <summary>
            The actual contents of the container element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerElement.IdentifierWasSpecified">
            <summary>
            Whether or not the caller specified an identifier. If an identifier was specified, then
            the resulting child token will have its identifier replaced (if it was non-null) or cleared
            (if it was null)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerElement.Identifier">
            <summary>
            The identifier associated with the container element
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataTransformation">
            <summary>
            The DataTransformation class provides the rules and functionality that convert
            data from one internal representation to another. This provides the ability to change
            the encoding and to move from the physical encoding to the logical native type.
            
            In some cases, the internal representation format will be the same (i.e. converting
            from a zipped byte array to an unzipped byte array), and the transformation only changes
            the encoding
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.ToXml(System.Xml.XmlDocument)">
            <summary>
            Write the data transformation to Xml
            </summary>
            <param name="owningDocument"></param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.Create(MS.Swi.Data.IConstElementDefinitions,System.Xml.XmlElement)">
            <summary>
            Construct a DataTransformation object from an Xml description
            </summary>
            <param name="definitions">The definition table to use in finding the FCL definitions</param>
            <param name="transformation">The Xml definition of the transformation</param>
            <returns>The constructed object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.Create(MS.Swi.Data.IConstElementDefinitions,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Construct a DataTransformation object based on the specified parameters
            </summary>
            <param name="definitions">The definition table to use in finding the FCL definitions</param>
            <param name="name">The name of the transformation</param>
            <param name="sourceDefinitionName">The name of the FCL definition the source implements</param>
            <param name="outputDefinitionName">The name of the FCL definition the source implements</param>
            <param name="characteristics">The characteristics of the transformation</param>
            <param name="elementSize">The size of each output element of this transformation type (in terms of its source type )</param>
            <param name="transformationMethodName">The name of the transformation method to use</param>
            <param name="reverseTransformationMethodName">The name of the reverse transformation method to use</param>
            <returns>The constructed object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.Create(MS.Swi.Data.ElementDefinition)">
            <summary>
            Construct a container transformation for the specified output definition
            </summary>
            <param name="outputDefinition">The output definition of the container transformation</param>
            <returns>The transformation</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.Create(MS.Swi.Data.IConstElementDefinitions,System.String,System.String,System.String,System.String,System.UInt32,System.String,System.String)">
            <summary>
            Construct a DataTransformation object based on the specified parameters
            </summary>
            <param name="definitions">The definition table to use in finding the FCL definitions</param>
            <param name="name">The name of the transformation</param>
            <param name="sourceDefinitionName">The name of the FCL definition the source implements</param>
            <param name="outputDefinitionName">The name of the FCL definition the source implements</param>
            <param name="characteristics">The characteristics of the transformation</param>
            <param name="elementSize">The size of each output element of this transformation type (in terms of its source type )</param>
            <param name="transformationMethodName">The name of the transformation method to use</param>
            <param name="reverseTransformationMethodName">The name of the reverse transformation method to use</param>
            <returns>The constructed object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.Equals(System.Object)">
            <summary>
            Determine if two DataTransformations are equal. Because DataTransformation objects
            are immutable, we can do a true Equals override
            </summary>
            <param name="obj">The other object</param>
            <returns>Whether or not they are equal</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.GetHashCode">
            <summary>
            Create a hash code for the DataTransformation
            </summary>
            <returns>The calculated hash code</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.HasCharacteristic(MS.Swi.Data.DataTransformation.CharacteristicsFlags)">
            <summary>
            Does the tramsfpr,atopm have the specified characteristic? If the characteristic is a combination of multiple
            characteristics, it will return true only if all of the characteristics are a match
            </summary>
            <param name="characteristic">The characteristic (or characteristics) to check for</param>
            <returns>True if there is an exact match, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.Transform(System.Object)">
            <summary>
            Transform the source object into the output object
            </summary>
            <param name="source">The source object that is being converted</param>
            <returns>The transformed output object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation.ReverseTransform(System.Object)">
            <summary>
            Transform the output object into a source object
            </summary>
            <param name="output">The object which is the output of a previous Transform call</param>
            <returns>The inversely transformed source object</returns>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.Name">
            <summary>
            The name of the transformation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.Characteristics">
            <summary>
            The characteristics of this transformation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.SourceNativeType">
            <summary>
            The native type of the contents that this transformation consumes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.SourceDefinition">
            <summary>
            The name of the FCL definition that this transformation consumes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.OutputNativeType">
            <summary>
            The native type of the contents that this transformation produces
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.OutputDefinition">
            <summary>
            The name of the FCL definition that this transformation produces
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.TransformationDelegateName">
            <summary>
            The name of the transformation delegate
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.ReverseTransformationDelegateName">
            <summary>
            The name of the reverse transformation delegate
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation.ElementSize">
            <summary>
            The size of an element of this transformation output type (considering strings as char[]) 
            in terms of its source type. Note that this is not valid if the Characteristics include 
            VariableSize
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataTransformation.CharacteristicsFlags">
            <summary>
            The set of possible characteristics for a DataTransformation
            </summary>
        </member>
        <member name="F:MS.Swi.Data.DataTransformation.CharacteristicsFlags.None">
            <summary>
            No characteristics apply
            </summary>
        </member>
        <member name="F:MS.Swi.Data.DataTransformation.CharacteristicsFlags.VariableSize">
            <summary>
            The transformation will produce differently sized results depending on
            the actual contents
            </summary>
        </member>
        <member name="F:MS.Swi.Data.DataTransformation.CharacteristicsFlags.PartialTransformationValid">
            <summary>
            Sub-elements that use this transformation can be transformed, and the results will
            be the same if sub-element transformations are combined as they would be if the 
            entire element were to be transformed at once
            </summary>
        </member>
        <member name="T:MS.Swi.Data.ContainerTransformation">
            <summary>
            The ContainerTransformation transforms a single length ContainerElement[] into the underlying
            type, and visa-versa. This is used to handle the container transformations
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ContainerTransformation.#ctor(MS.Swi.Data.ElementDefinition)">
            <summary>
            Construct a DataTransformation object
            </summary>
            <param name="outputDefinition">The FCL definition which represents the output</param>
        </member>
        <member name="M:MS.Swi.Data.ContainerTransformation.Transform(System.Object)">
            <summary>
            Transform the source object into the output object
            </summary>
            <param name="source">The source object that is being converted</param>
            <returns>The transformed output object</returns>
        </member>
        <member name="M:MS.Swi.Data.ContainerTransformation.ReverseTransform(System.Object)">
            <summary>
            Transform the output object(s) into a source object
            </summary>
            <param name="output">The object which is the output of a previous Transform call</param>
            <returns>The inversely transformed source object</returns>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.Name">
            <summary>
            The name of the transformation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.Characteristics">
            <summary>
            The characteristics of this transformation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.ElementSize">
            <summary>
            The size of an element of this transformation output type (considering strings as char[]) 
            in terms of its source type. Note that this is not valid if the Characteristics include 
            VariableSize
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.SourceNativeType">
            <summary>
            The native type of the contents that this transformation consumes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.SourceDefinition">
            <summary>
            The FCL definition that this transformation consumes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.OutputNativeType">
            <summary>
            The native type of the contents that this transformation produces
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.OutputDefinition">
            <summary>
            The name of the FCL definition that this transformation produces
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.TransformationDelegateName">
            <summary>
            The name of the transformation delegate, which is not used in a
            container transformation, and so is an empty string
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ContainerTransformation.ReverseTransformationDelegateName">
            <summary>
            The name of the reverse transformation delegate, which is not used in a
            container transformation, and so is an empty string
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataTransformation`2">
            <summary>
            The DataTransformation class provides the rules and functionality that convert
            data from one internal representation to another. This provides the ability to change
            the encoding and to move from the physical encoding to the logical native type.
            
            In some cases, the internal representation format will be the same (i.e. converting
            from a zipped byte array to an unzipped byte array), and the transformation only changes
            the encoding
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation`2.#ctor(System.String,System.String,System.UInt32,MS.Swi.Data.ElementDefinition,MS.Swi.Data.ElementDefinition,System.String,System.String)">
            <summary>
            Construct a DataTransformation object
            </summary>
            <param name="name">The name of the transformation</param>
            <param name="characteristics">The characteristics of the transformation as a string</param>
            <param name="elementSize">The size of an output element in terms of source elements</param>
            <param name="sourceDefinition">The FCL definition which represents the source</param>
            <param name="outputDefinition">The FCL definition which represents the output</param>
            <param name="transformationMethod">The transformation method name</param>
            <param name="reverseTransformationMethod">The reverse transformation method name</param>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation`2.Transform(System.Object)">
            <summary>
            Transform the source object into the output object
            </summary>
            <param name="source">The source object that is being converted</param>
            <returns>The transformed output object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation`2.Transform(`0)">
            <summary>
            Transform the source object into the output object
            </summary>
            <param name="source">The source object that is being converted</param>
            <returns>The transformed output object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation`2.ReverseTransform(System.Object)">
            <summary>
            Transform the output object(s) into a source object
            </summary>
            <param name="output">The object which is the output of a previous Transform call</param>
            <returns>The inversely transformed source object</returns>
        </member>
        <member name="M:MS.Swi.Data.DataTransformation`2.ReverseTransform(`1)">
            <summary>
            Transform the output object(s) into a source object
            </summary>
            <param name="output">The objects which are the outputs if a previous Transform call</param>
            <returns>The inversely transformed source object</returns>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.Name">
            <summary>
            The name of the transformation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.Characteristics">
            <summary>
            The characteristics of this transformation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.ElementSize">
            <summary>
            The size of an element of this transformation output type (considering strings as char[]) 
            in terms of its source type. Note that this is not valid if the Characteristics include 
            VariableSize
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.SourceNativeType">
            <summary>
            The native type of the contents that this transformation consumes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.SourceDefinition">
            <summary>
            The FCL definition that this transformation consumes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.OutputNativeType">
            <summary>
            The native type of the contents that this transformation produces
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.OutputDefinition">
            <summary>
            The name of the FCL definition that this transformation produces
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.TransformationDelegateName">
            <summary>
            The name of the transformation delegate
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataTransformation`2.ReverseTransformationDelegateName">
            <summary>
            The name of the reverse transformation delegate
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataTransformation`2.TransformationDelegate">
            <summary>
            A function which transforms the source data into the output object 
            </summary>
            <param name="source">The source object</param>
            <returns>The output object</returns>
        </member>
        <member name="T:MS.Swi.Data.DataTransformation`2.ReverseTransformationDelegate">
            <summary>
            A function which transforms the output object back into the source data
            </summary>
            <param name="output">The previous transformed output data</param>
            <returns>The reconstructed source object</returns>
        </member>
        <member name="T:MS.Swi.Data.TokenPosition">
             <summary>
             The TokenPosition defines the position of a block of data in a buffer in such a way that:
            		Sequences of zero-length fields are valid
                 Sequences of adjacent tokens can be swapped without causing conflicts
            		Insertions of new tokens are always valid
            		The original source buffer can always be determined
            		Any two positions of different lengths MUST differ before the shorter terminates
            
             This replaces the GroupOrdinalPosition and OrdinalPosition fields of all previous CTF
             implementations
             </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.#ctor">
            <summary>
            Internal constructor for creating the parent and sibling positions
            </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.#ctor(System.String)">
            <summary>
            Construct a TokenPosition from a dotted string representation. This will throw an
            exception if the string cannot be parsed. Note that all elements both a root and
            a terminal node
            </summary>
            <param name="positionRepresentation">The representation in the #.#.#.#... format</param>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct a token position given a root position, and the sequence position of the
            sub-element. This is used when doing top level constructions of data
            </summary>
            <param name="rootPosition">The root element</param>
            <param name="sequencePosition">The sequence of this position among the children of the parent</param>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.#ctor(MS.Swi.Data.TokenPosition,System.UInt32)">
            <summary>
            Construct a token position given a parent, and the sequence position of the
            sub-element. This is primarily used when splitting or changing data
            </summary>
            <param name="parent">The parent position</param>
            <param name="sequencePosition">The sequence of this position among the children of the parent</param>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.IsChildOf(MS.Swi.Data.TokenPosition)">
            <summary>
            Whether or not this position is a child of a given token position. For the purposes
            of this test, we will consider a TokenPosition to be a child of itself.
            </summary>
            <param name="position">The token position</param>
            <returns>True if it is a child of that position, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.IsChildOf(System.UInt32)">
            <summary>
            Whether or not this position is a child of a given root position
            </summary>
            <param name="rootPosition"></param>
            <returns>True if the root position of the node is the same as the given root position</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.Equals(System.Object)">
            <summary>
            Determine if this is equal to another object
            </summary>
            <param name="obj">The other object</param>
            <returns>True if they are equal, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.GetHashCode">
            <summary>
            Compute the hash code for the object. Note that two objects which are equal MUST
            have the same Hash Code, so we need to ignore trailing zeros
            </summary>
            <returns>The computed hash code</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.ToString">
            <summary>
            Convert the TokenPosition to string format
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Data.TokenPosition.CompareTo(System.Object)">
            <summary>
            Compare the TokenPosition to another object. Note that for the sake of comparison x and x.0 are 
            considered equal
            </summary>
            <param name="obj">The object for comparison</param>
            <returns>Negative number if this instance is less than obj, Zero if they are the same, and Positive number of this instance is greater than obj </returns>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.Parent">
            <summary>
            The parent position of this position, or null if this position cannot have a parent
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.Predecessor">
            <summary>
            The previous token position to this position, or null if there cannot be a predecessor
            node
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.Successor">
            <summary>
            The next token position after this one, or null if we are already at the maximum
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.Vector">
            <summary>
            The underlying vector
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.RootPosition">
            <summary>
            The root position of the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.TerminalPosition">
            <summary>
            The terminal position in the node
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.Depth">
            <summary>
            The depth of the position
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenPosition.Item(System.Int32)">
            <summary>
            The value it a given sequence position 
            </summary>
            <param name="sequencePosition">The sequence position</param>
            <returns>The value</returns>
        </member>
        <member name="T:MS.Swi.Data.TokenRestriction">
            <summary>
            The TokenRestriction class defines format specific limits for a data token.
            This information is available to the strategy and to manipulations to allow for smarter
            fuzzing of the data.
            </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.#ctor(MS.Swi.Data.TokenRestriction)">
            <summary>
            Internal copy constructor for a TokenRestriction object
            </summary>
            <param name="source">The source token</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.#ctor(System.String,System.Type)">
            <summary>
            Parse the restrictions string into an individual restriction<br/>
            
            The format of the restrictions is:<br/>
            	Value			Single valid value<br/>
            	Min_Max			Exclusive value range<br/>
            	Min+Max			Inclusive value range<br/>
            	Min-Max			Exclusive size range<br/>
            	Min=Max			Inclusive size range<br/>
            	Value|Value		Set of valid values<br/><br/>
            	
            </summary>
            <param name="restriction">The restriction string</param>
            <param name="valueType">The type of the item (for content restrictions). For size restrictions, we always use a uint</param>
            <returns>The restriction</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.#ctor(MS.Swi.Data.TokenRestriction.TokenRestrictionType,System.Object,System.Object)">
            <summary>
            Construct a content restriction based on the type and ranges
            </summary>
            <param name="type">The type of restriction</param>
            <param name="minimum">The minimum range endpoint</param>
            <param name="maximum">The maximum range endpoint</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.#ctor(MS.Swi.Data.TokenRestriction.TokenRestrictionType,System.UInt32,System.UInt32)">
            <summary>
            Construct a size or content restriction based on a range
            </summary>
            <param name="type">The type of restriction</param>
            <param name="minimum">The minimum range endpoint</param>
            <param name="maximum">The maximum range endpoint</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.#ctor(System.Object[])">
            <summary>
            Construct a content restriction based a set of valid values
            </summary>
            <param name="validValues">The valid values</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.IsValidValue(System.Object)">
            <summary>
            Determine if an object is a valid value
            </summary>
            <param name="whichValue">The object to check</param>
            <returns>True if it is, false if it is not</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.IsTheSameAs(System.Object)">
            <summary>
            Determine if two restrictions are the same
            </summary>
            <param name="otherObject">The compared object</param>
            <returns>True if they are equal, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.AddValidValues(MS.Swi.Data.TokenRestriction)">
            <summary>
            Integrate the other valid values. Note that this may have duplicates, we are not filtering
            for them because of the expense
            </summary>
            <param name="restriction">The restriction whose values are being added</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.System#ICloneable#Clone">
            <summary>
            Clone this token restriction
            </summary>
            <returns>The newly created clone of this token restriction</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestriction.Clone">
            <summary>
            Clone this token restriction
            </summary>
            <returns>A newly created clone of this token restriction</returns>
        </member>
        <member name="P:MS.Swi.Data.TokenRestriction.RestrictionType">
            <summary>
            The type of restriction being enforced
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestriction.Minimum">
            <summary>
            The restricted minimum value
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestriction.Maximum">
            <summary>
            The restricted maximum value
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestriction.ValidValues">
            <summary>
            Get a copy of the set of valid values
            </summary>
            <returns>A shallow copy of the set of valid values</returns>
        </member>
        <member name="T:MS.Swi.Data.TokenRestriction.TokenRestrictionType">
            <summary>
            The types of content restrictions. 
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenRestriction.TokenRestrictionType.Invalid">
            <summary>
            The default invalid value
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenRestriction.TokenRestrictionType.SizeRangeInclusive">
            <summary>
            The content restriction is a size range, inclusive of the end points
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenRestriction.TokenRestrictionType.SizeRangeExclusive">
            <summary>
            The content restriction is a size range, exclusive of the end points
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenRestriction.TokenRestrictionType.ValueRangeInclusive">
            <summary>
            The content restriction is a value range, inclusive of the end points
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenRestriction.TokenRestrictionType.ValueRangeExclusive">
            <summary>
            The content restriction is a value range, exclusive of the end points
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenRestriction.TokenRestrictionType.ValidValues">
            <summary>
            The content restriction is a set of valid values
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstTokenRestrictions">
            <summary>
            Public const interface to the TokenRestrictions class
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstTokenRestrictions.SelectRandomSizeRestriction(System.Random)">
            <summary>
            Select a random valid size restriction and return it to the caller, using the provided 
            random number generator
            </summary>
            <param name="prnGenerator">The generator to use</param>
            <returns>The restriction selected, or null if there are no size restrictions</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstTokenRestrictions.SelectRandomContentRestriction(System.Random)">
            <summary>
            Select a random valid content restriction and return it to the caller, using the provided 
            random number generator
            </summary>
            <param name="prnGenerator">The generator to use</param>
            <returns>The restriction selected, or null if there are no content restrictions</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenRestrictions.SizeRestrictions">
            <summary>
            The list of all size restrictions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenRestrictions.ValueRangeRestrictions">
            <summary>
            The list of all value range restrictions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenRestrictions.ValidValuesRestriction">
            <summary>
            The valid values restriction (or null if it does not exist)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenRestrictions.HasSizeRestrictions">
            <summary>
            Whether or not the restriction set includes size restrictions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenRestrictions.HasContentRestrictions">
            <summary>
            Whether or not the restriction set includes content restrictions
            </summary>
        </member>
        <member name="T:MS.Swi.Data.TokenRestrictions">
            <summary>
            The set of restrictions that apply to a token
            </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.#ctor(MS.Swi.Data.TokenRestrictions)">
            <summary>
            Private copy constructor
            </summary>
            <param name="source">The source restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.#ctor(System.Type,System.String[])">
            <summary>
            Create restrictions based on a sequence of format strings and value type information
            </summary>
            <param name="valueType">The native type of the object</param>
            <param name="restrictions">The restriction definitions</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.#ctor(MS.Swi.Data.TokenRestriction[])">
            <summary>
            Create token restrictions based on a set of existing restrictions
            </summary>
            <param name="restrictions"></param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.#ctor(MS.Swi.Data.Generic.ConstList{MS.Swi.Data.TokenRestriction},MS.Swi.Data.Generic.ConstList{MS.Swi.Data.TokenRestriction},MS.Swi.Data.TokenRestriction)">
            <summary>
            Construct a set of token restrictions based on the three categories
            </summary>
            <param name="sizeRestrictions">Size restrictions (or null)</param>
            <param name="valueRangeRestrictions">Value range restrictions (or null)</param>
            <param name="validValues">Valid values (or null)</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.SelectRandomContentRestriction(System.Random)">
            <summary>
            Select a random valid content restriction and return it to the caller, using the provided 
            random number generator
            </summary>
            <param name="prnGenerator">The generator to use</param>
            <returns>The restriction selected, or null if there are no content restrictions</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.SelectRandomSizeRestriction(System.Random)">
            <summary>
            Select a random valid size restriction and return it to the caller, using the provided 
            random number generator
            </summary>
            <param name="prnGenerator">The generator to use</param>
            <returns>The restriction selected, or null if there are no size restrictions</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.Add(MS.Swi.Data.TokenRestriction)">
            <summary>
            Add a restriction to the set of Token Restrictions
            </summary>
            <param name="restriction">The new restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.Add(MS.Swi.Data.IConstTokenRestrictions)">
            <summary>
            Add the existing restriction set, replacing any current size restrictions
            with new size restrictions if they exist, and preserving the size restrictions
            if not, and adding the content restrictions
            </summary>
            <param name="restrictions">The restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.ReplaceSizeRestrictions(MS.Swi.Data.IConstTokenRestrictions)">
            <summary>
            Replace the existing size restrictions with the size restrictions from the new set
            IF and ONLY IF they exist. If there are no size restrictions in the new
            set, nothing is changed
            </summary>
            <param name="restrictions">The new restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.AddContentRestrictions(MS.Swi.Data.IConstTokenRestrictions)">
            <summary>
            Add the content restrictions
            </summary>
            <param name="restrictions">The restrictions</param>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.System#ICloneable#Clone">
            <summary>
            Clone these token restrictions
            </summary>
            <returns>The newly created clone of these token restrictions</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenRestrictions.Clone">
            <summary>
            Clone these token restrictions
            </summary>
            <returns>A newly created clone of these token restrictions</returns>
        </member>
        <member name="P:MS.Swi.Data.TokenRestrictions.SizeRestrictions">
            <summary>
            The list of all size restrictions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestrictions.ValueRangeRestrictions">
            <summary>
            The list of all value range restrictions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestrictions.ValidValuesRestriction">
            <summary>
            The valid values restriction (or null if it does not exist)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestrictions.HasSizeRestrictions">
            <summary>
            Whether or not the restriction set includes size restrictions
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenRestrictions.HasContentRestrictions">
            <summary>
            Whether or not the restriction set includes content restrictions
            </summary>
        </member>
        <member name="T:MS.Swi.InstallationManagement">
            <summary>
            The FCL Management class is a singleton wrapper for FCL installation management functionality
            that is actually implemented in the CTFInstallationManager assembly. It is provided here to allow
            runtime access by the very components that the actual implementation is dependent on. 
            </summary>
        </member>
        <member name="M:MS.Swi.InstallationManagement.#cctor">
            <summary>
            On use of the installation management shim, make sure that we have the
            actual implementation loaded
            </summary>
        </member>
        <member name="M:MS.Swi.InstallationManagement.#ctor">
            <summary>
            FCL Management is a container for static helper functions, and does not
            have a valid instance
            </summary>
        </member>
        <member name="M:MS.Swi.InstallationManagement.LoadAssembliesFromFclDirectories">
            <summary>
            Load the assemblies from the FCL directories for this system
            </summary>
        </member>
        <member name="M:MS.Swi.InstallationManagement.HasDirectoryAssigned">
            <summary>
            Determine if the directory has been assigned for this installation
            </summary>
            <returns>True if one was assigned, false if not </returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.GetDirectory">
            <summary>
            Get the directory associated with the assembly, or null if it doesn't exist
            </summary>
            <returns>The associated directory, or null if it wasn't set</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.SetDirectory(System.String)">
            <summary>
            Set the directory associated with this assembly 
            </summary>
            <param name="directoryPath">The directory path</param>
            <returns>True if it worked, false if not</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.ClearDirectory">
            <summary>
            Clear the directory assigned to this installation
            </summary>
        </member>
        <member name="M:MS.Swi.InstallationManagement.InstallFiles(System.String,System.String[])">
            <summary>
            Install files from the source into the managed storage location
            </summary>
            <param name="sourceDirectory">The source directory</param>
            <param name="files">The files (including wildcards) to be installed</param>
            <returns>The set of files installed, or null if they could not all be installed.
            Each subdirectory is a key, and the value is the set of files in that directory.</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.UninstallFiles(System.String[])">
            <summary>
            Uninstall files from the managed store location
            </summary>
            <param name="files">The files (including wildcards) to be removed</param>
            <returns>True if none of the named files remain in the storage, false if an error occurred or no storage is defined</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.RemoveStorageDirectory">
            <summary>
            Remove the storage directory. Note that this does NOT clear the
            storage directory assignment, that must be done separately, but it
            does delete all of the files in the storage directory and remove
            the directory
            </summary>
        </member>
        <member name="M:MS.Swi.InstallationManagement.DefaultStorageDirectory">
            <summary>
            Build the default storage directory for the current version
            </summary>
            <returns>The calculated storage directory, or null if the attempt to build a directory failed</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.IncrementInstallationCount">
            <summary>
            Increment the installation count
            </summary>
            <returns>The installation count, or 0xffffffff if an error occurred</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.DecrementInstallationCount">
            <summary>
            Decrement the installation count
            
            </summary>
            <returns>The installation count, or 0xffffffff if an error occurred</returns>
        </member>
        <member name="M:MS.Swi.InstallationManagement.RemoveConfigurationInformation">
            <summary>
            Remove the registry information for this installation
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstTokenReference">
            <summary>
            The read-only access definition for the TokenReference class.
            Note that when accessing the referenced tokens, they are unsorted.
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenReference.ReferenceType">
            <summary>
            The type of reference
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenReference.Count">
            <summary>
            The number of elements that make up the reference
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstTokenReference.References">
            <summary>
            The referenced contents
            </summary>
        </member>
        <member name="T:MS.Swi.Data.TokenReference">
            <summary>
            The definition of a reference from one token to another, handling cases where the 
            tokens are split. Note that when accessing the referenced tokens, they are unsorted.
            </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.#ctor(MS.Swi.Data.TokenReference.TokenReferenceType,MS.Swi.Data.Token[])">
            <summary>
            Create a new TokenReference to a specific token
            </summary>
            <param name="referenceType">The reference type</param>
            <param name="referencedTokens">The referenced token</param>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.#ctor(MS.Swi.Data.TokenReference.TokenReferenceType,MS.Swi.Data.DataContents[])">
            <summary>
            Create a new TokenReference to a specific contents
            </summary>
            <param name="referenceType">The reference type</param>
            <param name="referencedContents">The referenced contents</param>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.#ctor(MS.Swi.Data.TokenReference.TokenReferenceType,System.Collections.Generic.List{MS.Swi.Data.Token})">
            <summary>
            Create a new TokenReference to a specific token
            </summary>
            <param name="referenceType">The reference type</param>
            <param name="referencedTokens">The referenced token</param>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.#ctor(MS.Swi.Data.TokenReference.TokenReferenceType,System.Collections.Generic.List{MS.Swi.Data.DataContents})">
            <summary>
            Create a new TokenReference to a specific contents
            </summary>
            <param name="referenceType">The reference type</param>
            <param name="referencedContents">The referenced contents</param>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.CloneReferences">
            <summary>
            Provide a copy of the reference list
            </summary>
            <returns>The copied reference list</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.Apply">
            <summary>
            Apply the reference. This was split out from the original creation of the reference to handle
            the usage pattern in which references are created, but not necessarily applied
            </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.RemoveInvalidReferences(MS.Swi.Data.Token,MS.Swi.Data.IDataContentsInformationSource)">
            <summary>
            Remove from the reference any DataContents which are no longer present in the DataMap, based
            on the information provided, or for which the references are now no longer calculable
            </summary>
            <param name="owner">The Token which owns this reference </param>
            <param name="informationSource">The source of information about the contents</param>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.System#ICloneable#Clone">
            <summary>
            Clone the TokenReference
            </summary>
            <returns>The newly created token reference</returns>
        </member>
        <member name="M:MS.Swi.Data.TokenReference.Clone">
            <summary>
            Clone the TokenReference
            </summary>
            <returns>The newly created token reference</returns>
        </member>
        <member name="P:MS.Swi.Data.TokenReference.ReferenceType">
            <summary>
            The type of reference
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenReference.Count">
            <summary>
            The number of tokens that make up the reference
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenReference.MS#Swi#Data#IConstTokenReference#References">
            <summary>
            Allow the enumeration of the references
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenReference.References">
            <summary>
            Allow the enumeration of the references
            </summary>
        </member>
        <member name="T:MS.Swi.Data.TokenReference.TokenReferenceType">
            <summary>
            The type of reference
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenReference.TokenReferenceType.NoReference">
            <summary>
            The requisite zero value, in this case indicating that we have no reference at all
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenReference.TokenReferenceType.Position">
            <summary>
            The reference is to the start position of the contents
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenReference.TokenReferenceType.RelativePosition">
            <summary>
            The reference is to the start position of the contents relative to the start position of this contents
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenReference.TokenReferenceType.Size">
            <summary>
            The reference is to the size of the contents
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenReference.TokenReferenceType.Contents">
            <summary>
            The reference is to the contents
            </summary>
        </member>
        <member name="F:MS.Swi.Data.TokenReference.TokenReferenceType.Children">
            <summary>
            The reference is to the number of descendents the contents has
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstEncapsulation">
            <summary>
            The cont interface to an Encapsulation. While Encapsulations are themselves immutable (and so
            would not ordinarily require an IConst style interface, this provides interface serves to 
            ensure that all data pulled from an IConstEncapsulation is also either immutable or IConst in nature.
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstEncapsulation.FindReferencedTokens(System.String)">
            <summary>
            Find all the tokens referenced as part of the encapsulation, under the given label
            </summary>
            <param name="label">The specified label</param>
            <returns>The list of tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstEncapsulation.FindReferencedTokens">
            <summary>
            Find all tokens referenced as part of the encapsulation
            </summary>
            <returns>The list of tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstEncapsulation.GetValidDefinitions">
            <summary>
            Construct a list of all of the possible valid definitions for this encapsulation
            </summary>
            <returns>The list of valid definitions</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstEncapsulation.References">
            <summary>
            The references of the Encapsulation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstEncapsulation.ReferenceList">
            <summary>
            All of the references of the encapsulation, expressed as a list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstEncapsulation.Definition">
            <summary>
            The definition of the Encapsulation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstEncapsulation.Identifier">
            <summary>
            The identifier associated with the encapsulation
            </summary>
        </member>
        <member name="T:MS.Swi.Data.Encapsulation">
            <summary>
            An encapsulation is a reference
            </summary>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.#ctor(MS.Swi.Data.ElementDefinition,System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{MS.Swi.Data.DataContents}})">
            <summary>
            Construct the encapsulation given a set of references
            </summary>
            <param name="definition">The encapsulation definition to use</param>
            <param name="identifier">The identifier for the encapsulation (null will be silently changed to an empty string)</param>
            <param name="references">The references. Note that the Encapsulation will take ownership of the underlying lists after this is called</param>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.FindReferencedTokens(System.String)">
            <summary>
            Find all the tokens referenced as part of the encapsulation, under the given label
            </summary>
            <param name="label">The specified label</param>
            <returns>The list of tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.FindReferencedTokens">
            <summary>
            Find all tokens referenced as part of the encapsulation
            </summary>
            <returns>The list of tokens</returns>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.GetValidDefinitions">
            <summary>
            Construct a list of all of the possible valid definitions for this encapsulation
            </summary>
            <returns>The list of valid definitions</returns>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.Equals(System.Object)">
            <summary>
            Do two Encapsulation objects have the same contents
            </summary>
            <param name="otherObject">The encapsulation to compare against</param>
            <returns>True if they have the same contents, False if not</returns>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.IsEquivalentTo(MS.Swi.Data.Encapsulation)">
            <summary>
            Determine if this encapsulation is equivalent to another. Encapsulations are equivalent if one is a
            refinement of the other and they include the same references. Note that this means that differences
            in identifier are unimportant.
            </summary>
            <param name="otherEncapsulation">The other encapsulation</param>
            <returns>True if they are equivalent, false otherwise</returns>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.GetHashCode">
            <summary>
            The hashcode for the Encapsulation
            </summary>
            <returns>The calculated hash code</returns>
        </member>
        <member name="M:MS.Swi.Data.Encapsulation.RemoveInvalidReferences(MS.Swi.Data.IDataContentsInformationSource)">
            <summary>
            Remove any references inside of the encapsulation that are to DataContents that no longer exist
            </summary>
            <param name="informationSource">The information source to query for the status of a given DataContents</param>
        </member>
        <member name="P:MS.Swi.Data.Encapsulation.References">
            <summary>
            The references of the Encapsulation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Encapsulation.ReferenceList">
            <summary>
            All of the references of the encapsulation, expressed as a list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Encapsulation.MS#Swi#Data#IConstEncapsulation#References">
            <summary>
            The references of the Encapsulation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Encapsulation.MS#Swi#Data#IConstEncapsulation#ReferenceList">
            <summary>
            All of the references of the encapsulation, expressed as a list
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Encapsulation.Definition">
            <summary>
            The definition of the Encapsulation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.Encapsulation.Identifier">
            <summary>
            The value associated with the encapsulation
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.Add(MS.Swi.Data.DataContents)">
            <summary>
            Add a DataContents element to the state table
            </summary>
            <param name="contents">The contents to add</param>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.Contains(MS.Swi.Data.DataContents)">
            <summary>
            Whether or not the table already contains the specified contents
            </summary>
            <param name="contents">The contents</param>
            <returns>True if it is already contained, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.IndexOfPosition(MS.Swi.Data.TokenPosition)">
            <summary>
            The index ordinal for a given token position
            </summary>
            <param name="position">The token position</param>
            <returns>The index ordinal</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.SetTokenAssociations">
            <summary>
            Set the associations between leaf states and tokens
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.ResolveOrphanedStates(MS.Swi.Data.IConstDataMap)">
            <summary>
            Resolve any states that have been orphaned out
            </summary>
            <param name="sourceMap">The source data map</param>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.InitializePositionsForResolution">
            <summary>
            Initialize the positions of all known locations in the state table. Note that this should
            only be run once, and it requires that the token associations already be set. This does NOT
            clear other positions, it assumes it is only run once per state table
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.RemoveInvalidReferences(MS.Swi.Data.IDataContentsInformationSource)">
            <summary>
            Fix up any token references to contents that no longer exist in the modified DataMap, or which
            can no longer be handled due to changes in the DataMap
            </summary>
            <param name="informationSource">The information source to use for the fixup</param>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.Item(MS.Swi.Data.DataContents)">
            <summary>
            Contents state indexed by contents
            </summary>
            <param name="index">The contents</param>
            <returns>The state</returns>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.Item(MS.Swi.Data.TokenPosition)">
            <summary>
            Contents state of the contents associated with the token position
            </summary>
            <param name="position">The index position</param>
            <returns>The contents state</returns>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.Item(System.Int32)">
            <summary>
            Contents state indexed by the ordinal associated with the token position
            </summary>
            <param name="index">The index</param>
            <returns>The contents state</returns>
        </member>
        <member name="T:MS.Swi.Data.DataContentsStateTable.State">
            <summary>
            The state information for each contents node
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.#ctor(MS.Swi.Data.DataContentsStateTable,MS.Swi.Data.DataContents)">
            <summary>
            Construct a new DataContentsState
            </summary>
            <param name="associatedTable">The table the state is a part of</param>
            <param name="associatedContents">The contents this state is associated with</param>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.IsOrphan(MS.Swi.Data.IConstDataMap)">
            <summary>
            Whether or not this state was orphaned by other manipulations
            </summary>
            <param name="sourceMap">The DataMap to check against</param>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.CalculateRelativePosition(MS.Swi.Data.DataContents)">
            <summary>
            Calculate the relative position between this contents and the referenced contents
            </summary>
            <param name="referencedContents">The referenced contents</param>
            <returns>The relative position</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.IsResolvable">
            <summary>
            Is this data contents element resolvable
            </summary>
            <returns>True if the element is resolvable, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.ClearBaseTokenPosition">
            <summary>
            Reset the BaseTokenPosition to null
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.ClearContents">
            <summary>
            Clear the contents, flagging them as cleared, for garbage collection
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.SetToInitialPosition(System.Collections.Generic.List{MS.Swi.Data.DataContents})">
            <summary>
            Set the state to its initial position. Note that this REQUIRES that it is called
            in order on the states to function correctly. This works by checking to see if there
            is already a position resolved for this contents PositionBase, and if there is not, 
            setting this position to zero and resolving the position base
            </summary>
            <param name="resolvedBasePositions">The list of already resolved base positions</param>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.RemoveInvalidReferencesInAssociatedToken(MS.Swi.Data.IDataContentsInformationSource)">
            <summary>
            Fixup any references in the associated token
            </summary>
            <param name="informationSource">The information source to use for the fixup</param>
        </member>
        <member name="M:MS.Swi.Data.DataContentsStateTable.State.UpdateSiblingPositions">
            <summary>
            Update the positions of Siblings for the DataContents associated with this State
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.Table">
            <summary>
            The parent state table
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.IsLeaf">
            <summary>
            Whether or not this state is a leaf state (i.e. directly associated with a token)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.IsSizeDetermined">
            <summary>
            Is the size of the resolved contents known? Note that
            this is the size of the contents object in its native units
            by the type (i.e. if it is a string, the size is in characters)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.IsPositionDetermined">
            <summary>
            Is the position of the resolved contents known? Note that
            this is the position of the contents object within its root element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.AreContentsDetermined">
            <summary>
            Are the contents determined?
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.HoldFurtherResolution">
            <summary>
            Whether or not any DataMap resolution should proceed past this DataContents at this time. This
            is used to hold resolution until an Encapsulation can resolve all of its contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.SetSizeWhenContentsAreDetermined">
            <summary>
            Whether or not the size of the item should be set when its contents are determined
            (if that is possible).
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.Contents">
            <summary>
            The resolved contents of the contents object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.Position">
            <summary>
            The position of the contents. Note that
            this is the position of the contents object its root element, indexed
            in bytes
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.Size">
            <summary>
            The size of the contents. Note that this is in bytes, regardless of the actual
            form of the data
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.BaseTokenPosition">
            <summary>
            The base token position for this contents (i.e. the earliest of its child positions)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContentsStateTable.State.Transformation">
            <summary>
            The transformation associated with this data child
            </summary>
        </member>
        <member name="T:MS.Swi.Data.EncapsulationAttackInformation">
            <summary>
            The attack details for a given encapsulation
            </summary>
        </member>
        <member name="M:MS.Swi.Data.EncapsulationAttackInformation.#ctor(MS.Swi.Data.Encapsulation,MS.Swi.Data.ElementDefinition,MS.Swi.Data.DataContentsStateTable)">
            <summary>
            Construct attack information specifying that the encapsulation should be attacked as the specified
            definition (or null, if the definition is unimportant). Note that if there is an existing encapsulation
            that is being attacked that shares any of the same references, we will silently default to not attack.
            </summary>
            <param name="encapsulation">The encapsulation being attacked</param>
            <param name="definition">The target definition of that encapsulation (or null, to use the default)</param>
            <param name="contentsTable">The content mapping table that is managing the attack results</param>
        </member>
        <member name="M:MS.Swi.Data.EncapsulationAttackInformation.#ctor(MS.Swi.Data.Encapsulation,MS.Swi.Data.DataMapResolver.AttackType)">
            <summary>
            A non-contents attack on the encapsulation (either do not attack, or only attack the 
            structure)
            </summary>
            <param name="encapsulation">The specified encapsulation</param>
            <param name="attackType">The attack type</param>
        </member>
        <member name="M:MS.Swi.Data.EncapsulationAttackInformation.PlaceContentHolds">
            <summary>
            Place holds on the contents that the encapsulation requires, preventing further resolution
            </summary>
        </member>
        <member name="M:MS.Swi.Data.EncapsulationAttackInformation.ReleaseContentHolds">
            <summary>
            Release holds on the contents that the encapsulation requires, allowing further resolution
            </summary>
        </member>
        <member name="M:MS.Swi.Data.EncapsulationAttackInformation.RequiredHoldsConflict">
            <summary>
            Check for existing content holds that would indicate another encapsulation already is 
            attacking some of the values we would be using
            </summary>
        </member>
        <member name="M:MS.Swi.Data.EncapsulationAttackInformation.IsResolvable">
            <summary>
            Determine if the encapsulation is currently resolvable
            </summary>
            <returns>True if all of the required contents are known, and we should attack, and aren't already resolved</returns>
        </member>
        <member name="P:MS.Swi.Data.EncapsulationAttackInformation.Attack">
            <summary>
            Whether or not the target encapsulation should be attacked
            </summary>
        </member>
        <member name="P:MS.Swi.Data.EncapsulationAttackInformation.IsResolved">
            <summary>
            Whether or not the encapsulation is resolved. By definition, if no attack is going to happen,
            it was resolved.
            </summary>
        </member>
        <member name="P:MS.Swi.Data.EncapsulationAttackInformation.TargetEncapsulation">
            <summary>
            The target encapsulation
            </summary>
        </member>
        <member name="P:MS.Swi.Data.EncapsulationAttackInformation.TargetDefinition">
            <summary>
            The target definition to be used for the attack
            </summary>
        </member>
        <member name="T:MS.Swi.Data.TokenAttackInformation">
            <summary>
            The attack details for a given token
            </summary>
        </member>
        <member name="M:MS.Swi.Data.TokenAttackInformation.#ctor(MS.Swi.Data.Token,MS.Swi.Data.ElementDefinition)">
            <summary>
            Construct the attack information for the token. Note that if we cannot get to the requested
            data type, we will turn this into a no-attack
            </summary>
            <param name="token">The token</param>
            <param name="definition">The preferred target definition</param>
        </member>
        <member name="M:MS.Swi.Data.TokenAttackInformation.#ctor(MS.Swi.Data.Token,MS.Swi.Data.DataMapResolver.AttackType)">
            <summary>
            A non-contents attack on the token (either do not attack, or only attack the 
            structure)
            </summary>
            <param name="token">The token</param>
            <param name="attack">The attack type</param>
        </member>
        <member name="P:MS.Swi.Data.TokenAttackInformation.Attack">
            <summary>
            Whether or not we should apply an attack to this token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenAttackInformation.TargetDefinition">
            <summary>
            The name of the object which is our target definition
            </summary>
        </member>
        <member name="P:MS.Swi.Data.TokenAttackInformation.TargetContents">
            <summary>
            The target contents
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver">
            <summary>
            Resolve the contents of a DataMap
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IDataContentsInformationSource">
            <summary>
            An accessor interface to allow the partially resolved values of the data to be extracted
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IDataContentsInformationSource.WasContentsDeleted(MS.Swi.Data.IConstDataContents)">
            <summary>
            Does the specified DataContents still exist in the InformationSource. This is
            to handle cases where a structural manipulation may have removed a referenced Token
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>True if the DataContents was deleted, False if not</returns>
        </member>
        <member name="M:MS.Swi.Data.IDataContentsInformationSource.GetContents(MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the resolved contents of the specified IConstDataContents
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>The contents</returns>
        </member>
        <member name="M:MS.Swi.Data.IDataContentsInformationSource.GetPosition(MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the position of the resolved contents, relative to its root element, and in bytes
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>The position</returns>
        </member>
        <member name="M:MS.Swi.Data.IDataContentsInformationSource.GetSize(MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the size of the resolved contents, in bytes
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>The size</returns>
        </member>
        <member name="M:MS.Swi.Data.IDataContentsInformationSource.GetRelativeOffset(MS.Swi.Data.IConstDataContents,MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the relative offset between one item and another.
            </summary>
            <param name="source">The contents which is requesting the relative offset</param>
            <param name="target">The target contents</param>
            <returns>The relative offset</returns>
        </member>
        <member name="M:MS.Swi.Data.IDataContentsInformationSource.CanCalculateRelativeOffset(MS.Swi.Data.IConstDataContents,MS.Swi.Data.IConstDataContents)">
            <summary>
            Determine whether or not a relative position can be calculated between two contents
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.Resolve(MS.Swi.Data.DataMap)">
            <summary>
            Resolve a DataMap to the core byte arrays, making no changes
            </summary>
            <param name="map">The DataMap</param>
            <returns>The list of byte arrays that correspond to the DataMap root elements</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.Resolve(MS.Swi.Data.DataMap,MS.Swi.Data.DataMapResolver.QueryTokenAttackInformationDelegate,MS.Swi.Data.DataMapResolver.QueryEncapsulationAttackInformationDelegate,MS.Swi.Data.DataMapResolver.ResolveTokenContentsDelegate,MS.Swi.Data.DataMapResolver.ResolveEncapsulationContentsDelegate,MS.Swi.Data.DataMapResolver.ResolveTokenStructureDelegate,MS.Swi.Data.DataMapResolver.ResolveEncapsulationStructureDelegate,System.Random)">
            <summary>
            Resolve a DataMap to the core byte arrays, applying the specified changes
            </summary>
            <param name="map">The map to resolve</param>
            <param name="tokenAttackInformationCallback">The callback to use to determine what action should be applied to a Token</param>
            <param name="encapsulationAttackInformationCallback">The callback to use to determine what action should be applied to an Encapsulation</param>
            <param name="tokenResolveContentsCallback">The callback to use to determine the actual contents</param>
            <param name="encapsulationResolveContentsCallback">The callback to use to determine the actual contents</param>
            <param name="tokenResolveStructureCallback">The callback to use to modify the DataMap based on a token</param>
            <param name="encapsulationResolveStructureCallback">The callback to use to modify the DataMap based on an Encapsulation</param>
            <param name="prnGenerator">The random number generator to use</param>
            <returns>The list of byte arrays that correspond to the DataMap root elements</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.#ctor(MS.Swi.Data.DataMap,MS.Swi.Data.DataMapResolver.QueryTokenAttackInformationDelegate,MS.Swi.Data.DataMapResolver.QueryEncapsulationAttackInformationDelegate,MS.Swi.Data.DataMapResolver.ResolveTokenContentsDelegate,MS.Swi.Data.DataMapResolver.ResolveEncapsulationContentsDelegate,MS.Swi.Data.DataMapResolver.ResolveTokenStructureDelegate,MS.Swi.Data.DataMapResolver.ResolveEncapsulationStructureDelegate,System.Random)">
            <summary>
            Initialize the data map resolver. Note that this will generate queries to the attack information
            delegates if one is specified
            </summary>
            <param name="map">The map to resolve</param>
            <param name="tokenAttackInformationCallback">The callback to use to determine what action should be applied to a Token</param>
            <param name="encapsulationAttackInformationCallback">The callback to use to determine what action should be applied to an Encapsulation</param>
            <param name="tokenResolveContentsCallback">The callback to use to determine the actual contents</param>
            <param name="encapsulationResolveContentsCallback">The callback to use to determine the actual contents</param>
            <param name="tokenResolveStructureCallback">The callback to use to modify the DataMap based on a token</param>
            <param name="encapsulationResolveStructureCallback">The callback to use to modify the DataMap based on an Encapsulation</param>
            <param name="prnGenerator">The random number generator to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.WasContentsDeleted(MS.Swi.Data.IConstDataContents)">
            <summary>
            Does the specified DataContents still exist in the InformationSource. This is
            to handle cases where a structural manipulation may have removed a referenced Token
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>True if the DataContents was deleted, False if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.GetContents(MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the resolved contents of the specified IConstDataContents
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>The contents</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.GetPosition(MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the position of the resolved contents, relative to its parent object base, and
            in units based on the type (i.e. arrays are in terms of array elements, strings are in
            terms of characters, everything else would be a singleton)
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>The position</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.GetSize(MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the size of the resolved contents, in units based on the type (i.e. arrays are in
            terms of array elements, strings are in terms of characters, everything else would be a singleton)
            </summary>
            <param name="source">The DataContents object being queried</param>
            <returns>The size</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.GetRelativeOffset(MS.Swi.Data.IConstDataContents,MS.Swi.Data.IConstDataContents)">
            <summary>
            Get the relative offset between one item and another.
            </summary>
            <param name="source">The contents which is requesting the relative offset</param>
            <param name="target">The target contents</param>
            <returns>The relative offset</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.CanCalculateRelativeOffset(MS.Swi.Data.IConstDataContents,MS.Swi.Data.IConstDataContents)">
            <summary>
            Determine whether or not a relative position can be calculated between two contents
            </summary>
            <param name="source">The contents which is requesting the relative offset</param>
            <param name="target">The target contents</param>
            <returns>True if a relative offset can be calculated, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.Resolve">
            <summary>
            Resolve the entire DataMap, returning the constructed results. Note that this can
            modify the underlying DataMap, if the strategy includes structural manipulations
            </summary>
            <returns>The list of byte[] objects that correspond to the root elements</returns>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.ResolveStructuralManipulations">
            <summary>
            Resolve all structural manipulations and update the attack target information to exclude
            the newly created items
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.ResolveContentManipulations(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Resolve all scheduled content manipulations
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.ResolveContents(MS.Swi.Data.EncapsulationAttackInformation)">
            <summary>
            Resolve the contents for the specified encapsulation. Note that the encapsulation must be unresolved,
            and must have been determined to be resolvable.
            </summary>
            <param name="encapsulationAttack">The encapsulation attack</param>
        </member>
        <member name="M:MS.Swi.Data.DataMapResolver.ResolveContents(MS.Swi.Data.Token,MS.Swi.Data.DataContents)">
            <summary>
            Resolve the contents for the specific token. Note that the token must be unresolved, 
            and must have been determined to be resolvable
            </summary>
            <param name="token">The token being resolved</param>
            <param name="contents">The contents being resolved</param>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.AttackType">
            <summary>
            What type of attack should be conducted on a given DataMap element
            </summary>
        </member>
        <member name="F:MS.Swi.Data.DataMapResolver.AttackType.None">
            <summary>
            No attack, the element should not be attacked
            </summary>
        </member>
        <member name="F:MS.Swi.Data.DataMapResolver.AttackType.AttackContents">
            <summary>
            The contents of the element should be attacked
            </summary>
        </member>
        <member name="F:MS.Swi.Data.DataMapResolver.AttackType.AttackStructure">
            <summary>
            The structure of the DataMap should be attacked, using the
            element as the reference point
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.QueryTokenAttackInformationDelegate">
            <summary>
            Query to determine what the desired targetting is for a given token
            </summary>
            <param name="prnGenerator">The random number generator to use</param>
            <param name="token">The token being considered</param>
            <param name="definition">The definition to be used (or null if this is unimportant)</param>
            <returns>The AttackType selected</returns>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.QueryEncapsulationAttackInformationDelegate">
            <summary>
            Query to determine what the desired targetting is for a given encapsulation
            </summary>
            <param name="prnGenerator">The random number generator to use</param>
            <param name="encapsulation">The encapsulation being considered</param>
            <param name="definition">The definition to be used (or null if this is unimportant)</param>
            <returns>The AttackType selected</returns>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.ResolveTokenContentsDelegate">
            <summary>
            Resolve any changes being made to the token contents
            </summary>
            <param name="prnGenerator">The random number generator to use</param>
            <param name="token">The token being attacked</param>
            <param name="contentsDefinition">The definition of the contents being attacked</param>
            <param name="source">The data contents that the contents came from</param>
            <param name="contents">The contents</param>
            <returns>The modified contents</returns>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.ResolveEncapsulationContentsDelegate">
            <summary>
            Resolve any changes being made to the token encapsulation
            </summary>
            <param name="prnGenerator">The random number generator to use</param>
            <param name="encapsulation">The encapsulation being attacked</param>
            <param name="contentsDefinition">The definition of the contents being attacked</param>
            <param name="contents">The contents (which will be modified in place)</param>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.ResolveTokenStructureDelegate">
            <summary>
            Resolve any changes being made to the structure focusing on a given token
            </summary>
            <param name="prnGenerator">The random number generator to use</param>
            <param name="sourceMap">The data map being modified</param>
            <param name="token">The token being referenced</param>
        </member>
        <member name="T:MS.Swi.Data.DataMapResolver.ResolveEncapsulationStructureDelegate">
            <summary>
            Resolve any changes being made to the structure focusing on a given encapsulation
            </summary>
            <param name="prnGenerator">The random number generator to use</param>
            <param name="sourceMap">The data map being modified</param>
            <param name="encapsulation">The encapsulation being referenced</param>
        </member>
        <member name="T:MS.Swi.Data.IConstDataContents">
            <summary>
            The read-only version of the internal mapping information for the contents of a data token. 
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstDataContents.CanDescendFrom(MS.Swi.Data.DataContents)">
            <summary>
            Whether not one DataContents can descend from another
            </summary>
            <param name="prospectiveParent">The prospective parent data contents</param>
            <returns>True if this contents could descend from that one, otherwise false</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataContents.FindAssociatedTokens">
            <summary>
            Find the list of all of the tokens which descend from this DataContents
            </summary>
            <returns>The constructed list</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstDataContents.TrimSplitPoints(System.Collections.IEnumerable)">
            <summary>
            Trim out zero length split points from the specified set (including split points at the ends)
            </summary>
            <param name="splitPoints">The split points to analyzer</param>
            <returns>The new set of split points</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Parent">
            <summary>
            The parent of this DataContents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Root">
            <summary>
            The root contents for this DataContents object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Container">
            <summary>
            The first parent DataContents for this DataContents that contains more than
            one child, or null if there is no container for this DataContents (which would
            make it the only DataContents in the root)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.PositionBase">
            <summary>
            The DataContents that the position of this contents is relative to, or null, if no position
            can be calculated
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.BaseDefinition">
            <summary>
            The base FCL definition for this contents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.IsSplit">
            <summary>
            Whether or not this is a split of the parent object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.IsRoot">
            <summary>
            Whether or not this is a root container
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.NumberOfChildren">
            <summary>
            The number of children the node has
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.AssociatedToken">
            <summary>
            The token that this DataContents element is associated with, or null if it does
            not have a directly associated token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Transformation">
            <summary>
            The transformation that applies to this DataContents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Restrictions">
            <summary>
            The restrictions that apply to the contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.ContentsNativeType">
            <summary>
            The native type of this DataContents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.ReferenceTypesTo">
            <summary>
            The types of references to this contents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Children">
            <summary>
            The child nodes of this node
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.Child">
            <summary>
            The child of this node. This is only valid if there is one and only one child node
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.IsImmutable">
            <summary>
            Whether or not the DataContents is immutable
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.IsSizeDeterminable">
            <summary>
            Whether or not the size of the DataContents can ever be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.IsAbsolutePositionDeterminable">
            <summary>
            Whether or not the absolute position of the DataContents can ever be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.IsPositionDeterminable">
            <summary>
            Whether or not any position can be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.From">
            <summary>
            The transformation which created these contents, if it can be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstDataContents.SizeMultiplier">
            <summary>
            The size multiplier that can convert from the number of elements in the actual contents
            to the number of bytes they represent, or 0 if there is no constant size multiplier that
            applies
            </summary>
        </member>
        <member name="T:MS.Swi.Data.DataContents">
            <summary>
            The internal mapping information for the contents of a data token. Please note that
            there is no ordering information contained in a DataContents object. All of the ordering
            is in the associated Token.
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor">
            <summary>
            Construct an empty data contents element
            </summary>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor(MS.Swi.Data.DataContents)">
            <summary>
            Construct a copy of a DataContents element
            </summary>
            <param name="sourceContents">The source contents to use</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor(System.Byte[])">
            <summary>
            Construct a root data contents element
            </summary>
            <param name="data">The source data</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor(System.Object,MS.Swi.Data.DataTransformation[])">
            <summary>
            Create a contents leaf element, and build the parent objects automatically
            </summary>
            <param name="contents">The contents</param>
            <param name="transformations">The full set of transformations to apply backwards</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor(System.Object,MS.Swi.Data.IConstTokenRestrictions,MS.Swi.Data.DataTransformation[])">
            <summary>
            Create a contents leaf element, and build the parent objects automatically
            </summary>
            <param name="contents">The contents</param>
            <param name="restrictions">New restrictions on the contents, or null if no restrictions are being added</param>
            <param name="transformations">The full set of transformations to apply backwards</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor(MS.Swi.Data.DataContents,System.Object)">
            <summary>
            Construct an element that is a subset of the parent element. Note that this is where we handle
            the case in a split operation where we are splitting a field whose transformation is defined as
            f(x) + f(y) = f(x+y), by pushing the Transformation data down. For this to work, after the split,
            the actual parent is responsible for voiding its own Transformation in the Split() function
            </summary>
            <param name="parent">The parent contents</param>
            <param name="contents">These contents</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.#ctor(MS.Swi.Data.DataContents,MS.Swi.Data.DataTransformation)">
            <summary>
            Construct an element that is a transformation of the parent element
            </summary>
            <param name="parent">The parent contents</param>
            <param name="transformation">The transformation</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.Split">
            <summary>
            Split the contents into single element subcontents (i.e. the maximum number of
            possible sub-contents)
            </summary>
            <returns>The list of contents</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContents.Split(System.Collections.IEnumerable)">
            <summary>
            Split the contents into sub-contents, given the split points provided. Note that the child
            elements are already added as children of this DataContents node by the time they are returned.
            
            This will create zero length children, if they are specified. To exclude zero-length children, use the
            TrimSplitPoints() function first
            
            The length of the resulting contents will always be the length of the split points + 1. This means that
            an empty set of split points will return a single split of the entire section
            
            The contents object must be an array or a String
            </summary>
            <param name="splitPoints">The array of split points (expressed as elements of the underlying splittable native type)</param>
        </member>
        <member name="M:MS.Swi.Data.DataContents.CanDescendFrom(MS.Swi.Data.DataContents)">
            <summary>
            Whether not one DataContents can descend from another
            </summary>
            <param name="prospectiveParent">The prospective parent data contents</param>
            <returns>True if this contents could descend from that one, otherwise false</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContents.FindAssociatedTokens">
            <summary>
            Find the list of all of the tokens which descend from this DataContents
            </summary>
            <returns>The constructed list</returns>
        </member>
        <member name="M:MS.Swi.Data.DataContents.TrimSplitPoints(System.Collections.IEnumerable)">
            <summary>
            Trim out zero length split points from the specified set (including split points at the ends)
            </summary>
            <param name="splitPoints">The split points to analyzer</param>
            <returns>The new set of split points</returns>
        </member>
        <member name="F:MS.Swi.Data.DataContents.mParent">
            Contents tracking:
            	The parent is the parent DataContents, or null if this is the root
            	The associated token is the token that this contents is currently associated with
            	The transformation is the transformation that applies to the parent node, if any
            	The children are the set of child nodes
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#Restrictions">
            <summary>
            The restrictions that apply to the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Restrictions">
            <summary>
            The restrictions that apply to the token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.IsImmutable">
            <summary>
            Whether or not the DataContents is immutable
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.IsRoot">
            <summary>
            Whether or not this is a root DataContents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Contents">
            <summary>
            The modifiable contents of the Data
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.ContentsNativeType">
            <summary>
            The native type of the contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.SizeMultiplier">
            <summary>
            The size multiplier that can convert from the number of elements in the actual contents
            to the number of bytes they represent, or 0 if there is no constant size multiplier that
            applies
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.IsSizeDeterminable">
            <summary>
            Whether or not the size of the DataContents can ever be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.IsAbsolutePositionDeterminable">
            <summary>
            Whether or not the absolute position of the DataContents can ever be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.IsPositionDeterminable">
            <summary>
            Whether or not any position can be determined
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#AssociatedToken">
            <summary>
            The token which is currently associated with these contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.AssociatedToken">
            <summary>
            The token which is currently associated with these contents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.IsSplit">
            <summary>
            Whether or not this is a split of the parent object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.NumberOfChildren">
            <summary>
            The number of children the node has
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Transformation">
            <summary>
            The transformation that is required to transform these contents to their parent type
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#Parent">
            <summary>
            The parent contents for this DataContents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Parent">
            <summary>
            The parent contents for this DataContents
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#Children">
            <summary>
            The children of this DataContents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Children">
            <summary>
            The children of this DataContents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#Child">
            <summary>
            The child of this node. This will return null if this is a leaf node, and throw an exception if
            this node has multiple children
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Child">
            <summary>
            The child of this node. This will return null if this is a leaf node, and throw an exception if
            this node has multiple children
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.From">
            <summary>
            The name of the transformation which created this data, if it can be determined, otherwise ""
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#Root">
            <summary>
            The root contents for this DataContents object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Root">
            <summary>
            The root contents for this DataContents object
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#PositionBase">
            <summary>
            The DataContents that the position of this contents is relative to, or null, if no position
            can be calculated
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.PositionBase">
            <summary>
            The DataContents that the position of this contents is relative to, or null, if no position
            can be calculated
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.MS#Swi#Data#IConstDataContents#Container">
            <summary>
            The first parent DataContents for this DataContents that contains more than
            one child, or null if there is no container for this DataContents (which would
            make it the only DataContents in the root)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.Container">
            <summary>
            The first parent DataContents for this DataContents that contains more than
            one child, or null if there is no container for this DataContents (which would
            make it the only DataContents in the root)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.ReferenceTypesTo">
            <summary>
            The types of references to this contents element
            </summary>
        </member>
        <member name="P:MS.Swi.Data.DataContents.BaseDefinition">
            <summary>
            The base FCL definition for this contents element
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.AccessPermissions">
            <summary>
            Access flags for permissions on individual common objects
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.OwnerWrite">
            <summary>
            Base Flag:
            Owner can write to/modify the common storage logical object after creation
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.OwnerDelete">
            <summary>
            Base Flag:
            Owner can delete the common storage logical object
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.AnyWrite">
            <summary>
            Base Flag:
            Any object can write to/modify the common storage logical object after creation
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.AnyDelete">
            <summary>
            Base Flag
            Any object can delete the common storage logical object
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.None">
            <summary>
            Common Flag Mask:
            No one can modify or delete the common storage logical object
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.Default">
            <summary>
            Common Flag Mask:
            Default setting: The owner can delete the common storage logical object, and any object
            can modify it
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.ReadOnly">
            <summary>
            Common Flag Mask:
            No one can write to/modify the common storage logical object after creation, but the
            owning object can delete it
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.OthersReadOnly">
            <summary>
            Common Flag Mask
            The owning object can write to/modify or delete the common storage logical object, but other
            objects have read-only access
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.AccessPermissions.All">
            <summary>
            Common Flag Mask
            All flag options are set, any object can do anything to the common storage logical object
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.Storage">
            <summary>
            CommonStorage is a forced Singleton class, with the public
            static field Data as an implementation.
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.#ctor">
            <summary>
            Private constructor to build an individual CommonStorage object, which have no contents
            anyway
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.RegisterForObjectManagementEvents(MS.Swi.CommonStorage.DataUpdateEventHandler)">
            <summary>
            Register the specified handler for object management (Creation/Deletion) events
            </summary>
            <param name="eventHandler">The specified handler</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.UnregisterForObjectManagementEvents(MS.Swi.CommonStorage.DataUpdateEventHandler)">
            <summary>
            Unregister the specified handler for object management (Creation/Deletion) events
            </summary>
            <param name="eventHandler">The specified handler</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.RegisterForObjectUpdateEvents(System.String,MS.Swi.CommonStorage.DataUpdateEventHandler)">
            <summary>
            Register the specified handler for modification events for the specified logical object
            </summary>
            <param name="logicalName">The logical object name</param>
            <param name="eventHandler">The specified handler</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.UnregisterForObjectUpdateEvents(System.String,MS.Swi.CommonStorage.DataUpdateEventHandler)">
            <summary>
            Unregister the specified handler for modification events for the specified logical object
            </summary>
            <param name="logicalName">The logical object name</param>
            <param name="eventHandler">The specified handler</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Contents(System.String)">
            <summary>
            Return the contents associated with the specified logical object
            </summary>
            <param name="logicalName">The name of the logical object</param>
            <returns>The contents of the </returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Exists(System.String)">
            <summary>
            Does an object of the given logical name exist in common storage?
            </summary>
            <param name="logicalName">The logical name</param>
            <returns>True if the object already exists, false if not</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Permissions(System.String)">
            <summary>
            What are the permissions for the object
            </summary>
            <param name="logicalName">The object logical name</param>
            <returns>The object permissions, or None if the object does not exist</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Clear">
            <summary>
            Reset the storage completely. Note that this ignores any permissions values
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Create(System.Object,System.String,System.Type,System.Object,MS.Swi.CommonStorage.AccessPermissions)">
            <summary>
            Create a logical object. This will fail if the object already exists. If the object is
            created, an ObjectCreated event will be generated for it
            </summary>
            <param name="owner">The object owner</param>
            <param name="logicalName">The object logical name</param>
            <param name="requiredType">The type of the logical object, or null if all types are valid</param>
            <param name="initialValue">The initial object value</param>
            <param name="permissions">The permissions flags for the object</param>
            <returns>True if it worked, false if not</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Modify(System.Object,System.String,System.Object)">
            <summary>
            Modify an already existing logical object. If the object cannot be changed by the accessor, an
            ObjectAccessViolation message will be sent to any listeners who have registered for updates on
            that particular object, otherwise, an ObjectModified message will be sent instead.
            </summary>
            <param name="accessor">The object accessing the logical object</param>
            <param name="logicalName">The logical object name</param>
            <param name="replacementValue">The new object value</param>
            <returns>True if it worked, false if not</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Delete(System.Object)">
            <summary>
            Delete (or attempt to delete) all logical objects owned by the specified owning object. Note
            that objects whose permissions don't allow it will not be removed.
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.Delete(System.Object,System.String)">
            <summary>
            Delete a logical object. If the object cannot be deleted by the accessor, an
            ObjectAccessViolation message will be sent to any listeners who have registered for
            object management events, otherwise, an ObjectDeleted message will be sent instead.
            </summary>
            <param name="accessor">The object deleting the logical object</param>
            <param name="logicalName">The logical object name</param>
            <returns>True if it worked, false if not</returns>
        </member>
        <member name="P:MS.Swi.CommonStorage.Storage.LogicalObjectNames">
            <summary>
            Return an ICollection of the names of all of the logical objects
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.Storage.ContentDefinition">
            <summary>
            The content definition class for the internal hash table. The ContentDefinition fully identify the
            object, owner, permissions, and contents of every logical object in the Common Storage
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.ContentDefinition.#ctor(System.Object,System.String,System.Type,System.Object,MS.Swi.CommonStorage.AccessPermissions)">
            <summary>
            ContentDefinition constructor
            </summary>
            <param name="owner">Owner of the object</param>
            <param name="logicalName">Full logical name of the object</param>
            <param name="objectType">Type of the object, or null if all types are valid</param>
            <param name="objectValue">The initial contents of the object</param>
            <param name="permissions">Permission flags for the object</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.ContentDefinition.CheckPermissions(System.Object,MS.Swi.CommonStorage.Storage.ContentDefinition.OperationType)">
            <summary>
            Determine if the accessor has sufficient permissions to perform the operation on the logical object
            </summary>
            <param name="accessor"></param>
            <param name="operation"></param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.ContentDefinition.CheckType(System.Object)">
             <summary>
             Check the proposed value against the type
            
             Values are valid if:
             One: The type restriction for these contents is null, meaning no restrictions OR
             Two: The object is null, and the required type is a reference type or interface OR
             Three: The object is of the same class or a subclass of the required type OR
             Four: The required type is an interface, and the object implements it 
             
             
             </summary>
             <param name="proposedValue">The value to check</param>
             <returns>True if the value was valid for the type restriction, false if not</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.ContentDefinition.Modify(System.Object,System.Object)">
            <summary>
            Modify the object contents
            </summary>
            <param name="accessor">The accessor</param>
            <param name="replacementValue">The replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.ContentDefinition.Register(MS.Swi.CommonStorage.DataUpdateEventHandler)">
            <summary>
            Register a handler for this particular logical object (and this object only)
            </summary>
            <param name="eventHandler"></param>
        </member>
        <member name="M:MS.Swi.CommonStorage.Storage.ContentDefinition.Unregister(MS.Swi.CommonStorage.DataUpdateEventHandler)">
            <summary>
            Unregister a handler for this particular logical object (and this object only)
            </summary>
            <param name="eventHandler"></param>
        </member>
        <member name="P:MS.Swi.CommonStorage.Storage.ContentDefinition.Owner">
            <summary>
            The owner of the logical object
            </summary>
        </member>
        <member name="P:MS.Swi.CommonStorage.Storage.ContentDefinition.ObjectContents">
            <summary>
            The current contents of the logical object
            </summary>
        </member>
        <member name="P:MS.Swi.CommonStorage.Storage.ContentDefinition.ObjectType">
            <summary>
            The object type (or NULL) of the object
            </summary>
        </member>
        <member name="P:MS.Swi.CommonStorage.Storage.ContentDefinition.ObjectPermissions">
            <summary>
            The permission flags for the logical object
            </summary>
        </member>
        <member name="P:MS.Swi.CommonStorage.Storage.ContentDefinition.ObjectName">
            <summary>
            The logical name of the referenced object
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.Storage.ContentDefinition.OperationType">
            <summary>
            Private enumeration defining the type of operation being considered for permissions checks
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.StorageGroup">
            <summary>
            Helper class providing access to the Common Storage shared objects table
            
            This is used to provide a cleaner, and simpler interface for classes which are only
            concerned with their own Common Storage shared objects, and will not be looking at objects
            used by other modules 
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.#ctor(System.String)">
            <summary>
            Construct the StorageGroup with an initial identifier
            </summary>
            <param name="identifier">The identifier to use</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.IdentifiedName(System.String)">
            <summary>
            Accessor to construct a string, based on the logical name, that should be
            used for all references in the Common Storage space. 
            </summary>
            <param name="name">Base Logical variable name</param>
            <returns>Constructed global name</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.Delete(System.String)">
            <summary>
            Delete the specified logical name from common storage. Note that this is only designed to
            work for variables created as part of the VariableWrapper. While it may work for other variables,
            it will only do so if the identifier is the same, and AccessAnyDelete is set as an access flag. 
            
            In general, anything dealing with variables not defined as part of the VariableWrapper should be
            done via CommonStorage directly.
            
            NOTE: Permission failures will generate an ObjectAccessViolation event from CommonStorage,
            although not an exception.
            
            </summary>
            <param name="name">Base Logical variable name</param>
            <returns>True if the object was deleted, false if not</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.Clear">
            <summary>
            Delete all logical objects owned by the StorageWrapper, if they can be deleted.
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.Exists(System.String)">
            <summary>
            Determine if the specified logical name exists in common storage. Note that this is only designed to
            work for variables created as part of the VariableWrapper. While it may work for other variables,
            it will only do so if the identifier is the same
            </summary>
            <param name="name">Base logical variable name</param>
            <returns>True if the variable exists, false if not</returns>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.Create(System.String,System.Object)">
            <summary>
            Simplest variable create, which creates an object in Common Storage based on the
            base name, with the access values set to AccessDefault, and the type restrictions
            based on the initial value
            </summary>
            <param name="name">Base logical name</param>
            <param name="initialValue">Initial value of the logical object</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.Create(System.String,MS.Swi.CommonStorage.AccessPermissions,System.Object)">
            <summary>
            Create a logical object in Common Storage based on the base name. Note that the
            type restriction will be inferred from the type of the value
            </summary>
            <param name="name">The base name</param>
            <param name="permissions">The permissions to apply</param>
            <param name="initialValue">The initial value</param>
        </member>
        <member name="M:MS.Swi.CommonStorage.StorageGroup.Create(System.String,System.Type,MS.Swi.CommonStorage.AccessPermissions,System.Object)">
            <summary>
            Create a fully specified logical object in Common Storage
            </summary>
            <param name="name">The base name</param>
            <param name="restriction">The type restrictions (or null, for no restrictions)</param>
            <param name="permissions">The permissions to apply</param>
            <param name="initialValue">The initial value</param>
        </member>
        <member name="P:MS.Swi.CommonStorage.StorageGroup.Identifier">
            <summary>
            Method for getting/setting the identification string that is used to 
            access the data. Please note that modifying the identifier after Common Storage elements
            have been created with this StorageGroup will cause problems in finding those elements later.
            </summary>
        </member>
        <member name="P:MS.Swi.CommonStorage.StorageGroup.Item(System.String)">
            <summary>
            Indexing function to provide access to get/set variables in the Common Storage space.
            
            If the variable does not exist, this version (unlike the version in Common Storage) will
            throw an exception, as we do NOT expect to find that variables don't exist.
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.DataUpdateEventArgs">
            <summary>
            DataUpdate Event Argument Definition
            </summary>
        </member>
        <member name="M:MS.Swi.CommonStorage.DataUpdateEventArgs.#ctor(MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType,System.String)">
            <summary>
            Event Arguments
            </summary>
            <param name="type">The type of event</param>
            <param name="logicalName">The logical object involved</param>
        </member>
        <member name="P:MS.Swi.CommonStorage.DataUpdateEventArgs.Type">
            <summary>
            Property to return the event Type
            </summary>
        </member>
        <member name="P:MS.Swi.CommonStorage.DataUpdateEventArgs.ObjectName">
            <summary>
            Property to return the name of the logical object
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType">
            <summary>
            Event Types
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType.ObjectCreated">
            <summary>
            Report the creation of a common storage logical object
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType.ObjectDeleted">
            <summary>
            Report the deletion of a common storage logical object
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType.ObjectModified">
            <summary>
            Report the modification of a common storage logical object
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType.ObjectAccessViolation">
            <summary>
            Report that an illegal attempt to modify or delete a common storage logical object occurred
            </summary>
        </member>
        <member name="F:MS.Swi.CommonStorage.DataUpdateEventArgs.UpdateType.AllObjectsDeleted">
            <summary>
            Report that all objects in the storage have been deleted
            </summary>
        </member>
        <member name="T:MS.Swi.CommonStorage.DataUpdateEventHandler">
            <summary>
            DataUpdateEvent Handler Definition
            </summary>
        </member>
        <member name="T:MS.Swi.Mitm.IConstRemoteClassDefinition">
            <summary>
            The read-only (i.e. true const) interface for a RemoteClassDefinition
            </summary>
        </member>
        <member name="M:MS.Swi.Mitm.IConstRemoteClassDefinition.ToXml(System.Xml.XmlDocument)">
            <summary>
            Export the definition to Xml
            </summary>
            <param name="owningDocument">The owning document for the XmlNode</param>
            <returns>The constructed Xml node</returns>
        </member>
        <member name="M:MS.Swi.Mitm.IConstRemoteClassDefinition.GetArgumentList">
            <summary>
            Extract the arguments as an argument list
            </summary>
            <returns>A newly created array of strings which is the argument list</returns>
        </member>
        <member name="M:MS.Swi.Mitm.IConstRemoteClassDefinition.AsDefinitionString(System.Char)">
            <summary>
            Extract the entire definition as a definition string for passing to the instrumentation
            </summary>
            <param name="separator">The separator character to use</param>
            <returns>The constructed string</returns>
        </member>
        <member name="M:MS.Swi.Mitm.IConstRemoteClassDefinition.Clone">
            <summary>
            Create a duplicate of the object as a remote class definition
            </summary>
            <returns>The duplicate as a remote class definition</returns>
        </member>
        <member name="P:MS.Swi.Mitm.IConstRemoteClassDefinition.Classname">
            <summary>
            The fully qualified name of the remote class
            </summary>
        </member>
        <member name="P:MS.Swi.Mitm.IConstRemoteClassDefinition.Arguments">
            <summary>
            Read-only access to the arguments
            </summary>
        </member>
        <member name="T:MS.Swi.Mitm.RemoteClassDefinition">
            <summary>
            The full definition of a MitmClass, including the fully qualified classname and the arguments to 
            the class on initialization
            </summary>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.#ctor">
            <summary>
            Define a remote class
            </summary>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.#ctor(System.String)">
            <summary>
            Define a remote class with no arguments
            </summary>
            <param name="classname">The name of the IMitmRemoteClass class</param>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.#ctor(System.String,System.String[])">
            <summary>
            Define a remote class
            </summary>
            <param name="classname">The name of the IMitmRemoteClass class</param>
            <param name="arguments">The arguments for the initialization of that class</param>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Define a remote class
            </summary>
            <param name="classname">The name of the IMitmRemoteClass class</param>
            <param name="arguments">The arguments for the initialization of that class</param>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.#ctor(System.Xml.XmlElement)">
            <summary>
            Define a remote class from Xml
            </summary>
            <param name="definition">The Xml definition</param>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.FromXml(System.Xml.XmlElement)">
            <summary>
            Set the contents from the Xml definition
            </summary>
            <param name="definition">The Xml definition to use</param>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.ToXml(System.Xml.XmlDocument)">
            <summary>
            Export the definition to Xml
            </summary>
            <param name="owningDocument">The owning document for the element</param>
            <returns>The constructed Xml element</returns>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.GetArgumentList">
            <summary>
            Extract the arguments as an argument list
            </summary>
            <returns>A newly created array of strings which is the argument list</returns>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.AsDefinitionString(System.Char)">
            <summary>
            Extract the entire definition as a definition string for passing to the instrumentation
            </summary>
            <param name="separator">The separator character to use</param>
            <returns>The constructed string</returns>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.System#ICloneable#Clone">
            <summary>
            Create a deep copy of the remote class definition as an object
            </summary>
            <returns>The duplicate as an object</returns>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.MS#Swi#Mitm#IConstRemoteClassDefinition#Clone">
            <summary>
            Create a deep copy of the remote class definition as a const remote class definition
            </summary>
            <returns>The duplicate as a const remote class definition</returns>
        </member>
        <member name="M:MS.Swi.Mitm.RemoteClassDefinition.Clone">
            <summary>
            Create a deep copy of the remote class definition
            </summary>
            <returns>The duplicate as a remote class definition</returns>
        </member>
        <member name="P:MS.Swi.Mitm.RemoteClassDefinition.Classname">
            <summary>
            The fully qualified name of the remote class
            </summary>
        </member>
        <member name="P:MS.Swi.Mitm.RemoteClassDefinition.ModifiableArguments">
            <summary>
            The arguments to the remote class
            </summary>
        </member>
        <member name="P:MS.Swi.Mitm.RemoteClassDefinition.Arguments">
            <summary>
            Read-only access to the arguments
            </summary>
        </member>
        <member name="T:MS.Swi.Data.ElementCharacteristics">
            <summary>
            Specific characteristics about the type
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.None">
            <summary>
            The requisit flag indicating that no flags are set
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.Severable">
            <summary>
            The token can be split at any point into subtokens of the same type
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.Singleton">
            <summary>
            This definition is a singleton, and cannot be subdivided except by a Transformation
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.ValidAsAncestor">
            <summary>
            The token can validly be treated as its parent. Note that this
            is recursive
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.Encapsulation">
            <summary>
            This definition is an encapsulation. 
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.Token">
            <summary>
            This definition is a token
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementCharacteristics.Specific">
            <summary>
            This definition is a specific definition, and should not be included by default by 
            analyzers
            </summary>
        </member>
        <member name="T:MS.Swi.Data.ElementDefinition">
            <summary>
            The token definition class defines the characteristics of each specific token type
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementDefinition.BaseTokenDefinitionName">
            <summary>
            The name of the base FCL type
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementDefinition.ContainerTokenDefinitionName">
            <summary>
            The name of the special FCL heterogenous container type
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementDefinition.ContainerTokenNativeType">
            <summary>
            The type of the special FCL heterogenous container native representation
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementDefinition.BaseTokenDefinition">
            <summary>
            The base FCL Definition for data
            </summary>
        </member>
        <member name="F:MS.Swi.Data.ElementDefinition.ContainerTokenDefinition">
            <summary>
            A specialized FCL Definition for Containers
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.#ctor(System.String,System.Type,MS.Swi.Data.ElementCharacteristics)">
            <summary>
            Constructor for the token definition
            </summary>
            <param name="tokenName">The name of the token</param>
            <param name="nativeType">The native type the token represents</param>
            <param name="characteristics">The characteristics of this type of token</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.#ctor(System.String,System.String,MS.Swi.Data.ElementCharacteristics)">
            <summary>
            Constructor for the token definition
            </summary>
            <param name="tokenName">The name of the token</param>
            <param name="baseName">The name of the token this token refines</param>
            <param name="characteristics">The characteristics of this type of token</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.#ctor(System.String,MS.Swi.Data.ElementCharacteristics)">
            <summary>
            Constructor for the encapsulation definition definition
            </summary>
            <param name="tokenName">The name of the token</param>
            <param name="characteristics">The characteristics of this type of token</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.#ctor(System.Xml.XmlElement)">
            <summary>
            Construct a token definition from an Xml node. Note that it currently only will recognize
            types in the System or current assembly for the associated type. This will change.
            </summary>
            <param name="xmlDefinition">The defined node</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.CalculateHashCode">
            <summary>
            Calculate the internal hash code
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.ValidateCharacteristics">
            <summary>
            Validate the characteristics, and fill in any defaults that are blank
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.GetHashCode">
            <summary>
            Get a hash code for the token definition
            </summary>
            <returns>The calculated hash</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.Equals(System.Object)">
            <summary>
            Determine if two objects are equivalent token definitions
            </summary>
            <param name="obj">The other object</param>
            <returns>True if it is an equivalent definition, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.ToXmlElement(System.Xml.XmlDocument)">
            <summary>
            Create an Xml element that defines the definition, for the specified owning document
            </summary>
            <param name="owningDocument">The owning document</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.HasCharacteristic(MS.Swi.Data.ElementCharacteristics)">
            <summary>
            Does the element have the specified characteristic? If the characteristic is a combination of multiple
            characteristics, it will return true only if all of the characteristics are a match
            </summary>
            <param name="characteristic">The characteristic (or characteristics) to check for</param>
            <returns>True if there is an exact match, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.IsRefinementOf(System.String)">
            <summary>
            Determine if one token is a refinement of another. Note that we allow for a type
            to be a refinement of itself
            </summary>
            <param name="definitionName">The base definition name</param>
            <returns>True if the definition is a refinement of the definitionName</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.CanDescendFrom(System.String)">
            <summary>
            Determine if a token of this type can descend from the specified definition. This handles
            checking for ancestral equivalences (i.e. it uses CanBeTreatedAs)
            </summary>
            <param name="definitionName">The base definition name</param>
            <returns>True if the this definition can descend from the definitionName</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinition.CanBeTreatedAs(System.String)">
            <summary>
            Determine if one token can be treated as another. Note that it is always valid to ask if you
            can be treated as yourself. Note that this is MORE restrictive than checking for inheritance,
            and exists for analyzers that match particular types. In normal usage, the IsRefinementOf 
            accessor is more likely to be the desired accessor
            </summary>
            <param name="baseDefinitionName">The base definition name</param>
            <returns>True if this definition can be treated as the baseDefinitionName</returns>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.NativeType">
            <summary>
            The NativeType
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.Ancestor">
            <summary>
            The token definition instance that this definition refines
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.Refines">
            <summary>
            The token that this token refines (i.e. XMLString refines String which refines ByteArray)
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.Defines">
            <summary>
            The token name
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.Characteristics">
            <summary>
            The known characteristics of this type of token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.IsSpecific">
            <summary>
            Whether or not this definition is included only if specifically requested
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.IsGeneral">
            <summary>
            Whether or not this definition is included by default
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.IsTokenDefinition">
            <summary>
            Whether or not this definition defines a token
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinition.IsEncapsulationDefinition">
            <summary>
            Whether or not this token definition defines an encapsulation
            </summary>
        </member>
        <member name="T:MS.Swi.Data.IConstElementDefinitions">
            <summary>
            The const (i.e. true Read Only) interface definition for ElementDefinitions
            </summary>
        </member>
        <member name="M:MS.Swi.Data.IConstElementDefinitions.IsTheSameAs(MS.Swi.Data.IConstElementDefinitions)">
            <summary>
            Is this set of definitions the same as the other set of definitions
            </summary>
            <param name="otherDefinitions">The comparison set of definitions</param>
            <returns>True if they are the same, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstElementDefinitions.ToXmlElement(System.Xml.XmlDocument)">
            <summary>
            Create an Xml element that defines the definitions, for the specified owning document
            </summary>
            <param name="owningDocument">The owning document</param>
        </member>
        <member name="M:MS.Swi.Data.IConstElementDefinitions.Find(System.String)">
            <summary>
            Find a registered token definition
            </summary>
            <param name="tokenName">The name of the token definition</param>
            <returns>The token definition, or null if it could not be found</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstElementDefinitions.Contains(System.String)">
            <summary>
            Determine if the token definition is contained in this collection
            </summary>
            <param name="tokenName">The name to check</param>
            <returns>True if it is contained, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.IConstElementDefinitions.Clone">
            <summary>
            Return a clone of the IConstElementDefinitions as a new ElementDefinitions object
            </summary>
            <returns>The new ElementDefinitions as ElementDefinitions</returns>
        </member>
        <member name="P:MS.Swi.Data.IConstElementDefinitions.Count">
            <summary>
            The number of definitions 
            </summary>
        </member>
        <member name="P:MS.Swi.Data.IConstElementDefinitions.Definitions">
            <summary>
            Enumerate the definitions
            </summary>
        </member>
        <member name="T:MS.Swi.Data.ElementDefinitions">
            <summary>
            The token definitions class serves as an encapsulation of a set of registered token
            definitions
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.LoadDefinitions(System.String)">
            <summary>
            Load the entire set of token definitions. The filename will be searched for first as given,
            then in the local directory, and then in the FCL installation directory.
            </summary>
            <param name="fileName">The filename for the Xml file containing the definitions</param>
            <returns>The definition set</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.LoadDefinitions(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Load a set of definitions based on a specific whitelist and blacklist.  The filename will be searched for first as given,
            then in the local directory, and then in the FCL installation directory.
            </summary>
            <param name="fileName">The filename for the Xml file containing the definitions</param>
            <param name="whitelist">Whitelisted definitions (regular expressions acceptable), or null</param>
            <param name="blacklist">Blacklisted definitions (regular expressions acceptable), or null</param>
            <returns>The definition set</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.LoadDefinitions(System.Xml.XmlElement)">
            <summary>
            Load the entire set of token definitions
            </summary>
            <param name="tokenDefinitions">The Xml node containing the token definitions, defined by </param>
            <returns>The definition set</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.LoadDefinitions(System.Xml.XmlElement,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Load a set of definitions based on a specific whitelist and blacklist
            </summary>
            <param name="tokenDefinitions">The Xml node containing the token definitions, defined by </param>
            <param name="whitelist">Whitelisted definitions (regular expressions acceptable), or null</param>
            <param name="blacklist">Blacklisted definitions (regular expressions acceptable), or null</param>
            <returns>The definition set</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.#ctor">
            <summary>
            Create the basic token definition table, consisting only of the base data type
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.#ctor(MS.Swi.Data.ElementDefinitions)">
            <summary>
            A private copy constructor for efficient handling of the clone
            </summary>
            <param name="definitions">The source definitions</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.Add(MS.Swi.Data.ElementDefinition)">
            <summary>
            Add a token definition to the table of token definitions
            </summary>
            <param name="definition">The token definition</param>
            <returns>True if the definition is now in the set, and false if it conflicts with an existing definition</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.Add(MS.Swi.Data.ElementDefinitions)">
            <summary>
            Add another set of definitions into the current set
            </summary>
            <param name="definitions">The token definitions to add</param>
            <returns>True if the definitions could be added, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.RemoveOrphans">
            <summary>
            Remove any orphaned definitions from the set. This should be called after
            all token definitions have been loaded into a set, and it will prune out any
            definitions whose ancestors cannot be traced.
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.Clear">
            <summary>
            Clear the set of registered token definitions
            </summary>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.IsTheSameAs(MS.Swi.Data.IConstElementDefinitions)">
            <summary>
            Is this set of token definitions the same as the comparison set
            </summary>
            <param name="otherDefinitions">The comparison definitions</param>
            <returns>True if they are the same, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.ToXmlElement(System.Xml.XmlDocument)">
            <summary>
            Create an Xml element that defines the definitions, for the specified owning document
            </summary>
            <param name="owningDocument">The owning document</param>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.Find(System.String)">
            <summary>
            Find a registered token definition
            </summary>
            <param name="tokenName">The name of the token definition</param>
            <returns>The token definition, or null if it could not be found</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.Contains(System.String)">
            <summary>
            Determine if the token definition is contained in this collection
            </summary>
            <param name="tokenName">The name to check</param>
            <returns>True if it is contained, false if not</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.GetEnumerator">
            <summary>
            The enumerator for iteration
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.System#ICloneable#Clone">
            <summary>
            Return a clone of the ElementDefinitions
            </summary>
            <returns>The new ElementDefinitions as an object</returns>
        </member>
        <member name="M:MS.Swi.Data.ElementDefinitions.Clone">
            <summary>
            Return a clone of the ElementDefinitions
            </summary>
            <returns>The new ElementDefinitions as ElementDefinitions</returns>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinitions.Count">
            <summary>
            The number of definitions 
            </summary>
        </member>
        <member name="P:MS.Swi.Data.ElementDefinitions.Definitions">
            <summary>
            An enumerator for the set of definitions
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\LbaPluginParameters.xml ===
<?xml version="1.0" encoding="utf-8" ?>
<lbaPlugins>
  <plugin id="CopyLba">
    <parameter name="source" />
    <parameter name="target" />
    <parameter name="overwrite">
      <value>none</value>
      <value>older</value>
      <value>all</value>
    </parameter>
    <parameter name="removeReadOnly">
      <valueTypeRef id="bool" />
    </parameter>
    <parameter name="IncludeProjectFile">
      <valueTypeRef id="bool" />
    </parameter>
    <parameter name="LimitToActiveCulturesAndProjects">
      <valueTypeRef id="bool" />
    </parameter>
    <parameter name="Mirror">
      <valueTypeRef id="bool" />
    </parameter>
    <parameter name="SubFoldersToInclude">
    </parameter>
  </plugin>
  <plugin id="CustomScript">
    <parameter name="path" />
    <parameter name="executionMode">
      <value>Once</value>
      <value>PerCulture</value>
      <value>PerProject</value>
    </parameter>
    <parameter name="timeout" />
    <parameter name="arguments" />
    <parameter name="AllowMultiThread">
      <valueTypeRef id="bool" />
    </parameter>
  </plugin>
  <plugin id="MlpWebService">
    <parameter name="service" hidden="true">
      <value>CreateBranch</value>
      <value>CreateBuild</value>
      <value>UpdateBuild</value>
      <value>UpdateTransaction</value>
    </parameter>
    <parameter name="FinalizeStatus">
      <valueTypeRef id="bool"/>
    </parameter>
    <parameter name="BuildContainsHandoff" >
      <valueTypeRef id="bool"/>
    </parameter>
    <parameter name="HandoffType" >
      <value>Preview</value>
      <value>Normal</value>
    </parameter>
    <parameter name="AllowMultipleBuildHandoffs">
      <valueTypeRef id="bool" />
    </parameter>
    <parameter name="BuildType">
      <value>Content</value>
      <value>Software</value>
    </parameter>
  </plugin>
  <plugin id="ResourceWebServicePlugin">
    <parameter name="resourceType">
      <value>source</value>
      <value>target</value>
      <value>both</value>
    </parameter>
  </plugin>
  <plugin id="SourceDepot">
    <parameter name="Operation">
      <value>CreateChangelist</value>
      <value>CheckinFiles</value>
      <value>SubmitChangelist</value>
    </parameter>
    <parameter name="IncludeProjectFile">
      <valueTypeRef id="bool" />
    </parameter>
    <parameter name="SubFoldersToInclude" />
  </plugin>
  <plugin id="Policheck">
    <parameter name="ResultType">
      <value>Txt</value>
      <value>Xml</value>
      <value>Xls</value>
    </parameter>
    <parameter name="ScanMode" />
  </plugin>

  <plugin id="Bin2Lcx">
    <parameter name="parameterList" />
    <parameterRef name="HandleResxConversion" />
    <parameterRef name="IncludeResxInFileName" />
    <parameterRef name="UseCommentsForGeneration" />
    <parameterRef name="UseValidationForGeneration" />
    <parameterRef name="SuppressWarnings" />
  </plugin>
  <plugin id="BuildEdb">
    <parameter name="parameterList" />
    <parameterRef name="HandleResxConversion" />
    <parameterRef name="IncludeResxInFileName" />
    <parameterRef name="GlossaryFolderUsage" />
    <parameterRef name="PerformEdbAnalysis" />
    <parameterRef name="PerformEdbValidation" />
    <parameterRef name="FailOnEdbAnalysisErrors" />
    <parameterRef name="FailOnEdbValidationErrors" />
    <parameterRef name="PerformEdbAutoTranslation" />
    <parameterRef name="FailOnEdbAutoTranslationErrors" />
    <parameterRef name="ImportSourceLocks" />
    <parameterRef name="PerformEdbLanguageCheck" />
  </plugin>
  <plugin id="Edb2Bin">
    <parameter name="parameterList" />
    <parameterRef name="HandleResxConversion" />
    <parameterRef name="IncludeResxInFileName" />
    <parameterRef name="PerformEdbValidation" />
    <parameterRef name="FailOnEdbValidationErrors" />
    <parameterRef name="PerformEdbLanguageCheck" />
    <parameterRef name="PseudoLocMode" />
    <parameterRef name="UseCommentsForGeneration" />
    <parameterRef name="UseValidationForGeneration" />
    <parameterRef name="SuppressWarnings" />
    <parameterRef name="GenerationMode" />
    <parameterRef name="UseExistingLclForGeneration" />
  </plugin>
  <plugin id="Edb2Lcl">
    <parameter name="parameterList" />
    <parameterRef name="PerformEdbValidation" />
    <parameterRef name="UseValidationForGeneration" />
    <parameterRef name="FailOnEdbValidationErrors" />
    <parameterRef name="PerformEdbLanguageCheck" />
    <parameterRef name="SuppressWarnings" />
  </plugin>
  <plugin id="LSTask">
    <parameter name="parameterList" />
    <parameter name="task">
      <value>CreateEdb</value>
      <value>SyncEdb</value>
      <value>UpdateEdb</value>
      <value>AutoTransEdb</value>
      <value>ConfigEdb</value>
      <value>AnalyzeEdb</value>
      <value>ValidateEdb</value>
      <value>BldGloss</value>
      <value>Edb2Bin</value>
      <value>Edb2Lcl</value>
      <value>Bin2Lcx</value>
      <value>Resx2Xml</value>
      <value>Xml2Resx</value>
      <value>CommentEdb</value>
      <value>CheckEdb</value>
    </parameter>
    <parameterRef name="HandleResxConversion" />
    <parameterRef name="IncludeResxInFileName" />
    <parameterRef name="GlossaryFolderUsage" />
    <parameterRef name="PerformEdbAnalysis" />
    <parameterRef name="PerformEdbValidation" />
    <parameterRef name="FailOnEdbAnalysisErrors" />
    <parameterRef name="FailOnEdbValidationErrors" />
    <parameterRef name="PerformEdbAutoTranslation" />
    <parameterRef name="FailOnEdbAutoTranslationErrors" />
    <parameterRef name="ImportSourceLocks" />
    <parameterRef name="PerformEdbLanguageCheck" />
    <parameterRef name="UseCommentsForGeneration" />
    <parameterRef name="UseValidationForGeneration" />
    <parameterRef name="SuppressWarnings" />
    <parameterRef name="PseudoLocMode" />
    <parameterRef name="GenerationMode" />
    <parameterRef name="UseExistingLclForGeneration" />
  </plugin>
  
  <plugin id="BuildZip">
  </plugin>
  <plugin id="ExtractZip">
    <parameter name="parameterList" />
    <parameter name="PerformZipValidation">
      <valueTypeRef id="bool" />
    </parameter>
  </plugin>
  
  <valueType id="bool" >
    <value>true</value>
    <value>false</value>
  </valueType>
  <parameter name="ImportSourceLocks">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="FailOnEdbAnalysisErrors">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="FailOnEdbValidationErrors">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="FailOnEdbAutoTranslationErrors">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="HandleResxConversion" hidden="true">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="PerformEdbValidation">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="PerformEdbAnalysis">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="PerformEdbLanguageCheck">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="PseudoLocMode">
    <value>Full</value>
    <value>Mixed</value>
    <value>None</value>
  </parameter>
  <parameter name="UseCommentsForGeneration">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="GlossaryFolderUsage">
    <value>None</value>
    <value>First</value>
    <value>All</value>
  </parameter>
  <parameter name="PerformEdbAutotranslation">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="UseValidationForGeneration">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="SuppressWarnings">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="IncludeResxInFilename">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="GenerationMode">
    <value>Normal</value>
    <value>FailSafe</value>
  </parameter>
  <parameter name="UseExistingLclForGeneration">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="IgnoreUpdatedStringsForPseudoLoc">
    <valueTypeRef id="bool" />
  </parameter>
  <parameter name="IgnoreUpdatedStringsForLoc">
    <valueTypeRef id="bool" />
  </parameter>

	<!-- Helium command parameters-->
	<parameter name="heliumTask" hidden="true">
		<value>PrepHE</value>
		<value>RebuildGlossaryHE</value>
		<value>SetTermHE</value>
		<value>ArchiveHE</value>
		<value>UpdateHE</value>
		<value>TransRptHE</value>
		<value>StatsRptHE</value>
		<value>AutoTransHE</value>
		<value>TermRptHE</value>
		<value>ValidationRptHE</value>
		<value>ExportGlossaryHE</value>
		<value>CleanUpHE</value>
	</parameter>
	<parameter name="NewTermState">
		<value>Review</value>
		<value>Reviewed</value>
		<value>Legacy</value>
	</parameter>
	<parameter name="TermStateFilter" />
	<parameter name="MatchThreshold" />
	<parameter name="PriorityLevel" />
	<parameter name="NewLsgFolder">
		<valueTypeRef id="bool" />
	</parameter>
	<parameter name="IncRepeatsFile">
		<valueTypeRef id="bool" />
	</parameter>

	<!-- Resource Manager command parameters-->
	<plugin id="ResourceManager">
		<parameter name="StatisticsTask">
			<value>LocStatistics</value>
			<value>BuildStatistics</value>
		</parameter>
	</plugin>
</lbaPlugins>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\LbaProjectTypeJobs.xml ===
<?xml version="1.0" encoding="utf-8" ?>
<lbaProjectTypes>
  <projectType type="Edb">
    <job id="LocBuild" defaultJobType="DailyBuildLocalizationCustomEdbEnv">
      <jobType id="DailyBuildLocalizationEdb" />
      <jobType id="DailyBuildLocalizationCustomEdbEnv" />
    </job>
    <job id="RegisterBuild" defaultJobType="MlpRegisterBuildEdb">
      <jobType id="MlpRegisterBuildEdb" />
      <jobType id="MlpRegisterBuildEdbMultipleHandoff" />
    </job>
    <job id="PrepHandoff" defaultJobType="MlpPrepHandoffEdb">
      <jobType id="MlpPrepHandoffEdb" />
    </job>
    <job id="Handback" defaultJobType="MlpHandbackEdbEnv">
      <jobType id="MlpHandbackEdb" />
      <jobType id="MlpHandbackEdbEnv" />
    </job>
    <job id="HandbackRemote1" defaultJobType="MlpHandbackRemoteEdb1Env">
      <jobType id="MlpHandbackRemoteEdb1" />
      <jobType id="MlpHandbackRemoteEdb1Env" />
    </job>
    <job id="HandbackRemote2" defaultJobType="MlpHandbackRemoteEdb2">
      <jobType id="MlpHandbackRemoteEdb2" />
    </job>
    <job id="Checkin" defaultJobType="MlpCheckinEdb">
      <jobType id="MlpCheckinEdb" />
      <jobType id="MlpCheckinEdbTfs" />
      <jobType id="MlpCheckinCustomEdb" />
      <jobType id="MlpCheckinCustomEdbEnv" />
    </job>
    <job id="ValidateEdb" defaultJobType="ValidateEdb">
      <jobType id="ValidateEdb" />
    </job>
    <job id="Policheck" defaultJobType="PolicheckEdb">
      <jobType id="PolicheckEdb" />
    </job>
    <job id="CheckinLcl" defaultJobType="CheckinLcl">
      <jobType id="CheckinLcl" />
    </job>
  </projectType>
  <projectType type="Lspkg">
    <job id="LocBuild" defaultJobType="DailyBuildLocalizationCustomLspkgEnv" >
      <jobType id="DailyBuildLocalizationCustomLspkgEnv" />
    </job>
    <job id="RegisterBuild" defaultJobType="MlpRegisterBuildLspkg" >
      <jobType id="MlpRegisterBuildLspkg" />
    </job>
    <job id="PrepHandoff" defaultJobType="MlpPrepHandoffLspkg" >
      <jobType id="MlpPrepHandoffLspkg" />
    </job>
    <job id="Handback" defaultJobType="MlpHandbackLspkgEnv" >
      <jobType id="MlpHandbackLspkgEnv" />
    </job>
    <job id="HandbackRemote1" defaultJobType="MlpHandbackRemoteLspkg1Env" >
      <jobType id="MlpHandbackRemoteLspkg1Env" />
    </job>
    <job id="HandbackRemote2" defaultJobType="MlpHandbackRemoteLspkg2" >
      <jobType id="MlpHandbackRemoteLspkg2" />
    </job>
    <job id="Checkin" defaultJobType="MlpCheckinLspkg" >
      <jobType id="MlpCheckinLspkg" />
      <jobType id="MlpCheckinLspkgTfs" />
      <jobType id="MlpCheckinCustomLspkgEnv" />
    </job>
    <job id="ValidateLspkg" defaultJobType="ValidateLspkg" >
      <jobType id="ValidateLspkg" />
    </job>
    <job id="Policheck" defaultJobType="PolicheckLspkg" >
      <jobType id="PolicheckLspkg" />
    </job>
    <job id="CheckinLcl" defaultJobType="CheckinLspkgLcl" >
      <jobType id="CheckinLspkgLcl" />
    </job>
  </projectType>
  <projectType type="Helium">
    <job id="HeliumRegisterBuild" defaultJobType="MlpRegisterBuildHelium" >
      <jobType id="MlpRegisterBuildHelium" />
    </job>
    <job id="HeliumPrepHandoff" defaultJobType="MlpPrepHandoffHelium" >
      <jobType id="MlpPrepHandoffHelium" />
    </job>
    <job id="HeliumHandback" defaultJobType="MlpHandbackHelium" >
      <jobType id="MlpHandbackHelium" />
    </job>
    <job id="HeliumCheckin" defaultJobType="MlpCheckinHelium" >
      <jobType id="MlpCheckinHelium" />
      <jobType id="MlpCheckinHeliumTfs" />
    </job>
  </projectType>
  <projectType type="Zip">
    <job id="RegisterBuild" defaultJobType="MlpRegisterBuildZip" >
      <jobType id="MlpRegisterBuildZip" />
    </job>
    <job id="PrepHandoff" defaultJobType="MlpPrepHandoffZip" >
      <jobType id="MlpPrepHandoffZip" />
    </job>
    <job id="Handback" defaultJobType="MlpHandbackZip" >
      <jobType id="MlpHandbackZip" />
    </job>
    <job id="Checkin" defaultJobType="MlpCheckinZip" >
      <jobType id="MlpCheckinZip" />
      <jobType id="MlpCheckinZipTfs" />
    </job>
  </projectType>
</lbaProjectTypes>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\LbaCultures.xml ===
﻿<?xml version="1.0" encoding="utf-8" ?>
<lbaCultureList xmlns="http://msn.com/mlp">

	<lbaCulture id="af" lcid="0x0036" language="af" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="af-ZA" lcid="0x0436" country="ZA" />
	</lbaCulture>

	<!-- Amharic -->
	<lbaCulture id="am" lcid="0x005E" language="am" ansiCodePage="0" oemCodePage="1">
		<!-- Amharic (Ethiopia) -->
		<lbaCulture id="am-ET" lcid="0x045E" language="am" country="ET" />
	</lbaCulture>

	<lbaCulture id="ar" lcid="0x0001" language="ar" ansiCodePage="1256" oemCodePage="720">
		<lbaCulture id="ar-AE" lcid="0x3801" country="AE" />
		<lbaCulture id="ar-BH" lcid="0x3C01" country="BH" />
		<lbaCulture id="ar-DZ" lcid="0x1401" country="DZ" />
		<lbaCulture id="ar-EG" lcid="0x0C01" country="EG" />
		<lbaCulture id="ar-IQ" lcid="0x0801" country="IQ" />
		<lbaCulture id="ar-JO" lcid="0x2C01" country="JO" />
		<lbaCulture id="ar-KW" lcid="0x3401" country="KW" />
		<lbaCulture id="ar-LB" lcid="0x3001" country="LB" />
		<lbaCulture id="ar-LY" lcid="0x1001" country="LY" />
		<lbaCulture id="ar-MA" lcid="0x1801" country="MA" />
		<lbaCulture id="ar-OM" lcid="0x2001" country="OM" />
		<lbaCulture id="ar-QA" lcid="0x4001" country="QA" />
		<lbaCulture id="ar-SA" lcid="0x0401" country="SA" />
		<!-- Pseudo (Mirror) -->
		<lbaCulture id="qps-plocm" lcid="0x09FF" country="plocm" enablePseudoLoc="true" />
		<!-- Legacy Bidi Pseduo -->
		<lbaCulture id="ar-SA-PSLOC" lcid="0x0401" country="SA-PSLOC" enablePseudoLoc="true" />
		<lbaCulture id="ar-SY" lcid="0x2801" country="SY" />
		<lbaCulture id="ar-TN" lcid="0x1C01" country="TN" />
		<!-- Arabic X-Arabia -->
		<lbaCulture id="ar-XA" lcid="0x0401" country="XA" />
		<lbaCulture id="ar-YE" lcid="0x2401" country="YE" />
	</lbaCulture>

	<!-- New Bidi Pseduo -->
	<lbaCulture id="ar-ploc" lcid="0x0001" language="ar-ploc" ansiCodePage="1256" oemCodePage="720" enablePseudoLoc="true" >
		<lbaCulture id="ar-ploc-SA" lcid="0x0401" country="SA" enablePseudoLoc="true" />
	</lbaCulture>

	<!-- Mapudungun -->
	<lbaCulture id="arn" lcid="0x007A" language="arn" ansiCodePage="1252" oemCodePage="850">
		<!-- Mapudungun (Chile) -->
		<lbaCulture id="arn-CL" lcid="0x047A" language="arn" country="CL" />
	</lbaCulture>

	<!-- Assamese -->
	<lbaCulture id="as" lcid="0x004D" language="as" ansiCodePage="0" oemCodePage="1">
		<!-- Assamese (India) -->
		<lbaCulture id="as-IN" lcid="0x044D" language="as" country="IN" />
	</lbaCulture>

	<lbaCulture id="az" lcid="0x002C" language="az" ansiCodePage="1254" oemCodePage="857">
		<lbaCulture id="az-AZ-Cyrl" lcid="0x082C" language="az-Cyrl" country="AZ" ansiCodePage="1251" oemCodePage="866"/>
		<lbaCulture id="az-Cyrl-AZ" lcid="0x082C" language="az-Cyrl" country="AZ" ansiCodePage="1251" oemCodePage="866"/>
		<lbaCulture id="az-AZ-Latn" lcid="0x042C" language="az-Latn" country="AZ" />
		<lbaCulture id="az-Latn-AZ" lcid="0x042C" language="az-Latn" country="AZ" />
	</lbaCulture>

	<!-- Bashkir -->
	<lbaCulture id="ba" lcid="0x006D" language="ba" ansiCodePage="1251" oemCodePage="866">
		<!-- Bashkir (Russia) -->
		<lbaCulture id="ba-RU" lcid="0x046D" language="ba" country="RU" />
	</lbaCulture>

	<lbaCulture id="be" lcid="0x0023" language="be" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="be-BY" lcid="0x0423" country="BY" />
	</lbaCulture>

	<lbaCulture id="bg" lcid="0x0002" language="bg" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="bg-BG" lcid="0x0402" country="BG" />
	</lbaCulture>

	<!-- Edo Nigeria -->
	<lbaCulture id="bin-NG" lcid="0x0466" language="bin" country="NG" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="bin" lcid="0x0466" language="bin" ansiCodePage="0" oemCodePage="1" />

  <!-- Bengali -->
	<lbaCulture id="bn" lcid="0x0045" language="bn" ansiCodePage="0" oemCodePage="1" >
		<!-- Bengali (Bangladesh) -->
		<lbaCulture id="bn-BD" lcid="0x0845" language="bn" country="BD" />
		<!-- Bengali (India) -->
		<lbaCulture id="bn-IN" lcid="0x0445" language="bn" country="IN" />
	</lbaCulture>

	<!-- Tibetan -->
	<lbaCulture id="bo" lcid="0x0051" language="bo" ansiCodePage="0" oemCodePage="1">
		<!-- Tibetan (Bhutan) -->
		<lbaCulture id="bo-BT" lcid="0x0851" language="bo" country="BT" />
		<!-- Tibetan (PRC) -->
		<lbaCulture id="bo-CN" lcid="0x0451" language="bo" country="CN" />
	</lbaCulture>

	<!-- Breton -->
	<lbaCulture id="br" lcid="0x007E" language="br" ansiCodePage="1252" oemCodePage="850">
		<!-- Breton (France) -->
		<lbaCulture id="br-FR" lcid="0x047E" language="br" country="FR" />
	</lbaCulture>

	<!-- Bosnian -->
	<lbaCulture id="bs" lcid="0x781A" language="bs" ansiCodePage="1250" oemCodePage="852">
		<!-- Bosnian (Cyrillic, Bosnia and Herzegovina) -->
		<lbaCulture id="bs-Cyrl-BA" lcid="0x201A" language="bs-Cyrl" country="BA" ansiCodePage="1251" oemCodePage="855" />
		<!-- Bosnian (Latin, Bosnia and Herzegovina) -->
		<lbaCulture id="bs-Latn-BA" lcid="0x141A" language="bs-Latn" country="BA" ansiCodePage="1250" oemCodePage="852" />
	</lbaCulture>

	<lbaCulture id="ca" lcid="0x0003" language="ca" ansiCodePage="1252" oemCodePage="850" >
		<lbaCulture id="ca-ES" lcid="0x0403" country="ES" />
	</lbaCulture>

	<!-- Cherokee -->
	<lbaCulture id="chr" lcid="0x005C" language="chr" ansiCodePage="0" oemCodePage="1">
		<!-- Cherokee (United States) -->
		<lbaCulture id="chr-US" lcid="0x045C" language="chr" country="US" />
	</lbaCulture>

	<!-- Corsican -->
	<lbaCulture id="co" lcid="0x0083" language="co" ansiCodePage="1252" oemCodePage="850">
		<!-- Corsican (France) -->
		<lbaCulture id="co-FR" lcid="0x0483" language="co" country="FR" />
	</lbaCulture>

	<lbaCulture id="cs" lcid="0x0005" language="cs" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="cs-CZ" lcid="0x0405" country="CZ" />
	</lbaCulture>

	<!-- Welsh -->
	<lbaCulture id="cy" lcid="0x0052" language="cy" ansiCodePage="1252" oemCodePage="850">
		<!-- Welsh (United Kingdom) -->
		<lbaCulture id="cy-GB" lcid="0x0452" language="cy" country="GB" />
	</lbaCulture>

	<lbaCulture id="da" lcid="0x0006" language="da" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="da-DK" lcid="0x0406" country="DK" />
	</lbaCulture>

	<lbaCulture id="de" lcid="0x0007" language="de" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="de-AT" lcid="0x0C07" country="AT" />
		<lbaCulture id="de-CH" lcid="0x0807" country="CH" />
		<lbaCulture id="de-DE" lcid="0x0407" country="DE" />
		<lbaCulture id="de-LI" lcid="0x1407" country="LI" />
		<lbaCulture id="de-LU" lcid="0x1007" country="LU" />
	</lbaCulture>

	<lbaCulture id="div" lcid="0x0065" language="div" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="div-MV" lcid="0x0465" country="MV" />
	</lbaCulture>

	<!-- Divehi -->
	<lbaCulture id="dv" lcid="0x0065" language="dv" ansiCodePage="0" oemCodePage="1">
		<!-- Divehi	(Maldives) -->
		<lbaCulture id="dv-MV" lcid="0x0465" language="dv" country="MV" />
	</lbaCulture>

	<!-- Greek -->
	<lbaCulture id="el" lcid="0x0008" language="el" ansiCodePage="1253" oemCodePage="737">
		<!-- Greek (Greece) -->
		<lbaCulture id="el-GR" lcid="0x0408" country="GR" />
		<!-- Greek 2 (Greece) -->
		<lbaCulture id="el-GR-2" lcid="0x2008" country="GR" ansiCodePage="1253" oemCodePage="869"/>
	</lbaCulture>

	<lbaCulture id="en" lcid="0x0009" language="en" ansiCodePage="1252" oemCodePage="437">
		<!-- English Caribbean -->
		<lbaCulture id="en-029" lcid="0x2409" country="029" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-AU" lcid="0x0C09" country="AU" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-BZ" lcid="0x2809" country="BZ" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-CA" lcid="0x1009" country="CA" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-GB" lcid="0x0809" country="GB" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-HK" lcid="0x3C09" country="HK" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-ID" lcid="0x3809" country="ID" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-IE" lcid="0x1809" country="IE" ansiCodePage="1252" oemCodePage="850" />
		<!--<lbaCulture id="en-IL" lcid="" country="IL" /> !!NO LCID!!-->
		<lbaCulture id="en-IN" lcid="0x4009" country="IN" ansiCodePage="1252" oemCodePage="437" />
		<lbaCulture id="en-JM" lcid="0x2009" country="JM" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-MY" lcid="0x4409" country="MY" ansiCodePage="1252" oemCodePage="437" />
		<lbaCulture id="en-NZ" lcid="0x1409" country="NZ" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-PH" lcid="0x3409" country="PH" ansiCodePage="1252" oemCodePage="437" />
		<lbaCulture id="en-SG" lcid="0x4809" country="SG" ansiCodePage="1252" oemCodePage="437" />
		<lbaCulture id="en-TT" lcid="0x2C09" country="TT" ansiCodePage="1252" oemCodePage="850" />
		<lbaCulture id="en-US" lcid="0x0409" country="US" ansiCodePage="1252" oemCodePage="437" />
		<lbaCulture id="en-WW" lcid="0x0409" country="WW" ansiCodePage="1252" oemCodePage="850" />
		<!-- English X-Arabia -->
		<lbaCulture id="en-XA" lcid="0x0409" country="XA" ansiCodePage="1252" oemCodePage="850" />
		<!-- English South Africa -->
		<lbaCulture id="en-ZA" lcid="0x1C09" country="ZA" ansiCodePage="1252" oemCodePage="437" />
		<!-- English Zimbabwe -->
		<lbaCulture id="en-ZW" lcid="0x3009" country="ZW" ansiCodePage="1252" oemCodePage="437" />
		<!-- Pseudo Language (Pseudo Country) -->
		<lbaCulture id="qps-ploc" lcid="0x0501" country="ploc" ansiCodePage="1250" oemCodePage="852" enablePseudoLoc="true" />
	</lbaCulture>

	<lbaCulture id="es" lcid="0x000A" language="es" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="es-AR" lcid="0x2C0A" country="AR" />
		<lbaCulture id="es-BO" lcid="0x400A" country="BO" />
		<lbaCulture id="es-CL" lcid="0x340A" country="CL" />
		<lbaCulture id="es-CO" lcid="0x240A" country="CO" />
		<lbaCulture id="es-CR" lcid="0x140A" country="CR" />
		<lbaCulture id="es-DO" lcid="0x1C0A" country="DO" />
		<lbaCulture id="es-EC" lcid="0x300A" country="EC" />
		<!-- Spanish International Sort -->
		<lbaCulture id="es-ES" lcid="0x0C0A" country="ES" />
		<!-- Spanish Tranditional Sort -->
		<lbaCulture id="es-ES_tradnl" lcid="0x040A" country="ES" />
		<lbaCulture id="es-GT" lcid="0x100A" country="GT" />
		<lbaCulture id="es-HN" lcid="0x480A" country="HN" />
		<lbaCulture id="es-LA" lcid="0x0C0A" country="LA" />
		<lbaCulture id="es-MX" lcid="0x080A" country="MX" />
		<lbaCulture id="es-NI" lcid="0x4C0A" country="NI" />
		<lbaCulture id="es-PA" lcid="0x180A" country="PA" />
		<lbaCulture id="es-PE" lcid="0x280A" country="PE" />
		<lbaCulture id="es-PR" lcid="0x500A" country="PR" />
		<lbaCulture id="es-PY" lcid="0x3C0A" country="PY" />
		<lbaCulture id="es-SV" lcid="0x440A" country="SV" />
		<lbaCulture id="es-US" lcid="0x540A" country="US" />
		<lbaCulture id="es-UY" lcid="0x380A" country="UY" />
		<lbaCulture id="es-VE" lcid="0x200A" country="VE" />
		<lbaCulture id="es-WW" lcid="0x0C0A" country="WW" />
		<!-- Spanish Latin America -->
		<lbaCulture id="es-XL" lcid="0x580A" country="XL" />
    <lbaCulture id="es-419" lcid="0x580A" language="es-419" country="419" />
  </lbaCulture>

	<lbaCulture id="et" lcid="0x0025" language="et" ansiCodePage="1257" oemCodePage="775">
		<lbaCulture id="et-EE" lcid="0x0425" country="EE" />
	</lbaCulture>

	<lbaCulture id="eu" lcid="0x002D" language="eu" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="eu-ES" lcid="0x042D" country="ES" />
	</lbaCulture>

	<lbaCulture id="fa" lcid="0x0029" language="fa" ansiCodePage="1256" oemCodePage="720">
		<lbaCulture id="fa-IR" lcid="0x0429" country="IR" />
	</lbaCulture>

	<lbaCulture id="fi" lcid="0x000B" language="fi" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="fi-FI" lcid="0x040B" country="FI" />
	</lbaCulture>

	<!-- Filipino -->
	<lbaCulture id="fil" lcid="0x0064" language="fil" ansiCodePage="1252" oemCodePage="437">
		<!-- Filipino (Philippines) -->
		<lbaCulture id="fil-PH" lcid="0x0464" language="fil" country="PH" />
	</lbaCulture>

	<lbaCulture id="fo" lcid="0x0038" language="fo" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="fo-FO" lcid="0x0438" country="FO" />
	</lbaCulture>

	<lbaCulture id="fr" lcid="0x000C" language="fr" ansiCodePage="1252" oemCodePage="850">
		<!-- French North Africa -->
		<lbaCulture id="fr-015" lcid="0xE40C" country="015" />
		<lbaCulture id="fr-BE" lcid="0x080C" country="BE" />
		<lbaCulture id="fr-CA" lcid="0x0C0C" country="CA" />
		<lbaCulture id="fr-CD" lcid="0x240C" country="CD" />
		<!-- French	Democratic Republic of Congo -->
		<lbaCulture id="fr-CG" lcid="0x240C" country="CG" />
		<lbaCulture id="fr-CH" lcid="0x100C" country="CH" />
		<lbaCulture id="fr-CI" lcid="0x300C" country="CI" />
		<lbaCulture id="fr-CM" lcid="0x2C0C" country="CM" />
		<lbaCulture id="fr-FR" lcid="0x040C" country="FR" />
		<lbaCulture id="fr-HT" lcid="0x3C0C" country="HT" />
		<lbaCulture id="fr-LU" lcid="0x140C" country="LU" />
		<lbaCulture id="fr-MA" lcid="0x380C" country="MA" />
		<lbaCulture id="fr-MC" lcid="0x180C" country="MC" />
		<lbaCulture id="fr-ML" lcid="0x340C" country="ML" />
		<lbaCulture id="fr-RE" lcid="0x200C" country="RE" />
		<lbaCulture id="fr-SN" lcid="0x280C" country="SN" />
		<!-- French	West Indies -->
		<lbaCulture id="fr-x-windies" lcid="0x1C0C" country="x-windies" ansiCodePage="0" oemCodePage="1" />
	</lbaCulture>

	<!-- Frisian -->
	<lbaCulture id="fy" lcid="0x0062" language="fy" ansiCodePage="1252" oemCodePage="850">
		<!-- Frisian (Netherlands) -->
		<lbaCulture id="fy-NL" lcid="0x0462" language="fy" country="NL" />
	</lbaCulture>

	<!-- Fulfulde Nigeria -->
	<lbaCulture id="fuv-NG" lcid="0x0467" language="fuv" country="NG" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="fuv" lcid="0x0467" language="fuv" country="NG" ansiCodePage="0" oemCodePage="1" />

  <!-- Irish -->
	<lbaCulture id="ga" lcid="0x003C" language="ga" ansiCodePage="1252" oemCodePage="850">
		<!-- Gaelic (Scotland) -->
		<lbaCulture id="ga-GB" lcid="0x043C" language="ga" country="GB" />
		<!-- Irish (Ireland) -->
		<lbaCulture id="ga-IE" lcid="0x083C" language="ga" country="IE" />
	</lbaCulture>

	<!-- Oromo Ethiopia -->
	<lbaCulture id="gaz-ET" lcid="0x0472" language="gaz" country="ET" ansiCodePage="0" oemCodePage="1" />

	<lbaCulture id="gl" lcid="0x0056" language="gl" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="gl-ES" lcid="0x0456" country="ES" />
	</lbaCulture>

	<!-- Guarani Paraguay -->
	<lbaCulture id="gn-PY" lcid="0x0474" language="gn" country="PY" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="gn" lcid="0x0474" language="gn" ansiCodePage="0" oemCodePage="1" />

  <lbaCulture id="gu" lcid="0x0047" language="gu" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="gu-IN" lcid="0x0447" country="IN" />
	</lbaCulture>

	<!-- Alsatian -->
	<lbaCulture id="gsw" lcid="0x0084" language="gsw" ansiCodePage="1252" oemCodePage="850">
		<!-- Alsatian (France) -->
		<lbaCulture id="gsw-FR" lcid="0x0484" language="gsw" country="FR" />
	</lbaCulture>

	<!-- Hausa -->
	<lbaCulture id="ha" lcid="0x0068" language="ha" ansiCodePage="1252" oemCodePage="437">
		<!-- Hausa (Nigeria) -->
		<lbaCulture id="ha-Latn-NG" lcid="0x0468" language="ha-Latn" country="NG" />
	</lbaCulture>

	<!-- Hawaiian United States -->
	<lbaCulture id="haw-US" lcid="0x0475" language="haw" country="US" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="haw" lcid="0x0475" language="haw" ansiCodePage="0" oemCodePage="1" />

  <lbaCulture id="he" lcid="0x000D" language="he" ansiCodePage="1255" oemCodePage="862">
		<lbaCulture id="he-IL" lcid="0x040D" country="IL" />
	</lbaCulture>

	<lbaCulture id="hi" lcid="0x0039" language="hi" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="hi-IN" lcid="0x0439" country="IN" />
	</lbaCulture>

	<lbaCulture id="hr" lcid="0x001A" language="hr" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="hr-BA" lcid="0x101A" country="BA" />
		<lbaCulture id="hr-HR" lcid="0x041A" country="HR" />
	</lbaCulture>

	<lbaCulture id="hu" lcid="0x000E" language="hu" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="hu-HU" lcid="0x040E" country="HU" />
	</lbaCulture>

	<lbaCulture id="hy" lcid="0x002B" language="hy" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="hy-AM" lcid="0x042B" country="AM" />
	</lbaCulture>

	<!-- Ibibio Nigeria -->
	<lbaCulture id="ibb-NG" lcid="0x0469" language="ibb" country="NG" ansiCodePage="0" oemCodePage="1" />

	<!-- Igbo -->
	<lbaCulture id="ig" lcid="0x0070" language="ig" ansiCodePage="1252" oemCodePage="437">
		<!-- Igbo (Nigeria) -->
		<lbaCulture id="ig-NG" lcid="0x0470" language="ig" country="NG" />
	</lbaCulture>

	<!-- Somali -->
	<lbaCulture id="so" lcid="0x0077" language="so" ansiCodePage="1252" oemCodePage="850">
		<!-- Somali (Somalia) -->
		<lbaCulture id="so-SO" lcid="0x0477" language="so" country="SO" />
	</lbaCulture>

	<lbaCulture id="id" lcid="0x0021" language="id" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="id-ID" lcid="0x0421" country="ID" />
	</lbaCulture>

	<!-- Yi -->
	<lbaCulture id="ii" lcid="0x0078" language="ii" ansiCodePage="0" oemCodePage="1">
		<!-- Yi	(PRC) -->
		<lbaCulture id="ii-CN" lcid="0x0478" language="ii" country="CN" />
	</lbaCulture>

	<lbaCulture id="is" lcid="0x000F" language="is" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="is-IS" lcid="0x040F" country="IS" />
	</lbaCulture>

	<lbaCulture id="it" lcid="0x0010" language="it" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="it-CH" lcid="0x0810" country="CH" />
		<lbaCulture id="it-IT" lcid="0x0410" country="IT" />
	</lbaCulture>

	<!-- Inuktitut -->
	<lbaCulture id="iu" lcid="0x005D" language="iu" ansiCodePage="1252" oemCodePage="850">
		<!-- Inuktitut (Syllabics, Canada) -->
		<lbaCulture id="iu-Cans-CA" lcid="0x045D" language="iu-Cans" country="CA" ansiCodePage="0" oemCodePage="1" />
		<!-- Inuktitut (Latin, Canada) -->
		<lbaCulture id="iu-Latn-CA" lcid="0x085D" language="iu-Latn" country="CA" ansiCodePage="1252" oemCodePage="437" />
	</lbaCulture>

	<lbaCulture id="ja" lcid="0x0011" language="ja" ansiCodePage="932" oemCodePage="932">
		<lbaCulture id="ja-JP" lcid="0x0411" country="JP" />
		<!-- Legacy Japanese Pseduo -->
		<lbaCulture id="ja-JP-PSLOC" lcid="0x0411" country="JP-PSLOC" enablePseudoLoc="true" />
		<!-- Pseudo (Asia) -->
		<lbaCulture id="qps-ploca" lcid="0x05FE" country="ploca" enablePseudoLoc="true" />
	</lbaCulture>

	<!-- New Japanese Pseduo -->
	<lbaCulture id="ja-ploc" lcid="0x0011" language="ja-ploc" ansiCodePage="932" oemCodePage="932" enablePseudoLoc="true" >
		<lbaCulture id="ja-ploc-JP" lcid="0x0411" country="JP" enablePseudoLoc="true" />
	</lbaCulture>

	<lbaCulture id="ka" lcid="0x0037" language="ka" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="ka-GE" lcid="0x0437" country="GE" />
	</lbaCulture>

	<lbaCulture id="kk" lcid="0x003F" language="kk" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="kk-KZ" lcid="0x043F" country="KZ" />
	</lbaCulture>

	<!-- Greenlandic -->
	<lbaCulture id="kl" lcid="0x006F" language="kl" ansiCodePage="1252" oemCodePage="850">
		<!-- Greenlandic Greenland -->
		<lbaCulture id="kl-GL" lcid="0x046F" language="kl" country="GL" />
	</lbaCulture>

	<!-- Khmer -->
	<lbaCulture id="km" lcid="0x0053" language="km" ansiCodePage="0" oemCodePage="1">
		<!-- Khmer (Cambodia) -->
		<lbaCulture id="km-KH" lcid="0x0453" language="km" country="KH" />
	</lbaCulture>

	<lbaCulture id="kn" lcid="0x004B" language="kn" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="kn-IN" lcid="0x044B" country="IN" />
	</lbaCulture>

	<lbaCulture id="ko" lcid="0x0012" language="ko" ansiCodePage="949" oemCodePage="949">
		<lbaCulture id="ko-KR" lcid="0x0412" country="KR" />
	</lbaCulture>

	<lbaCulture id="kok" lcid="0x0057" language="kok" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="kok-IN" lcid="0x0457" country="IN" />
	</lbaCulture>

	<!-- Kanuri Nigeria -->
	<lbaCulture id="kr-NG" lcid="0x0471" language="kr" country="NG" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="kr" lcid="0x0471" language="kr" ansiCodePage="0" oemCodePage="1" />

  <lbaCulture id="ky" lcid="0x0040" language="ky" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="ky-KZ" lcid="0x0440" country="KZ" />
		<lbaCulture id="ky-KG" lcid="0x0440" country="KG" />
	</lbaCulture>

	<!-- Kashmiri -->
	<lbaCulture id="ks" lcid="0x0860" language="ks" country="" ansiCodePage="0" oemCodePage="1" />

	<!-- Latin -->
	<lbaCulture id="la" lcid="0x0476" language="la" country="" ansiCodePage="0" oemCodePage="1" />

	<!-- Luxembourgish -->
	<lbaCulture id="lb" lcid="0x006E" language="lb" ansiCodePage="1252" oemCodePage="850">
		<!-- Luxembourgish (Luxembourg) -->
		<lbaCulture id="lb-LU" lcid="0x046E" language="lb" country="LU" />
	</lbaCulture>

	<!-- Lao -->
	<lbaCulture id="lo" lcid="0x0054" language="lo" ansiCodePage="0" oemCodePage="1">
		<!-- Lao (Lao P.D.R.) -->
		<lbaCulture id="lo-LA" lcid="0x0454" language="lo" country="LA" />
	</lbaCulture>

	<!-- Lithuanian -->
	<lbaCulture id="lt" lcid="0x0027" language="lt" ansiCodePage="1257" oemCodePage="775">
		<!-- Lithuanian (Lithuania) -->
		<lbaCulture id="lt-LT" lcid="0x0427" country="LT" />
		<!-- Lithuanian, Classic (Lithuania) -->
		<lbaCulture id="lt-LT-C" lcid="0x0827" country="LT" />
	</lbaCulture>

	<lbaCulture id="lv" lcid="0x0026" language="lv" ansiCodePage="1257" oemCodePage="775">
		<lbaCulture id="lv-LV" lcid="0x0426" country="LV" />
	</lbaCulture>

	<!-- Maori -->
	<lbaCulture id="mi" lcid="0x0081" language="mi" ansiCodePage="0" oemCodePage="1">
		<!-- Maori (New Zealand) -->
		<lbaCulture id="mi-NZ" lcid="0x0481" language="mi" country="NZ" />
	</lbaCulture>

	<lbaCulture id="mk" lcid="0x002F" language="mk" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="mk-MK" lcid="0x042F" country="MK" />
	</lbaCulture>

	<!-- Malayalam -->
	<lbaCulture id="ml" lcid="0x004C" language="ml" ansiCodePage="0" oemCodePage="1">
		<!-- Malayalam (India) -->
		<lbaCulture id="ml-IN" lcid="0x044C" language="ml" country="IN" />
	</lbaCulture>

	<lbaCulture id="mn" lcid="0x0050" language="mn" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="mn-MN" lcid="0x0450" country="MN" ansiCodePage="1251" oemCodePage="866"/>
		<!-- Mongolian (Mongolian) PRC -->
		<lbaCulture id="mn-Mong-CN" lcid="0x0850" country="CN" ansiCodePage="1251" oemCodePage="1" />
	</lbaCulture>

	<!-- Mohawk -->
	<lbaCulture id="moh" lcid="0x007C" language="moh" ansiCodePage="1252" oemCodePage="850">
		<!-- Mohawk (Mohawk) -->
		<lbaCulture id="moh-CA" lcid="0x047C" language="moh" country="CA" />
	</lbaCulture>

	<!-- Manipuri -->
	<lbaCulture id="mni" lcid="0x0458" language="mni" country="" ansiCodePage="0" oemCodePage="1" />

	<lbaCulture id="mr" lcid="0x004E" language="mr" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="mr-IN" lcid="0x044E" country="IN" />
	</lbaCulture>

	<lbaCulture id="ms" lcid="0x003E" language="ms" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="ms-BN" lcid="0x083E" country="BN" />
		<lbaCulture id="ms-MY" lcid="0x043E" country="MY" />
	</lbaCulture>

	<!-- Maltese -->
	<lbaCulture id="mt" lcid="0x003A" language="mt" ansiCodePage="0" oemCodePage="1">
		<!-- Maltese (Malta) -->
		<lbaCulture id="mt-MT" lcid="0x043A" language="mt" country="MT" />
	</lbaCulture>

	<!-- Myanmar Myanmar -->
	<lbaCulture id="my-MM" lcid="0x0455" language="my" country="MM" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="my" lcid="0x0455" language="my" ansiCodePage="0" oemCodePage="1" />

  <!-- Nepali -->
	<lbaCulture id="ne" lcid="0x0061" language="ne" ansiCodePage="0" oemCodePage="1">
		<!-- Nepali (India) -->
		<lbaCulture id="ne-IN" lcid="0x0861" language="ne" country="IN" />
		<!-- Nepali (Nepal) -->
		<lbaCulture id="ne-NP" lcid="0x0461" language="ne" country="NP" />
	</lbaCulture>

	<!-- Norwegian -->
	<lbaCulture id="no" lcid="0x0014" language="no" ansiCodePage="1252" oemCodePage="850">
		<!-- Legacy Norwegian -->
		<lbaCulture id="nb" lcid="0x0014" language="nb" ansiCodePage="1252" oemCodePage="850">
			<lbaCulture id="nb-NO" lcid="0x0414" country="NO" ansiCodePage="1252" oemCodePage="850" />
		</lbaCulture>

		<!-- Legacy Norwegian -->
		<lbaCulture id="nn" lcid="0x0014" language="nn" ansiCodePage="1252" oemCodePage="850">
			<lbaCulture id="nn-NO" lcid="0x0814" country="NO" ansiCodePage="1252" oemCodePage="850" />
		</lbaCulture>
	</lbaCulture>

	<lbaCulture id="nl" lcid="0x0013" language="nl" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="nl-BE" lcid="0x0813" country="BE" />
		<lbaCulture id="nl-NL" lcid="0x0413" country="NL" />
	</lbaCulture>

	<!-- Sesotho sa Leboa -->
	<lbaCulture id="nso" lcid="0x006C" language="nso" ansiCodePage="1252" oemCodePage="850">
		<!-- Sesotho sa Leboa (South Africa) -->
		<lbaCulture id="nso-ZA" lcid="0x046C" language="nso" country="ZA" />
	</lbaCulture>

	<!-- Occitan -->
	<lbaCulture id="oc" lcid="0x0082" language="oc" ansiCodePage="1252" oemCodePage="850">
		<!-- Occitan (France) -->
		<lbaCulture id="oc-FR" lcid="0x0482" language="oc" country="FR" />
	</lbaCulture>

	<!-- Oriya -->
	<lbaCulture id="or" lcid="0x0048" language="or" ansiCodePage="0" oemCodePage="1">
		<!-- Oriya (India) -->
		<lbaCulture id="or-IN" lcid="0x0448" language="or" country="IN" />
	</lbaCulture>

	<!-- Punjabi -->
	<lbaCulture id="pa" lcid="0x0046" language="pa" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="pa-IN" lcid="0x0446" country="IN" />
		<lbaCulture id="pa-PK" lcid="0x0846" country="PK" />
	</lbaCulture>

	<!-- Malagasy Madagascar -->
	<lbaCulture id="plt-MG" lcid="0x048D" language="plt" country="MG" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="plt" lcid="0x048D" language="plt" ansiCodePage="0" oemCodePage="1" />

  <lbaCulture id="pl" lcid="0x0015" language="pl" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="pl-PL" lcid="0x0415" country="PL" />
	</lbaCulture>

	<!-- Papiamentu Netherlands Antilles -->
	<lbaCulture id="pap-AN" lcid="0x0479" language="pap" country="AN" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="pap" lcid="0x0479" language="pap" ansiCodePage="0" oemCodePage="1" />

  <!-- Dari Afghanistan -->
	<lbaCulture id="prs" lcid="0x008C" language="prs" ansiCodePage="1256" oemCodePage="720">
		<lbaCulture id="prs-AF" lcid="0x048C" country="AF" />
	</lbaCulture>

	<lbaCulture id="pt" lcid="0x0016" language="pt" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="pt-brz" lcid="0x0416" language="pt-brz">
			<lbaCulture id="pt-BR" lcid="0x0416" country="BR" />
		</lbaCulture>
		<lbaCulture id="pt-PT" lcid="0x0816" country="PT" />
	</lbaCulture>

	<!-- Pashto -->
	<lbaCulture id="ps" lcid="0x0063" language="ps" ansiCodePage="1256" oemCodePage="720">
		<!-- Pashto (Afghanistan) -->
		<lbaCulture id="ps-AF" lcid="0x0463" language="ps" country="AF" />
	</lbaCulture>

	<!-- K'iche -->
	<lbaCulture id="qut" lcid="0x0086" language="qut" ansiCodePage="1252" oemCodePage="850">
		<!-- K'iche	(Guatemala) -->
		<lbaCulture id="qut-GT" lcid="0x0486" language="qut" country="GT" />
	</lbaCulture>

	<lbaCulture id="quz" lcid="0x006B" language="quz" ansiCodePage="1252" oemCodePage="850">
		<!-- Quechua Bolivia -->
		<lbaCulture id="quz-BO" lcid="0x046B" country="BO" />
		<!-- Quechua Ecuador -->
		<lbaCulture id="quz-EC" lcid="0x086B" country="EC" />
		<!-- Quechua Ecuador -->
		<lbaCulture id="quz-PE" lcid="0x0C6B" country="PE" />
	</lbaCulture>

	<!-- Romansh -->
	<lbaCulture id="rm" lcid="0x0017" language="rm" ansiCodePage="1252" oemCodePage="850">
		<!-- Romansh Switzerland -->
		<lbaCulture id="rm-CH" lcid="0x0417" language="rm" country="CH" />
	</lbaCulture>

	<lbaCulture id="ro" lcid="0x0018" language="ro" ansiCodePage="1250" oemCodePage="852">
		<!-- Romanian Moldova -->
		<lbaCulture id="ro-MO" lcid="0x0818" country="MO" />
		<lbaCulture id="ro-RO" lcid="0x0418" country="RO" />
	</lbaCulture>

	<lbaCulture id="ru" lcid="0x0019" language="ru" ansiCodePage="1251" oemCodePage="866">
		<!-- Russian Moldova -->
		<lbaCulture id="ru-MO" lcid="0x0819" country="MO" />
		<lbaCulture id="ru-RU" lcid="0x0419" country="RU" />
	</lbaCulture>

	<!-- Kinyarwanda -->
	<lbaCulture id="rw" lcid="0x0087" language="rw" ansiCodePage="1252" oemCodePage="437">
		<!-- Kinyarwanda (Rwanda) -->
		<lbaCulture id="rw-RW" lcid="0x0487" language="rw" country="RW" />
	</lbaCulture>

	<lbaCulture id="sa" lcid="0x004F" language="sa" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="sa-IN" lcid="0x044F" country="IN" />
	</lbaCulture>

	<!-- Yakut -->
	<lbaCulture id="sah" lcid="0x0085" language="sah" ansiCodePage="1251" oemCodePage="866">
		<!-- Yakut (Russia) -->
		<lbaCulture id="sah-RU" lcid="0x0485" language="sah" country="RU" />
	</lbaCulture>

	<lbaCulture id="sd" lcid="0x0059" language="sd" ansiCodePage="1256" oemCodePage="720">
		<!-- Sindhi India -->
		<lbaCulture id="sd-IN" lcid="0x0459" language="sd" country="IN" />
		<!-- Sindhi Pakistan -->
		<lbaCulture id="sd-PK" lcid="0x0859" language="sd" country="PK" />
	</lbaCulture>

	<!-- Sinhala -->
	<lbaCulture id="si" lcid="0x005B" language="si" ansiCodePage="0" oemCodePage="1">
		<!-- Sinhala (Sri Lanka) -->
		<lbaCulture id="si-LK" lcid="0x045B" language="si" country="LK" />
	</lbaCulture>

	<lbaCulture id="sk" lcid="0x001B" language="sk" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="sk-SK" lcid="0x041B" country="SK" />
	</lbaCulture>

	<lbaCulture id="sl" lcid="0x0024" language="sl" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="sl-SI" lcid="0x0424" country="SI" />
	</lbaCulture>

	<lbaCulture id="se" lcid="0x003B" language="se" ansiCodePage="1252" oemCodePage="850">
		<!-- Sami, Inari Finland -->
		<lbaCulture id="smn-FI" lcid="0x243B" language="smn" country="FI" />
    <lbaCulture id="smn" lcid="0x243B" language="smn" />
    <!-- Sami, Lule Norway-->
		<lbaCulture id="smj-NO" lcid="0x103B" language="smj" country="NO" />
    <lbaCulture id="smj" lcid="0x103B" language="smj" />
    <!-- Sami, Lule Sweden -->
		<lbaCulture id="smj-SE" lcid="0x143B" language="smj" country="SE" />
		<!-- Sami, Northern Finland -->
		<lbaCulture id="se-FI" lcid="0x0c3B" language="se" country="FI" />
		<!-- Sami, Northern Norway -->
		<lbaCulture id="se-NO" lcid="0x043B" language="se" country="NO" />
		<!-- Sami, Northern Sweden -->
		<lbaCulture id="se-SE" lcid="0x083B" language="se" country="SE" />
		<!-- Sami, Southern Norway -->
		<lbaCulture id="sma-NO" lcid="0x183B" language="sma" country="NO" />
    <lbaCulture id="sma" lcid="0x183B" language="sma" />
    <!-- Sami, Southern Sweden -->
		<lbaCulture id="sma-SE" lcid="0x1C3B" language="sma" country="SE" />
		<!-- Sami, Skolt Finland -->
		<lbaCulture id="sms-FI" lcid="0x203B" language="sms" country="FI" />
    <lbaCulture id="sms" lcid="0x203B" language="sms" />
  </lbaCulture>

	<lbaCulture id="sq" lcid="0x001C" language="sq" ansiCodePage="1250" oemCodePage="852">
		<lbaCulture id="sq-AL" lcid="0x041C" language="sq-AL" />
	</lbaCulture>

	<!-- Serbian -->
	<lbaCulture id="sr" lcid="0x7C1A" language="sr" ansiCodePage="1250" oemCodePage="855">
		<!-- Serbian (Cyrillic) Bosnia and Herzegovina -->
		<lbaCulture id="sr-Cyrl-BA" lcid="0x1C1A" language="sr-Cyrl" country="BA" ansiCodePage="1251" oemCodePage="855" />
		<!-- Serbian (Cyrillic) Serbia -->
		<lbaCulture id="sr-Cyrl-SP" lcid="0x0C1A" language="sr-Cyrl" country="SP" ansiCodePage="1251" oemCodePage="855" />
		<lbaCulture id="sr-Cyrl-CS" lcid="0x0C1A" language="sr-Cyrl" country="CS" ansiCodePage="1251" oemCodePage="855" />
		<!-- Serbian (Latin) Bosnia and Herzegovina -->
		<lbaCulture id="sr-Latn-BA" lcid="0x181A" language="sr-Latn" country="BA" ansiCodePage="1250" oemCodePage="852" />
		<!-- Serbian (Latin) Serbia -->
		<lbaCulture id="sr-Latn-SP" lcid="0x081A" language="sr-Latn" country="SP" ansiCodePage="1250" oemCodePage="852" />
		<lbaCulture id="sr-Latn-CS" lcid="0x081A" language="sr-Latn" country="CS" ansiCodePage="1250" oemCodePage="852" />
		<lbaCulture id="sr-SP-Cyrl" lcid="0x0C1A" language="sr-Cyrl" country="SP" ansiCodePage="1251" oemCodePage="855" />
		<lbaCulture id="sr-SP-Latn" lcid="0x081A" language="sr-Latn" country="SP" ansiCodePage="1251" oemCodePage="855" />
	</lbaCulture>

	<!-- Sutu -->
	<lbaCulture id="st" lcid="0x0030" language="st" ansiCodePage="1252" oemCodePage="850">
		<!-- Sutu (South Africa) -->
		<lbaCulture id="st-ZA" lcid="0x0430" language="st" country="ZA" />
	</lbaCulture>

	<lbaCulture id="sv" lcid="0x001D" language="sv" ansiCodePage="1252" oemCodePage="850">
		<lbaCulture id="sv-FI" lcid="0x081D" country="FI" />
		<lbaCulture id="sv-SE" lcid="0x041D" country="SE" />
	</lbaCulture>

	<lbaCulture id="sw" lcid="0x0041" language="sw" ansiCodePage="1252" oemCodePage="437">
		<lbaCulture id="sw-KE" lcid="0x0441" country="KE" />
	</lbaCulture>

	<lbaCulture id="syr" lcid="0x005A" language="syr" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="syr-SY" lcid="0x045A" country="SY" />
	</lbaCulture>

	<lbaCulture id="ta" lcid="0x0049" language="ta" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="ta-IN" lcid="0x0449" country="IN" />
	</lbaCulture>

	<lbaCulture id="te" lcid="0x004A" language="te" ansiCodePage="0" oemCodePage="1">
		<lbaCulture id="te-IN" lcid="0x044A" country="IN" />
	</lbaCulture>

	<!-- Tajik -->
	<lbaCulture id="tg" lcid="0x0028" language="tg" ansiCodePage="1251" oemCodePage="866">
		<!-- Tajik (Cyrillic, Tajikistan) -->
		<lbaCulture id="tg-Cyrl-TJ" lcid="0x0428" language="tg-Cyrl" country="TJ" />
	</lbaCulture>

	<lbaCulture id="th" lcid="0x001E" language="th" ansiCodePage="874" oemCodePage="874">
		<lbaCulture id="th-TH" lcid="0x041E" country="TH" />
	</lbaCulture>

	<!-- Tigrigna -->
	<lbaCulture id="ti" lcid="0x0073" language="ti" ansiCodePage="0" oemCodePage="1">
		<!-- Tigrigna (Eritrea) -->
		<lbaCulture id="ti-ER" lcid="0x0473" language="ti" country="ER" />
		<!-- Tigrigna (Ethiopia) -->
		<lbaCulture id="ti-ET" lcid="0x0873" language="ti" country="ET" />
	</lbaCulture>

	<!-- Turkmen -->
	<lbaCulture id="tk" lcid="0x0042" language="tk" ansiCodePage="1250" oemCodePage="852">
		<!-- Turkmen (Turkmenistan) -->
		<lbaCulture id="tk-TM" lcid="0x0442" language="tk" country="TM" />
	</lbaCulture>

	<!-- Setswana -->
	<lbaCulture id="tn" lcid="0x0032" language="tn" ansiCodePage="1252" oemCodePage="850">
		<!-- Setswana (South Africa) -->
		<lbaCulture id="tn-ZA" lcid="0x0432" language="tn" country="ZA" />
	</lbaCulture>

	<lbaCulture id="tr" lcid="0x001F" language="tr" ansiCodePage="1254" oemCodePage="857">
		<lbaCulture id="tr-TR" lcid="0x041F" country="TR" />
	</lbaCulture>

	<!-- Xitsonga South Africa -->
	<lbaCulture id="ts-ZA" lcid="0x0431" language="ts" country="ZA" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="ts" lcid="0x0431" language="ts" ansiCodePage="0" oemCodePage="1" />

  <lbaCulture id="tt" lcid="0x0044" language="tt" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="tt-RU" lcid="0x0444" country="RU" />
	</lbaCulture>

	<!-- Tamazight -->
	<lbaCulture id="tzm" lcid="0x005F" language="tzm" ansiCodePage="1252" oemCodePage="850">
		<!-- Tamazight (Latin, Algeria) -->
		<lbaCulture id="tzm-Latn-DZ" lcid="0x085F" language="tzm-Latn" country="DZ" />
	</lbaCulture>

	<!-- Uighur -->
	<lbaCulture id="ug" lcid="0x0080" language="ug" ansiCodePage="1256" oemCodePage="720">
		<!-- Uighur (PRC) -->
		<lbaCulture id="ug-CN" lcid="0x0480" language="ug" country="CN" />
	</lbaCulture>

	<lbaCulture id="uk" lcid="0x0022" language="uk" ansiCodePage="1251" oemCodePage="866">
		<lbaCulture id="uk-UA" lcid="0x0422" country="UA" />
	</lbaCulture>

	<!-- Urdu -->
	<lbaCulture id="ur" lcid="0x0020" language="ur" ansiCodePage="1256" oemCodePage="720">
		<!-- Urdu India -->
		<lbaCulture id="ur-IN" lcid="0x0820" language="ur" country="IN" />
		<!-- Urdu Pakistan -->
		<lbaCulture id="ur-PK" lcid="0x0420" language="ur" country="PK" />
	</lbaCulture>

	<lbaCulture id="uz" lcid="0x0043" language="uz" ansiCodePage="1254" oemCodePage="857">
		<lbaCulture id="uz-UZ-Cyrl" lcid="0x0843" language="uz-Cyrl" country="UZ" ansiCodePage="1251" oemCodePage="866" />
		<lbaCulture id="uz-Cyrl-UZ" lcid="0x0843" language="uz-Cyrl" country="UZ" ansiCodePage="1251" oemCodePage="866" />
    <lbaCulture id="uz-Cyrl" lcid="0x0843" language="uz-Cyrl" country="UZ" ansiCodePage="1251" oemCodePage="866" />
    <lbaCulture id="uz-UZ-Latn" lcid="0x0443" language="uz-Latn" country="UZ" ansiCodePage="1254" oemCodePage="857" />
		<lbaCulture id="uz-Latn-UZ" lcid="0x0443" language="uz-Latn" country="UZ" ansiCodePage="1254" oemCodePage="857" />
    <lbaCulture id="uz-Latn" lcid="0x0443" language="uz-Latn" country="UZ" ansiCodePage="1254" oemCodePage="857" />
  </lbaCulture>

	<!-- Venda South Africa -->
	<lbaCulture id="ven-ZA" lcid="0x0433" language="ven" country="ZA" ansiCodePage="0" oemCodePage="1" />
  <lbaCulture id="ven" lcid="0x0433" language="ven" ansiCodePage="0" oemCodePage="1" />

  <lbaCulture id="vi" lcid="0x002A" language="vi" ansiCodePage="1258" oemCodePage="1258">
		<lbaCulture id="vi-VN" lcid="0x042A" country="VN" />
	</lbaCulture>

	<!-- Sorbian -->
	<lbaCulture id="wen" lcid="0x002E" language="wen" ansiCodePage="1252" oemCodePage="850">
		<!-- Lower Sorbian (Germany) -->
		<lbaCulture id="dsb-DE" lcid="0x082E" language="dsb" country="DE" />
    <lbaCulture id="dsb" lcid="0x082E" language="dsb" country="DE" />
    <!-- Upper Sorbian (Germany) -->
		<lbaCulture id="wen-DE" lcid="0x042E" language="wen" country="DE" />
    <lbaCulture id="hsb" lcid="0x042E" language="hsb" country="DE" />
  </lbaCulture>

	<!-- Wolof -->
	<lbaCulture id="wo" lcid="0x0088" language="wo" ansiCodePage="1252" oemCodePage="850">
		<!-- Wolof (Senegal) -->
		<lbaCulture id="wo-SN" lcid="0x0488" language="wo" country="SN" />
	</lbaCulture>

	<!-- Yoruba -->
	<lbaCulture id="yo" lcid="0x006A" language="yo" ansiCodePage="1252" oemCodePage="437">
		<!-- Yoruba Nigeria -->
		<lbaCulture id="yo-NG" lcid="0x046A" language="yo" country="NG" />
	</lbaCulture>

	<!-- isiXhosa -->
	<lbaCulture id="xh" lcid="0x0034" language="xh" ansiCodePage="1252" oemCodePage="850">
		<!-- isiXhosa (South Africa) -->
		<lbaCulture id="xh-ZA" lcid="0x0434" language="xh" country="ZA" />
	</lbaCulture>

	<!-- isiZulu -->
	<lbaCulture id="zu" lcid="0x0035" language="zu" ansiCodePage="1252" oemCodePage="850">
		<!-- isiZulu (South Africa) -->
		<lbaCulture id="zu-ZA" lcid="0x0435" language="zu" country="ZA" />
	</lbaCulture>

	<!-- Chinese -->
	<lbaCulture id="zh" lcid="0x0004" language="zh" ansiCodePage="950" oemCodePage="950">
		<!-- Chinese (Traditional) -->
		<lbaCulture id="zh-Hant" lcid="0x7C04" language="zh-Hant" ansiCodePage="950" oemCodePage="950">
			<!-- Chinese (Traditional) -->
			<lbaCulture id="zh-CHT" lcid="0x7C04" language="zh-CHT" ansiCodePage="950" oemCodePage="950">
				<!-- Chinese (Taiwan) -->
				<lbaCulture id="zh-TW" lcid="0x0404" country="TW" />
				<!-- Chinese (Hong Kong S.A.R.) -->
				<lbaCulture id="zh-HK" lcid="0x0C04" country="HK" />
				<!-- Chinese (Macao S.A.R.) -->
				<lbaCulture id="zh-MO" lcid="0x1404" country="MO" />
			</lbaCulture>
		</lbaCulture>
		<!-- Chinese (Simplified) -->
		<lbaCulture id="zh-Hans" lcid="0x0004" language="zh-Hans" ansiCodePage="936" oemCodePage="936">
			<!-- Chinese (Simplified) -->
			<lbaCulture id="zh-CHS" lcid="0x0004" language="zh-CHS" ansiCodePage="936" oemCodePage="936">
				<!-- Chinese (PRC) -->
				<lbaCulture id="zh-CN" lcid="0x0804" country="CN" />
				<!-- Chinese (Singapore) -->
				<lbaCulture id="zh-SG" lcid="0x1004" country="SG" />
			</lbaCulture>
		</lbaCulture>
	</lbaCulture>

	<!-- Neutral -->
	<lbaCulture id="neu" lcid="0x0000" language="neu" ansiCodePage="1252" oemCodePage="437" />

	<!-- Neutral (Default) -->
	<lbaCulture id="ned" lcid="0x0400" language="ned" ansiCodePage="1252" oemCodePage="437" />

	<!-- Neutral (Sys. Default) -->
	<lbaCulture id="nes" lcid="0x0800" language="nes" ansiCodePage="1252" oemCodePage="437" />

</lbaCultureList>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\lbajobtypetemplates.xml ===
<?xml version="1.0" encoding="utf-8" ?>
<jobTypeTemplates xmlns="http://msn.com/mlp" version="2.0">

  <!-- EDB JOB TEMPLATES (w/ Environment Variables) -->

  <jobType id="DailyBuildLocalizationCustomEdbEnv">
    <commandList>
      <command id="Edb2Bin" 
               plugin="Edb2Bin" 
               position="10" 
               executionLevel="Project" 
               parameterListId="Edb2BinParameterList"
               timeout="60"
               />
      <command id="PostEdb2BinAction" 
               plugin="CustomScript" 
               position="20"
               executionLevel="Project" 
               parameterListId="PostEdb2BinActionParameterList"
               timeout="120"
               />
    </commandList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="FailSafe"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="PseudoLocMode" value="Mixed"/>
      <parameter name="SuppressWarnings" value="true"/>
      <parameter name="UseExistingLclForGeneration" value="true"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="PostEdb2BinActionParameterList">
      <parameter name="path" value="%LBA_DAILYBUILDPOSTEDB2BIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackEdbEnv">
    <commandList>
      <command id="UpdateMlpForStart" 
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Bin" 
               plugin="Edb2Bin"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2BinParameterList"
               timeout="60"
               />
      <command id="PostEdb2BinAction" 
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="PostEdb2BinActionParameterList"
               timeout="120"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba" 
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30"               
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish" 
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30"       
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="PostEdb2BinActionParameterList">
      <parameter name="path" value="%LBA_HANDBACKPOSTEDB2BIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="true"/>
      <parameter name="FailOnEdbValidationErrors" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="Normal"/>
      <parameter name="PerformEdbLanguageCheck" value="true"/>
      <parameter name="PseudoLocMode" value="None"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="UseExistingLclForGeneration" value="false"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="SubFoldersToInclude" value="buildfiles | locstudio.target"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackRemoteEdb1Env">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Bin" 
               plugin="Edb2Bin"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2BinParameterList" 
               timeout="60"
               />
      <command id="PostEdb2BinAction" 
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="PostEdb2BinActionParameterList" 
               timeout="120"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba"
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%" 
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false" 
               alwaysExecute="true"
               />
    </commandList>
    <errorCommandList>
      <command id="UpdateMlpForError"
                 plugin="MlpWebService"
                 position="10"
                 executionLevel="Root"
                 parameterListId="UpdateMlpForErrorParameterList" 
                 timeout="30" 
                 runInLocalMode="false"
                 />
    </errorCommandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="true"/>
      <parameter name="FailOnEdbValidationErrors" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="Normal"/>
      <parameter name="PerformEdbLanguageCheck" value="true"/>
      <parameter name="PseudoLocMode" value="None"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="UseExistingLclForGeneration" value="false"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="PostEdb2BinActionParameterList">
      <parameter name="path" value="%LBA_HANDBACKPOSTEDB2BIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="buildfiles | locstudio.target | buildtools | miscfiles"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
    <parameterList id="UpdateMlpForErrorParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinCustomEdbEnv">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Lcl"
               plugin="Edb2Lcl"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2LclParameterList" 
               timeout="30" 
               />
      <command id="CustomCheckinScript" 
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="CustomCheckinScriptParameterList"
               timeout="120"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root" 
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="CustomCheckinScriptParameterList">
      <parameter name="path" value="%LBA_CUSTOMCHECKIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>


  <!-- EDB JOB TEMPLATES (with full paths) -->

  <jobType id="DailyBuildLocalizationEdb">
    <commandList>
      <command id="Edb2Bin" 
               plugin="Edb2Bin"
               position="10"
               executionLevel="Project" 
               parameterListId="Edb2BinParameterList"
               timeout="60"                
               />
    </commandList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="FailSafe"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="PseudoLocMode" value="Mixed"/>
      <parameter name="SuppressWarnings" value="true"/>
      <parameter name="UseExistingLclForGeneration" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
  </jobType>

  <jobType id="DailyBuildLocalizationCustomEdb">
    <commandList>
      <command id="Edb2Bin" 
               plugin="Edb2Bin" 
               position="10" 
               executionLevel="Project" 
               parameterListId="Edb2BinParameterList"
               timeout="60"
               />
      <command id="PostEdb2BinAction" 
               plugin="CustomScript" 
               position="20"
               executionLevel="Project" 
               parameterListId="PostEdb2BinActionParameterList"
               timeout="120"
               />
    </commandList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="FailSafe"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="PseudoLocMode" value="Mixed"/>
      <parameter name="SuppressWarnings" value="true"/>
      <parameter name="UseExistingLclForGeneration" value="true"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="PostEdb2BinActionParameterList">
      <parameter name="path" value="%INETROOT%\tools\loctools\lba\scripts\DailyBuildPostEdb2Bin.cmd"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
  </jobType>

  <jobType id="MlpRegisterBuildEdb">
    <commandList>
      <command id="Bin2Lcx" 
               plugin="Bin2Lcx" 
               position="5"
               executionLevel="Project"
               parameterListId="Bin2LcxParameterList"
               timeout="30"
               />
      <command id="CreateMlpBuild" 
               plugin="MlpWebService"
               position="10" 
               executionLevel="Root"
               parameterListId="CreateMlpBuildParameterList"
               timeout="30" 
               runInLocalMode="false"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba" 
               position="20"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               />
    </commandList>
    <parameterList id="Bin2LcxParameterList">
      <parameter name="HandleResxConversion" value="true" />
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="CreateMlpBuildParameterList">
      <parameter name="service" value="CreateBuild"/>
      <parameter name="AllowMultipleBuildHandoffs" value="false" />
      <parameter name="BuildType" value="Software" />
      <parameter name="BuildContainsHandoff" value="false"/>
      <parameter name="BuildHandoffType" value="Normal" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\build\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="locstudio.source | miscfiles | handoff.extra | lce | lci | resx.comments | locstudio.reference"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
  </jobType>
  
  <jobType id="MlpRegisterBuildEdbMultipleHandoff">
    <commandList>
      <command id="Bin2Lcx" 
               plugin="Bin2Lcx" 
               position="5"
               executionLevel="Project"
               parameterListId="Bin2LcxParameterList"
               timeout="30"
               />
      <command id="CreateMlpBuild" 
               plugin="MlpWebService"
               position="10" 
               executionLevel="Root"
               parameterListId="CreateMlpBuildParameterList"
               timeout="30" 
               runInLocalMode="false"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba" 
               position="20"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               />
    </commandList>
    <parameterList id="Bin2LcxParameterList">
      <parameter name="HandleResxConversion" value="true" />
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="CreateMlpBuildParameterList">
      <parameter name="service" value="CreateBuild"/>
      <parameter name="AllowMultipleBuildHandoffs" value="true" />
      <parameter name="BuildType" value="Software" />
      <parameter name="BuildHandoffType" value="Normal"/>
      <parameter name="BuildContainsHandoff" value="false"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\build\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="locstudio.source | miscfiles | handoff.extra | lce | lci | resx.comments | locstudio.reference"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
  </jobType>

  <jobType id="MlpPrepHandoffEdb">
    <commandList>
      <command id="UpdateMlpForStart" 
               plugin="MlpWebService"
               position="10" 
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="BuildEdb" 
               plugin="BuildEdb"
               position="20" 
               executionLevel="Project"
               parameterListId="BuildEdbParameterList"
               timeout="60"
               />
      <command id="Edb2Lcl"
               plugin="Edb2Lcl"
               position="30" 
               executionLevel="Project" 
               parameterListId="Edb2LclParameterList" 
               timeout="30" 
               ignoreError="true"
               runInLocalMode="true"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba"
               position="40" 
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish" 
               plugin="MlpWebService"
               position="70" 
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="BuildEdbParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="GlossaryFolderUsage" value="First"/>
      <parameter name="PerformEdbAutotranslation" value="true" />
      <parameter name="FailOnEdbAutoTranslationErrors" value="true"/>
      <parameter name="PerformEdbAnalysis" value="true"/>
      <parameter name="FailOnEdbAnalysisErrors" value="true"/>
      <parameter name="PerformEdbValidation" value="true"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="ImportSourceLocks" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\handoffbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="Mirror" value="true" />
      <parameter name="SubFoldersToInclude" value=""/>
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackEdb">
    <commandList>
      <command id="UpdateMlpForStart" 
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
                alwaysExecute="true"
               />
      <command id="Edb2Bin" 
               plugin="Edb2Bin"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2BinParameterList"
               timeout="60"
               />
      <command id="PostEdb2BinAction" 
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="PostEdb2BinActionParameterList"
               timeout="120"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba" 
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish" 
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="PostEdb2BinActionParameterList">
      <parameter name="path" value="%INETROOT%\tools\loctools\lba\scripts\HandbackPostEdb2Bin.cmd"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="true"/>
      <parameter name="FailOnEdbValidationErrors" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="Normal"/>
      <parameter name="PerformEdbLanguageCheck" value="true"/>
      <parameter name="PseudoLocMode" value="None"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="UseExistingLclForGeneration" value="false"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="SubFoldersToInclude" value="buildfiles | locstudio.target"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackRemoteEdb1">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Bin" 
               plugin="Edb2Bin"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2BinParameterList" 
               timeout="60"
               />
      <command id="PostEdb2BinAction" 
              plugin="CustomScript"
              position="30"
              executionLevel="Project"
              parameterListId="PostEdb2BinActionParameterList" 
              timeout="120"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba"
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%" 
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false" 
               alwaysExecute="true"
               />
    </commandList>
    <errorCommandList>
      <command id="UpdateMlpForError"
                 plugin="MlpWebService"
                 position="10"
                 executionLevel="Root"
                 parameterListId="UpdateMlpForErrorParameterList" 
                 timeout="30" 
                 runInLocalMode="false"
                 />
    </errorCommandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Edb2BinParameterList">
      <parameter name="HandleResxConversion" value="true"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformEdbValidation" value="true"/>
      <parameter name="FailOnEdbValidationErrors" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="Normal"/>
      <parameter name="PerformEdbLanguageCheck" value="true"/>
      <parameter name="PseudoLocMode" value="None"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="UseExistingLclForGeneration" value="false"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="PostEdb2BinActionParameterList">
      <parameter name="path" value="%INETROOT%\tools\loctools\lba\scripts\HandbackPostEdb2Bin.cmd"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="buildfiles | locstudio.target | buildtools | miscfiles"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForErrorParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackRemoteEdb2">
    <commandList>
      <command id="CustomCopyScript"
               plugin="CustomScript"
               position="10"
               executionLevel="Culture"
               parameterListId="CustomCopyScriptParameterList"
               timeout="120"
               ignoreError="true"
               />
       <command id="UpdateMlpForFinish"
                plugin="MlpWebService"
                position="20"
                executionLevel="Root"
                parameterListId="UpdateMlpForFinishParameterList" 
                timeout="30" 
                runInLocalMode="false"
                alwaysExecute="true"
                />
    </commandList>
    <parameterList id="CustomCopyScriptParameterList">
      <parameter name="path" value="$LbaConfigInfo.WorkspaceLbaRoot$\default\buildtools\CustomRemoteCopy.cmd"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinEdb">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="SDCreateChangeList"
               plugin="SourceDepot"
               position="11"
               executionLevel="Root"
               parameterListId="SDCreateChangelistParameterList"
               timeout="30"
               />
      <command id="Edb2Lcl"
               plugin="Edb2Lcl"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2LclParameterList" 
               timeout="30"
               />
      <command id="SDCheckin" 
               plugin="SourceDepot"
               position="30"
               executionLevel="Culture"
               parameterListId="SDCheckinParameterList"
               timeout="60"
               />
      <command id="SDSubmitChangelist"
               plugin="SourceDepot"
               position="49"
               executionLevel="Root"
               parameterListId="SDSubmitChangelistParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root" 
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="SDCreateChangelistParameterList">
      <parameter name="Operation" value="CreateChangelist" />
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="SDCheckinParameterList">
      <parameter name="operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="SubFoldersToInclude" value="handback.extra | lcl" />
    </parameterList>
    <parameterList id="SDSubmitChangelistParameterList">
      <parameter name="Operation" value="SubmitChangelist" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinEdbTfs">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Lcl"
               plugin="Edb2Lcl"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2LclParameterList"
               timeout="30"
               />
      <command id="TfsCheckin"
               plugin="Tfs"
               position="40"
               executionLevel="Culture"
               parameterListId="TfsCheckinParameterList"
               timeout="60"
               />
      <command id="TfsSubmitFiles"
               plugin="Tfs"
               position="50"
               executionLevel="Root"
               parameterListId="TfsSubmitFilesParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="60"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="TfsCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="SubFoldersToInclude" value="handback.extra | lcl" />
    </parameterList>
    <parameterList id="TfsSubmitFilesParameterList">
      <parameter name="Operation" value="SubmitFiles" />
      <parameter name="OverridePolicyFailure" value="true" />
      <parameter name="OverrideReasonText" value="Automatically checked in by LBA." />
      <parameter name="CheckinNotesText" value="Code reviewer=N/A;Security reviewer=N/A;Performance reviewer=N/A" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>
  
  <jobType id="MlpCheckinCustomEdb">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Lcl"
               plugin="Edb2Lcl"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2LclParameterList" 
               timeout="30"
               />
      <command id="CustomCheckinScript" 
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="CustomCheckinScriptParameterList"
               timeout="120"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root" 
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="CustomCheckinScriptParameterList">
      <parameter name="path" value="%INETROOT%\tools\loctools\lba\scripts\CustomCheckin.cmd"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="ValidateEdb">
    <commandList>
      <command id="ValidateLanguage"
               plugin="LSTask"
               position="10"
               executionLevel="Project"
               parameterListId="ValidateLanguageParameterList"
               timeout="30"
               />
      <command id="ValidateEdb"
               plugin="LSTask"
               position="20"
               executionLevel="Project"
               parameterListId="ValidateEdbParameterList"
               timeout="30"
               />
    </commandList>
    <parameterList id="ValidateLanguageParameterList">
      <parameter name="Task" value="CheckEdb"/>
      <parameter name="PerformEdbLanguageCheck" value="true"/>
    </parameterList>
    <parameterList id="ValidateEdbParameterList">
      <parameter name="Task" value="ValidateEdb"/>
      <parameter name="PerformEdbValidation" value="true"/>
      <parameter name="FailOnEdbValidationErrors" value="true"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
  </jobType>

  <jobType id="PolicheckEdb">
    <commandList>
      <command id="PolicheckScan" 
               plugin="Policheck"
               position="10"
               executionLevel="Project"
               parameterListId="PolicheckScanParameterList"
               timeout="60"
               />
    </commandList>
    <parameterList id="PolicheckScanParameterList">
      <parameter name="ScanMode" value="Edb | Source"/>
      <parameter name="ResultFileType" value="Xls"/>
    </parameterList>
  </jobType>

  <jobType id="CheckinLcl">
    <commandList>
      <command id="SDCreateChangeList"
               plugin="SourceDepot"
               position="1"
               executionLevel="Root"
               parameterListId="SDCreateChangelistParameterList"
               timeout="30"
               />
      <command id="Edb2Lcl"
              plugin="Edb2Lcl"
              position="10"
              executionLevel="Project"
              parameterListId="Edb2LclParameterList"
              timeout="30"
               />
      <command id="SDCheckin"
               plugin="SourceDepot"
               position="20"
               executionLevel="Project"
               parameterListId="SDCheckinParameterList"
               timeout="60"
               />
      <command id="SDSubmitChangelist"
               plugin="SourceDepot"
               position="30"
               executionLevel="Root"
               parameterListId="SDSubmitChangelistParameterList"
               timeout="30"
               />
    </commandList>
    <parameterList id="SDCreateChangelistParameterList">
      <parameter name="Operation" value="CreateChangelist" />
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="SDCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="SubFoldersToInclude" value="lcl" />
    </parameterList>
    <parameterList id="SDSubmitChangelistParameterList">
      <parameter name="Operation" value="SubmitChangelist" />
    </parameterList>
  </jobType>

  <jobType id="MlpRegisterBranchContent">
    <commandList>
      <command id="RegisterBranch" 
               plugin="MlpWebService" 
               position="10"
               executionLevel="Root"
               parameterListId="RegisterBranchParameterList"
               timeout="30" 
               />
    </commandList>
    <parameterList id="RegisterBranchParameterList">
      <parameter name="service" value="CreateBranch"/>
      <parameter name="BuildType" value="Content" />
      <parameter name="AllowMultipleBuildHandoffs" value="false"/>
    </parameterList>
  </jobType>


  <!-- HELIUM JOB TEMPLATES -->

  <jobType id="MlpRegisterBuildHelium">
    <commandList>
      <command id="CreateMlpBuild" 
               plugin="MlpWebService"
               position="10" 
               executionLevel="Root"
               parameterListId="CreateMlpHeliumBuildParameterList"
               timeout="30" 
               runInLocalMode="false"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba" 
               position="20"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               />
    </commandList>
    <parameterList id="CreateMlpHeliumBuildParameterList">
      <parameter name="service" value="CreateBuild"/>
      <parameter name="AllowMultipleBuildHandoffs" value="true" />
      <parameter name="BuildType" value="Software" />
      <parameter name="BuildContainsHandoff" value="false"/>
      <parameter name="BuildHandoffType" value="Normal" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\build\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="helium.newsource | handoff.extra "/>
      <parameter name="Mirror" value="true" />
    </parameterList>
  </jobType>
  
  <jobType id="MlpPrepHandoffHelium">
    <commandList>
      <command id="UpdateMlpForStart" 
               plugin="MlpWebService"
               position="10" 
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="PrepHE" 
               plugin="Helium"
               position="20" 
               executionLevel="Project"
               parameterListId="PrepHEParameterList"
               ignoreError="false"
               timeout="60"
               />
      <command id="RebuildGlossaryHE" 
               plugin="Helium"
               position="30" 
               executionLevel="Project"
               parameterListId="RebuildGlossaryHEParameterList"
               ignoreError="false"
               enabled="true"
               timeout="5"
               />
      <command id="SetTermHE"
               plugin="Helium"
               position="40" 
               executionLevel="Project" 
               parameterListId="SetTermHEParameterList" 
               timeout="60" 
               ignoreError="false"
               />
      <command id="ArchiveHE" 
               plugin="Helium"
               position="50" 
               executionLevel="Project"
               parameterListId="ArchiveHEParameterList"
               ignoreError="false"
               timeout="60" 
               />
      <command id="UpdateHE" 
               plugin="Helium"
               position="60" 
               executionLevel="Project" 
               parameterListId="UpdateHEParameterList" 
               timeout="60" 
               ignoreError="false"
               />
      <command id="CreateTransRpt" 
               plugin="Helium"
               position="70" 
               executionLevel="Project" 
               parameterListId="CreateTransRptParameterList"
               timeout="60" 
               ignoreError="false"
               />
      <command id="CreateStatsRpt" 
               plugin="Helium"
               position="80" 
               executionLevel="Project" 
               parameterListId="CreateStatsRptParameterList"
               timeout="60" 
               ignoreError="false"
               />
      <command id="AutoTransHE" 
               plugin="Helium"
               position="90" 
               executionLevel="Project" 
               parameterListId="AutoTransHEParameterList"
               timeout="60" 
               enabled="true"
               ignoreError="false"
               />
      <command id="CreateTermRpt" 
               plugin="Helium"
               position="100" 
               executionLevel="Project" 
               parameterListId="CreateTermRptParameterList"
               timeout="60" 
               ignoreError="false"
               enabled="false"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba"
               position="110" 
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish" 
               plugin="MlpWebService"
               position="120" 
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="PrepHEParameterList">
      <parameter name="heliumTask" value="PrepHE"/>
    </parameterList>
    <parameterList id="RebuildGlossaryHEParameterList">
      <parameter name="heliumTask" value="RebuildGlossaryHE"/>
    </parameterList>
    <parameterList id="SetTermHEParameterList">
      <parameter name="heliumTask" value="SetTermHE"/>
      <parameter name="NewTermState" value="Reviewed"/>
      <parameter name="TermStateFilter" value="Review|Edited|NonEdited"/>
    </parameterList>
    <parameterList id="ArchiveHEParameterList">
      <parameter name="heliumTask" value="ArchiveHE"/>
    </parameterList>
    <parameterList id="UpdateHEParameterList">
      <parameter name="heliumTask" value="UpdateHE"/>
    </parameterList>
    <parameterList id="CreateTransRptParameterList">
      <parameter name="heliumTask" value="TransRptHE"/>
      <parameter name="MatchThreshold" value="100"/>
    </parameterList>
    <parameterList id="CreateStatsRptParameterList">
      <parameter name="heliumTask" value="StatsRptHE"/>
    </parameterList>
    <parameterList id="AutoTransHEParameterList">
      <parameter name="heliumTask" value="AutoTransHE"/>
      <parameter name="MatchThreshold" value="100"/>
    </parameterList>
    <parameterList id="CreateTermRptParameterList">
      <parameter name="heliumTask" value="TermRptHE"/>
      <parameter name="PriorityLevel" value="5"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\handoffbuild\lba"/>
      <parameter name="RemoveReadOnly" value="true"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="Mirror" value="true" />
      <parameter name="SubFoldersToInclude" value="handoff.extra | helium.source | helium.working | helium.target | helium.support | reports | lsg"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackHelium">
    <commandList>
      <command id="UpdateMlpForStart" 
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="RebuildGlossaryHE" 
               plugin="Helium"
               position="20" 
               executionLevel="Project"
               parameterListId="RebuildGlossaryHEParameterList"
               ignoreError="false"
               timeout="60"
               />
      <command id="ValidationReport" 
               plugin="Helium"
               position="30" 
               executionLevel="Project" 
               parameterListId="ValidationRptParameterList"
               timeout="60" 
               ignoreError="false"
               />
      <command id="CopyResultsToMlpFileServer" 
               plugin="CopyLba" 
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="CustomCopyAction" 
               plugin="CustomScript" 
               position="45" 
               executionLevel="Project" 
               parameterListId="CustomCopyActionParameterList" 
               timeout="120" 
               enabled="false"
               /> 
      <command id="UpdateMlpForFinish" 
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="RebuildGlossaryHEParameterList">
      <parameter name="heliumTask" value="RebuildGlossaryHE"/>
    </parameterList>
    <parameterList id="ValidationRptParameterList">
      <parameter name="heliumTask" value="ValidationRptHE"/>
      <parameter name="IncRepeatsFile" value="false"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="SubFoldersToInclude" value="reports"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="CustomCopyActionParameterList">
      <parameter name="path" value="%LBA_HELIUMCUSTOMCOPY%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinHelium">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root" 
               parameterListId="UpdateMlpForStartParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="SDCreateChangeList"
               plugin="SourceDepot"
               position="20"
               executionLevel="Root"
               parameterListId="SDCreateChangelistParameterList"
               timeout="30"
               />
      <command id="ExportGlossary" 
               plugin="Helium"
               position="30" 
               executionLevel="Project" 
               parameterListId="ExportGlossaryParameterList"
               timeout="60" 
               ignoreError="true"
               />
      <command id="SDCheckin" 
               plugin="SourceDepot"
               position="40"
               executionLevel="Culture"
               parameterListId="SDCheckinParameterList"
               timeout="60"
               />
      <command id="SDSubmitChangelist"
               plugin="SourceDepot"
               position="50"
               executionLevel="Root"
               parameterListId="SDSubmitChangelistParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="60"
               executionLevel="Root" 
               parameterListId="UpdateMlpForFinishParameterList" 
               timeout="30" 
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="SDCreateChangelistParameterList">
      <parameter name="Operation" value="CreateChangelist" />
    </parameterList>
    <parameterList id="ExportGlossaryParameterList">
      <parameter name="heliumTask" value="ExportGlossaryHE"/>
      <parameter name="NewLsgFolder" value="false" />
    </parameterList>
    <parameterList id="SDCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="SubFoldersToInclude" value="helium.source | helium.working | helium.target | lsg | lsg.target | handback.extra" />
      <parameter name="Mirror" value="true"/>
    </parameterList>
    <parameterList id="SDSubmitChangelistParameterList">
      <parameter name="Operation" value="SubmitChangelist" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinHeliumTfs">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="ExportGlossary"
               plugin="Helium"
               position="30"
               executionLevel="Project"
               parameterListId="ExportGlossaryParameterList"
               timeout="60"
               ignoreError="true"
               />
      <command id="TfsCheckin"
               plugin="Tfs"
               position="40"
               executionLevel="Culture"
               parameterListId="TfsCheckinParameterList"
               timeout="60"
               />
      <command id="TfsSubmitFiles"
               plugin="Tfs"
               position="50"
               executionLevel="Root"
               parameterListId="TfsSubmitFilesParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="60"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="ExportGlossaryParameterList">
      <parameter name="heliumTask" value="ExportGlossaryHE"/>
      <parameter name="NewLsgFolder" value="false" />
    </parameterList>
    <parameterList id="TfsCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="SubFoldersToInclude" value="helium.source | helium.working | helium.target | lsg | lsg.target | handback.extra" />
      <parameter name="Mirror" value="true"/>
    </parameterList>
    <parameterList id="TfsSubmitFilesParameterList">
      <parameter name="Operation" value="SubmitFiles" />
      <parameter name="OverridePolicyFailure" value="true" />
      <parameter name="OverrideReasonText" value="Automatically checked in by LBA." />
      <parameter name="CheckinNotesText" value="Code reviewer=N/A;Security reviewer=N/A;Performance reviewer=N/A" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>
  
  <!--LSPKG JOB TEMPLATES (w/ Environment Variables) -->

  <jobType id="DailyBuildLocalizationCustomLspkgEnv">
    <commandList>
      <command id="Lspkg2Bin"
               plugin="Lspkg"
               position="10"
               executionLevel="Project"
               parameterListId="Lspkg2BinParameterList"
               timeout="60"
               />
      <command id="PostBinAction"
               plugin="CustomScript"
               position="20"
               executionLevel="Project"
               parameterListId="PostBinActionParameterList"
               timeout="120"
               />
    </commandList>
    <parameterList id="Lspkg2BinParameterList">
      <parameter name="Action" value="Lspkg2Bin" />
      <parameter name="HandleResxConversion" value="false"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="FailSafe"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="PseudoLocMode" value="Mixed"/>
      <parameter name="SuppressWarnings" value="true"/>
      <parameter name="UseExistingLclForGeneration" value="true"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="PostBinActionParameterList">
      <parameter name="path" value="%LBA_DAILYBUILDPOSTBIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackLspkgEnv">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Lspkg2Bin"
               plugin="Lspkg"
               position="20"
               executionLevel="Project"
               parameterListId="Lspkg2BinParameterList"
               timeout="60"
               />
      <command id="PostBinAction"
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="PostBinActionParameterList"
               timeout="120"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="PostBinActionParameterList">
      <parameter name="path" value="%LBA_HANDBACKPOSTBIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="Lspkg2BinParameterList">
      <parameter name="Action" value="Lspkg2Bin" />
      <parameter name="HandleResxConversion" value="false"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformValidation" value="true"/>
      <parameter name="FailOnValidationErrors" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="Normal"/>
      <parameter name="PerformLanguageCheck" value="true"/>
      <parameter name="PseudoLocMode" value="None"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="UseExistingLclForGeneration" value="false"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="SubFoldersToInclude" value="buildfiles | locstudio.target"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackRemoteLspkg1Env">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Lspkg2Bin"
               plugin="Lspkg"
               position="20"
               executionLevel="Project"
               parameterListId="Lspkg2BinParameterList"
               timeout="60"
               />
      <command id="PostBinAction"
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="PostBinActionParameterList"
               timeout="120"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <errorCommandList>
      <command id="UpdateMlpForError"
                 plugin="MlpWebService"
                 position="10"
                 executionLevel="Root"
                 parameterListId="UpdateMlpForErrorParameterList"
                 timeout="30"
                 runInLocalMode="false"
                 />
    </errorCommandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Lspkg2BinParameterList">
      <parameter name="Action" value="Lspkg2Bin" />
      <parameter name="HandleResxConversion" value="false"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="PerformValidation" value="true"/>
      <parameter name="FailOnValidationErrors" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="GenerationMode" value="Normal"/>
      <parameter name="PerformLanguageCheck" value="true"/>
      <parameter name="PseudoLocMode" value="None"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="UseExistingLclForGeneration" value="false"/>
      <parameter name="IgnoreUpdatedStringsForLoc" value="false"/>
      <parameter name="IgnoreUpdatedStringsForPseudoLoc" value="true"/>
      <parameter name="GenerateTranslationFiles" value="false" />
    </parameterList>
    <parameterList id="PostBinActionParameterList">
      <parameter name="path" value="%LBA_HANDBACKPOSTBIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="buildfiles | locstudio.target | buildtools | miscfiles"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
    <parameterList id="UpdateMlpForErrorParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinCustomLspkgEnv">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Lspkg2Lcl"
               plugin="Lspkg"
               position="20"
               executionLevel="Project"
               parameterListId="Lspkg2LclParameterList"
               timeout="30"
               />
      <command id="CustomCheckinScript"
               plugin="CustomScript"
               position="30"
               executionLevel="Project"
               parameterListId="CustomCheckinScriptParameterList"
               timeout="120"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Lspkg2LclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="CustomCheckinScriptParameterList">
      <parameter name="path" value="%LBA_CUSTOMCHECKIN%"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>


  <!-- LSPKG JOB TEMPLATES (with full paths) -->

  <jobType id="MlpRegisterBuildLspkg">
    <commandList>
      <command id="Bin2Lcx"
               plugin="Lspkg"
               position="5"
               executionLevel="Project"
               parameterListId="Bin2LcxParameterList"
               timeout="30"
               />
      <command id="CreateMlpBuild"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="CreateMlpBuildParameterList"
               timeout="30"
               runInLocalMode="false"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="20"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               />
    </commandList>
    <parameterList id="Bin2LcxParameterList">
      <parameter name="Action" value="Bin2Lcx" />
      <parameter name="HandleResxConversion" value="false" />
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="UseValidationForGeneration" value="true"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="CreateMlpBuildParameterList">
      <parameter name="service" value="CreateBuild"/>
      <parameter name="AllowMultipleBuildHandoffs" value="false" />
      <parameter name="BuildType" value="Software" />
      <parameter name="BuildContainsHandoff" value="false"/>
      <parameter name="BuildHandoffType" value="Normal" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\build\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="locstudio.source | miscfiles | handoff.extra | lce | lci | resx.comments | locstudio.reference"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
  </jobType>

  <jobType id="MlpPrepHandoffLspkg">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="CreateLspkg"
               plugin="Lspkg"
               position="20"
               executionLevel="Project"
               parameterListId="CreateLspkgParameterList"
               timeout="60"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="40"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="70"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="CreateLspkgParameterList">
      <parameter name="Action" value="CreateLspkg" />
      <parameter name="HandleResxConversion" value="false"/>
      <parameter name="IncludeResxInFilename" value="true"/>
      <parameter name="GlossaryFolderUsage" value="First"/>
      <parameter name="PerformAutotranslation" value="true" />
      <parameter name="FailOnAutoTranslationErrors" value="true"/>
      <parameter name="GlossaryGenerationThreadTimeout" value="5"/>
      <parameter name="PerformLanguageCheck" value="true"/>
      <parameter name="ResolveValidationErrors" value="true"/>
      <parameter name="ResolveMode" value="Ignore"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\handoffbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="Mirror" value="true" />
      <parameter name="SubFoldersToInclude" value=""/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpHandbackRemoteLspkg2">
    <commandList>
      <command id="CustomCopyScript"
               plugin="CustomScript"
               position="10"
               executionLevel="Culture"
               parameterListId="CustomCopyScriptParameterList"
               timeout="120"
               ignoreError="true"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="20"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
                />
    </commandList>
    <parameterList id="CustomCopyScriptParameterList">
      <parameter name="path" value="$LbaConfigInfo.WorkspaceLbaRoot$\default\buildtools\CustomRemoteCopy.cmd"/>
      <parameter name="AllowMultithread" value="false"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinLspkg">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="SDCreateChangeList"
               plugin="SourceDepot"
               position="11"
               executionLevel="Root"
               parameterListId="SDCreateChangelistParameterList"
               timeout="30"
               />
      <command id="Lspkg2Lcl"
               plugin="Lspkg"
               position="20"
               executionLevel="Project"
               parameterListId="Lspkg2LclParameterList"
               timeout="30"
               />
      <command id="SDCheckin"
               plugin="SourceDepot"
               position="30"
               executionLevel="Culture"
               parameterListId="SDCheckinParameterList"
               timeout="60"
               />
      <command id="SDSubmitChangelist"
               plugin="SourceDepot"
               position="49"
               executionLevel="Root"
               parameterListId="SDSubmitChangelistParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="SDCreateChangelistParameterList">
      <parameter name="Operation" value="CreateChangelist" />
    </parameterList>
    <parameterList id="Lspkg2LclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="SDCheckinParameterList">
      <parameter name="operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="SubFoldersToInclude" value="handback.extra | lcl" />
    </parameterList>
    <parameterList id="SDSubmitChangelistParameterList">
      <parameter name="Operation" value="SubmitChangelist" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinLspkgTfs">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Lspkg2Lcl"
               plugin="Lspkg"
               position="30"
               executionLevel="Project"
               parameterListId="Lspkg2LclParameterList"
               timeout="30"
               />
      <command id="TfsCheckin"
               plugin="Tfs"
               position="40"
               executionLevel="Culture"
               parameterListId="TfsCheckinParameterList"
               timeout="60"
               />
      <command id="TfsSubmitFiles"
               plugin="Tfs"
               position="50"
               executionLevel="Root"
               parameterListId="TfsSubmitFilesParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="60"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Lspkg2LclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>    
    <parameterList id="TfsCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="SubFoldersToInclude" value="handback.extra | lcl" />
    </parameterList>
    <parameterList id="TfsSubmitFilesParameterList">
      <parameter name="Operation" value="SubmitFiles" />
      <parameter name="OverridePolicyFailure" value="true" />
      <parameter name="OverrideReasonText" value="Automatically checked in by LBA." />
      <parameter name="CheckinNotesText" value="Code reviewer=N/A;Security reviewer=N/A;Performance reviewer=N/A" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>
  
  <jobType id="ValidateLspkg">
    <commandList>
      <command id="ValidateLcl"
               plugin="Lspkg"
               position="10"
               executionLevel="Project"
               parameterListId="ValidateLclParameterList"
               timeout="30"
               />
    </commandList>
    <parameterList id="ValidateLclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="true"/>
      <parameter name="FailOnValidationErrors" value="true"/>
      <parameter name="PerformLanguageCheck" value="true"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
  </jobType>

  <jobType id="PolicheckLspkg">
    <commandList>
      <command id="Lspkg2Lcl"
               plugin="Lspkg"
               position="10"
               executionLevel="Project"
               parameterListId="Lspkg2LclParameterList"
               timeout="30"
               />
      <command id="PolicheckScan"
               plugin="Policheck"
               position="20"
               executionLevel="Project"
               parameterListId="PolicheckScanParameterList"
               timeout="60"
               />
    </commandList>
    <parameterList id="Lspkg2LclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="PolicheckScanParameterList">
      <parameter name="ScanMode" value="Lcl | Source"/>
      <parameter name="ResultFileType" value="Xls"/>
      <parameter name="Severity" value="1|2" />
    </parameterList>
  </jobType>

  <jobType id="CheckinLspkgLcl">
    <commandList>
      <command id="SDCreateChangeList"
               plugin="SourceDepot"
               position="1"
               executionLevel="Root"
               parameterListId="SDCreateChangelistParameterList"
               timeout="30"
               />
      <command id="Lspkg2Lcl"
              plugin="Lspkg"
              position="10"
              executionLevel="Project"
              parameterListId="Lspkg2LclParameterList"
              timeout="30"
               />
      <command id="SDCheckin"
               plugin="SourceDepot"
               position="20"
               executionLevel="Project"
               parameterListId="SDCheckinParameterList"
               timeout="60"
               />
      <command id="SDSubmitChangelist"
               plugin="SourceDepot"
               position="30"
               executionLevel="Root"
               parameterListId="SDSubmitChangelistParameterList"
               timeout="30"
               />
    </commandList>
    <parameterList id="SDCreateChangelistParameterList">
      <parameter name="Operation" value="CreateChangelist" />
    </parameterList>
    <parameterList id="Lspkg2LclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="SDCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="SubFoldersToInclude" value="lcl" />
    </parameterList>
    <parameterList id="SDSubmitChangelistParameterList">
      <parameter name="Operation" value="SubmitChangelist" />
    </parameterList>
  </jobType>


  <!-- ZIP JOB TEMPLATES -->

  <jobType id="MlpRegisterBuildZip">
    <commandList>
      <command id="CreateMlpBuild"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="CreateMlpBuildParameterList"
               timeout="30"
               runInLocalMode="false"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="20"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               />
    </commandList>
    <parameterList id="CreateMlpBuildParameterList">
      <parameter name="service" value="CreateBuild"/>
      <parameter name="AllowMultipleBuildHandoffs" value="false" />
      <parameter name="BuildType" value="Software" />
      <parameter name="BuildContainsHandoff" value="false"/>
      <parameter name="BuildHandoffType" value="Normal" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\build\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="zip.source | miscfiles | handoff.extra"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
  </jobType>
  <jobType id="MlpPrepHandoffZip" >
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="BuildZip"
               plugin="BuildZip"
               position="20"
               executionLevel="Project"
               timeout="60"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="30"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="40"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList">
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpBuildRoot$\handoffbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="true"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="Mirror" value="true" />
      <parameter name="SubFoldersToInclude" value=""/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>
  <jobType id="MlpHandbackZip" >
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="ExtractZip"
               plugin="ExtractZip"
               position="20"
               executionLevel="Project"
               parameterListId="ExtractZipParameterList"
               timeout="60"
               />
      <command id="CopyResultsToMlpFileServer"
               plugin="CopyLba"
               position="30"
               executionLevel="%LBA_COPYLBA_EXECUTIONLEVEL%"
               parameterListId="CopyResultsToMlpFileServerParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="40"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="ExtractZipParameterList">
      <parameter name="PerformZipValidation" value="true" />
      <parameter name="ZipValidationMode" value="Full" />
    </parameterList>
    <parameterList id="CopyResultsToMlpFileServerParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\handbackbuild\lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="true"/>
      <parameter name="SubFoldersToInclude" value="buildfiles"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>
  <jobType id="MlpCheckinZip">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="SDCreateChangeList"
               plugin="SourceDepot"
               position="20"
               executionLevel="Root"
               parameterListId="SDCreateChangelistParameterList"
               timeout="30"
               />
      <command id="ExtractZip"
               plugin="ExtractZip"
               position="30"
               executionLevel="Project"
               parameterListId="ExtractZipParameterList"
               timeout="60"
               />
      <command id="SDCheckin"
               plugin="SourceDepot"
               position="40"
               executionLevel="Culture"
               parameterListId="SDCheckinParameterList"
               timeout="60"
               />
      <command id="SDSubmitChangelist"
               plugin="SourceDepot"
               position="50"
               executionLevel="Root"
               parameterListId="SDSubmitChangelistParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="60"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="SDCreateChangelistParameterList">
      <parameter name="Operation" value="CreateChangelist" />
    </parameterList>
    <parameterList id="ExtractZipParameterList">
      <parameter name="PerformZipValidation" value="false" />
      <parameter name="ZipValidationMode" value="Full" />
    </parameterList>
    <parameterList id="SDCheckinParameterList">
      <parameter name="operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="SubFoldersToInclude" value="zip.target" />
    </parameterList>
    <parameterList id="SDSubmitChangelistParameterList">
      <parameter name="Operation" value="SubmitChangelist" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="MlpCheckinZipTfs">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="ExtractZip"
               plugin="ExtractZip"
               position="30"
               executionLevel="Project"
               parameterListId="ExtractZipParameterList"
               timeout="60"
               />
      <command id="TfsCheckin"
               plugin="Tfs"
               position="40"
               executionLevel="Culture"
               parameterListId="TfsCheckinParameterList"
               timeout="60"
               />
      <command id="TfsSubmitFiles"
               plugin="Tfs"
               position="50"
               executionLevel="Root"
               parameterListId="TfsSubmitFilesParameterList"
               timeout="30"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="60"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="ExtractZipParameterList">
      <parameter name="PerformZipValidation" value="false" />
      <parameter name="ZipValidationMode" value="Full" />
    </parameterList>
    <parameterList id="TfsCheckinParameterList">
      <parameter name="Operation" value="CheckinFiles"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="SubFoldersToInclude" value="zip.target" />
    </parameterList>
    <parameterList id="TfsSubmitFilesParameterList">
      <parameter name="Operation" value="SubmitFiles" />
      <parameter name="OverridePolicyFailure" value="true" />
      <parameter name="OverrideReasonText" value="Automatically checked in by LBA." />
      <parameter name="CheckinNotesText" value="Code reviewer=N/A;Security reviewer=N/A;Performance reviewer=N/A" />
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <!-- RESOURCE JOB TEMPLATES-->

  <jobType id="PrepareBuildResourcesStart">
    <commandList>
      <command id="UpdateMlpTransactionStatus"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpTransactionStatusParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpTransactionStatusParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
  </jobType>

  <jobType id="PrepareBuildResourcesFinish">
    <commandList>
      <command id="CreateBuildStatistics"
               plugin="ResourceManager"
               position="10"
               executionLevel="Root"
               parameterListId="CreateStatisticsParameterList"
               timeout="30"
               />
      <command id="CopyStatisticsToMlpFileServer"
               plugin="CopyLba"
               position="20"
               executionLevel="Root"
               parameterListId="CopyStatisticsParameterList"
               timeout="30"
               runInLocalMode="false"
               />
      <command id="ImportBuildStatistics"
               plugin="ResourceWebService"
               position="40"
               executionLevel="Root"
               parameterListId="ImportStatisticsParameterList"
               timeout="30"
               runInLocalMode="false"
               />
      <command id="UpdateMlpTransactionStatus"
               plugin="MlpWebService"
               position="50"
               executionLevel="Root"
               parameterListId="UpdateMlpTransactionStatusParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="CreateStatisticsParameterList">
      <parameter name="StatisticsTask" value="BuildStatistics"/>
    </parameterList>
    <parameterList id="CopyStatisticsParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\Resource\Lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="buildstatistics | lcg"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="ImportStatisticsParameterList">
      <parameter name="Service" value="ImportStatistics"/>
    </parameterList>
    <parameterList id="UpdateMlpTransactionStatusParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

  <jobType id="PrepareLocResources">
    <commandList>
      <command id="UpdateMlpForStart"
               plugin="MlpWebService"
               position="10"
               executionLevel="Root"
               parameterListId="UpdateMlpForStartParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
      <command id="Edb2Lcl"
               plugin="Edb2Lcl"
               position="20"
               executionLevel="Project"
               parameterListId="Edb2LclParameterList"
               timeout="60"
               />
      <command id="Lspkg2Lcl"
               plugin="Lspkg"
               position="30"
               executionLevel="Project"
               parameterListId="Lspkg2LclParameterList"
               timeout="30"
               />
      <command id="CreateLocStatistics"
               plugin="ResourceManager"
               position="40"
               executionLevel="Project"
               parameterListId="CreateStatisticsParameterList"
               timeout="30"
               />
      <command id="CopyStatisticsToMlpFileServer"
               plugin="CopyLba"
               position="50"
               executionLevel="Root"
               parameterListId="CopyStatisticsParameterList"
               timeout="30"
               runInLocalMode="false"
               />
      <command id="ImportLocStatistics"
               plugin="ResourceWebService"
               position="60"
               executionLevel="Root"
               parameterListId="ImportStatisticsParameterList"
               timeout="30"
               runInLocalMode="false"
               />
      <command id="UpdateMlpForFinish"
               plugin="MlpWebService"
               position="70"
               executionLevel="Root"
               parameterListId="UpdateMlpForFinishParameterList"
               timeout="30"
               runInLocalMode="false"
               alwaysExecute="true"
               />
    </commandList>
    <parameterList id="UpdateMlpForStartParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
    </parameterList>
    <parameterList id="Edb2LclParameterList">
      <parameter name="PerformEdbValidation" value="false"/>
      <parameter name="FailOnEdbValidationErrors" value="false"/>
      <parameter name="PerformEdbLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
      <parameter name="EdbValidationActions" value="All"/>
      <parameter name="EdbValidationErrorActions" value="All"/>
    </parameterList>
    <parameterList id="Lspkg2LclParameterList">
      <parameter name="Action" value="Lspkg2Lcl" />
      <parameter name="PerformValidation" value="false"/>
      <parameter name="FailOnValidationErrors" value="false"/>
      <parameter name="PerformLanguageCheck" value="false"/>
      <parameter name="SuppressWarnings" value="false"/>
    </parameterList>
    <parameterList id="CreateStatisticsParameterList">
      <parameter name="StatisticsTask" value="LocStatistics"/>
    </parameterList>
    <parameterList id="CopyStatisticsParameterList" >
      <parameter name="source" value="$LbaConfigInfo.WorkspaceLbaRoot$"/>
      <parameter name="target" value="$LbaConfigInfo.MlpTransactionRoot$\Resource\Lba"/>
      <parameter name="overwrite" value="all"/>
      <parameter name="IncludeProjectFile" value="false"/>
      <parameter name="LimitToActiveCulturesAndProjects" value="false"/>
      <parameter name="SubFoldersToInclude" value="locstatistics | lcl"/>
      <parameter name="Mirror" value="true" />
    </parameterList>
    <parameterList id="ImportStatisticsParameterList">
      <parameter name="Service" value="ImportStatistics"/>
    </parameterList>
    <parameterList id="UpdateMlpForFinishParameterList">
      <parameter name="Service" value="UpdateTransaction"/>
      <parameter name="finalizeStatus" value="true"/>
    </parameterList>
  </jobType>

</jobTypeTemplates>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\Edb2LspkgLbaConfig.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<lbaConfig xmlns="http://msn.com/mlp" version="2.0">
    <jobList>
        <job id="UpgradeLbaConfig" jobType="UpgradeLbaConfig"/>
        <job id="CreateLspkg" jobType="Lcl2Lspkg" />
        <job id="Edb2Lcl6" jobType="Edb2Lcl6" />
    </jobList>
    <customJobTypes>
        <jobType id="UpgradeLbaConfig">
            <commandList>
                <command id="UpgradeLbaConfigScript"
                       plugin="CustomScript"
                       position="20"
                       executionLevel="root"
                       parameterListId="UpgradeLbaConfigScriptParameterList"
                       timeout="10"
        />
            </commandList>
            <parameterList id="UpgradeLbaConfigScriptParameterList">
                <parameter name="path" value="$LbaConfigInfo.WorkspaceLbaRoot$\default\UpgradeLbaConfig\UpgradeLbaConfig.cmd"/>
            </parameterList>
        </jobType>
        <jobType id="Lcl2Lspkg">
            <commandList>
                <command id="Edb2LspkgProcess"
                         plugin="Lspkg"
                         position="10"
                         executionLevel="Project"
                         ignoreError="false"
                         parameterListId="Lcl2LspkgParameterList" />
            </commandList>
            <parameterList id="Lcl2LspkgParameterList">
                <parameter name="Action" value="Lcl2Lspkg"/>
                <parameter name="UseSourceFolderForLclFileList" value="false" />
            </parameterList>
        </jobType>
        <jobType id="Edb2Lcl6">
            <commandList>
                <command id="Edb2Lcl6Process"
                         plugin="Lspkg"
                         position="10"
                         executionLevel="Project"
                         ignoreError="false"
                         parameterListId="Edb2Lcl6ParameterList" />
            </commandList>
            <parameterList id="Edb2Lcl6ParameterList">
                <parameter name="Action" value="SingleTask"/>
                <parameter name="Task" value="Edb2Lcl6"/>
            </parameterList>
        </jobType>
    </customJobTypes>
</lbaConfig>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\PolicheckLanguageLcidMap.xml ===
<?xml version="1.0" encoding="utf-8" ?>
<languageLcidMap xmlns="http://msn.com/mlp">
  
  <languages>
    <!-- Afrikaans --><language id="af" lcid="1078" />        
    <!-- Albanian --><language id="sq" lcid="1052" />        
    <!-- Arabic --><language id="ar" lcid="14337 " />      
    <!-- Armenian --><language id="hy" lcid="1067" />        
    <!-- Assamese [non-GeoPol] --><language id="as" lcid="1101" />        
    <!-- Azerbaijani --><language id="az-Latn" lcid="1068" />   
    <!-- Basque --><language id="eu" lcid="1069" />        
    <!-- Bosnian - Cyrillic --><language id="bs-cyrl" lcid="8218" />   
    <!-- Bosnian - Latin --><language id="bs-latn" lcid="5146" />   
    <!-- Breton [non-GeoPol] --><language id="br" lcid="1150" />        
    <!-- Bulgarian --><language id="bg" lcid="1026" />        
    <!-- Byelorussian --><language id="be" lcid="1059" />        
    <!-- Catalan --><language id="ca" lcid="1027" />        
    <!-- Chinese (Simplified) --><language id="zh-chs" lcid="2052" />    
    <!-- Chinese (Traditional) - Taiwan --><language id="zh-cht" lcid="1028" />    
    <!-- Croatian --><language id="hr" lcid="1050" />        
    <!-- Czech --><language id="cs" lcid="1029" />        
    <!-- Danish --><language id="da" lcid="1030" />        
    <!-- Dutch --><language id="nl" lcid="1043" />        
    <!-- English --><language id="en" lcid="9" />           
    <!-- Estonian --><language id="et" lcid="1061" />        
    <!-- Farsi --><language id="fa" lcid="1065" />        
    <!-- Filipino [non-GeoPol] --><language id="fil" lcid="1124" />       
    <!-- Finnish --><language id="fi" lcid="1035" />        
    <!-- French --><language id="fr" lcid="1036" />        
    <!-- Galician --><language id="gl" lcid="1110" />        
    <!-- Georgian [non-GeoPol] --><language id="ka" lcid="1079" />        
    <!-- German --><language id="de" lcid="1031" />        
    <!-- Greek --><language id="el" lcid="1032" />        
    <!-- Gujarati [non-GeoPol] --><language id="gu" lcid="1095" />        
    <!-- Hausa --><language id="ha-Latn" lcid="1128" />   
    <!-- Hebrew --><language id="he" lcid="1037" />        
    <!-- Hindi --><language id="hi" lcid="1081" />        
    <!-- Hungarian --><language id="hu" lcid="1038" />        
    <!-- Icelandic [non-GeoPol] --><language id="is" lcid="1039" />        
    <!-- Igbo --><language id="ig" lcid="1136" />        
    <!-- Indonesian [non-GeoPol] --><language id="id" lcid="1057" />        
    <!-- Irish [non-GeoPol] --><language id="ga" lcid="2108" />        
    <!-- Italian --><language id="it" lcid="1040" />        
    <!-- Japanese --><language id="ja" lcid="1041" />        
    <!-- Kannada [non-GeoPol] --><language id="kn" lcid="1099" />        
    <!-- Kazakh --><language id="kk" lcid="1087" />        
    <!-- Khmer --><language id="km" lcid="1107" />        
    <!-- Kinyarwanda [non-GeoPol] --><language id="rw" lcid="1159" />        
    <!-- Konkani [non-GeoPol] --><language id="kok" lcid="1111" />       
    <!-- Korean --><language id="ko" lcid="1042" />        
    <!-- Kyrgyz --><language id="ky" lcid="1088" />        
    <!-- Lao --><language id="lo" lcid="1108" />        
    <!-- Latvian --><language id="lv" lcid="1062" />        
    <!-- Lithuanian --><language id="lt" lcid="1063" />        
    <!-- Luxembourg [non-GeoPol] --><language id="lb" lcid="1134" />        
    <!-- Macedonian (FYROM) --><language id="mk" lcid="1071" />        
    <!-- Malay [non-GeoPol] --><language id="ms" lcid="1086" />        
    <!-- Malayalam [non-GeoPol] --><language id="ml" lcid="1100" />        
    <!-- Marathi [non-GeoPol] --><language id="mr" lcid="1102" />        
    <!-- Nepali [non-GeoPol] --><language id="ne" lcid="1121" />
    <!-- Norwegian --><language id="no" lcid="1044" />
    <!-- Norwegian(Nynorsk) --><language id="nn" lcid="2068" />
    <!-- Norwegian(bokmal) --><language id="nb" lcid="1044" />
    <!-- Oriya[non-GeoPol] --><language id="or" lcid="1096" />        
    <!-- Pashto --><language id="ps" lcid="1123" />        
    <!-- Polish --><language id="pl" lcid="1045" />        
    <!-- Portuguese - Brazil --><language id="pt-brz" lcid="1046" />     
    <!-- Portuguese - Portugal --><language id="pt" lcid="2070" />        
    <!-- Quechua [non-GeoPol] --><language id="quz" lcid="3179" />       
    <!-- Romanian --><language id="ro" lcid="1048" />        
    <!-- Russian --><language id="ru" lcid="1049" />        
    <!-- Serbian (Cyrillic) --><language id="sr-cyrl" lcid="3098" />   
    <!-- Serbian (Latin) --><language id="sr-latn" lcid="2074" />   
    <!-- Sesotho (Southern Sotho) --><language id="st" lcid="1072" />        
    <!-- Sesotho sa Leboa (Northern Sotho) --><language id="nso" lcid="1132" />       
    <!-- Slovak --><language id="sk" lcid="1051" />        
    <!-- Slovenian --><language id="sl" lcid="1060" />        
    <!-- Spanish --><language id="es" lcid="1034" />        
    <!-- Swahili --><language id="sw" lcid="1089" />        
    <!-- Swedish --><language id="sv" lcid="1053" />        
    <!-- Tamil --><language id="ta" lcid="1097" />        
    <!-- Tatar [non-GeoPol] --><language id="tt" lcid="1092" />        
    <!-- Thai --><language id="th" lcid="1054" />        
    <!-- Tswana --><language id="tn" lcid="1074" />        
    <!-- Turkish --><language id="tr" lcid="1055" />        
    <!-- Ukrainian --><language id="uk" lcid="1058" />        
    <!-- Urdu --><language id="ur" lcid="1056" />        
    <!-- Uzbek [non-GeoPol] --><language id="uz" lcid="1091" />        
    <!-- Vietnamese [non-GeoPol] --><language id="vi" lcid="1066" />        
    <!-- Welsh --><language id="cy" lcid="1106" />        
    <!-- Xhosa --><language id="xh" lcid="1076" />        
    <!-- Yoruba --><language id="yo" lcid="1130" />        
    <!-- Zulu --><language id="zu" lcid="1077" />        
  </languages>

  <cultureExceptions>
    <!-- Bangla - Bangladesh --><culture id="bn-bd" lcid="2117" />      
    <!-- Bangla - India --><culture id="bn-in" lcid="1093" />      
    <!-- Chinese - Hong Kong --><culture id="zh-hk" lcid="3076" />      
  </cultureExceptions>

</languageLcidMap>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\lcxadmin.ini ===
[FileExtension]
SourceFile =  Windows LCG file (*.lcg)|*.lcg;*.lcx|All Files (*.*)|*.*||
CommentingFile = Windows LCI file (*.lci)|*.lci|All Files (*.*)|*.*||

[Help]
OnlineReference = http://localizability/longhorn/LcxAdmin.asp

[WaterMark]
LCXAdmin = Commenting file created by LCXAdmin. For more information, please visit http://localizability/longhorn/LcxAdmin.asp

[Options]
PromptCommentFile = false
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\locxml.xml ===
<?xml version="1.0"?>
<!DOCTYPE _locDefinition SYSTEM "locXML.dtd">
<_locDefinition>
	<!-- To Do: uncomment following line to set elements as none-localizable by default -->
	<!-- <_locDefault _loc="locNone"/> -->
	<!-- To Do: uncomment following line to set all attributes to localizable by default -->
	<!-- <_locDefaultAttr _loc="locData"/> -->

	<!-- To Do: uncomment following line to set tag test to none-localizable 

		and its attributes size and type to localizable.
	        The _locIDAttr is optional and defines the id-attribute as the 
		resource id to use in place of a _locID attribute. 
		For eg: the value of the 'name' attribute of the 'test' tag will be 
		treated as the id for all the localizable content of the 'test' tag.
		-->
	<!-- <_locTag _loc="locNone" _locIDAttr="name" _locAttrData="size,type">test</_locTag> -->

	<!-- To Do: uncomment following line to set tag bold to fully-localizable  -->
	<!-- <_locTag _loc="locFull">bold</_locTag> -->
</_locDefinition>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\MICROSOFT LS 4.8 ROLLUP QFE 8 LSBUILD TOOLS 1.5 ROLLUP QFE 8 README.doc ===
Microsoft Office Word 97-2003 Document MSWordDoc Word.Document.8Microsoft LS 4.8 QFE 7 Title _PID_HLINKS _TentativeReviewCycleID _ReviewCycleID _NewReviewCycle _EmailEntryID _EmailStoreID _ReviewingToolsShownOnce 0000000038A1BB1005E5101AA1BB08002B2A56C20000454D534D44422E444C4C00000000000000001B55FA20AA6611CD9BC800AA002FC45A0C0000005245442D4D53472D3130002F4F3D6D6963726F736F66742F4F553D6E6F727468616D65726963612F636E3D526563697069656E74732F636E3D74696D6B696E00Microsoft LS 4.8 QFE 7 timkin Normal.dotm Tim King Microsoft Office Word[Content_Types].xml _rels/.rels theme/theme/themeManager.xml theme/theme/theme1.xml w toc'v 3Vq%'#q :\TZaG IqbJ#x T[XF64 theme/theme/_rels/themeManager.xml.rels K(M&$R(.1 [Content_Types].xmlPK _rels/.relsPK theme/theme/themeManager.xmlPK theme/theme/theme1.xmlPK theme/theme/_rels/themeManager.xml.relsPK <?xml version="1.0" encoding="UTF-8" standalone="yes"?> <a:clrMap xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/>bjbj| RELEASE NOTES FOR MICROSOFT LOCSTUDIO 4.8 ROLLUP QFE 8  and LS BUILD TOOLS 1.5 ROLLUP QFE 8  2006 Microsoft Corporation. All rights reserved. This Rollup QFE contains all bug fixes and file changes released in QFEs 1 through 8, as noted below. Before installing this ROLLUP QFE 8 version of LocStudio 4.8 and LS Build 1.5, please review these important notes. LocStudio 4.8 Before you install the LocStudio 4.8 ROLLUP QFE 8, please ensure you have LocStudio 4.8 installed.  This ROLLUP QFE can be installed over the base RTM product or any previously installed QFEs (single or multiple). LocStudio 4.8 can be installed from the following locations: Install LocStudio 4.8.  For more information, visit   HYPERLINK "http://bgit/applications/help/LocStudio/default.asp?URL=LSW_install_310.htm"  http://bgit/applications/help/LocStudio/default.asp?URL=LSW_install_310.htm Install this ROLLUP QFE 8 from   HYPERLINK "http://bgit/applications/LocStudio/LocStudio_Updates_LS48.asp"  http://bgit/applications/LocStudio/LocStudio_Updates_LS48.asp Install previous individual QFEs (1-8) from   HYPERLINK "http://bgit/applications/LocStudio/LocStudio_Updates_LS48.asp"  http://bgit/applications/LocStudio/LocStudio_Updates_LS48.asp LocStudio 4.8 QFE Removal: To uninstall this ROLLUP QFE, you must uninstall all of LocStudio 4.8.  The QFE may not be removed independently. To uninstall LocStudio 4.8, click Start, click Control Panel, and then double click Add/Remove Programs. Scroll to Microsoft Localization Studio 4.8 and select LocStudio 4.8, and then click Remove. LS Build Tools 1.5 Before you install the LS Build Tools 1.5 ROLLUP QFE 8, please ensure you have LS Build Tools 1.5 installed.  This ROLLUP QFE can be installed over the base RTM product or any previously installed QFEs (single or multiple). LSBuild Tools 1.5 can be installed from the following location: Install LS Build Tools 1.5.  For more information see   HYPERLINK "http://bgit/applications/help/LocStudioSDK/default.asp?URL=LSSDK_LSBuildGuide_364.htm"  http://bgit/applications/help/LocStudioSDK/default.asp?URL=LSSDK_LSBuildGuide_364.htm Install this ROLLUP QFE 8 from   HYPERLINK "http://bgit/applications/LocStudio/LocStudio_LSBuild_Updates_LSBT15.asp"  http://bgit/applications/LocStudio/LocStudio_LSBuild_Updates_LSBT15.asp Install previous individual QFEs (1-8) from   HYPERLINK "http://bgit/applications/LocStudio/LocStudio_LSBuild_Updates_LSBT15.asp"  http://bgit/applications/LocStudio/LocStudio_LSBuild_Updates_LSBT15.asp LS Build Tools 1.5 QFE Removal: To uninstall this ROLLUP QFE, you must uninstall all of LS Build Tools 1.5.  The QFE may not be removed independently. To uninstall, please see the information at   HYPERLINK "http://bgit/applications/help/LocStudioSDK/default.asp?URL=LSSDK_LSBuildGuide_364.htm"  http://bgit/applications/help/LocStudioSDK/default.asp?URL=LSSDK_LSBuildGuide_364.htm Bugs fixed:  QFE 1 Import Comments: Not able to pickup LCG files from sub folders under LCG folder (folder structure based on the file path inside the EDB- project) Managed extension: Setting a item to have LocStatus = Localized; UserLock=false does not work when userLock=true initially LSBuild: LCT contains different info from the one which is saved in the binary TP:LocRule:{NoLocRule} doesn't work with MinLenght Rule Automatically upgrade an EDB before command line utility command. DCR doc: http://team/sites/LLTTools/Specs/Shared%20Documents/DCR%20-%20AutomaticallyUpgradeEDB.doc MUISubParser - Support generation of MUI Source Binaries QFE 2 XML parser doesn't include the node name as part of the resource ID XML parser reports duplicate resource ID even the resource ID is different Enable RTL Layout and No Layout Inhreritance on the control level for Win32 binaries INF parser: support for leading spaces Duplicate resource IDs if the resource IDs differ in case QFE 3 LSSETUP: Not able to register mlocxml.dll during lssetup install on Windows Vista machine LocVer doesn't generate correct Cashed file when this option is ON Vista BVT Blocker: Edb2Lcl command giving "Class not registered" error on Vista Splice: Change LSBuild to ignore LCL Comments when LCL Translations are not used. (Req# 497 in Localization Tools Requirements) LSBUILD: Tracking - Add manifests to components exposing COM classes QFE 4 Enable RTL Layout and No Layout Inheritance on the control level for Win32 binaries QFE 5 Hindi characters show question marks in Layout > Test Req# 513 - LS:Dialog editor: allow WYSIWYG editing of BS_COMMANDLINK controls in LS Dialog editor on Vista E Req# 514 - LS:Editor: to allow WYSIWYG editing of SYSLINK controls in LS Dialog editor on Vista QFE 6 TP:Pseudo engine: LSBUILD fails to generate file when {Split='|'}{ValidChars=s'0-3','[0-9] rule when using ( as delimiters QFE 7 QFE-BLOCKING *XMR*: Microsoft.Localization.LocCulture does not work from ASP.Net webservice UnicodeMap.xml file needs to support Windows and Office12 Lip languages (For Locstudio 4.8) Updated values for LocCultures.xml MSI dialog test doesn't work with QFE#5 Win32 Parser - Target File does not shrink when resources section gets smaller. Win32 Parser To strip resources that have not been localized. WIN32 parser: to be able to turn off warnings when generating multi lang binaries about resources not matching with source language LSBuild Merge: Need a Commandline utility to merge Commenting files to existing LCX files LS 4.8 - Invalid text in comments passed to parsers Pseudo LCIDs QFE - Comments in SQL files can be localized LocStudio Update: change how LS update modifies the prev. source field Need a new parser to handle PNG QFE: LS Editor - LS 48 EDBs being validated every time once the QFE1 is installed PCCX pick up the lower comment RCCX does not escape the Itemld correctly QFE 8 Extension registration fails on Vista LLTT Requirement 509: EDB2LCL - Addition of EDBName Gif/Jpeg under HTML is no longer stripped Affected files: LS 4.8 QFE 1 TransPlatform.dll, Microsoft.LocVer.Rules.dll, Lsutils.dll, ImportComments.dll, Esputil.dll, MUISubParser.dll, Espprj.pkg QFE 2 infparse.dll, locxml.dll, win32.dll QFE 3 splice.dll, Microsoft.Locver.Engine.dll QFE 4 win32.dll QFE 5 Devres.pkg, Dlgprvw.exe QFE 6 PseudoTransEngine.dll QFE 7 DevRes.pkg, DlgPrvw.exe, Edb.dll, ESPPRJ.pkg, EspUtil.dll, GifJpegS.dll, LocCultures.xml, LocDataUtils.dll, LSUtils.dll, Microsoft.Localization.dll, Microsoft.LocVer.Engine.dll, MitUti.dll, SQLParse.dll, UnicodeMap.xml, Win32.dll QFE 8 LSUtils.dll, Win32.dll LSBT 1.5 QFE 1 lsbuild.exe, esputil.dll, LSUtils.dll, Microsoft.LocVer.Rules.dll, TransPlatform.dll, MUISubParser.dll QFE 2 infparse.dll, locxml.dll, win32.dll QFE 3 lsbuild.exe, splice.dll, Microsoft.Locver.Engine.dll Msjtor35.dll, Mlocxml.dll, Locxml.dll, Pomhtml.dll, Pomxml.dll, Pommanager.dll, Managedparser.dll, Parserhelpers.dll, Lsom.dll, Parsers.reg.template, Mcp.reg.templace, Parserhelpers.reg.template, Setup.config, Lsbuild.exe.manifest, LcxAdmin.exe.manifest, RuleAdvisor.exe.manifest QFE 4 win32.dll QFE 5 QFE 6 PseudoTransEngine.dll QFE 7 ESPUtil.dll, GifJPegs.dll, LocCultures.xml, LocDataUtils.dll, LSUtils.dll, ManagedParser.dll, Microsoft.Localization.dll, Microsoft.LocVer.Engine.dll, MitUtil.dll, ParserHelpers.dll, RcDll.dll, SQLParse.dll, Win32.dll QFE 8 EDBConv.dll, LSBuild.exe.config, LSUtils.dll, Win32.dll File versions: LS 4.8:  4.80.1015.0  note: the following files have a version number of 1.5.1018.0: LSUtils.dll, Win32.dll. LSBuild 1.5: 1.5.1015.0 note: the following files have a version number of 1.5.1018.0: EDBConv.dll, LSBuild.exe.config, LSUtils.dll, Win32.dll. Known Issues: Uninstall will not remove all files.  The uninstallation of LocStudio 4.8 or LSBuild 1.5 will not remove all files installed by QFEs; if LocStudio or LSBUild is subsequently reinstalled problems may result.  Please manually delete files from the program location after uninstallation to ensure that reinstallation is successful and program performance is as expected. Modification to Setup.Config. Any required modifications to the setup.config file should be performed after the QFE is installed. Display of EDB Name (bug 3216).  Additional information for bug 3216:  the default value for the attribute  IncludeEDBNameDuringEdb2lcl  in LSBuild.exe.config is  False ;  if you wish to see the EDB name please modify this value to  Parsing Vista-only Languages.  A XP system can be used to parse XP resources, and to generate to any XP or Vista language. But a Vista-only language can only be parsed on a Vista system (and not on a XP system). Unsupported Culture Name error.  If the .NET Framework installed on your machine doesn t support a language and you attempt to upload an assembly in that unsupported language, or update an EDB whose source language is set to that unsupported language, you will see an error message stating the culture name is not supported. New/changed languages.  QFE 7 (bug 3101) provides support via LocCultures.xml for name changes made by NLS (to conform with IETF syntax   please see end of ReadMe for further information): az-AZ-Latn az-Latn-AZ uz-UZ-Latn uz-Latn-UZ sr-SP-Latn sr-Latn-SP az-AZ-Cyrl az-Cyrl-AZ uz-UZ-Cyrl uz-Cyrl-UZ sr-SP-Cyrl sr-Cyrl-SP bs-BA-Cyrl bs-Cyrl-BA sr-BA-Latn sr-Latn-BA sr-BA-Cyrl sr-Cyrl-BA bs-BA-Latn bs-Latn-BA en-CB en-029 iu-CA-Latn iu-Latn-CA iu-CA-Cans iu-Cans-CA (new for Vista) mn-CN-Mong mn-Mong-CN (New for Vista) tmz-DZ-Latn tmz-Latn-DZ (New for Vista) es-es-ts es-es_tradnl sr-Latn-SP sr-Latn-CS sr-Cyrl-SP sr-Cyrl-CS div-MV dv-MV tmz-Latn-DZ tzm-Latn-DZ wee-DE dsb-DE The following languages were also changed but for compatibility reasons the old names have been retained and will be recognized: zh-CHT zh-CHT, zh-Hant zh-CHS zh-CHS, zh-Hans  The following new  thunked  languages have been included ( thunking  is when LocStudio creates custom ANSI pages that work only within LocStudio, to enable these languages to be edited within the LocStudio UI): Language LangID Macedonian 0x042f Slovak 0x041b Slovenian 0x0424 Bengali (Bangladesh) 0x0845 Icelandic 0x040f Kazakh 0x043f Kyrgyz (cyrillic)" 0x0440 Tatar 0x0444 Tatar (Tatarstan)" 0x0044 Ukrainian 0x0422 Azeri (Latin, Azerbaijan) 0x042c Khmer (Cambodia) 0x0453 Lao (Lao P.D.R.)   0x0454 Amharic and Inuktitut. These languages, as exceptions, are not supported by this release of Loc Studio.  These languages have more than 128 used characters and thus are not candidates for  thunking zkz^MC gdZF+ lbXbXb XNXDX4 gdOg< gdOg< gd-:  gd-:  |qcVL gdOg< sh[MC9M cxcxn
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lba\LocCultures.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<LocCultures>
  <LocCulture RFC3066Name="ar" LCID="1" EnglishName="Arabic" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
		<LocCulture RFC3066Name="ar-SA" LCID="1025" EnglishName="Arabic (Saudi Arabia)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SA"/>
		<LocCulture RFC3066Name="ar-IQ" LCID="2049" EnglishName="Arabic (Iraq)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARI" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-IQ"/>
		<LocCulture RFC3066Name="ar-EG" LCID="3073" EnglishName="Arabic (Egypt)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARE" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-EG"/>
		<LocCulture RFC3066Name="ar-LY" LCID="4097" EnglishName="Arabic (Libya)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARL" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-LY"/>
		<LocCulture RFC3066Name="ar-DZ" LCID="5121" EnglishName="Arabic (Algeria)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-DZ"/>
		<LocCulture RFC3066Name="ar-MA" LCID="6145" EnglishName="Arabic (Morocco)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARM" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-MA"/>
		<LocCulture RFC3066Name="ar-TN" LCID="7169" EnglishName="Arabic (Tunisia)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ART" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-TN"/>
		<LocCulture RFC3066Name="ar-OM" LCID="8193" EnglishName="Arabic (Oman)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARO" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-OM"/>
		<LocCulture RFC3066Name="ar-YE" LCID="9217" EnglishName="Arabic (Yemen)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARY" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-YE"/>
		<LocCulture RFC3066Name="ar-SY" LCID="10241" EnglishName="Arabic (Syria)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SY"/>
		<LocCulture RFC3066Name="ar-JO" LCID="11265" EnglishName="Arabic (Jordan)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARJ" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-JO"/>
		<LocCulture RFC3066Name="ar-LB" LCID="12289" EnglishName="Arabic (Lebanon)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARB" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-LB"/>
		<LocCulture RFC3066Name="ar-KW" LCID="13313" EnglishName="Arabic (Kuwait)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARK" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-KW"/>
		<LocCulture RFC3066Name="ar-AE" LCID="14337" EnglishName="Arabic (U.A.E.)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARU" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-AE"/>
		<LocCulture RFC3066Name="ar-BH" LCID="15361" EnglishName="Arabic (Bahrain)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARH" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-BH"/>
		<LocCulture RFC3066Name="ar-QA" LCID="16385" EnglishName="Arabic (Qatar)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARQ" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-QA"/>
                <LocCulture RFC3066Name="qps-plocm" LCID="2559" EnglishName="Pseudo (Mirror)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SA" />
	</LocCulture>
	<LocCulture RFC3066Name="bg" LCID="2" EnglishName="Bulgarian" ISO639_1="bg" ISO639_2="bul" WindowsTLA="BGR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="bg">
		<LocCulture RFC3066Name="bg-BG" LCID="1026" EnglishName="Bulgarian (Bulgaria)" ISO639_1="bg" ISO639_2="bul" WindowsTLA="BGR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="bg-BG"/>
	</LocCulture>
	<LocCulture RFC3066Name="ca" LCID="3" EnglishName="Catalan" ISO639_1="ca" ISO639_2="cat" WindowsTLA="CAT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ca">
		<LocCulture RFC3066Name="ca-ES" LCID="1027" EnglishName="Catalan (Catalan)" ISO639_1="ca" ISO639_2="cat" WindowsTLA="CAT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ca-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="zh-CHS" LCID="4" EnglishName="Chinese (Simplified)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHS" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-CHS">
		<LocCulture RFC3066Name="zh-CN" LCID="2052" EnglishName="Chinese (PRC)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHS" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-CN"/>
		<LocCulture RFC3066Name="zh-SG" LCID="4100" EnglishName="Chinese (Singapore)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHI" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-SG"/>
	</LocCulture>
	<LocCulture RFC3066Name="cs" LCID="5" EnglishName="Czech" ISO639_1="cs" ISO639_2="ces" WindowsTLA="CSY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="cs">
		<LocCulture RFC3066Name="cs-CZ" LCID="1029" EnglishName="Czech (Czech Republic)" ISO639_1="cs" ISO639_2="ces" WindowsTLA="CSY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="cs-CZ"/>
	</LocCulture>
	<LocCulture RFC3066Name="da" LCID="6" EnglishName="Danish" ISO639_1="da" ISO639_2="dan" WindowsTLA="DAN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="da">
		<LocCulture RFC3066Name="da-DK" LCID="1030" EnglishName="Danish (Denmark)" ISO639_1="da" ISO639_2="dan" WindowsTLA="DAN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="da-DK"/>
	</LocCulture>
	<LocCulture RFC3066Name="de" LCID="7" EnglishName="German" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de">
		<LocCulture RFC3066Name="de-DE" LCID="1031" EnglishName="German (Germany)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-DE"/>
		<LocCulture RFC3066Name="de-CH" LCID="2055" EnglishName="German (Switzerland)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DES" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-CH"/>
		<LocCulture RFC3066Name="de-AT" LCID="3079" EnglishName="German (Austria)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-AT"/>
		<LocCulture RFC3066Name="de-LU" LCID="4103" EnglishName="German (Luxembourg)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-LU"/>
		<LocCulture RFC3066Name="de-LI" LCID="5127" EnglishName="German (Liechtenstein)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-LI"/>
	</LocCulture>
	<LocCulture RFC3066Name="el" LCID="8" EnglishName="Greek" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="737" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el">
		<LocCulture RFC3066Name="el-GR" LCID="1032" EnglishName="Greek (Greece)" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="737" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el-GR"/>
		<LocCulture RFC3066Name="el-GR-2" LCID="8200" EnglishName="Greek 2 (Greece)" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="869" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el-GR"/>
    	</LocCulture>
	<LocCulture RFC3066Name="en" LCID="9" EnglishName="English" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en">
		<LocCulture RFC3066Name="en-US" LCID="1033" EnglishName="English (United States)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-US"/>
		<LocCulture RFC3066Name="en-GB" LCID="2057" EnglishName="English (United Kingdom)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/>
		<LocCulture RFC3066Name="en-AU" LCID="3081" EnglishName="English (Australia)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-AU"/>
		<LocCulture RFC3066Name="en-CA" LCID="4105" EnglishName="English (Canada)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-CA"/>
		<LocCulture RFC3066Name="en-NZ" LCID="5129" EnglishName="English (New Zealand)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENZ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-NZ"/>
		<LocCulture RFC3066Name="en-IE" LCID="6153" EnglishName="English (Ireland)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-IE"/>
		<LocCulture RFC3066Name="en-ZA" LCID="7177" EnglishName="English (South Africa)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENS" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-ZA"/>
		<LocCulture RFC3066Name="en-JM" LCID="8201" EnglishName="English (Jamaica)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENJ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-JM"/>
		<LocCulture RFC3066Name="en-029" LCID="9225" EnglishName="English (Caribbean)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="en-BZ" LCID="10249" EnglishName="English (Belize)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-BZ"/>
		<LocCulture RFC3066Name="en-TT" LCID="11273" EnglishName="English (Trinidad and Tobago)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-TT"/>
		<LocCulture RFC3066Name="en-ZW" LCID="12297" EnglishName="English (Zimbabwe)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENW" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-ZW"/>
		<LocCulture RFC3066Name="en-PH" LCID="13321" EnglishName="English (Republic of the Philippines)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENP" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-PH"/>
		<LocCulture RFC3066Name="en-IN" LCID="16393" EnglishName="English (India)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/> 
		<LocCulture RFC3066Name="en-MY" LCID="17417" EnglishName="English (Malaysia)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENM" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/>
		<LocCulture RFC3066Name="en-SG" LCID="18441" EnglishName="English (Singapore)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENE" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/> 
                <LocCulture RFC3066Name="qps-ploc" LCID="1281" EnglishName="Pseudo Language (Pseudo Country)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="en-US" />
	</LocCulture>
	<LocCulture RFC3066Name="es" LCID="10" EnglishName="Spanish" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es">
        	<LocCulture RFC3066Name="es-es_tradnl" LCID="1034" EnglishName="Spanish, Traditional Sort (Spain)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="es-MX" LCID="2058" EnglishName="Spanish (Mexico)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-MX"/>
		<LocCulture RFC3066Name="es-ES" LCID="3082" EnglishName="Spanish, International Sort (Spain)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-ES"/>
		<LocCulture RFC3066Name="es-GT" LCID="4106" EnglishName="Spanish (Guatemala)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-GT"/>
		<LocCulture RFC3066Name="es-CR" LCID="5130" EnglishName="Spanish (Costa Rica)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CR"/>
		<LocCulture RFC3066Name="es-PA" LCID="6154" EnglishName="Spanish (Panama)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PA"/>
		<LocCulture RFC3066Name="es-DO" LCID="7178" EnglishName="Spanish (Dominican Republic)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-DO"/>
		<LocCulture RFC3066Name="es-VE" LCID="8202" EnglishName="Spanish (Venezuela)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESV" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-VE"/>
		<LocCulture RFC3066Name="es-CO" LCID="9226" EnglishName="Spanish (Colombia)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CO"/>
		<LocCulture RFC3066Name="es-PE" LCID="10250" EnglishName="Spanish (Peru)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PE"/>
		<LocCulture RFC3066Name="es-AR" LCID="11274" EnglishName="Spanish (Argentina)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-AR"/>
		<LocCulture RFC3066Name="es-EC" LCID="12298" EnglishName="Spanish (Ecuador)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-EC"/>
		<LocCulture RFC3066Name="es-CL" LCID="13322" EnglishName="Spanish (Chile)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CL"/>
		<LocCulture RFC3066Name="es-UY" LCID="14346" EnglishName="Spanish (Uruguay)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESY" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-UY"/>
		<LocCulture RFC3066Name="es-PY" LCID="15370" EnglishName="Spanish (Paraguay)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESZ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PY"/>
		<LocCulture RFC3066Name="es-BO" LCID="16394" EnglishName="Spanish (Bolivia)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-BO"/>
		<LocCulture RFC3066Name="es-SV" LCID="17418" EnglishName="Spanish (El Salvador)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-SV"/>
		<LocCulture RFC3066Name="es-HN" LCID="18442" EnglishName="Spanish (Honduras)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESH" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-HN"/>
		<LocCulture RFC3066Name="es-NI" LCID="19466" EnglishName="Spanish (Nicaragua)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-NI"/>
		<LocCulture RFC3066Name="es-PR" LCID="20490" EnglishName="Spanish (Puerto Rico)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PR"/>
		<LocCulture RFC3066Name="es-US" LCID="21514" EnglishName="Spanish (United States)" ISO639_1="es" ISO639_2="spa" WindowsTLA="EST" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es"/>
	</LocCulture>
	<LocCulture RFC3066Name="fi" LCID="11" EnglishName="Finnish" ISO639_1="fi" ISO639_2="fin" WindowsTLA="FIN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fi">
		<LocCulture RFC3066Name="fi-FI" LCID="1035" EnglishName="Finnish (Finland)" ISO639_1="fi" ISO639_2="fin" WindowsTLA="FIN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fi-FI"/>
	</LocCulture>
	<LocCulture RFC3066Name="fr" LCID="12" EnglishName="French" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr">
		<LocCulture RFC3066Name="fr-FR" LCID="1036" EnglishName="French (France)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-FR"/>
		<LocCulture RFC3066Name="fr-BE" LCID="2060" EnglishName="French (Belgium)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-BE"/>
		<LocCulture RFC3066Name="fr-CA" LCID="3084" EnglishName="French (Canada)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-CA"/>
		<LocCulture RFC3066Name="fr-CH" LCID="4108" EnglishName="French (Switzerland)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-CH"/>
		<LocCulture RFC3066Name="fr-LU" LCID="5132" EnglishName="French (Luxembourg)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-LU"/>
		<LocCulture RFC3066Name="fr-MC" LCID="6156" EnglishName="French (Monaco)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-MC"/>
	</LocCulture>
	<LocCulture RFC3066Name="he" LCID="13" EnglishName="Hebrew" ISO639_1="he" ISO639_2="heb" WindowsTLA="HEB" ANSICodePage="1255" OEMCodePage="862" MacCodePage="10005" RightToLeft="1" BuiltInCultureInfo="he">
		<LocCulture RFC3066Name="he-IL" LCID="1037" EnglishName="Hebrew (Israel)" ISO639_1="he" ISO639_2="heb" WindowsTLA="HEB" ANSICodePage="1255" OEMCodePage="862" MacCodePage="10005" RightToLeft="1" BuiltInCultureInfo="he-IL"/>
	</LocCulture>
	<LocCulture RFC3066Name="hu" LCID="14" EnglishName="Hungarian" ISO639_1="hu" ISO639_2="hun" WindowsTLA="HUN" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="hu">
		<LocCulture RFC3066Name="hu-HU" LCID="1038" EnglishName="Hungarian (Hungary)" ISO639_1="hu" ISO639_2="hun" WindowsTLA="HUN" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="hu-HU"/>
	</LocCulture>
	<LocCulture RFC3066Name="is" LCID="15" EnglishName="Icelandic" ISO639_1="is" ISO639_2="isl" WindowsTLA="ISL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="is">
		<LocCulture RFC3066Name="is-IS" LCID="1039" EnglishName="Icelandic (Iceland)" ISO639_1="is" ISO639_2="isl" WindowsTLA="ISL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="is-IS"/>
	</LocCulture>
	<LocCulture RFC3066Name="it" LCID="16" EnglishName="Italian" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it">
		<LocCulture RFC3066Name="it-IT" LCID="1040" EnglishName="Italian (Italy)" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it-IT"/>
		<LocCulture RFC3066Name="it-CH" LCID="2064" EnglishName="Italian (Switzerland)" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it-CH"/>
	</LocCulture>
	<LocCulture RFC3066Name="ja" LCID="17" EnglishName="Japanese" ISO639_1="ja" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja">
		<LocCulture RFC3066Name="ja-JP" LCID="1041" EnglishName="Japanese (Japan)" ISO639_1="ja" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja-JP"/>
                <LocCulture RFC3066Name="qps-ploca" LCID="1534" EnglishName="Pseudo (Asia)" ISO639_1="qps" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja-JP" />
	</LocCulture>
	<LocCulture RFC3066Name="ko" LCID="18" EnglishName="Korean" ISO639_1="ko" ISO639_2="kor" WindowsTLA="KOR" ANSICodePage="949" OEMCodePage="949" MacCodePage="10003" RightToLeft="0" BuiltInCultureInfo="ko">
		<LocCulture RFC3066Name="ko-KR" LCID="1042" EnglishName="Korean (Korea)" ISO639_1="ko" ISO639_2="kor" WindowsTLA="KOR" ANSICodePage="949" OEMCodePage="949" MacCodePage="10003" RightToLeft="0" BuiltInCultureInfo="ko-KR"/>
	</LocCulture>
	<LocCulture RFC3066Name="nl" LCID="19" EnglishName="Dutch" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl">
		<LocCulture RFC3066Name="nl-NL" LCID="1043" EnglishName="Dutch (Netherlands)" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl-NL"/>
		<LocCulture RFC3066Name="nl-BE" LCID="2067" EnglishName="Dutch (Belgium)" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl-BE"/>
	</LocCulture>
	<LocCulture RFC3066Name="no" LCID="20" EnglishName="Norwegian" ISO639_1="no" ISO639_2="nor" WindowsTLA="NOR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="no">
		<LocCulture RFC3066Name="nb-NO" LCID="1044" EnglishName="Norwegian, Bokmål (Norway)" ISO639_1="nb" ISO639_2="nob" WindowsTLA="NOR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nb-NO"/>
		<LocCulture RFC3066Name="nn-NO" LCID="2068" EnglishName="Norwegian, Nynorsk (Norway)" ISO639_1="nn" ISO639_2="nno" WindowsTLA="NON" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nn-NO"/>
	</LocCulture>
	<LocCulture RFC3066Name="pl" LCID="21" EnglishName="Polish" ISO639_1="pl" ISO639_2="pol" WindowsTLA="PLK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="pl">
		<LocCulture RFC3066Name="pl-PL" LCID="1045" EnglishName="Polish (Poland)" ISO639_1="pl" ISO639_2="pol" WindowsTLA="PLK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="pl-PL"/>
	</LocCulture>
	<LocCulture RFC3066Name="pt" LCID="22" EnglishName="Portuguese" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt">
		<LocCulture RFC3066Name="pt-BR" LCID="1046" EnglishName="Portuguese (Brazil)" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt-BR"/>
		<LocCulture RFC3066Name="pt-PT" LCID="2070" EnglishName="Portuguese (Portugal)" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt-PT"/>
	</LocCulture>
	<LocCulture RFC3066Name="rm" LCID="23" EnglishName="Romansh" ISO639_1="rm" ISO639_2="roh" WindowsTLA="RMC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="rm-CH" LCID="1047" EnglishName="Romansh (Switzerland)" ISO639_1="rm" ISO639_2="roh" WindowsTLA="RMC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ro" LCID="24" EnglishName="Romanian" ISO639_1="ro" ISO639_2="ron" WindowsTLA="ROM" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="ro">
		<LocCulture RFC3066Name="ro-RO" LCID="1048" EnglishName="Romanian (Romania)" ISO639_1="ro" ISO639_2="ron" WindowsTLA="ROM" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="ro-RO"/>
	</LocCulture>
	<LocCulture RFC3066Name="ru" LCID="25" EnglishName="Russian" ISO639_1="ru" ISO639_2="rus" WindowsTLA="RUS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ru">
		<LocCulture RFC3066Name="ru-RU" LCID="1049" EnglishName="Russian (Russia)" ISO639_1="ru" ISO639_2="rus" WindowsTLA="RUS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ru-RU"/>
	</LocCulture>
	<LocCulture RFC3066Name="hr" LCID="26" EnglishName="Croatian" ISO639_1="hr" ISO639_2="hrv" WindowsTLA="HRV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr">
		<LocCulture RFC3066Name="hr-HR" LCID="1050" EnglishName="Croatian (Croatia)" ISO639_1="hr" ISO639_2="hrv" WindowsTLA="HRV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr-HR"/>
		<LocCulture RFC3066Name="hr-BA" LCID="4122" EnglishName="Croatian (Latin, Bosnia and Herzegovina)" ISO639_1="hr" ISO639_2="hrb" WindowsTLA="HRB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr-HR"/>
	</LocCulture>
	<LocCulture RFC3066Name="sk" LCID="27" EnglishName="Slovak" ISO639_1="sk" ISO639_2="slk" WindowsTLA="SKY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sk">
		<LocCulture RFC3066Name="sk-SK" LCID="1051" EnglishName="Slovak (Slovakia)" ISO639_1="sk" ISO639_2="slk" WindowsTLA="SKY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sk-SK"/>
	</LocCulture>
	<LocCulture RFC3066Name="sq" LCID="28" EnglishName="Albanian" ISO639_1="sq" ISO639_2="sqi" WindowsTLA="SQI" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sq">
		<LocCulture RFC3066Name="sq-AL" LCID="1052" EnglishName="Albanian (Albania)" ISO639_1="sq" ISO639_2="sqi" WindowsTLA="SQI" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sq-AL"/>
	</LocCulture>
	<LocCulture RFC3066Name="sv" LCID="29" EnglishName="Swedish" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv">
		<LocCulture RFC3066Name="sv-SE" LCID="1053" EnglishName="Swedish (Sweden)" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv-SE"/>
		<LocCulture RFC3066Name="sv-FI" LCID="2077" EnglishName="Swedish (Finland)" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv-FI"/>
	</LocCulture>
	<LocCulture RFC3066Name="th" LCID="30" EnglishName="Thai" ISO639_1="th" ISO639_2="tha" WindowsTLA="THA" ANSICodePage="874" OEMCodePage="874" MacCodePage="10021" RightToLeft="0" BuiltInCultureInfo="th">
		<LocCulture RFC3066Name="th-TH" LCID="1054" EnglishName="Thai (Thailand)" ISO639_1="th" ISO639_2="tha" WindowsTLA="THA" ANSICodePage="874" OEMCodePage="874" MacCodePage="10021" RightToLeft="0" BuiltInCultureInfo="th-TH"/>
	</LocCulture>
	<LocCulture RFC3066Name="tr" LCID="31" EnglishName="Turkish" ISO639_1="tr" ISO639_2="tur" WindowsTLA="TRK" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="tr">
		<LocCulture RFC3066Name="tr-TR" LCID="1055" EnglishName="Turkish (Turkey)" ISO639_1="tr" ISO639_2="tur" WindowsTLA="TRK" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="tr-TR"/>
	</LocCulture>
	<LocCulture RFC3066Name="ur" LCID="32" EnglishName="Urdu" ISO639_1="ur" ISO639_2="urd" WindowsTLA="URD" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ur">
		<LocCulture RFC3066Name="ur-PK" LCID="1056" EnglishName="Urdu (Pakistan)" ISO639_1="ur" ISO639_2="urd" WindowsTLA="URD" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ur-PK"/>
	</LocCulture>
	<LocCulture RFC3066Name="id" LCID="33" EnglishName="Indonesian" ISO639_1="id" ISO639_2="ind" WindowsTLA="IND" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="id">
		<LocCulture RFC3066Name="id-ID" LCID="1057" EnglishName="Indonesian (Indonesia)" ISO639_1="id" ISO639_2="ind" WindowsTLA="IND" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="id-ID"/>
	</LocCulture>
	<LocCulture RFC3066Name="uk" LCID="34" EnglishName="Ukrainian" ISO639_1="uk" ISO639_2="ukr" WindowsTLA="UKR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10017" RightToLeft="0" BuiltInCultureInfo="uk">
		<LocCulture RFC3066Name="uk-UA" LCID="1058" EnglishName="Ukrainian (Ukraine)" ISO639_1="uk" ISO639_2="ukr" WindowsTLA="UKR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10017" RightToLeft="0" BuiltInCultureInfo="uk-UA"/>
	</LocCulture>
	<LocCulture RFC3066Name="be" LCID="35" EnglishName="Belarusian" ISO639_1="be" ISO639_2="bel" WindowsTLA="BEL" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="be">
		<LocCulture RFC3066Name="be-BY" LCID="1059" EnglishName="Belarusian (Belarus)" ISO639_1="be" ISO639_2="bel" WindowsTLA="BEL" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="be-BY"/>
	</LocCulture>
	<LocCulture RFC3066Name="sl" LCID="36" EnglishName="Slovenian" ISO639_1="sl" ISO639_2="slv" WindowsTLA="SLV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sl">
		<LocCulture RFC3066Name="sl-SI" LCID="1060" EnglishName="Slovenian (Slovenia)" ISO639_1="sl" ISO639_2="slv" WindowsTLA="SLV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sl-SI"/>
	</LocCulture>
	<LocCulture RFC3066Name="et" LCID="37" EnglishName="Estonian" ISO639_1="et" ISO639_2="est" WindowsTLA="ETI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="et">
		<LocCulture RFC3066Name="et-EE" LCID="1061" EnglishName="Estonian (Estonia)" ISO639_1="et" ISO639_2="est" WindowsTLA="ETI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="et-EE"/>
	</LocCulture>
	<LocCulture RFC3066Name="lv" LCID="38" EnglishName="Latvian" ISO639_1="lv" ISO639_2="lav" WindowsTLA="LVI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lv">
		<LocCulture RFC3066Name="lv-LV" LCID="1062" EnglishName="Latvian (Latvia)" ISO639_1="lv" ISO639_2="lav" WindowsTLA="LVI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lv-LV"/>
	</LocCulture>
	<LocCulture RFC3066Name="lt" LCID="39" EnglishName="Lithuanian" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTH" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt">
		<LocCulture RFC3066Name="lt-LT" LCID="1063" EnglishName="Lithuanian (Lithuania)" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTH" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt-LT"/>
		<LocCulture RFC3066Name="lt-LT-C" LCID="2087" EnglishName="Lithuanian, Classic (Lithuania)" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTC" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt-LT"/>
	</LocCulture>
	<LocCulture RFC3066Name="tg" LCID="40" EnglishName="Tajik" ISO639_1="tg" ISO639_2="tgk" WindowsTLA="TAJ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tg-Cyrl-TJ" LCID="1064" EnglishName="Tajik (Cyrillic, Tajikistan)" ISO639_1="tg" ISO639_2="tgk" WindowsTLA="TAJ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="fa" LCID="41" EnglishName="Persian" ISO639_1="fa" ISO639_2="fas" WindowsTLA="FAR" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="fa">
		<LocCulture RFC3066Name="fa-IR" LCID="1065" EnglishName="Persian (Iran)" ISO639_1="fa" ISO639_2="fas" WindowsTLA="FAR" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="fa-IR"/>
	</LocCulture>
	<LocCulture RFC3066Name="vi" LCID="42" EnglishName="Vietnamese" ISO639_1="vi" ISO639_2="vie" WindowsTLA="VIT" ANSICodePage="1258" OEMCodePage="1258" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="vi">
		<LocCulture RFC3066Name="vi-VN" LCID="1066" EnglishName="Vietnamese (Vietnam)" ISO639_1="vi" ISO639_2="vie" WindowsTLA="VIT" ANSICodePage="1258" OEMCodePage="1258" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="vi-VN"/>
	</LocCulture>
	<LocCulture RFC3066Name="hy" LCID="43" EnglishName="Armenian" ISO639_1="hy" ISO639_2="hye" WindowsTLA="HYE" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hy">
		<LocCulture RFC3066Name="hy-AM" LCID="1067" EnglishName="Armenian (Armenia)" ISO639_1="hy" ISO639_2="hye" WindowsTLA="HYE" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hy-AM"/>
	</LocCulture>
	<LocCulture RFC3066Name="az" LCID="44" EnglishName="Azeri" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZE" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="az">
		<LocCulture RFC3066Name="az-Latn-AZ" LCID="1068" EnglishName="Azeri (Latin, Azerbaijan)" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZE" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="az-Cyrl-AZ" LCID="2092" EnglishName="Azeri (Cyrillic, Azerbaijan)" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZC" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="eu" LCID="45" EnglishName="Basque" ISO639_1="eu" ISO639_2="eus" WindowsTLA="EUQ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="eu">
		<LocCulture RFC3066Name="eu-ES" LCID="1069" EnglishName="Basque (Basque)" ISO639_1="eu" ISO639_2="eus" WindowsTLA="EUQ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="eu-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="wen" LCID="46" EnglishName="Sorbian" ISO639_1="hs" ISO639_2="hsb" WindowsTLA="HSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="wen-DE" LCID="1070" EnglishName="Upper Sorbian (Germany)" ISO639_1="wen" ISO639_2="wen" WindowsTLA="HSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
	    <LocCulture RFC3066Name="dsb-DE" LCID="2094" EnglishName="Lower Sorbian (Germany)" ISO639_1="dsb" ISO639_2="dsb" WindowsTLA="DSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
	</LocCulture>
	<LocCulture RFC3066Name="mk" LCID="47" EnglishName="Macedonian" ISO639_1="mk" ISO639_2="mkd" WindowsTLA="MKI" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mk">
		<LocCulture RFC3066Name="mk-MK" LCID="1071" EnglishName="Macedonian (Former Yugoslav Republic of Macedonia)" ISO639_1="mk" ISO639_2="mkd" WindowsTLA="MKI" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mk-MK"/>
	</LocCulture>
	<LocCulture RFC3066Name="st" LCID="48" EnglishName="Sutu" ISO639_1="st" ISO639_2="sot" WindowsTLA="SOT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="st-ZA" LCID="1072" EnglishName="Sutu (South Africa)" ISO639_1="st" ISO639_2="sot" WindowsTLA="SOT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="tn" LCID="50" EnglishName="Setswana" ISO639_1="tn" ISO639_2="tsn" WindowsTLA="TSN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tn-ZA" LCID="1074" EnglishName="Setswana (South Africa)" ISO639_1="tn" ISO639_2="tsn" WindowsTLA="TSN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="xh" LCID="52" EnglishName="isiXhosa" ISO639_1="xh" ISO639_2="xho" WindowsTLA="XHO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="xh-ZA" LCID="1076" EnglishName="isiXhosa (South Africa)" ISO639_1="xh" ISO639_2="xho" WindowsTLA="XHO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>    
	<LocCulture RFC3066Name="zu" LCID="53" EnglishName="isiZulu" ISO639_1="zu" ISO639_2="zul" WindowsTLA="ZUL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="zu-ZA" LCID="1077" EnglishName="isiZulu (South Africa)" ISO639_1="zu" ISO639_2="zul" WindowsTLA="ZUL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>    
	<LocCulture RFC3066Name="af" LCID="54" EnglishName="Afrikaans" ISO639_1="af" ISO639_2="afr" WindowsTLA="AFK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="af">
		<LocCulture RFC3066Name="af-ZA" LCID="1078" EnglishName="Afrikaans (South Africa)" ISO639_1="af" ISO639_2="afr" WindowsTLA="AFK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="af-ZA"/>
	</LocCulture>
	<LocCulture RFC3066Name="ka" LCID="55" EnglishName="Georgian" ISO639_1="ka" ISO639_2="kat" WindowsTLA="KAT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ka">
		<LocCulture RFC3066Name="ka-GE" LCID="1079" EnglishName="Georgian (Georgia)" ISO639_1="ka" ISO639_2="kat" WindowsTLA="KAT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ka-GE"/>
	</LocCulture>
	<LocCulture RFC3066Name="fo" LCID="56" EnglishName="Faroese" ISO639_1="fo" ISO639_2="fao" WindowsTLA="FOS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="fo">
		<LocCulture RFC3066Name="fo-FO" LCID="1080" EnglishName="Faroese (Faroe Islands)" ISO639_1="fo" ISO639_2="fao" WindowsTLA="FOS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="fo-FO"/>
	</LocCulture>
	<LocCulture RFC3066Name="hi" LCID="57" EnglishName="Hindi" ISO639_1="hi" ISO639_2="hin" WindowsTLA="HIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hi">
		<LocCulture RFC3066Name="hi-IN" LCID="1081" EnglishName="Hindi (India)" ISO639_1="hi" ISO639_2="hin" WindowsTLA="HIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hi-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="mt" LCID="58" EnglishName="Maltese" ISO639_1="mt" ISO639_2="mlt" WindowsTLA="MLT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="mt-MT" LCID="1082" EnglishName="Maltese (Malta)" ISO639_1="mt" ISO639_2="mlt" WindowsTLA="MLT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
		<LocCulture RFC3066Name="se" LCID="59" EnglishName="Sami" ISO639_1="smi" ISO639_2="SME" WindowsTLA="SME" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="se-NO" LCID="1083" EnglishName="Sami, Northern (Norway)" ISO639_1="se" ISO639_2="sme" WindowsTLA="SME" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="se-SE" LCID="2107" EnglishName="Sami, Northern (Sweden)" ISO639_1="se" ISO639_2="smf" WindowsTLA="SMF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="se-FI" LCID="3131" EnglishName="Sami, Northern (Finland)" ISO639_1="se" ISO639_2="smg" WindowsTLA="SMG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smj-NO" LCID="4155" EnglishName="Sami, Lule (Norway)" ISO639_1="smj" ISO639_2="smj" WindowsTLA="SMJ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smj-SE" LCID="5179" EnglishName="Sami, Lule (Sweden)" ISO639_1="smj" ISO639_2="smk" WindowsTLA="SMK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sma-NO" LCID="6203" EnglishName="Sami, Southern (Norway)" ISO639_1="sma" ISO639_2="sma" WindowsTLA="SMA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sma-SE" LCID="7227" EnglishName="Sami, Southern (Sweden)" ISO639_1="sma" ISO639_2="SMB" WindowsTLA="SMB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sms-FI" LCID="8251" EnglishName="Sami, Skolt (Finland)" ISO639_1="sms" ISO639_2="sms" WindowsTLA="SMS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smn-FI" LCID="9275" EnglishName="Sami, Inari (Finland)" ISO639_1="smn" ISO639_2="smn" WindowsTLA="SMN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ga" LCID="60" EnglishName="Irish" ISO639_1="ga" ISO639_2="gle" WindowsTLA="IRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ga-GB" LCID="1084" EnglishName="Gaelic (Scotland)" ISO639_1="ga" ISO639_2="gle" WindowsTLA="GAE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="ga-IE" LCID="2108" EnglishName="Irish (Ireland)" ISO639_1="ga" ISO639_2="gle" WindowsTLA="IRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ms" LCID="62" EnglishName="Malay" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms">
		<LocCulture RFC3066Name="ms-MY" LCID="1086" EnglishName="Malay (Malaysia)" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms-MY"/>
		<LocCulture RFC3066Name="ms-BN" LCID="2110" EnglishName="Malay (Brunei Darussalam)" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms-BN"/>
	</LocCulture>
	<LocCulture RFC3066Name="kk" LCID="63" EnglishName="Kazakh" ISO639_1="kk" ISO639_2="kaz" WindowsTLA="KKZ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="kk">
		<LocCulture RFC3066Name="kk-KZ" LCID="1087" EnglishName="Kazakh (Kazakhstan)" ISO639_1="kk" ISO639_2="kaz" WindowsTLA="KKZ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="kk-KZ"/>
	</LocCulture>
	<LocCulture RFC3066Name="ky" LCID="64" EnglishName="Kyrgyz" ISO639_1="ky" ISO639_2="kir" WindowsTLA="KYR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ky">
		<LocCulture RFC3066Name="ky-KG" LCID="1088" EnglishName="Kyrgyz (Kyrgyzstan)" ISO639_1="ky" ISO639_2="kir" WindowsTLA="KYR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ky-KG"/>
	</LocCulture>
	<LocCulture RFC3066Name="sw" LCID="65" EnglishName="Kiswahili" ISO639_1="sw" ISO639_2="swa" WindowsTLA="SWK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sw">
		<LocCulture RFC3066Name="sw-KE" LCID="1089" EnglishName="Kiswahili (Kenya)" ISO639_1="sw" ISO639_2="swa" WindowsTLA="SWK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sw-KE"/>
	</LocCulture>
	<LocCulture RFC3066Name="tk" LCID="66" EnglishName="Turkmen" ISO639_1="tk" ISO639_2="tuk" WindowsTLA="TUK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tk-TM" LCID="1090" EnglishName="Turkmen (Turkmenistan)" ISO639_1="tk" ISO639_2="tuk" WindowsTLA="TUK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="uz" LCID="67" EnglishName="Uzbek" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="uz">
		<LocCulture RFC3066Name="uz-Latn-UZ" LCID="1091" EnglishName="Uzbek (Latin, Uzbekistan)" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="uz-Cyrl-UZ" LCID="2115" EnglishName="Uzbek (Cyrillic, Uzbekistan)" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
  	<LocCulture RFC3066Name="tt" LCID="68" EnglishName="Tatar" ISO639_1="tt" ISO639_2="tat" WindowsTLA="TTT" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="tt">
		<LocCulture RFC3066Name="tt-RU" LCID="1092" EnglishName="Tatar (Russia)" ISO639_1="tt" ISO639_2="tat" WindowsTLA="TTT" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="tt-RU"/>
	</LocCulture>
	<LocCulture RFC3066Name="bn" LCID="69" EnglishName="Bengali" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNG" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="bn-IN" LCID="1093" EnglishName="Bengali (India)" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNG" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="bn-BD" LCID="2117" EnglishName="Bengali (Bangladesh)" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="pa" LCID="70" EnglishName="Punjabi" ISO639_1="pa" ISO639_2="pan" WindowsTLA="PAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="pa">
		<LocCulture RFC3066Name="pa-IN" LCID="1094" EnglishName="Punjabi (India)" ISO639_1="pa" ISO639_2="pan" WindowsTLA="PAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="pa-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="gu" LCID="71" EnglishName="Gujarati" ISO639_1="gu" ISO639_2="guj" WindowsTLA="GUJ" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="gu">
		<LocCulture RFC3066Name="gu-IN" LCID="1095" EnglishName="Gujarati (India)" ISO639_1="gu" ISO639_2="guj" WindowsTLA="GUJ" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="gu-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="or" LCID="72" EnglishName="Oriya" ISO639_1="or" ISO639_2="ori" WindowsTLA="ORI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="or-IN" LCID="1096" EnglishName="Oriya (India)" ISO639_1="or" ISO639_2="ori" WindowsTLA="ORI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ta" LCID="73" EnglishName="Tamil" ISO639_1="ta" ISO639_2="tam" WindowsTLA="TAM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ta">
		<LocCulture RFC3066Name="ta-IN" LCID="1097" EnglishName="Tamil (India)" ISO639_1="ta" ISO639_2="tam" WindowsTLA="TAM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ta-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="te" LCID="74" EnglishName="Telugu" ISO639_1="te" ISO639_2="tel" WindowsTLA="TEL" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="te">
		<LocCulture RFC3066Name="te-IN" LCID="1098" EnglishName="Telugu (India)" ISO639_1="te" ISO639_2="tel" WindowsTLA="TEL" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="te-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="kn" LCID="75" EnglishName="Kannada" ISO639_1="kn" ISO639_2="kan" WindowsTLA="KDI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kn">
		<LocCulture RFC3066Name="kn-IN" LCID="1099" EnglishName="Kannada (India)" ISO639_1="kn" ISO639_2="kan" WindowsTLA="KDI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kn-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="ml" LCID="76" EnglishName="Malayalam" ISO639_1="ml" ISO639_2="mym" WindowsTLA="MYM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ml-IN" LCID="1100" EnglishName="Malayalam (India)" ISO639_1="ml" ISO639_2="mym" WindowsTLA="MYM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="as" LCID="77" EnglishName="Assamese" ISO639_1="as" ISO639_2="asm" WindowsTLA="ASM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="as-IN" LCID="1101" EnglishName="Assamese (India)" ISO639_1="as" ISO639_2="asm" WindowsTLA="ASM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="mr" LCID="78" EnglishName="Marathi" ISO639_1="mr" ISO639_2="mar" WindowsTLA="MAR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="mr">
		<LocCulture RFC3066Name="mr-IN" LCID="1102" EnglishName="Marathi (India)" ISO639_1="mr" ISO639_2="mar" WindowsTLA="MAR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="mr-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="sa" LCID="79" EnglishName="Sanskrit" ISO639_1="sa" ISO639_2="san" WindowsTLA="SAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="sa">
		<LocCulture RFC3066Name="sa-IN" LCID="1103" EnglishName="Sanskrit (India)" ISO639_1="sa" ISO639_2="san" WindowsTLA="SAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="sa-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="mn" LCID="80" EnglishName="Mongolian" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNG" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn">
		<LocCulture RFC3066Name="mn-MN" LCID="1104" EnglishName="Mongolian (Cyrillic, Mongolia)" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNN" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn-MN"/>
		<LocCulture RFC3066Name="mn-Mong-CN" LCID="2128" EnglishName="Mongolian (Traditional Mongolian, PRC)" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNG" ANSICodePage="1251" OEMCodePage="1" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn-MN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="bo" LCID="81" EnglishName="Tibetan" ISO639_1="bo" ISO639_2="bod" WindowsTLA="BOB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="bo-CN" LCID="1105" EnglishName="Tibetan (PRC)" ISO639_1="bo" ISO639_2="bod" WindowsTLA="BOB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
     	</LocCulture>
    	<LocCulture RFC3066Name="cy" LCID="82" EnglishName="Welsh" ISO639_1="cy" ISO639_2="cym" WindowsTLA="CYM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="cy-GB" LCID="1106" EnglishName="Welsh (United Kingdom)" ISO639_1="cy" ISO639_2="cym" WindowsTLA="CYM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="km" LCID="83" EnglishName="Khmer" ISO639_1="km" ISO639_2="khm" WindowsTLA="KHM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="km-KH" LCID="1107" EnglishName="Khmer (Cambodia)" ISO639_1="km" ISO639_2="khm" WindowsTLA="KHM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="lo" LCID="84" EnglishName="Lao" ISO639_1="lo" ISO639_2="lao" WindowsTLA="LAO" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="lo-LA" LCID="1108" EnglishName="Lao (Lao P.D.R.)" ISO639_1="lo" ISO639_2="lao" WindowsTLA="LAO" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="gl" LCID="86" EnglishName="Galician" ISO639_1="gl" ISO639_2="glg" WindowsTLA="GLC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="gl">
		<LocCulture RFC3066Name="gl-ES" LCID="1110" EnglishName="Galician (Galician)" ISO639_1="gl" ISO639_2="glg" WindowsTLA="GLC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="gl-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="kok" LCID="87" EnglishName="Konkani" ISO639_1="kok" ISO639_2="kok" WindowsTLA="KNK" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kok">
		<LocCulture RFC3066Name="kok-IN" LCID="1111" EnglishName="Konkani (India)" ISO639_1="kok" ISO639_2="kok" WindowsTLA="KNK" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kok-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="sd" LCID="89" EnglishName="Sindhi" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        	<LocCulture RFC3066Name="sd-IN" LCID="1113" EnglishName="Sindhi (India)" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
        	<LocCulture RFC3066Name="sd-PK" LCID="2137" EnglishName="Sindhi (Pakistan)" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="syr" LCID="90" EnglishName="Syriac" ISO639_1="syr" ISO639_2="syr" WindowsTLA="SYR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="syr">
		<LocCulture RFC3066Name="syr-SY" LCID="1114" EnglishName="Syriac (Syria)" ISO639_1="syr" ISO639_2="syr" WindowsTLA="SYR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="syr-SY"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="si" LCID="91" EnglishName="Sinhala" ISO639_1="si" ISO639_2="sin" WindowsTLA="SIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="si-LK" LCID="1115" EnglishName="Sinhala (Sri Lanka)" ISO639_1="si" ISO639_2="sin" WindowsTLA="SIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="iu" LCID="93" EnglishName="Inuktitut" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="iu-Cans-CA" LCID="1117" EnglishName="Inuktitut (Syllabics, Canada)" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUS" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        	<LocCulture RFC3066Name="iu-Latn-CA" LCID="2141" EnglishName="Inuktitut (Latin, Canada)" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="am" LCID="94" EnglishName="Amharic" ISO639_1="am" ISO639_2="amh" WindowsTLA="AMH" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="am-ET" LCID="1118" EnglishName="Amharic (Ethiopia)" ISO639_1="am" ISO639_2="amh" WindowsTLA="AMH" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="tzm" LCID="95" EnglishName="Tamazight" ISO639_1="tzm" ISO639_2="tzm" WindowsTLA="TZM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="tzm-Latn-DZ" LCID="2143" EnglishName="Tamazight (Latin, Algeria)" ISO639_1="tzm" ISO639_2="tzm" WindowsTLA="TZM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="ne" LCID="97" EnglishName="Nepali" ISO639_1="ne" ISO639_2="nep" WindowsTLA="NEP" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ne-NP" LCID="1121" EnglishName="Nepali (Nepal)" ISO639_1="ne" ISO639_2="nep" WindowsTLA="NEP" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="fy" LCID="98" EnglishName="Frisian" ISO639_1="fy" ISO639_2="fry" WindowsTLA="FYN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="fy-NL" LCID="1122" EnglishName="Frisian (Netherlands)" ISO639_1="fy" ISO639_2="fry" WindowsTLA="FYN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="ps" LCID="99" EnglishName="Pashto" ISO639_1="ps" ISO639_2="pus" WindowsTLA="PAS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        	<LocCulture RFC3066Name="ps-AF" LCID="1123" EnglishName="Pashto (Afghanistan)" ISO639_1="ps" ISO639_2="pus" WindowsTLA="PAS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="fil" LCID="100" EnglishName="Filipino" ISO639_1="fil" ISO639_2="fil" WindowsTLA="FPO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="fil-PH" LCID="1124" EnglishName="Filipino (Philippines)" ISO639_1="fil" ISO639_2="fil" WindowsTLA="FPO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    <LocCulture RFC3066Name="dv" LCID="101" EnglishName="Divehi" ISO639_1="dv" ISO639_2="div" WindowsTLA="DIV" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="ar">
		<LocCulture RFC3066Name="dv-MV" LCID="1125" EnglishName="Divehi (Maldives)" ISO639_1="dv" ISO639_2="div" WindowsTLA="DIV" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="ar"/>
    </LocCulture>
    <LocCulture RFC3066Name="ha" LCID="104" EnglishName="Hausa" ISO639_1="ha" ISO639_2="hau" WindowsTLA="HAU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ha-Latn-NG" LCID="1128" EnglishName="Hausa (Latin, Nigeria)" ISO639_1="ha" ISO639_2="hau" WindowsTLA="HAU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="yo" LCID="106" EnglishName="Yoruba" ISO639_1="yo" ISO639_2="yor" WindowsTLA="YOR" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="yo-NG" LCID="1130" EnglishName="Yoruba (Nigeria)" ISO639_1="yo" ISO639_2="yor" WindowsTLA="YOR" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="quz" LCID="107" EnglishName="Quechua" ISO639_1="quz" ISO639_2="qub" WindowsTLA="QUB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="quz-BO" LCID="1131" EnglishName="Quechua (Bolivia)" ISO639_1="quz" ISO639_2="qub" WindowsTLA="QUB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="quz-EC" LCID="2155" EnglishName="Quechua (Ecuador)" ISO639_1="quz" ISO639_2="que" WindowsTLA="QUE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="quz-PE" LCID="3179" EnglishName="Quechua (Peru)" ISO639_1="quz" ISO639_2="qup" WindowsTLA="QUP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="nso" LCID="108" EnglishName="Sesotho sa Leboa" ISO639_1="nso" ISO639_2="nso" WindowsTLA="NSO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="nso-ZA" LCID="1132" EnglishName="Sesotho sa Leboa (South Africa)" ISO639_1="nso" ISO639_2="nso" WindowsTLA="NSO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="ba" LCID="109" EnglishName="Bashkir" ISO639_1="ba" ISO639_2="bak" WindowsTLA="BAS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ba-RU" LCID="1133" EnglishName="Bashkir (Russia)" ISO639_1="ba" ISO639_2="bak" WindowsTLA="BAS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="lb" LCID="110" EnglishName="Luxembourgish" ISO639_1="lb" ISO639_2="ltz" WindowsTLA="LBX" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="lb-LU" LCID="1134" EnglishName="Luxembourgish (Luxembourg)" ISO639_1="lb" ISO639_2="ltz" WindowsTLA="LBX" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="kl" LCID="111" EnglishName="Greenlandic" ISO639_1="kl" ISO639_2="kal" WindowsTLA="KAL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="kl-GL" LCID="1135" EnglishName="Greenlandic (Greenland)" ISO639_1="kl" ISO639_2="kal" WindowsTLA="KAL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="ig" LCID="112" EnglishName="Igbo" ISO639_1="ig" ISO639_2="ibo" WindowsTLA="IBO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ig-NG" LCID="1136" EnglishName="Igbo (Nigeria)" ISO639_1="ig" ISO639_2="ibo" WindowsTLA="IBO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="so" LCID="119" EnglishName="Somali" ISO639_1="so" ISO639_2="som" WindowsTLA="SOM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="so-SO" LCID="1143" EnglishName="Somali (Somalia)" ISO639_1="so" ISO639_2="som" WindowsTLA="SOM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="ii" LCID="120" EnglishName="Yi" ISO639_1="ii" ISO639_2="iii" WindowsTLA="III" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="ii-CN" LCID="1144" EnglishName="Yi (PRC)" ISO639_1="ii" ISO639_2="iii" WindowsTLA="III" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="arn" LCID="122" EnglishName="Mapudungun" ISO639_1="arn" ISO639_2="arn" WindowsTLA="MPD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="arn-CL" LCID="1146" EnglishName="Mapudungun (Chile)" ISO639_1="arn" ISO639_2="arn" WindowsTLA="MPD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="moh" LCID="124" EnglishName="Mohawk" ISO639_1="moh" ISO639_2="moh" WindowsTLA="MWK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="moh-CA" LCID="1148" EnglishName="Mohawk (Mohawk)" ISO639_1="moh" ISO639_2="moh" WindowsTLA="MWK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="br" LCID="126" EnglishName="Breton" ISO639_1="br" ISO639_2="bre" WindowsTLA="BRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="br-FR" LCID="1150" EnglishName="Breton (France)" ISO639_1="br" ISO639_2="bre" WindowsTLA="BRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="ug" LCID="128" EnglishName="Uighur" ISO639_1="ug" ISO639_2="uig" WindowsTLA="UIG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        <LocCulture RFC3066Name="ug-CN" LCID="1152" EnglishName="Uighur (PRC)" ISO639_1="ug" ISO639_2="uig" WindowsTLA="UIG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    </LocCulture>
    <LocCulture RFC3066Name="mi" LCID="129" EnglishName="Maori" ISO639_1="mi" ISO639_2="mri" WindowsTLA="MRI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="mi-NZ" LCID="1153" EnglishName="Maori (New Zealand)" ISO639_1="mi" ISO639_2="mri" WindowsTLA="MRI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="oc" LCID="130" EnglishName="Occitan" ISO639_1="oc" ISO639_2="oci" WindowsTLA="OCI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="oc-FR" LCID="1154" EnglishName="Occitan (France)" ISO639_1="oc" ISO639_2="oci" WindowsTLA="OCI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="co" LCID="131" EnglishName="Corsican" ISO639_1="co" ISO639_2="cos" WindowsTLA="COS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="co-FR" LCID="1155" EnglishName="Corsican (France)" ISO639_1="co" ISO639_2="cos" WindowsTLA="COS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="gsw" LCID="132" EnglishName="Alsatian" ISO639_1="gsw" ISO639_2="gsw" WindowsTLA="GSW" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="gsw-FR" LCID="1156" EnglishName="Alsatian (France)" ISO639_1="gsw" ISO639_2="gsw" WindowsTLA="GSW" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="sah" LCID="133" EnglishName="Yakut" ISO639_1="sah" ISO639_2="sah" WindowsTLA="SAH" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="sah-RU" LCID="1157" EnglishName="Yakut (Russia)" ISO639_1="sah" ISO639_2="sah" WindowsTLA="SAH" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="qut" LCID="134" EnglishName="K'iche" ISO639_1="qut" ISO639_2="qut" WindowsTLA="QUT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="qut-GT" LCID="1158" EnglishName="K'iche (Guatemala)" ISO639_1="qut" ISO639_2="qut" WindowsTLA="QUT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="rw" LCID="135" EnglishName="Kinyarwanda" ISO639_1="rw" ISO639_2="kin" WindowsTLA="KIN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="rw-RW" LCID="1159" EnglishName="Kinyarwanda (Rwanda)" ISO639_1="rw" ISO639_2="kin" WindowsTLA="KIN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="wo" LCID="136" EnglishName="Wolof" ISO639_1="wo" ISO639_2="wol" WindowsTLA="WOL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="wo-SN" LCID="1160" EnglishName="Wolof (Senegal)" ISO639_1="wo" ISO639_2="wol" WindowsTLA="WOL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="prs" LCID="140" EnglishName="Dari" ISO639_1="prs" ISO639_2="prs" WindowsTLA="PRS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"> 
	    <LocCulture RFC3066Name="prs-AF" LCID="1164" EnglishName="Dari (Afghanistan)" ISO639_1="prs" ISO639_2="prs" WindowsTLA="PRS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/> 
    </LocCulture>
    <LocCulture RFC3066Name="bs" LCID="30746" EnglishName="Bosnian" ISO639_1="bs" ISO639_2="bsb" WindowsTLA="BSB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="bs-Latn-BA" LCID="5146" EnglishName="Bosnian (Latin, Bosnia and Herzegovina)" ISO639_1="bs" ISO639_2="bsb" WindowsTLA="BSB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="bs-Cyrl-BA" LCID="8218" EnglishName="Bosnian (Cyrillic, Bosnia and Herzegovina)" ISO639_1="bs" ISO639_2="bsc" WindowsTLA="BSC" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="zh-CHT" LCID="31748" EnglishName="Chinese (Traditional)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHT" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-CHT">
		<LocCulture RFC3066Name="zh-TW" LCID="1028" EnglishName="Chinese (Taiwan)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHT" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-TW"/>
		<LocCulture RFC3066Name="zh-HK" LCID="3076" EnglishName="Chinese (Hong Kong S.A.R.)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHH" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-HK"/>
		<LocCulture RFC3066Name="zh-MO" LCID="5124" EnglishName="Chinese (Macao S.A.R.)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHM" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-MO"/>
	</LocCulture>
    <LocCulture RFC3066Name="sr" LCID="31770" EnglishName="Serbian" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRB" ANSICodePage="1250" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="sr">
	<LocCulture RFC3066Name="sr-Latn-CS" LCID="2074" EnglishName="Serbian (Latin, Serbia and Montenegro)" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRL" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Cyrl-CS" LCID="3098" EnglishName="Serbian (Cyrillic, Serbia and Montenegro)" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRB" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Latn-BA" LCID="6170" EnglishName="Serbian (Latin, Bosnia and Herzegovina)" ISO639_1="sr" ISO639_2="SRS" WindowsTLA="SRS" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Cyrl-BA" LCID="7194" EnglishName="Serbian (Cyrillic, Bosnia and Herzegovina)" ISO639_1="sr" ISO639_2="SRN" WindowsTLA="SRN" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="neu" LCID="0" EnglishName="Neutral" ISO639_1="neu" ISO639_2="neu" WindowsTLA="NEU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
	<LocCulture RFC3066Name="ned" LCID="1024" EnglishName="Neutral (Default)" ISO639_1="ned" ISO639_2="ned" WindowsTLA="NED" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="nes" LCID="2048" EnglishName="Neutral (Sys. Default)" ISO639_1="nes" ISO639_2="nes" WindowsTLA="NES" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
</LocCultures>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\readme.txt ===
Update history
==============

11/08/2006  LSBuild 1.5 QFE8 roll-up package.
11/08/2006  loomsettings.reg.template (Mars0.1, CWD)
03/25/2008  Picked up QFE9 + lcxadmin.exe and lcxman.dll in QFE9 rollup
05/01/2008  Added lcxutils.exe from QFE9 rollup.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\LocCultures.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<LocCultures>
  <LocCulture RFC3066Name="ar" LCID="1" EnglishName="Arabic" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
		<LocCulture RFC3066Name="ar-SA" LCID="1025" EnglishName="Arabic (Saudi Arabia)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SA"/>
		<LocCulture RFC3066Name="ar-IQ" LCID="2049" EnglishName="Arabic (Iraq)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARI" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-IQ"/>
		<LocCulture RFC3066Name="ar-EG" LCID="3073" EnglishName="Arabic (Egypt)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARE" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-EG"/>
		<LocCulture RFC3066Name="ar-LY" LCID="4097" EnglishName="Arabic (Libya)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARL" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-LY"/>
		<LocCulture RFC3066Name="ar-DZ" LCID="5121" EnglishName="Arabic (Algeria)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-DZ"/>
		<LocCulture RFC3066Name="ar-MA" LCID="6145" EnglishName="Arabic (Morocco)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARM" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-MA"/>
		<LocCulture RFC3066Name="ar-TN" LCID="7169" EnglishName="Arabic (Tunisia)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ART" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-TN"/>
		<LocCulture RFC3066Name="ar-OM" LCID="8193" EnglishName="Arabic (Oman)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARO" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-OM"/>
		<LocCulture RFC3066Name="ar-YE" LCID="9217" EnglishName="Arabic (Yemen)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARY" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-YE"/>
		<LocCulture RFC3066Name="ar-SY" LCID="10241" EnglishName="Arabic (Syria)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SY"/>
		<LocCulture RFC3066Name="ar-JO" LCID="11265" EnglishName="Arabic (Jordan)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARJ" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-JO"/>
		<LocCulture RFC3066Name="ar-LB" LCID="12289" EnglishName="Arabic (Lebanon)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARB" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-LB"/>
		<LocCulture RFC3066Name="ar-KW" LCID="13313" EnglishName="Arabic (Kuwait)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARK" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-KW"/>
		<LocCulture RFC3066Name="ar-AE" LCID="14337" EnglishName="Arabic (U.A.E.)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARU" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-AE"/>
		<LocCulture RFC3066Name="ar-BH" LCID="15361" EnglishName="Arabic (Bahrain)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARH" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-BH"/>
		<LocCulture RFC3066Name="ar-QA" LCID="16385" EnglishName="Arabic (Qatar)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARQ" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-QA"/>
                <LocCulture RFC3066Name="qps-plocm" LCID="2559" EnglishName="Pseudo (Mirror)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SA" />
	</LocCulture>
	<LocCulture RFC3066Name="bg" LCID="2" EnglishName="Bulgarian" ISO639_1="bg" ISO639_2="bul" WindowsTLA="BGR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="bg">
		<LocCulture RFC3066Name="bg-BG" LCID="1026" EnglishName="Bulgarian (Bulgaria)" ISO639_1="bg" ISO639_2="bul" WindowsTLA="BGR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="bg-BG"/>
	</LocCulture>
	<LocCulture RFC3066Name="ca" LCID="3" EnglishName="Catalan" ISO639_1="ca" ISO639_2="cat" WindowsTLA="CAT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ca">
		<LocCulture RFC3066Name="ca-ES" LCID="1027" EnglishName="Catalan (Catalan)" ISO639_1="ca" ISO639_2="cat" WindowsTLA="CAT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ca-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="zh-CHS" LCID="4" EnglishName="Chinese (Simplified)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHS" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-CHS">
		<LocCulture RFC3066Name="zh-CN" LCID="2052" EnglishName="Chinese (PRC)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHS" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-CN"/>
		<LocCulture RFC3066Name="zh-SG" LCID="4100" EnglishName="Chinese (Singapore)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHI" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-SG"/>
	</LocCulture>
	<LocCulture RFC3066Name="cs" LCID="5" EnglishName="Czech" ISO639_1="cs" ISO639_2="ces" WindowsTLA="CSY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="cs">
		<LocCulture RFC3066Name="cs-CZ" LCID="1029" EnglishName="Czech (Czech Republic)" ISO639_1="cs" ISO639_2="ces" WindowsTLA="CSY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="cs-CZ"/>
	</LocCulture>
	<LocCulture RFC3066Name="da" LCID="6" EnglishName="Danish" ISO639_1="da" ISO639_2="dan" WindowsTLA="DAN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="da">
		<LocCulture RFC3066Name="da-DK" LCID="1030" EnglishName="Danish (Denmark)" ISO639_1="da" ISO639_2="dan" WindowsTLA="DAN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="da-DK"/>
	</LocCulture>
	<LocCulture RFC3066Name="de" LCID="7" EnglishName="German" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de">
		<LocCulture RFC3066Name="de-DE" LCID="1031" EnglishName="German (Germany)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-DE"/>
		<LocCulture RFC3066Name="de-CH" LCID="2055" EnglishName="German (Switzerland)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DES" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-CH"/>
		<LocCulture RFC3066Name="de-AT" LCID="3079" EnglishName="German (Austria)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-AT"/>
		<LocCulture RFC3066Name="de-LU" LCID="4103" EnglishName="German (Luxembourg)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-LU"/>
		<LocCulture RFC3066Name="de-LI" LCID="5127" EnglishName="German (Liechtenstein)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-LI"/>
	</LocCulture>
	<LocCulture RFC3066Name="el" LCID="8" EnglishName="Greek" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="737" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el">
		<LocCulture RFC3066Name="el-GR" LCID="1032" EnglishName="Greek (Greece)" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="737" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el-GR"/>
		<LocCulture RFC3066Name="el-GR-2" LCID="8200" EnglishName="Greek 2 (Greece)" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="869" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el-GR"/>
    	</LocCulture>
	<LocCulture RFC3066Name="en" LCID="9" EnglishName="English" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en">
		<LocCulture RFC3066Name="en-US" LCID="1033" EnglishName="English (United States)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-US"/>
		<LocCulture RFC3066Name="en-GB" LCID="2057" EnglishName="English (United Kingdom)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/>
		<LocCulture RFC3066Name="en-AU" LCID="3081" EnglishName="English (Australia)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-AU"/>
		<LocCulture RFC3066Name="en-CA" LCID="4105" EnglishName="English (Canada)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-CA"/>
		<LocCulture RFC3066Name="en-NZ" LCID="5129" EnglishName="English (New Zealand)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENZ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-NZ"/>
		<LocCulture RFC3066Name="en-IE" LCID="6153" EnglishName="English (Ireland)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-IE"/>
		<LocCulture RFC3066Name="en-ZA" LCID="7177" EnglishName="English (South Africa)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENS" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-ZA"/>
		<LocCulture RFC3066Name="en-JM" LCID="8201" EnglishName="English (Jamaica)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENJ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-JM"/>
		<LocCulture RFC3066Name="en-029" LCID="9225" EnglishName="English (Caribbean)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="en-BZ" LCID="10249" EnglishName="English (Belize)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-BZ"/>
		<LocCulture RFC3066Name="en-TT" LCID="11273" EnglishName="English (Trinidad and Tobago)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-TT"/>
		<LocCulture RFC3066Name="en-ZW" LCID="12297" EnglishName="English (Zimbabwe)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENW" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-ZW"/>
		<LocCulture RFC3066Name="en-PH" LCID="13321" EnglishName="English (Republic of the Philippines)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENP" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-PH"/>
		<LocCulture RFC3066Name="en-IN" LCID="16393" EnglishName="English (India)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/> 
		<LocCulture RFC3066Name="en-MY" LCID="17417" EnglishName="English (Malaysia)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENM" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/>
		<LocCulture RFC3066Name="en-SG" LCID="18441" EnglishName="English (Singapore)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENE" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/> 
                <LocCulture RFC3066Name="qps-ploc" LCID="1281" EnglishName="Pseudo Language (Pseudo Country)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="en-US" />
	</LocCulture>
	<LocCulture RFC3066Name="es" LCID="10" EnglishName="Spanish" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es">
        	<LocCulture RFC3066Name="es-es_tradnl" LCID="1034" EnglishName="Spanish, Traditional Sort (Spain)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="es-MX" LCID="2058" EnglishName="Spanish (Mexico)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-MX"/>
		<LocCulture RFC3066Name="es-ES" LCID="3082" EnglishName="Spanish, International Sort (Spain)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-ES"/>
		<LocCulture RFC3066Name="es-GT" LCID="4106" EnglishName="Spanish (Guatemala)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-GT"/>
		<LocCulture RFC3066Name="es-CR" LCID="5130" EnglishName="Spanish (Costa Rica)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CR"/>
		<LocCulture RFC3066Name="es-PA" LCID="6154" EnglishName="Spanish (Panama)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PA"/>
		<LocCulture RFC3066Name="es-DO" LCID="7178" EnglishName="Spanish (Dominican Republic)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-DO"/>
		<LocCulture RFC3066Name="es-VE" LCID="8202" EnglishName="Spanish (Venezuela)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESV" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-VE"/>
		<LocCulture RFC3066Name="es-CO" LCID="9226" EnglishName="Spanish (Colombia)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CO"/>
		<LocCulture RFC3066Name="es-PE" LCID="10250" EnglishName="Spanish (Peru)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PE"/>
		<LocCulture RFC3066Name="es-AR" LCID="11274" EnglishName="Spanish (Argentina)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-AR"/>
		<LocCulture RFC3066Name="es-EC" LCID="12298" EnglishName="Spanish (Ecuador)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-EC"/>
		<LocCulture RFC3066Name="es-CL" LCID="13322" EnglishName="Spanish (Chile)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CL"/>
		<LocCulture RFC3066Name="es-UY" LCID="14346" EnglishName="Spanish (Uruguay)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESY" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-UY"/>
		<LocCulture RFC3066Name="es-PY" LCID="15370" EnglishName="Spanish (Paraguay)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESZ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PY"/>
		<LocCulture RFC3066Name="es-BO" LCID="16394" EnglishName="Spanish (Bolivia)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-BO"/>
		<LocCulture RFC3066Name="es-SV" LCID="17418" EnglishName="Spanish (El Salvador)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-SV"/>
		<LocCulture RFC3066Name="es-HN" LCID="18442" EnglishName="Spanish (Honduras)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESH" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-HN"/>
		<LocCulture RFC3066Name="es-NI" LCID="19466" EnglishName="Spanish (Nicaragua)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-NI"/>
		<LocCulture RFC3066Name="es-PR" LCID="20490" EnglishName="Spanish (Puerto Rico)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PR"/>
		<LocCulture RFC3066Name="es-US" LCID="21514" EnglishName="Spanish (United States)" ISO639_1="es" ISO639_2="spa" WindowsTLA="EST" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es"/>
	</LocCulture>
	<LocCulture RFC3066Name="fi" LCID="11" EnglishName="Finnish" ISO639_1="fi" ISO639_2="fin" WindowsTLA="FIN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fi">
		<LocCulture RFC3066Name="fi-FI" LCID="1035" EnglishName="Finnish (Finland)" ISO639_1="fi" ISO639_2="fin" WindowsTLA="FIN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fi-FI"/>
	</LocCulture>
	<LocCulture RFC3066Name="fr" LCID="12" EnglishName="French" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr">
		<LocCulture RFC3066Name="fr-FR" LCID="1036" EnglishName="French (France)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-FR"/>
		<LocCulture RFC3066Name="fr-BE" LCID="2060" EnglishName="French (Belgium)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-BE"/>
		<LocCulture RFC3066Name="fr-CA" LCID="3084" EnglishName="French (Canada)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-CA"/>
		<LocCulture RFC3066Name="fr-CH" LCID="4108" EnglishName="French (Switzerland)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-CH"/>
		<LocCulture RFC3066Name="fr-LU" LCID="5132" EnglishName="French (Luxembourg)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-LU"/>
		<LocCulture RFC3066Name="fr-MC" LCID="6156" EnglishName="French (Monaco)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-MC"/>
	</LocCulture>
	<LocCulture RFC3066Name="he" LCID="13" EnglishName="Hebrew" ISO639_1="he" ISO639_2="heb" WindowsTLA="HEB" ANSICodePage="1255" OEMCodePage="862" MacCodePage="10005" RightToLeft="1" BuiltInCultureInfo="he">
		<LocCulture RFC3066Name="he-IL" LCID="1037" EnglishName="Hebrew (Israel)" ISO639_1="he" ISO639_2="heb" WindowsTLA="HEB" ANSICodePage="1255" OEMCodePage="862" MacCodePage="10005" RightToLeft="1" BuiltInCultureInfo="he-IL"/>
	</LocCulture>
	<LocCulture RFC3066Name="hu" LCID="14" EnglishName="Hungarian" ISO639_1="hu" ISO639_2="hun" WindowsTLA="HUN" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="hu">
		<LocCulture RFC3066Name="hu-HU" LCID="1038" EnglishName="Hungarian (Hungary)" ISO639_1="hu" ISO639_2="hun" WindowsTLA="HUN" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="hu-HU"/>
	</LocCulture>
	<LocCulture RFC3066Name="is" LCID="15" EnglishName="Icelandic" ISO639_1="is" ISO639_2="isl" WindowsTLA="ISL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="is">
		<LocCulture RFC3066Name="is-IS" LCID="1039" EnglishName="Icelandic (Iceland)" ISO639_1="is" ISO639_2="isl" WindowsTLA="ISL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="is-IS"/>
	</LocCulture>
	<LocCulture RFC3066Name="it" LCID="16" EnglishName="Italian" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it">
		<LocCulture RFC3066Name="it-IT" LCID="1040" EnglishName="Italian (Italy)" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it-IT"/>
		<LocCulture RFC3066Name="it-CH" LCID="2064" EnglishName="Italian (Switzerland)" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it-CH"/>
	</LocCulture>
	<LocCulture RFC3066Name="ja" LCID="17" EnglishName="Japanese" ISO639_1="ja" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja">
		<LocCulture RFC3066Name="ja-JP" LCID="1041" EnglishName="Japanese (Japan)" ISO639_1="ja" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja-JP"/>
                <LocCulture RFC3066Name="qps-ploca" LCID="1534" EnglishName="Pseudo (Asia)" ISO639_1="qps" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja-JP" />
	</LocCulture>
	<LocCulture RFC3066Name="ko" LCID="18" EnglishName="Korean" ISO639_1="ko" ISO639_2="kor" WindowsTLA="KOR" ANSICodePage="949" OEMCodePage="949" MacCodePage="10003" RightToLeft="0" BuiltInCultureInfo="ko">
		<LocCulture RFC3066Name="ko-KR" LCID="1042" EnglishName="Korean (Korea)" ISO639_1="ko" ISO639_2="kor" WindowsTLA="KOR" ANSICodePage="949" OEMCodePage="949" MacCodePage="10003" RightToLeft="0" BuiltInCultureInfo="ko-KR"/>
	</LocCulture>
	<LocCulture RFC3066Name="nl" LCID="19" EnglishName="Dutch" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl">
		<LocCulture RFC3066Name="nl-NL" LCID="1043" EnglishName="Dutch (Netherlands)" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl-NL"/>
		<LocCulture RFC3066Name="nl-BE" LCID="2067" EnglishName="Dutch (Belgium)" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl-BE"/>
	</LocCulture>
	<LocCulture RFC3066Name="no" LCID="20" EnglishName="Norwegian" ISO639_1="no" ISO639_2="nor" WindowsTLA="NOR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="no">
		<LocCulture RFC3066Name="nb-NO" LCID="1044" EnglishName="Norwegian, Bokmål (Norway)" ISO639_1="nb" ISO639_2="nob" WindowsTLA="NOR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nb-NO"/>
		<LocCulture RFC3066Name="nn-NO" LCID="2068" EnglishName="Norwegian, Nynorsk (Norway)" ISO639_1="nn" ISO639_2="nno" WindowsTLA="NON" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nn-NO"/>
	</LocCulture>
	<LocCulture RFC3066Name="pl" LCID="21" EnglishName="Polish" ISO639_1="pl" ISO639_2="pol" WindowsTLA="PLK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="pl">
		<LocCulture RFC3066Name="pl-PL" LCID="1045" EnglishName="Polish (Poland)" ISO639_1="pl" ISO639_2="pol" WindowsTLA="PLK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="pl-PL"/>
	</LocCulture>
	<LocCulture RFC3066Name="pt" LCID="22" EnglishName="Portuguese" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt">
		<LocCulture RFC3066Name="pt-BR" LCID="1046" EnglishName="Portuguese (Brazil)" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt-BR"/>
		<LocCulture RFC3066Name="pt-PT" LCID="2070" EnglishName="Portuguese (Portugal)" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt-PT"/>
	</LocCulture>
	<LocCulture RFC3066Name="rm" LCID="23" EnglishName="Romansh" ISO639_1="rm" ISO639_2="roh" WindowsTLA="RMC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="rm-CH" LCID="1047" EnglishName="Romansh (Switzerland)" ISO639_1="rm" ISO639_2="roh" WindowsTLA="RMC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ro" LCID="24" EnglishName="Romanian" ISO639_1="ro" ISO639_2="ron" WindowsTLA="ROM" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="ro">
		<LocCulture RFC3066Name="ro-RO" LCID="1048" EnglishName="Romanian (Romania)" ISO639_1="ro" ISO639_2="ron" WindowsTLA="ROM" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="ro-RO"/>
	</LocCulture>
	<LocCulture RFC3066Name="ru" LCID="25" EnglishName="Russian" ISO639_1="ru" ISO639_2="rus" WindowsTLA="RUS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ru">
		<LocCulture RFC3066Name="ru-RU" LCID="1049" EnglishName="Russian (Russia)" ISO639_1="ru" ISO639_2="rus" WindowsTLA="RUS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ru-RU"/>
	</LocCulture>
	<LocCulture RFC3066Name="hr" LCID="26" EnglishName="Croatian" ISO639_1="hr" ISO639_2="hrv" WindowsTLA="HRV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr">
		<LocCulture RFC3066Name="hr-HR" LCID="1050" EnglishName="Croatian (Croatia)" ISO639_1="hr" ISO639_2="hrv" WindowsTLA="HRV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr-HR"/>
		<LocCulture RFC3066Name="hr-BA" LCID="4122" EnglishName="Croatian (Latin, Bosnia and Herzegovina)" ISO639_1="hr" ISO639_2="hrb" WindowsTLA="HRB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr-HR"/>
	</LocCulture>
	<LocCulture RFC3066Name="sk" LCID="27" EnglishName="Slovak" ISO639_1="sk" ISO639_2="slk" WindowsTLA="SKY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sk">
		<LocCulture RFC3066Name="sk-SK" LCID="1051" EnglishName="Slovak (Slovakia)" ISO639_1="sk" ISO639_2="slk" WindowsTLA="SKY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sk-SK"/>
	</LocCulture>
	<LocCulture RFC3066Name="sq" LCID="28" EnglishName="Albanian" ISO639_1="sq" ISO639_2="sqi" WindowsTLA="SQI" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sq">
		<LocCulture RFC3066Name="sq-AL" LCID="1052" EnglishName="Albanian (Albania)" ISO639_1="sq" ISO639_2="sqi" WindowsTLA="SQI" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sq-AL"/>
	</LocCulture>
	<LocCulture RFC3066Name="sv" LCID="29" EnglishName="Swedish" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv">
		<LocCulture RFC3066Name="sv-SE" LCID="1053" EnglishName="Swedish (Sweden)" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv-SE"/>
		<LocCulture RFC3066Name="sv-FI" LCID="2077" EnglishName="Swedish (Finland)" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv-FI"/>
	</LocCulture>
	<LocCulture RFC3066Name="th" LCID="30" EnglishName="Thai" ISO639_1="th" ISO639_2="tha" WindowsTLA="THA" ANSICodePage="874" OEMCodePage="874" MacCodePage="10021" RightToLeft="0" BuiltInCultureInfo="th">
		<LocCulture RFC3066Name="th-TH" LCID="1054" EnglishName="Thai (Thailand)" ISO639_1="th" ISO639_2="tha" WindowsTLA="THA" ANSICodePage="874" OEMCodePage="874" MacCodePage="10021" RightToLeft="0" BuiltInCultureInfo="th-TH"/>
	</LocCulture>
	<LocCulture RFC3066Name="tr" LCID="31" EnglishName="Turkish" ISO639_1="tr" ISO639_2="tur" WindowsTLA="TRK" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="tr">
		<LocCulture RFC3066Name="tr-TR" LCID="1055" EnglishName="Turkish (Turkey)" ISO639_1="tr" ISO639_2="tur" WindowsTLA="TRK" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="tr-TR"/>
	</LocCulture>
	<LocCulture RFC3066Name="ur" LCID="32" EnglishName="Urdu" ISO639_1="ur" ISO639_2="urd" WindowsTLA="URD" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ur">
		<LocCulture RFC3066Name="ur-PK" LCID="1056" EnglishName="Urdu (Pakistan)" ISO639_1="ur" ISO639_2="urd" WindowsTLA="URD" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ur-PK"/>
	</LocCulture>
	<LocCulture RFC3066Name="id" LCID="33" EnglishName="Indonesian" ISO639_1="id" ISO639_2="ind" WindowsTLA="IND" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="id">
		<LocCulture RFC3066Name="id-ID" LCID="1057" EnglishName="Indonesian (Indonesia)" ISO639_1="id" ISO639_2="ind" WindowsTLA="IND" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="id-ID"/>
	</LocCulture>
	<LocCulture RFC3066Name="uk" LCID="34" EnglishName="Ukrainian" ISO639_1="uk" ISO639_2="ukr" WindowsTLA="UKR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10017" RightToLeft="0" BuiltInCultureInfo="uk">
		<LocCulture RFC3066Name="uk-UA" LCID="1058" EnglishName="Ukrainian (Ukraine)" ISO639_1="uk" ISO639_2="ukr" WindowsTLA="UKR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10017" RightToLeft="0" BuiltInCultureInfo="uk-UA"/>
	</LocCulture>
	<LocCulture RFC3066Name="be" LCID="35" EnglishName="Belarusian" ISO639_1="be" ISO639_2="bel" WindowsTLA="BEL" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="be">
		<LocCulture RFC3066Name="be-BY" LCID="1059" EnglishName="Belarusian (Belarus)" ISO639_1="be" ISO639_2="bel" WindowsTLA="BEL" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="be-BY"/>
	</LocCulture>
	<LocCulture RFC3066Name="sl" LCID="36" EnglishName="Slovenian" ISO639_1="sl" ISO639_2="slv" WindowsTLA="SLV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sl">
		<LocCulture RFC3066Name="sl-SI" LCID="1060" EnglishName="Slovenian (Slovenia)" ISO639_1="sl" ISO639_2="slv" WindowsTLA="SLV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sl-SI"/>
	</LocCulture>
	<LocCulture RFC3066Name="et" LCID="37" EnglishName="Estonian" ISO639_1="et" ISO639_2="est" WindowsTLA="ETI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="et">
		<LocCulture RFC3066Name="et-EE" LCID="1061" EnglishName="Estonian (Estonia)" ISO639_1="et" ISO639_2="est" WindowsTLA="ETI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="et-EE"/>
	</LocCulture>
	<LocCulture RFC3066Name="lv" LCID="38" EnglishName="Latvian" ISO639_1="lv" ISO639_2="lav" WindowsTLA="LVI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lv">
		<LocCulture RFC3066Name="lv-LV" LCID="1062" EnglishName="Latvian (Latvia)" ISO639_1="lv" ISO639_2="lav" WindowsTLA="LVI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lv-LV"/>
	</LocCulture>
	<LocCulture RFC3066Name="lt" LCID="39" EnglishName="Lithuanian" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTH" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt">
		<LocCulture RFC3066Name="lt-LT" LCID="1063" EnglishName="Lithuanian (Lithuania)" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTH" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt-LT"/>
		<LocCulture RFC3066Name="lt-LT-C" LCID="2087" EnglishName="Lithuanian, Classic (Lithuania)" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTC" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt-LT"/>
	</LocCulture>
	<LocCulture RFC3066Name="tg" LCID="40" EnglishName="Tajik" ISO639_1="tg" ISO639_2="tgk" WindowsTLA="TAJ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tg-Cyrl-TJ" LCID="1064" EnglishName="Tajik (Cyrillic, Tajikistan)" ISO639_1="tg" ISO639_2="tgk" WindowsTLA="TAJ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="fa" LCID="41" EnglishName="Persian" ISO639_1="fa" ISO639_2="fas" WindowsTLA="FAR" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="fa">
		<LocCulture RFC3066Name="fa-IR" LCID="1065" EnglishName="Persian (Iran)" ISO639_1="fa" ISO639_2="fas" WindowsTLA="FAR" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="fa-IR"/>
	</LocCulture>
	<LocCulture RFC3066Name="vi" LCID="42" EnglishName="Vietnamese" ISO639_1="vi" ISO639_2="vie" WindowsTLA="VIT" ANSICodePage="1258" OEMCodePage="1258" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="vi">
		<LocCulture RFC3066Name="vi-VN" LCID="1066" EnglishName="Vietnamese (Vietnam)" ISO639_1="vi" ISO639_2="vie" WindowsTLA="VIT" ANSICodePage="1258" OEMCodePage="1258" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="vi-VN"/>
	</LocCulture>
	<LocCulture RFC3066Name="hy" LCID="43" EnglishName="Armenian" ISO639_1="hy" ISO639_2="hye" WindowsTLA="HYE" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hy">
		<LocCulture RFC3066Name="hy-AM" LCID="1067" EnglishName="Armenian (Armenia)" ISO639_1="hy" ISO639_2="hye" WindowsTLA="HYE" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hy-AM"/>
	</LocCulture>
	<LocCulture RFC3066Name="az" LCID="44" EnglishName="Azeri" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZE" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="az">
		<LocCulture RFC3066Name="az-Latn-AZ" LCID="1068" EnglishName="Azeri (Latin, Azerbaijan)" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZE" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="az-Cyrl-AZ" LCID="2092" EnglishName="Azeri (Cyrillic, Azerbaijan)" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZC" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="eu" LCID="45" EnglishName="Basque" ISO639_1="eu" ISO639_2="eus" WindowsTLA="EUQ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="eu">
		<LocCulture RFC3066Name="eu-ES" LCID="1069" EnglishName="Basque (Basque)" ISO639_1="eu" ISO639_2="eus" WindowsTLA="EUQ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="eu-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="wen" LCID="46" EnglishName="Sorbian" ISO639_1="hs" ISO639_2="hsb" WindowsTLA="HSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="wen-DE" LCID="1070" EnglishName="Upper Sorbian (Germany)" ISO639_1="wen" ISO639_2="wen" WindowsTLA="HSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
	    <LocCulture RFC3066Name="dsb-DE" LCID="2094" EnglishName="Lower Sorbian (Germany)" ISO639_1="dsb" ISO639_2="dsb" WindowsTLA="DSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
	</LocCulture>
	<LocCulture RFC3066Name="mk" LCID="47" EnglishName="Macedonian" ISO639_1="mk" ISO639_2="mkd" WindowsTLA="MKI" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mk">
		<LocCulture RFC3066Name="mk-MK" LCID="1071" EnglishName="Macedonian (Former Yugoslav Republic of Macedonia)" ISO639_1="mk" ISO639_2="mkd" WindowsTLA="MKI" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mk-MK"/>
	</LocCulture>
	<LocCulture RFC3066Name="st" LCID="48" EnglishName="Sutu" ISO639_1="st" ISO639_2="sot" WindowsTLA="SOT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="st-ZA" LCID="1072" EnglishName="Sutu (South Africa)" ISO639_1="st" ISO639_2="sot" WindowsTLA="SOT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="tn" LCID="50" EnglishName="Setswana" ISO639_1="tn" ISO639_2="tsn" WindowsTLA="TSN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tn-ZA" LCID="1074" EnglishName="Setswana (South Africa)" ISO639_1="tn" ISO639_2="tsn" WindowsTLA="TSN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="xh" LCID="52" EnglishName="isiXhosa" ISO639_1="xh" ISO639_2="xho" WindowsTLA="XHO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="xh-ZA" LCID="1076" EnglishName="isiXhosa (South Africa)" ISO639_1="xh" ISO639_2="xho" WindowsTLA="XHO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>    
	<LocCulture RFC3066Name="zu" LCID="53" EnglishName="isiZulu" ISO639_1="zu" ISO639_2="zul" WindowsTLA="ZUL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="zu-ZA" LCID="1077" EnglishName="isiZulu (South Africa)" ISO639_1="zu" ISO639_2="zul" WindowsTLA="ZUL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>    
	<LocCulture RFC3066Name="af" LCID="54" EnglishName="Afrikaans" ISO639_1="af" ISO639_2="afr" WindowsTLA="AFK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="af">
		<LocCulture RFC3066Name="af-ZA" LCID="1078" EnglishName="Afrikaans (South Africa)" ISO639_1="af" ISO639_2="afr" WindowsTLA="AFK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="af-ZA"/>
	</LocCulture>
	<LocCulture RFC3066Name="ka" LCID="55" EnglishName="Georgian" ISO639_1="ka" ISO639_2="kat" WindowsTLA="KAT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ka">
		<LocCulture RFC3066Name="ka-GE" LCID="1079" EnglishName="Georgian (Georgia)" ISO639_1="ka" ISO639_2="kat" WindowsTLA="KAT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ka-GE"/>
	</LocCulture>
	<LocCulture RFC3066Name="fo" LCID="56" EnglishName="Faroese" ISO639_1="fo" ISO639_2="fao" WindowsTLA="FOS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="fo">
		<LocCulture RFC3066Name="fo-FO" LCID="1080" EnglishName="Faroese (Faroe Islands)" ISO639_1="fo" ISO639_2="fao" WindowsTLA="FOS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="fo-FO"/>
	</LocCulture>
	<LocCulture RFC3066Name="hi" LCID="57" EnglishName="Hindi" ISO639_1="hi" ISO639_2="hin" WindowsTLA="HIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hi">
		<LocCulture RFC3066Name="hi-IN" LCID="1081" EnglishName="Hindi (India)" ISO639_1="hi" ISO639_2="hin" WindowsTLA="HIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hi-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="mt" LCID="58" EnglishName="Maltese" ISO639_1="mt" ISO639_2="mlt" WindowsTLA="MLT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="mt-MT" LCID="1082" EnglishName="Maltese (Malta)" ISO639_1="mt" ISO639_2="mlt" WindowsTLA="MLT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
		<LocCulture RFC3066Name="se" LCID="59" EnglishName="Sami" ISO639_1="smi" ISO639_2="SME" WindowsTLA="SME" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="se-NO" LCID="1083" EnglishName="Sami, Northern (Norway)" ISO639_1="se" ISO639_2="sme" WindowsTLA="SME" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="se-SE" LCID="2107" EnglishName="Sami, Northern (Sweden)" ISO639_1="se" ISO639_2="smf" WindowsTLA="SMF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="se-FI" LCID="3131" EnglishName="Sami, Northern (Finland)" ISO639_1="se" ISO639_2="smg" WindowsTLA="SMG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smj-NO" LCID="4155" EnglishName="Sami, Lule (Norway)" ISO639_1="smj" ISO639_2="smj" WindowsTLA="SMJ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smj-SE" LCID="5179" EnglishName="Sami, Lule (Sweden)" ISO639_1="smj" ISO639_2="smk" WindowsTLA="SMK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sma-NO" LCID="6203" EnglishName="Sami, Southern (Norway)" ISO639_1="sma" ISO639_2="sma" WindowsTLA="SMA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sma-SE" LCID="7227" EnglishName="Sami, Southern (Sweden)" ISO639_1="sma" ISO639_2="SMB" WindowsTLA="SMB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sms-FI" LCID="8251" EnglishName="Sami, Skolt (Finland)" ISO639_1="sms" ISO639_2="sms" WindowsTLA="SMS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smn-FI" LCID="9275" EnglishName="Sami, Inari (Finland)" ISO639_1="smn" ISO639_2="smn" WindowsTLA="SMN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ga" LCID="60" EnglishName="Irish" ISO639_1="ga" ISO639_2="gle" WindowsTLA="IRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ga-GB" LCID="1084" EnglishName="Gaelic (Scotland)" ISO639_1="ga" ISO639_2="gle" WindowsTLA="GAE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="ga-IE" LCID="2108" EnglishName="Irish (Ireland)" ISO639_1="ga" ISO639_2="gle" WindowsTLA="IRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ms" LCID="62" EnglishName="Malay" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms">
		<LocCulture RFC3066Name="ms-MY" LCID="1086" EnglishName="Malay (Malaysia)" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms-MY"/>
		<LocCulture RFC3066Name="ms-BN" LCID="2110" EnglishName="Malay (Brunei Darussalam)" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms-BN"/>
	</LocCulture>
	<LocCulture RFC3066Name="kk" LCID="63" EnglishName="Kazakh" ISO639_1="kk" ISO639_2="kaz" WindowsTLA="KKZ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="kk">
		<LocCulture RFC3066Name="kk-KZ" LCID="1087" EnglishName="Kazakh (Kazakhstan)" ISO639_1="kk" ISO639_2="kaz" WindowsTLA="KKZ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="kk-KZ"/>
	</LocCulture>
	<LocCulture RFC3066Name="ky" LCID="64" EnglishName="Kyrgyz" ISO639_1="ky" ISO639_2="kir" WindowsTLA="KYR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ky">
		<LocCulture RFC3066Name="ky-KG" LCID="1088" EnglishName="Kyrgyz (Kyrgyzstan)" ISO639_1="ky" ISO639_2="kir" WindowsTLA="KYR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ky-KG"/>
	</LocCulture>
	<LocCulture RFC3066Name="sw" LCID="65" EnglishName="Kiswahili" ISO639_1="sw" ISO639_2="swa" WindowsTLA="SWK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sw">
		<LocCulture RFC3066Name="sw-KE" LCID="1089" EnglishName="Kiswahili (Kenya)" ISO639_1="sw" ISO639_2="swa" WindowsTLA="SWK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sw-KE"/>
	</LocCulture>
	<LocCulture RFC3066Name="tk" LCID="66" EnglishName="Turkmen" ISO639_1="tk" ISO639_2="tuk" WindowsTLA="TUK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tk-TM" LCID="1090" EnglishName="Turkmen (Turkmenistan)" ISO639_1="tk" ISO639_2="tuk" WindowsTLA="TUK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="uz" LCID="67" EnglishName="Uzbek" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="uz">
		<LocCulture RFC3066Name="uz-Latn-UZ" LCID="1091" EnglishName="Uzbek (Latin, Uzbekistan)" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="uz-Cyrl-UZ" LCID="2115" EnglishName="Uzbek (Cyrillic, Uzbekistan)" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
  	<LocCulture RFC3066Name="tt" LCID="68" EnglishName="Tatar" ISO639_1="tt" ISO639_2="tat" WindowsTLA="TTT" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="tt">
		<LocCulture RFC3066Name="tt-RU" LCID="1092" EnglishName="Tatar (Russia)" ISO639_1="tt" ISO639_2="tat" WindowsTLA="TTT" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="tt-RU"/>
	</LocCulture>
	<LocCulture RFC3066Name="bn" LCID="69" EnglishName="Bengali" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNG" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="bn-IN" LCID="1093" EnglishName="Bengali (India)" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNG" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="bn-BD" LCID="2117" EnglishName="Bengali (Bangladesh)" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="pa" LCID="70" EnglishName="Punjabi" ISO639_1="pa" ISO639_2="pan" WindowsTLA="PAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="pa">
		<LocCulture RFC3066Name="pa-IN" LCID="1094" EnglishName="Punjabi (India)" ISO639_1="pa" ISO639_2="pan" WindowsTLA="PAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="pa-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="gu" LCID="71" EnglishName="Gujarati" ISO639_1="gu" ISO639_2="guj" WindowsTLA="GUJ" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="gu">
		<LocCulture RFC3066Name="gu-IN" LCID="1095" EnglishName="Gujarati (India)" ISO639_1="gu" ISO639_2="guj" WindowsTLA="GUJ" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="gu-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="or" LCID="72" EnglishName="Oriya" ISO639_1="or" ISO639_2="ori" WindowsTLA="ORI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="or-IN" LCID="1096" EnglishName="Oriya (India)" ISO639_1="or" ISO639_2="ori" WindowsTLA="ORI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ta" LCID="73" EnglishName="Tamil" ISO639_1="ta" ISO639_2="tam" WindowsTLA="TAM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ta">
		<LocCulture RFC3066Name="ta-IN" LCID="1097" EnglishName="Tamil (India)" ISO639_1="ta" ISO639_2="tam" WindowsTLA="TAM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ta-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="te" LCID="74" EnglishName="Telugu" ISO639_1="te" ISO639_2="tel" WindowsTLA="TEL" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="te">
		<LocCulture RFC3066Name="te-IN" LCID="1098" EnglishName="Telugu (India)" ISO639_1="te" ISO639_2="tel" WindowsTLA="TEL" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="te-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="kn" LCID="75" EnglishName="Kannada" ISO639_1="kn" ISO639_2="kan" WindowsTLA="KDI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kn">
		<LocCulture RFC3066Name="kn-IN" LCID="1099" EnglishName="Kannada (India)" ISO639_1="kn" ISO639_2="kan" WindowsTLA="KDI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kn-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="ml" LCID="76" EnglishName="Malayalam" ISO639_1="ml" ISO639_2="mym" WindowsTLA="MYM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ml-IN" LCID="1100" EnglishName="Malayalam (India)" ISO639_1="ml" ISO639_2="mym" WindowsTLA="MYM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="as" LCID="77" EnglishName="Assamese" ISO639_1="as" ISO639_2="asm" WindowsTLA="ASM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="as-IN" LCID="1101" EnglishName="Assamese (India)" ISO639_1="as" ISO639_2="asm" WindowsTLA="ASM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="mr" LCID="78" EnglishName="Marathi" ISO639_1="mr" ISO639_2="mar" WindowsTLA="MAR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="mr">
		<LocCulture RFC3066Name="mr-IN" LCID="1102" EnglishName="Marathi (India)" ISO639_1="mr" ISO639_2="mar" WindowsTLA="MAR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="mr-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="sa" LCID="79" EnglishName="Sanskrit" ISO639_1="sa" ISO639_2="san" WindowsTLA="SAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="sa">
		<LocCulture RFC3066Name="sa-IN" LCID="1103" EnglishName="Sanskrit (India)" ISO639_1="sa" ISO639_2="san" WindowsTLA="SAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="sa-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="mn" LCID="80" EnglishName="Mongolian" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNG" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn">
		<LocCulture RFC3066Name="mn-MN" LCID="1104" EnglishName="Mongolian (Cyrillic, Mongolia)" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNN" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn-MN"/>
		<LocCulture RFC3066Name="mn-Mong-CN" LCID="2128" EnglishName="Mongolian (Traditional Mongolian, PRC)" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNG" ANSICodePage="1251" OEMCodePage="1" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn-MN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="bo" LCID="81" EnglishName="Tibetan" ISO639_1="bo" ISO639_2="bod" WindowsTLA="BOB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="bo-CN" LCID="1105" EnglishName="Tibetan (PRC)" ISO639_1="bo" ISO639_2="bod" WindowsTLA="BOB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
     	</LocCulture>
    	<LocCulture RFC3066Name="cy" LCID="82" EnglishName="Welsh" ISO639_1="cy" ISO639_2="cym" WindowsTLA="CYM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="cy-GB" LCID="1106" EnglishName="Welsh (United Kingdom)" ISO639_1="cy" ISO639_2="cym" WindowsTLA="CYM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="km" LCID="83" EnglishName="Khmer" ISO639_1="km" ISO639_2="khm" WindowsTLA="KHM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="km-KH" LCID="1107" EnglishName="Khmer (Cambodia)" ISO639_1="km" ISO639_2="khm" WindowsTLA="KHM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="lo" LCID="84" EnglishName="Lao" ISO639_1="lo" ISO639_2="lao" WindowsTLA="LAO" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="lo-LA" LCID="1108" EnglishName="Lao (Lao P.D.R.)" ISO639_1="lo" ISO639_2="lao" WindowsTLA="LAO" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="gl" LCID="86" EnglishName="Galician" ISO639_1="gl" ISO639_2="glg" WindowsTLA="GLC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="gl">
		<LocCulture RFC3066Name="gl-ES" LCID="1110" EnglishName="Galician (Galician)" ISO639_1="gl" ISO639_2="glg" WindowsTLA="GLC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="gl-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="kok" LCID="87" EnglishName="Konkani" ISO639_1="kok" ISO639_2="kok" WindowsTLA="KNK" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kok">
		<LocCulture RFC3066Name="kok-IN" LCID="1111" EnglishName="Konkani (India)" ISO639_1="kok" ISO639_2="kok" WindowsTLA="KNK" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kok-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="sd" LCID="89" EnglishName="Sindhi" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        	<LocCulture RFC3066Name="sd-IN" LCID="1113" EnglishName="Sindhi (India)" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
        	<LocCulture RFC3066Name="sd-PK" LCID="2137" EnglishName="Sindhi (Pakistan)" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="syr" LCID="90" EnglishName="Syriac" ISO639_1="syr" ISO639_2="syr" WindowsTLA="SYR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="syr">
		<LocCulture RFC3066Name="syr-SY" LCID="1114" EnglishName="Syriac (Syria)" ISO639_1="syr" ISO639_2="syr" WindowsTLA="SYR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="syr-SY"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="si" LCID="91" EnglishName="Sinhala" ISO639_1="si" ISO639_2="sin" WindowsTLA="SIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="si-LK" LCID="1115" EnglishName="Sinhala (Sri Lanka)" ISO639_1="si" ISO639_2="sin" WindowsTLA="SIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="iu" LCID="93" EnglishName="Inuktitut" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="iu-Cans-CA" LCID="1117" EnglishName="Inuktitut (Syllabics, Canada)" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUS" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        	<LocCulture RFC3066Name="iu-Latn-CA" LCID="2141" EnglishName="Inuktitut (Latin, Canada)" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="am" LCID="94" EnglishName="Amharic" ISO639_1="am" ISO639_2="amh" WindowsTLA="AMH" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="am-ET" LCID="1118" EnglishName="Amharic (Ethiopia)" ISO639_1="am" ISO639_2="amh" WindowsTLA="AMH" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="tzm" LCID="95" EnglishName="Tamazight" ISO639_1="tzm" ISO639_2="tzm" WindowsTLA="TZM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="tzm-Latn-DZ" LCID="2143" EnglishName="Tamazight (Latin, Algeria)" ISO639_1="tzm" ISO639_2="tzm" WindowsTLA="TZM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="ne" LCID="97" EnglishName="Nepali" ISO639_1="ne" ISO639_2="nep" WindowsTLA="NEP" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ne-NP" LCID="1121" EnglishName="Nepali (Nepal)" ISO639_1="ne" ISO639_2="nep" WindowsTLA="NEP" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="fy" LCID="98" EnglishName="Frisian" ISO639_1="fy" ISO639_2="fry" WindowsTLA="FYN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="fy-NL" LCID="1122" EnglishName="Frisian (Netherlands)" ISO639_1="fy" ISO639_2="fry" WindowsTLA="FYN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="ps" LCID="99" EnglishName="Pashto" ISO639_1="ps" ISO639_2="pus" WindowsTLA="PAS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        	<LocCulture RFC3066Name="ps-AF" LCID="1123" EnglishName="Pashto (Afghanistan)" ISO639_1="ps" ISO639_2="pus" WindowsTLA="PAS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="fil" LCID="100" EnglishName="Filipino" ISO639_1="fil" ISO639_2="fil" WindowsTLA="FPO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="fil-PH" LCID="1124" EnglishName="Filipino (Philippines)" ISO639_1="fil" ISO639_2="fil" WindowsTLA="FPO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    <LocCulture RFC3066Name="dv" LCID="101" EnglishName="Divehi" ISO639_1="dv" ISO639_2="div" WindowsTLA="DIV" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="ar">
		<LocCulture RFC3066Name="dv-MV" LCID="1125" EnglishName="Divehi (Maldives)" ISO639_1="dv" ISO639_2="div" WindowsTLA="DIV" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="ar"/>
    </LocCulture>
    <LocCulture RFC3066Name="ha" LCID="104" EnglishName="Hausa" ISO639_1="ha" ISO639_2="hau" WindowsTLA="HAU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ha-Latn-NG" LCID="1128" EnglishName="Hausa (Latin, Nigeria)" ISO639_1="ha" ISO639_2="hau" WindowsTLA="HAU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="yo" LCID="106" EnglishName="Yoruba" ISO639_1="yo" ISO639_2="yor" WindowsTLA="YOR" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="yo-NG" LCID="1130" EnglishName="Yoruba (Nigeria)" ISO639_1="yo" ISO639_2="yor" WindowsTLA="YOR" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="quz" LCID="107" EnglishName="Quechua" ISO639_1="quz" ISO639_2="qub" WindowsTLA="QUB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="quz-BO" LCID="1131" EnglishName="Quechua (Bolivia)" ISO639_1="quz" ISO639_2="qub" WindowsTLA="QUB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="quz-EC" LCID="2155" EnglishName="Quechua (Ecuador)" ISO639_1="quz" ISO639_2="que" WindowsTLA="QUE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="quz-PE" LCID="3179" EnglishName="Quechua (Peru)" ISO639_1="quz" ISO639_2="qup" WindowsTLA="QUP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="nso" LCID="108" EnglishName="Sesotho sa Leboa" ISO639_1="nso" ISO639_2="nso" WindowsTLA="NSO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="nso-ZA" LCID="1132" EnglishName="Sesotho sa Leboa (South Africa)" ISO639_1="nso" ISO639_2="nso" WindowsTLA="NSO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="ba" LCID="109" EnglishName="Bashkir" ISO639_1="ba" ISO639_2="bak" WindowsTLA="BAS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ba-RU" LCID="1133" EnglishName="Bashkir (Russia)" ISO639_1="ba" ISO639_2="bak" WindowsTLA="BAS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="lb" LCID="110" EnglishName="Luxembourgish" ISO639_1="lb" ISO639_2="ltz" WindowsTLA="LBX" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="lb-LU" LCID="1134" EnglishName="Luxembourgish (Luxembourg)" ISO639_1="lb" ISO639_2="ltz" WindowsTLA="LBX" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="kl" LCID="111" EnglishName="Greenlandic" ISO639_1="kl" ISO639_2="kal" WindowsTLA="KAL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="kl-GL" LCID="1135" EnglishName="Greenlandic (Greenland)" ISO639_1="kl" ISO639_2="kal" WindowsTLA="KAL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="ig" LCID="112" EnglishName="Igbo" ISO639_1="ig" ISO639_2="ibo" WindowsTLA="IBO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ig-NG" LCID="1136" EnglishName="Igbo (Nigeria)" ISO639_1="ig" ISO639_2="ibo" WindowsTLA="IBO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="so" LCID="119" EnglishName="Somali" ISO639_1="so" ISO639_2="som" WindowsTLA="SOM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="so-SO" LCID="1143" EnglishName="Somali (Somalia)" ISO639_1="so" ISO639_2="som" WindowsTLA="SOM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="ii" LCID="120" EnglishName="Yi" ISO639_1="ii" ISO639_2="iii" WindowsTLA="III" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="ii-CN" LCID="1144" EnglishName="Yi (PRC)" ISO639_1="ii" ISO639_2="iii" WindowsTLA="III" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="arn" LCID="122" EnglishName="Mapudungun" ISO639_1="arn" ISO639_2="arn" WindowsTLA="MPD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="arn-CL" LCID="1146" EnglishName="Mapudungun (Chile)" ISO639_1="arn" ISO639_2="arn" WindowsTLA="MPD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="moh" LCID="124" EnglishName="Mohawk" ISO639_1="moh" ISO639_2="moh" WindowsTLA="MWK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="moh-CA" LCID="1148" EnglishName="Mohawk (Mohawk)" ISO639_1="moh" ISO639_2="moh" WindowsTLA="MWK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="br" LCID="126" EnglishName="Breton" ISO639_1="br" ISO639_2="bre" WindowsTLA="BRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="br-FR" LCID="1150" EnglishName="Breton (France)" ISO639_1="br" ISO639_2="bre" WindowsTLA="BRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="ug" LCID="128" EnglishName="Uighur" ISO639_1="ug" ISO639_2="uig" WindowsTLA="UIG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        <LocCulture RFC3066Name="ug-CN" LCID="1152" EnglishName="Uighur (PRC)" ISO639_1="ug" ISO639_2="uig" WindowsTLA="UIG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    </LocCulture>
    <LocCulture RFC3066Name="mi" LCID="129" EnglishName="Maori" ISO639_1="mi" ISO639_2="mri" WindowsTLA="MRI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="mi-NZ" LCID="1153" EnglishName="Maori (New Zealand)" ISO639_1="mi" ISO639_2="mri" WindowsTLA="MRI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="oc" LCID="130" EnglishName="Occitan" ISO639_1="oc" ISO639_2="oci" WindowsTLA="OCI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="oc-FR" LCID="1154" EnglishName="Occitan (France)" ISO639_1="oc" ISO639_2="oci" WindowsTLA="OCI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="co" LCID="131" EnglishName="Corsican" ISO639_1="co" ISO639_2="cos" WindowsTLA="COS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="co-FR" LCID="1155" EnglishName="Corsican (France)" ISO639_1="co" ISO639_2="cos" WindowsTLA="COS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="gsw" LCID="132" EnglishName="Alsatian" ISO639_1="gsw" ISO639_2="gsw" WindowsTLA="GSW" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="gsw-FR" LCID="1156" EnglishName="Alsatian (France)" ISO639_1="gsw" ISO639_2="gsw" WindowsTLA="GSW" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="sah" LCID="133" EnglishName="Yakut" ISO639_1="sah" ISO639_2="sah" WindowsTLA="SAH" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="sah-RU" LCID="1157" EnglishName="Yakut (Russia)" ISO639_1="sah" ISO639_2="sah" WindowsTLA="SAH" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="qut" LCID="134" EnglishName="K'iche" ISO639_1="qut" ISO639_2="qut" WindowsTLA="QUT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="qut-GT" LCID="1158" EnglishName="K'iche (Guatemala)" ISO639_1="qut" ISO639_2="qut" WindowsTLA="QUT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="rw" LCID="135" EnglishName="Kinyarwanda" ISO639_1="rw" ISO639_2="kin" WindowsTLA="KIN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="rw-RW" LCID="1159" EnglishName="Kinyarwanda (Rwanda)" ISO639_1="rw" ISO639_2="kin" WindowsTLA="KIN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="wo" LCID="136" EnglishName="Wolof" ISO639_1="wo" ISO639_2="wol" WindowsTLA="WOL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="wo-SN" LCID="1160" EnglishName="Wolof (Senegal)" ISO639_1="wo" ISO639_2="wol" WindowsTLA="WOL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="prs" LCID="140" EnglishName="Dari" ISO639_1="prs" ISO639_2="prs" WindowsTLA="PRS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"> 
	    <LocCulture RFC3066Name="prs-AF" LCID="1164" EnglishName="Dari (Afghanistan)" ISO639_1="prs" ISO639_2="prs" WindowsTLA="PRS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/> 
    </LocCulture>
    <LocCulture RFC3066Name="bs" LCID="30746" EnglishName="Bosnian" ISO639_1="bs" ISO639_2="bsb" WindowsTLA="BSB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="bs-Latn-BA" LCID="5146" EnglishName="Bosnian (Latin, Bosnia and Herzegovina)" ISO639_1="bs" ISO639_2="bsb" WindowsTLA="BSB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="bs-Cyrl-BA" LCID="8218" EnglishName="Bosnian (Cyrillic, Bosnia and Herzegovina)" ISO639_1="bs" ISO639_2="bsc" WindowsTLA="BSC" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="zh-CHT" LCID="31748" EnglishName="Chinese (Traditional)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHT" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-CHT">
		<LocCulture RFC3066Name="zh-TW" LCID="1028" EnglishName="Chinese (Taiwan)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHT" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-TW"/>
		<LocCulture RFC3066Name="zh-HK" LCID="3076" EnglishName="Chinese (Hong Kong S.A.R.)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHH" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-HK"/>
		<LocCulture RFC3066Name="zh-MO" LCID="5124" EnglishName="Chinese (Macao S.A.R.)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHM" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-MO"/>
	</LocCulture>
    <LocCulture RFC3066Name="sr" LCID="31770" EnglishName="Serbian" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRB" ANSICodePage="1250" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="sr">
	<LocCulture RFC3066Name="sr-Latn-CS" LCID="2074" EnglishName="Serbian (Latin, Serbia and Montenegro)" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRL" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Cyrl-CS" LCID="3098" EnglishName="Serbian (Cyrillic, Serbia and Montenegro)" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRB" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Latn-BA" LCID="6170" EnglishName="Serbian (Latin, Bosnia and Herzegovina)" ISO639_1="sr" ISO639_2="SRS" WindowsTLA="SRS" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Cyrl-BA" LCID="7194" EnglishName="Serbian (Cyrillic, Bosnia and Herzegovina)" ISO639_1="sr" ISO639_2="SRN" WindowsTLA="SRN" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="neu" LCID="0" EnglishName="Neutral" ISO639_1="neu" ISO639_2="neu" WindowsTLA="NEU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
	<LocCulture RFC3066Name="ned" LCID="1024" EnglishName="Neutral (Default)" ISO639_1="ned" ISO639_2="ned" WindowsTLA="NED" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="nes" LCID="2048" EnglishName="Neutral (Sys. Default)" ISO639_1="nes" ISO639_2="nes" WindowsTLA="NES" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
</LocCultures>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\msiparse.ini ===
# DISCLAIMER
# Typically, this file should NOT be modified.
# Changing this file can cause data loss.
# Only modify this file if you understand the impact.

[LocalizeBitOverride]

# These columns are localized in the dialog editor.
Dialog.Title=0		# Not displayed in translation table.
Control.Text=0		# Not displayed in translation table.
RadioButton.Text=0	# Not displayed in translation table.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\locxml.xml ===
<?xml version="1.0"?>
<!DOCTYPE _locDefinition SYSTEM "locXML.dtd">
<_locDefinition>
	<!-- To Do: uncomment following line to set elements as none-localizable by default -->
	<!-- <_locDefault _loc="locNone"/> -->
	<!-- To Do: uncomment following line to set all attributes to localizable by default -->
	<!-- <_locDefaultAttr _loc="locData"/> -->

	<!-- To Do: uncomment following line to set tag test to none-localizable 

		and its attributes size and type to localizable.
	        The _locIDAttr is optional and defines the id-attribute as the 
		resource id to use in place of a _locID attribute. 
		For eg: the value of the 'name' attribute of the 'test' tag will be 
		treated as the id for all the localizable content of the 'test' tag.
		-->
	<!-- <_locTag _loc="locNone" _locIDAttr="name" _locAttrData="size,type">test</_locTag> -->

	<!-- To Do: uncomment following line to set tag bold to fully-localizable  -->
	<!-- <_locTag _loc="locFull">bold</_locTag> -->
</_locDefinition>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\regroute.txt ===
; 
 
 ;   * * *   N E W   S E C T I O N   * * * 
 
 ; 
 
 ; 
 
 ;   M a i n   T a r g e t   k e y 
 
 [ M a i n ] 
 
 ;   T h i s   i s   " m a i n "   t a r g e t   k e y ,   t h i s   i s   t h e   o n e   i n s t a l l   i d   w i l l   b e   a p p l i e d   t o 
 
 ;   i t   A L Y W A S   M U S T   b e   F I R S T 
 
 ;   c h e c k   ' i n s t a l l . i d '   f i l e   a f t e r   s e t u p   t o   f i n d   o u t   r e a l   i n s t a l l   i d 
 
 [ T a r g e t ] 
 
 H K C U \ S O F T W A R E \ M i c r o s o f t \ L S B u i l d   1 . 0 0 
 
 
 
 ;   S o u r c e   k e y s 
 
 [ S o u r c e ] 
 
 
 
 ;   N o r m a l   L o c S t u d i o   k e y s   ( l s 4 5 r e g . d l l ) 
 
 H K L M \ S O F T W A R E \ M i c r o s o f t \ L o c S t u d i o 
 
 H K L M \ S O F T W A R E \ M i c r o s o f t \ L o c S t u d i o   4 . 5 1   D e b u g 
 
 H K L M \ S O F T W A R E \ M i c r o s o f t \ L o c S t u d i o   4 . 5 1 
 
 H K C U \ S O F T W A R E \ M i c r o s o f t \ L o c S t u d i o   4 . 5 1 
 
 H K C U \ S O F T W A R E \ M i c r o s o f t \ L o c S t u d i o   4 . 5 1   D e b u g 
 
 
 
 ;   L O O M 
 
 H K L M \ S O F T W A R E \ M i c r o s o f t \ W e a v e r 
 
 
 
 ; 
 
 ;   * * *   N E W   S E C T I O N   * * * 
 
 ; 
 
 ; 
 
 ;   C L S I D   t a r g e t 
 
 [ T a r g e t ] 
 
 H K C U \ S o f t w a r e \ C l a s s e s \ C L S I D 
 
 
 
 ;   C L S I D   s o u r c e s 
 
 [ S o u r c e ] 
 
 ;   W a l k t r e e . d l l 
 
 H K C R \ C L S I D \ { 8 9 3 2 5 C 9 D - 3 2 E B - 1 1 d 1 - A 5 C D - 0 0 C 0 4 F C 2 C 6 D 8 } 
 
 
 
 ;   P O M P a r s e r M a n a g e r   ( P O M M a n a g e r . d l l ) 
 
 H K C R \ C L S I D \ { A D 3 C 0 5 0 6 - A 6 7 6 - 4 F A C - A 8 9 4 - 9 C 8 7 3 4 8 8 4 6 5 7 } 
 
 H K C R \ C L S I D \ { 7 F 0 B D 3 0 D - 0 5 7 0 - 4 4 D 5 - 8 F E F - 7 A E E 0 E D C B 1 A 7 } 
 
 
 
 ;   P a r s e r H e l p e r s   ( p a r s e r h e l p e r s . d l l ) 
 
 ;   M i c r o s o f t . L o c S t u d i o . P a r s e r s . P a r s e r H e l p e r s . S u b P a r s e r M a n a g e r 
 
 H K C R \ C L S I D \ { 9 1 D C 8 D 0 E - 8 D 2 A - 4 5 7 e - 9 8 8 E - F 2 9 B 9 0 D 6 B 1 A B } 
 
 
 
 ;   M a n a g e d   C o d e   P a r s e r   ( m a n a g e d p a r s e r . d l l ) 
 
 H K C R \ C L S I D \ { F A 5 5 B 4 6 5 - D E 9 E - 4 A E C - 9 E 2 C - 3 9 E E 7 6 8 C 7 E C D } 
 
 
 
 ;   L S O M   I n t e r f a c e s 
 
 H K C R \ C L S I D \ { C 4 5 8 8 0 E A - E E 7 B - 4 A 9 0 - B 0 9 D - 6 8 E 5 3 2 5 A 5 0 4 9 } 
 
 
 
 ;   L S O p t i o n   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { F 6 4 4 B A 9 9 - C 8 7 9 - 4 6 E 2 - 8 F 5 6 - F F 6 6 9 B 4 E B 3 C 5 } 
 
 
 
 ;   L S P r o j e c t   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { 4 0 8 E 3 5 2 C - 4 7 6 9 - 4 2 1 2 - 9 C 2 E - 1 4 E 5 3 8 0 8 7 F F 2 } 
 
 
 
 ;   L S I t e m   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { F 6 6 A 2 7 C 9 - D 3 5 B - 4 C 8 F - A 3 9 D - 1 7 C A 4 1 D E 1 C F 5 } 
 
 
 
 ;   L S I t e m s   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { E 3 3 8 1 3 6 7 - 9 8 7 B - 4 c 6 2 - B 4 3 8 - 1 E A 8 8 2 9 C 8 C 8 D } 
 
 
 
 ;   L S S t r i n g   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { 3 2 1 8 9 7 9 5 - 5 5 A 6 - 4 C 1 C - B 7 D 8 - A E 5 8 9 3 B D 9 6 2 3 } 
 
 
 
 ;   L S U n i q u e I d   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { A 1 A 2 D B 3 B - F 8 7 9 - 4 B 0 B - 9 0 1 4 - D 7 A 6 A 5 D 9 C 7 2 5 } 
 
 
 
 ;   L S C o n t e x t   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { 9 B F D 6 1 1 1 - 7 1 E 9 - 4 2 D B - A 3 1 D - 2 7 4 0 6 8 A F D A B B } 
 
 
 
 ;   L S O p t i o n s   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { E 7 0 8 9 D 9 E - B 0 3 4 - 4 8 7 4 - 8 D 3 6 - 7 2 4 C 0 1 4 2 4 6 B 8 } 
 
 H K C R \ C L S I D \ { 7 9 F E C A D C - 1 D B 0 - 4 B 5 F - 9 0 E 9 - 3 9 8 3 E 3 1 F C A B 5 } 
 
 
 
 ;   P a r s e r M e d i a t o r   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { 2 C 1 7 0 8 C 7 - 9 9 5 2 - 4 2 C 6 - A 7 7 A - 9 E 2 4 9 1 3 A A C B 9 } 
 
 
 
 ;   I P O M P a r s e r M a n a g e r   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { 3 C E 6 C F 9 0 - F 3 E 7 - 4 0 F 2 - 9 E 7 4 - 0 5 3 5 D 8 7 5 0 8 D 6 } 
 
 
 
 ;   P O M P a r s e r M a n   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { D C 4 4 A B 6 3 - D E 0 5 - 4 1 F A - A A 6 2 - A E F 9 5 8 F 8 B 4 A 2 } 
 
 
 
 ;   P O M C o n f i g   ( L S O M . D L L ) 
 
 H K C R \ C L S I D \ { E 8 B 4 0 7 8 2 - 4 1 9 1 - 4 9 2 8 - 9 D 0 E - 4 F A 4 4 5 0 4 4 8 F 9 } 
 
 
 
 ;   L o c X M L D o c   ( l o c x m l . d l l ) 
 
 H K C R \ C L S I D \ { B 7 F F A A C A - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 
 
 ;   L o c X M L M s g   ( l o c x m l . d l l ) 
 
 H K C R \ C L S I D \ { B 7 F F A A C 2 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 
 
 ;   L o c X M L M s g L i s t   ( l o c x m l . d l l ) 
 
 H K C R \ C L S I D \ { B 7 F F A A C 4 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 
 
 ;   L o c X M L T e r m   ( l o c x m l . d l l ) 
 
 H K C R \ C L S I D \ { B 7 F F A A C 6 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 
 
 ;   L o c X M L T e r m L i s t   ( l o c x m l . d l l ) 
 
 H K C R \ C L S I D \ { B 7 F F A A C 8 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 
 
 ;   P O M H T M L   ( p o m h t m l . d l l ) 
 
 H K C R \ C L S I D \ { 1 7 D 0 5 9 E E - 6 5 B 3 - 4 d 0 d - 9 C A A - A D 0 D 3 C C A E 8 B 5 } 
 
 
 
 ;   P O M X M L   ( p o x m l . d l l ) 
 
 H K C R \ C L S I D \ { 2 2 3 4 7 0 B B - 8 C 8 6 - 4 6 a 5 - B 4 6 6 - 3 4 9 6 8 E D D F A 8 3 } 
 
 
 
 ;   M L o c X M L D o c   ( m l o c x m l . d l l ) 
 
 H K C R \ C L S I D \ { 7 E B E C 9 5 9 - D D C F - 4 8 0 f - B 2 A E - 9 E 0 8 A B 8 0 6 E 2 2 } 
 
 H K C R \ C L S I D \ { B 3 B F 2 0 9 F - 1 4 C B - 4 4 1 8 - 8 A B E - F 7 6 A 7 4 5 B 4 5 F 9 } 
 
 H K C R \ C L S I D \ { 9 3 E 2 4 4 6 7 - 9 3 4 8 - 4 0 3 0 - 9 8 A 0 - E 5 0 7 C 6 F 4 4 D D A } 
 
 H K C R \ C L S I D \ { D C 6 6 B C 5 1 - 6 2 0 1 - 4 8 f 2 - A 3 F 3 - 9 C B A F C 9 9 3 A 2 D } 
 
 H K C R \ C L S I D \ { F 0 2 D 5 E C 9 - 2 6 1 3 - 4 0 d c - A D A 8 - E 1 C B D 5 B A E 2 2 D } 
 
 
 
 ;   M i c r o s o f t   J e t   3 . 5 1   ( m s j t o r 3 5 . d l l ) 
 
 H K C R \ C L S I D \ { d e e 3 5 0 6 0 - 5 0 6 b - 1 1 c f - b 1 a a - 0 0 a a 0 0 b 8 d e 9 5 } 
 
 H K C R \ C L S I D \ { d e e 3 5 0 6 1 - 5 0 6 b - 1 1 c f - b 1 a a - 0 0 a a 0 0 b 8 d e 9 5 } 
 
 
 
 ;   L o c V e r C S   ( L o c V e r C S . d l l ) 
 
 H K C R \ C L S I D \ { C 7 6 7 0 0 C E - F 1 B A - 4 A 1 F - 8 3 6 4 - 2 C 8 0 7 5 F F C 8 6 8 } 
 
 H K C R \ C L S I D \ { C 9 1 1 2 D 6 D - F 0 2 1 - 4 9 3 D - 8 8 9 F - B C 5 7 7 5 A 9 5 2 F B } 
 
 H K C R \ C L S I D \ { 2 5 1 7 6 D 5 C - C D 8 5 - 4 E B 6 - A E 8 F - 1 7 4 0 D 2 6 9 2 D 9 1 } 
 
 H K C R \ C L S I D \ { B A E B E 9 E 2 - B 4 E 2 - 4 9 2 B - A 6 F 6 - 0 9 5 E 6 2 B 0 E 6 8 1 } 
 
 H K C R \ C L S I D \ { 7 7 1 F E A 6 D - 0 C 4 F - 4 3 8 2 - A A 0 9 - 1 5 4 9 7 D C 8 A 8 9 A } 
 
 H K C R \ C L S I D \ { 2 2 4 2 7 0 B 4 - E C 6 E - 4 8 0 F - B 2 1 0 - 6 E 0 1 6 9 2 5 2 9 D 7 } 
 
 H K C R \ C L S I D \ { 8 6 7 4 F 7 2 E - 0 0 8 D - 4 0 A B - B 1 C 3 - 8 7 D 2 F 8 0 6 C A 4 E } 
 
 H K C R \ C L S I D \ { 3 1 9 F E 2 4 E - 4 F E 4 - 4 2 6 E - B E 7 F - F A 2 F 1 8 0 7 E 7 0 5 } 
 
 H K C R \ C L S I D \ { 5 0 0 2 7 0 5 D - E F 4 D - 4 F 8 7 - B 6 A 9 - E 5 6 F 6 7 3 8 4 A 0 7 } 
 
 H K C R \ C L S I D \ { 6 B 7 9 7 7 5 1 - A 9 D 4 - 4 8 3 B - A A 4 B - 9 3 A E C E 1 E F 7 5 E } 
 
 H K C R \ C L S I D \ { B 6 6 B F 7 4 3 - E E 3 1 - 4 0 3 B - A F D D - C 8 0 3 4 9 3 A E 9 3 0 } 
 
 
 
 ; 
 
 ;   * * *   N E W   S E C T I O N   * * * 
 
 ; 
 
 ; 
 
 ;   T a r g e t   k e y 
 
 [ T a r g e t ] 
 
 H K C U \ S o f t w a r e \ C l a s s e s \ C o m p o n e n t   C a t e g o r i e s 
 
 
 
 ;   S o u r c e   k e y s   -   c a t e g o r i e s 
 
 [ S o u r c e ] 
 
 ;   L S O M   P O M   C a t e g o r y 
 
 H K C R \ C o m p o n e n t   C a t e g o r i e s \ { 8 F E D 6 3 5 0 - A D 3 0 - 1 1 3 0 - B 6 9 F - 0 0 A 0 C 9 0 3 3 8 7 A } 
 
 
 
 ;   P O M X M L   ( p o x m l . d l l ) 
 
 H K C R \ C o m p o n e n t   C a t e g o r i e s \ { A 0 4 7 C E 6 B - A 3 5 E - 4 1 5 9 - B E 1 F - 3 4 9 6 3 4 1 3 F 4 D 0 } 
 
 
 
 ; 
 
 ;   * * *   N E W   S E C T I O N   * * * 
 
 ; 
 
 ; 
 
 ;   T a r g e t   k e y 
 
 [ T a r g e t ] 
 
 H K C U \ S o f t w a r e \ C l a s s e s 
 
 
 
 ;   S o u r c e   k e y s   -   P r o g I D s 
 
 [ S o u r c e ] 
 
 
 
 ;   P O M P a r s e r M a n a g e r   ( P O M M a n a g e r . d l l ) 
 
 H K C R \ P O M M a n a g e r . P O M P a r s e r M a n a g e r 
 
 H K C R \ P O M M a n a g e r . P O M P a r s e r M a n a g e r . 1 
 
 
 
 ;   M a n a g e d   C o d e   P a r s e r   ( m a n a g e d p a r s e r . d l l ) 
 
 H K C R \ M i c r o s o f t . M a n a g e d R e s o u r c e P a r s e r . P a r s e r 
 
 
 
 ;   S u b P a r s e r   M a n a g e r   ( p a r s e r h e l p e r s . d l l ) 
 
 H K C R \ M i c r o s o f t . L o c S t u d i o . P a r s e r s . P a r s e r H e l p e r s . S u b P a r s e r M a n a g e r 
 
 
 
 ;   L o c V e r C S   ( L o c V e r C S . d l l ) 
 
 H K C R \ M i c r o s o f t . L o c V e r . I n s t r u c t i o n s . I n s t r u c t i o n P a r s e r 
 
 H K C R \ M i c r o s o f t . L o c V e r . I t e m s . L o c I t e m 
 
 H K C R \ M i c r o s o f t . L o c V e r . N a m e S p a c e s . N a m e S p a c e M a n a g e r 
 
 H K C R \ M i c r o s o f t . L o c V e r . L o c V e r F a c t o r y 
 
 H K C R \ M i c r o s o f t . L o c V e r . R u l e s . L o c V e r R u l e 
 
 H K C R \ M i c r o s o f t . L o c V e r . R u l e s . R e t u r n V a l u e s . R e t u r n V a l u e 
 
 H K C R \ M i c r o s o f t . L o c V e r . S e t t i n g s . L V C o n t e x t 
 
 H K C R \ M i c r o s o f t . L o c V e r . S e t t i n g s . L V N u l l R e p o r t e r 
 
 H K C R \ M i c r o s o f t . L o c V e r . S e t t i n g s . L V D e l a y R e p o r t e r 
 
 H K C R \ M i c r o s o f t . L o c V e r . U t i l i t y . L o c V e r R e g E x 
 
 H K C R \ M i c r o s o f t . L o c V e r . I t e m s . L o c I t e m E x 
 
 
 
 ;   L S O p t i o n   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S O p t i o n 
 
 H K C R \ L S O M . L S O p t i o n . 1 
 
 
 
 ;   L S P r o j e c t   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S P r o j e c t 
 
 H K C R \ L S O M . L S P r o j e c t . 1 
 
 
 
 ;   L S I t e m   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S I t e m 
 
 H K C R \ L S O M . L S I t e m . 1 
 
 
 
 ;   L S I t e m s   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S I t e m s 
 
 H K C R \ L S O M . L S I t e m s . 1 
 
 
 
 ;   L S S t r i n g   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S S t r i n g 
 
 H K C R \ L S O M . L S S t r i n g . 1 
 
 
 
 ;   L S U n i q u e I d   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S U n i q u e I d 
 
 H K C R \ L S O M . L S U n i q u e I d . 1 
 
 
 
 ;   L S C o n t e x t   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S C o n t e x t 
 
 H K C R \ L S O M . L S C o n t e x t . 1 
 
 
 
 ;   L S O p t i o n s   ( L S O M . D L L ) 
 
 H K C R \ L S O M . L S O p t i o n s 
 
 H K C R \ L S O M . L S O p t i o n s . 1 
 
 
 
 ;   P a r s e r M e d i a t o r   ( L S O M . D L L ) 
 
 H K C R \ L S O M . P a r s e r M e d i a t o r 
 
 H K C R \ L S O M . P a r s e r M e d i a t o r . 1 
 
 
 
 ;   P O M P a r s e r M a n   ( L S O M . D L L ) 
 
 H K C R \ L S O M . P O M P a r s e r M a n 
 
 H K C R \ L S O M . P O M P a r s e r M a n . 1 
 
 
 
 ;   P O M C o n f i g   ( L S O M . D L L ) 
 
 H K C R \ L S O M . P O M C o n f i g 
 
 H K C R \ L S O M . P O M C o n f i g . 1 
 
 
 
 ;   L o c X M L D o c   ( l o c x m l . d l l ) 
 
 H K C R \ L o c x m l . L o c X M L D o c 
 
 H K C R \ L o c x m l . L o c X M L D o c . 1 
 
 
 
 ;   L o c X M L M s g   ( l o c x m l . d l l ) 
 
 H K C R \ L o c x m l . L o c X M L M s g 
 
 H K C R \ L o c x m l . L o c X M L M s g . 1 
 
 
 
 ;   L o c X M L M s g L i s t   ( l o c x m l . d l l ) 
 
 L o c x m l . L o c X M L M s g L i s t 
 
 L o c x m l . L o c X M L M s g L i s t . 1 
 
 
 
 ;   L o c X M L T e r m   ( l o c x m l . d l l ) 
 
 H K C R \ L o c x m l . L o c X M L T e r m 
 
 H K C R \ L o c x m l . L o c X M L T e r m . 1 
 
 
 
 ;   L o c X M L T e r m L i s t   ( l o c x m l . d l l ) 
 
 H K C R \ L o c x m l . L o c X M L T e r m L i s t 
 
 H K C R \ L o c x m l . L o c X M L T e r m L i s t . 1 
 
 
 
 ;   P O M H T M L   ( p o m h t m l . d l l ) 
 
 H K C R \ P O M H T M L . P O M H T M L 
 
 H K C R \ P O M H T M L . P O M H T M L . 1 
 
 
 
 ;   P O M X M L   ( p o x m l . d l l ) 
 
 H K C R \ P O M X M L . P O M X M L 
 
 H K C R \ P O M X M L . P O M X M L . 1 
 
 
 
 ;   M L o c X M L D o c   ( m l o c x m l . d l l ) 
 
 H K C R \ M L o c x m l . M L o c X M L D o c 
 
 H K C R \ M L o c x m l . M L o c X M L T e r m L i s t 
 
 H K C R \ M L o c x m l . M L o c X M L T e r m 
 
 H K C R \ M L o c x m l . M L o c X M L M s g L i s t 
 
 H K C R \ M L o c x m l . M L o c X M L M s g 
 
 H K C R \ M L o c x m l . M L o c X M L D o c . 1 
 
 H K C R \ M L o c x m l . M L o c X M L T e r m L i s t . 1 
 
 H K C R \ M L o c x m l . M L o c X M L T e r m . 1 
 
 H K C R \ M L o c x m l . M L o c X M L M s g L i s t . 1 
 
 H K C R \ M L o c x m l . M L o c X M L M s g . 1 
 
 
 
 ;   M i c r o s o f t   J e t   3 . 5 1   ( m s j t o r 3 5 . d l l ) 
 
 H K C R \ M i c r o s o f t . J e t . O L E D B . 3 . 5 1 E r r o r s 
 
 H K C R \ M i c r o s o f t . J e t . O L E D B . 3 . 5 1 E r r o r s . 1 
 
 H K C R \ . j o d 
 
 H K C R \ M i c r o s o f t . J e t . O L E D B . 3 . 5 1 
 
 H K C R \ M i c r o s o f t . J e t . O L E D B . 3 . 5 1 . 1 
 
 ; 
 
 ; 
 
 ;   * * *   N E W   S E C T I O N   * * * 
 
 ; 
 
 ; 
 
 ;   T a r g e t   k e y 
 
 [ T a r g e t ] 
 
 H K C U \ S o f t w a r e \ C l a s s e s \ T y p e l i b 
 
 
 
 ;   S o u r c e   k e y s   -   t y p e l i b s 
 
 [ S o u r c e ] 
 
 
 
 ;   P O M P a r s e r M a n a g e r   ( P O M M a n a g e r . d l l ) 
 
 H K C R \ T y p e l i b \ { 7 F 0 B D 3 0 D - 0 5 7 0 - 4 4 D 5 - 8 F E F - 7 A E E 0 E D C B 1 A 7 } 
 
 H K C R \ T y p e L i b \ { A D 3 C 0 5 0 6 - A 6 7 6 - 4 F A C - A 8 9 4 - 9 C 8 7 3 4 8 8 4 6 5 7 } 
 
 
 
 ;   L S O M   I n t e r f a c e s 
 
 H K C R \ T y p e l i b \ { C 4 5 8 8 0 E A - E E 7 B - 4 A 9 0 - B 0 9 D - 6 8 E 5 3 2 5 A 5 0 4 9 } 
 
 H K C R \ T y p e L i b \ { 3 2 1 8 9 7 9 5 - 5 5 A 6 - 4 C 1 C - B 7 D 8 - A E 5 8 9 3 B D 9 6 2 3 } 
 
 
 
 ;   L S O p t i o n s   ( L S O M . D L L ) 
 
 H K C R \ T y p e l i b \ { D B 7 F 6 8 F 2 - 6 F 4 3 - 4 D 1 F - B 8 A 6 - 7 9 6 8 A 3 C A E 5 4 0 } 
 
 
 
 ;   L o c X M L 
 
 H K C R \ T y p e l i b \ { B 1 3 A 1 4 5 1 - 7 9 D 7 - 1 1 D 2 - 8 C 9 9 - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 
 
 ;   P O M H T M L   ( p o m h t m l . d l l ) 
 
 H K C R \ T y p e l i b \ { 0 3 5 5 0 B 4 1 - D E D 2 - 4 d 3 a - 9 9 3 B - 3 1 C 8 3 8 D D 5 C 2 8 } 
 
 
 
 ;   P O M X M L   ( p o x m l . d l l ) 
 
 H K C R \ T y p e l i b \ { A 0 4 7 C E 6 B - A 3 5 E - 4 1 5 9 - B E 1 F - 3 4 9 6 3 4 1 3 F 4 D 0 } 
 
 H K C R \ T y p e L i b \ { 2 2 3 4 7 0 B B - 8 C 8 6 - 4 6 a 5 - B 4 6 6 - 3 4 9 6 8 E D D F A 8 3 } 
 
 
 
 ;   M L o c X M L D o c   ( m l o c x m l . d l l ) 
 
 H K C R \ T y p e L i b \ { F 4 5 4 9 0 D F - 1 6 F 7 - 4 F 6 9 - A 3 5 2 - D 1 0 5 4 2 9 0 A 8 1 4 } 
 
 H K C R \ T y p e L i b \ { B 3 B F 2 0 9 F - 1 4 C B - 4 4 1 8 - 8 A B E - F 7 6 A 7 4 5 B 4 5 F 9 } 
 
 ; 
 
 ;   * * *   N E W   S E C T I O N   * * * 
 
 ; 
 
 ; 
 
 ;   T a r g e t   k e y 
 
 [ T a r g e t ] 
 
 H K C U \ S o f t w a r e \ C l a s s e s \ I n t e r f a c e 
 
 
 
 ;   S o u r c e   k e y s   -   i n t e r f a c e s 
 
 [ S o u r c e ] 
 
 ;   L S O M   I n t e r f a c e s 
 
 H K C R \ I n t e r f a c e \ { 1 2 F 0 8 0 2 6 - B F 0 4 - 4 4 7 C - B E 4 9 - E 9 2 8 A A 9 A D E A 0 } 
 
 H K C R \ I n t e r f a c e \ { C F 3 A 0 8 6 5 - 7 8 7 0 - 4 1 0 B - 8 0 F E - 3 4 C 5 6 A 2 F 5 B 1 D } 
 
 H K C R \ I n t e r f a c e \ { A 7 0 0 E F 5 5 - B 3 8 B - 4 7 3 7 - B 5 D 8 - F C B 2 C B B F A 6 D 6 } 
 
 H K C R \ I n t e r f a c e \ { 0 2 2 A 1 A 0 F - 4 8 3 B - 4 C 3 C - A 7 5 C - 1 0 3 7 A 5 E B 7 F 1 0 } 
 
 H K C R \ I n t e r f a c e \ { F E A 0 F 1 B 1 - 7 E F 3 - 4 D 7 B - 9 2 0 E - 9 D 2 9 C D 8 8 B 7 B 6 } 
 
 H K C R \ I n t e r f a c e \ { D 4 1 1 3 2 B 9 - B 4 F A - 4 E D A - 8 7 7 F - 1 4 5 9 0 4 4 D 7 5 9 E } 
 
 H K C R \ I n t e r f a c e \ { 6 8 B 7 5 4 B E - C 1 7 5 - 4 4 A 5 - B 0 9 3 - 6 F 1 2 7 7 0 E 4 1 3 2 } 
 
 H K C R \ I n t e r f a c e \ { 9 2 E 5 6 9 6 2 - C 4 9 E - 4 E A 1 - A 2 B C - B A 5 4 E B 7 8 7 E 1 F } 
 
 H K C R \ I n t e r f a c e \ { D 0 A E D 4 4 2 - 3 2 8 A - 4 A 8 D - 8 0 0 0 - 0 3 F D 7 3 B 2 9 D D 8 } 
 
 H K C R \ I n t e r f a c e \ { 6 D 4 2 1 F A B - 0 A 3 8 - 4 2 7 7 - 9 9 A 6 - 9 1 E C C 2 A A 1 0 3 F } 
 
 H K C R \ I n t e r f a c e \ { 2 3 4 E A B 4 C - D 8 1 6 - 4 F 3 6 - A B B A - 9 0 2 C 9 C D D B 9 E 5 } 
 
 H K C R \ I n t e r f a c e \ { 7 7 5 C 6 7 9 8 - 1 2 C 7 - 4 8 E 7 - B 0 F A - 7 F 9 E 3 E 9 6 B 4 C A } 
 
 H K C R \ I n t e r f a c e \ { E 1 F F F D A 2 - 8 3 1 2 - 4 E 9 7 - B 5 4 F - 9 3 6 C D F B C E E 9 3 } 
 
 H K C R \ I n t e r f a c e \ { A F 3 3 2 9 F 4 - 6 7 5 1 - 4 F D 3 - A 0 A 1 - 9 0 5 4 B C D 9 B 4 7 3 } 
 
 H K C R \ I n t e r f a c e \ { 6 3 D D C 5 6 1 - 1 B A F - 4 E A 5 - A 6 4 F - 2 0 6 D 5 C 7 E B 5 3 7 } 
 
 H K C R \ I n t e r f a c e \ { 2 7 D 3 B 9 3 3 - E 4 6 C - 4 B 4 D - 9 4 8 7 - 5 0 D 7 4 2 F 9 B 7 E 8 } 
 
 H K C R \ I n t e r f a c e \ { D 3 0 3 2 F A C - F 1 0 9 - 4 6 3 0 - 8 7 5 3 - 5 F 0 F E A C 5 3 1 4 8 } 
 
 H K C R \ I n t e r f a c e \ { 5 B 8 A F E C B - E A C 7 - 4 5 A C - 9 2 8 F - B F 0 1 6 0 1 C 0 4 6 8 } 
 
 H K C R \ I n t e r f a c e \ { 0 2 0 6 6 D 5 7 - 5 5 6 A - 4 E B 5 - A 5 5 E - 7 B E D A 3 B 2 0 1 3 5 } 
 
 H K C R \ I n t e r f a c e \ { 2 1 4 9 B 0 F 0 - 6 C A 5 - 4 B 3 E - A E F 2 - 6 E B 6 6 0 0 B D F B 8 } 
 
 H K C R \ I n t e r f a c e \ { 0 B 7 6 B A 5 7 - 5 7 3 9 - 4 0 D C - 9 6 1 9 - 5 8 5 8 C 7 4 1 1 3 A A } 
 
 H K C R \ I n t e r f a c e \ { 0 0 5 B 5 F F E - C 7 8 8 - 4 2 A F - 9 3 D 3 - A F 3 7 E 8 2 D 6 4 4 1 } 
 
 H K C R \ I n t e r f a c e \ { 8 B B E 3 D 2 9 - F 9 4 5 - 4 0 9 A - B B B 1 - 5 3 E B 6 1 9 8 5 C 9 E } 
 
 H K C R \ I n t e r f a c e \ { D 5 6 4 6 C 3 B - A 0 B 3 - 4 D 7 3 - B 1 0 7 - F A 9 8 F 7 9 E 7 4 B 4 } 
 
 H K C R \ I n t e r f a c e \ { 8 D 0 7 4 E 5 0 - 5 5 A 4 - 4 C 8 7 - 8 F 2 7 - 0 9 8 8 B D E 5 2 B F 2 } 
 
 H K C R \ I n t e r f a c e \ { 5 A 4 1 F C 2 C - D 8 4 B - 4 4 9 E - A 2 4 2 - D C 8 B F 9 5 E C 8 7 6 } 
 
 H K C R \ I n t e r f a c e \ { 9 8 9 D E 2 3 9 - 5 A D 4 - 4 A E 1 - A 3 2 5 - 3 F 4 0 B 4 5 6 4 E 3 9 } 
 
 H K C R \ I n t e r f a c e \ { 2 F D 3 D A B B - 9 2 4 5 - 4 B 1 0 - 9 C A 4 - 3 6 6 5 8 E E 2 5 4 B 2 } 
 
 H K C R \ I n t e r f a c e \ { 1 9 2 8 8 2 8 B - 7 E 4 5 - 4 4 1 E - 9 7 D 9 - A F 9 9 2 9 1 4 4 D 6 0 } 
 
 H K C R \ I n t e r f a c e \ { C 2 6 C 5 2 9 D - 3 F C 8 - 4 B 6 E - A E 3 C - 6 B 7 5 F C 9 1 6 4 0 0 } 
 
 H K C R \ I n t e r f a c e \ { 7 C B 4 2 D 3 8 - E 6 2 0 - 4 F 5 6 - A 9 1 A - D B E 3 9 2 8 D 6 C 8 C } 
 
 H K C R \ I n t e r f a c e \ { A E E D 2 5 7 2 - 7 9 4 F - 1 1 D 3 - B 9 0 3 - 0 0 1 0 4 B 7 2 8 6 3 C } 
 
 H K C R \ I n t e r f a c e \ { 8 3 5 6 D 2 A 0 - D 9 2 2 - 4 2 9 3 - 8 5 E 9 - E 6 D 6 3 E 1 4 8 6 F C } 
 
 H K C R \ I n t e r f a c e \ { A E E D 2 5 7 4 - 7 9 4 F - 1 1 D 3 - B 9 0 3 - 0 0 1 0 4 B 7 2 8 6 3 C } 
 
 H K C R \ I n t e r f a c e \ { D 8 F 2 6 E D 4 - E 5 8 5 - 4 4 1 C - 8 6 F 1 - A 7 C 2 0 E B A 4 0 F C } 
 
 H K C R \ I n t e r f a c e \ { A E E D 2 5 7 5 - 7 9 4 F - 1 1 D 3 - B 9 0 3 - 0 0 1 0 4 B 7 2 8 6 3 C } 
 
 H K C R \ I n t e r f a c e \ { D 1 4 9 9 6 1 7 - A C 3 F - 4 1 B 0 - B 3 8 1 - C A 0 0 1 2 0 B 0 6 D 3 } 
 
 H K C R \ I n t e r f a c e \ { A E E D 2 5 7 3 - 7 9 4 F - 1 1 D 3 - B 9 0 3 - 0 0 1 0 4 B 7 2 8 6 3 C } 
 
 H K C R \ I n t e r f a c e \ { D 0 0 A 5 A 8 4 - D 6 8 1 - 4 C 1 0 - 8 9 D 6 - 5 E C C B 5 7 5 F 1 7 3 } 
 
 H K C R \ I n t e r f a c e \ { 7 1 5 5 7 C C 0 - 2 4 1 7 - 1 1 D 3 - 8 C C 8 - 0 0 C 0 4 F 7 9 4 8 B 0 } 
 
 H K C R \ I n t e r f a c e \ { 3 C E 6 C F 9 0 - F 3 E 7 - 4 0 F 2 - 9 E 7 4 - 0 5 3 5 D 8 7 5 0 8 D 6 } 
 
 ; I P O M S u b P a r s e r 
 
 H K C R \ I n t e r f a c e \ { 4 3 8 5 B 5 9 4 - 5 B C 4 - 4 2 e 4 - 8 5 A 4 - F F 6 B A 0 B C 2 7 F E } 
 
 ; I P O M S t r e a m P a r s e r 
 
 H K C R \ I n t e r f a c e \ { A E 2 7 B 0 C C - C 0 1 0 - 4 6 e 8 - 9 B B 0 - D B 0 D C 7 A 7 A 8 E B } 
 
 ; I P O M S u b P a r s e r M a n a g e r 
 
 H K C R \ I n t e r f a c e \ { 0 1 C A 0 B B A - 9 8 5 3 - 4 2 5 5 - 9 1 2 9 - 5 B C F 0 7 7 A 3 5 5 E } 
 
 
 
 ;   L o c X M L 
 
 H K C R \ I n t e r f a c e \ { B 7 F F A A C 1 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 H K C R \ I n t e r f a c e \ { B 7 F F A A C 3 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 H K C R \ I n t e r f a c e \ { B 7 F F A A C 5 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 H K C R \ I n t e r f a c e \ { B 7 F F A A C 7 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 H K C R \ I n t e r f a c e \ { B 7 F F A A C 9 - 7 D 8 0 - 1 1 D 2 - 8 C 9 A - 0 0 C 0 4 F 7 9 E C 6 A } 
 
 H K C R \ I n t e r f a c e \ { B 7 F F A E C 9 - 7 D 8 0 - 1 1 D 2 - 8 C E A - 0 0 C 0 4 F 7 9 6 A E C } 
 
 
 
 ; ; ; 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\TPSettings.xml ===
<TPSetting>
	<Owner Name="TransPlatform" DisplayName="Translation Engine Settings" Category="TranslationPlatform" Desc="Provides Translation Platform settings for validation on translation engine results. For example, you can select to enable LocAgent or select alternate settings for various components.">
		<Group Name="Components" Desc="Provides a way to define the Translation Platform programs to use." Visible="false">
			<Group Name="PseudoTransEngine" Desc="Select the Pseudo Translation engine and settings.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ITransEngine" Desc="Select the Pseudo Translation engine to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load Pseudo Translation Engine" Value="false" Desc="Select On to load the Pseudo Translation engine during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.Pseudo.PseudoTransEngine,PseudoTransEngine" Desc="Set the URT type for the Pseudo Translation engine." />
			</Group>
			<Group Name="LocRuleAgent" Desc="Select the LocRuleAgent and settings.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ILocAgent" Desc="Select the LocRuleAgent to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load LocRule Agent" Value="true" Desc="Select On to load the LocRuleAgent during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.LocRule.LocRuleAgent,LocRuleAgent" Desc="Set the URT type for the LocRuleAgent." />
				<Group Name="CustomRules" Desc="Enter any custom rules for the LocRuleAgent.">
				</Group>
			</Group>
			<Group Name="LocVer" Desc="Select the LocVerAgent and settings.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ILocAgent" Desc="Select the type of agent to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load LocVer Agent" Value="true" Desc="Select On to load the LocVerAgent during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.Verification.Engine,Microsoft.LocVer.Engine" Desc="Set the URT type for LocVerAgent." />
			</Group>
			<Group Name="LockAndMapCorrector" Desc="Select the LockAndMapCorrector engine.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ICorrectionEngine" Desc="Select the type of agent to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load LockAndMapCorrector" Value="true" Desc="Select On to load the LockAndMapCorrection engine during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.Corrector.LockAndMapCorrector,LockAndMapCorrector" Desc="Set the URT type for LockAndMapCorrector." />
			</Group>
		</Group>
	</Owner>
</TPSetting>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\msiparse.ini ===
# DISCLAIMER
# Typically, this file should NOT be modified.
# Changing this file can cause data loss.
# Only modify this file if you understand the impact.

[LocalizeBitOverride]

# These columns are localized in the dialog editor.
Dialog.Title=0		# Not displayed in translation table.
Control.Text=0		# Not displayed in translation table.
RadioButton.Text=0	# Not displayed in translation table.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\LocCultures.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<LocCultures>
  <LocCulture RFC3066Name="ar" LCID="1" EnglishName="Arabic" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
		<LocCulture RFC3066Name="ar-SA" LCID="1025" EnglishName="Arabic (Saudi Arabia)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SA"/>
		<LocCulture RFC3066Name="ar-IQ" LCID="2049" EnglishName="Arabic (Iraq)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARI" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-IQ"/>
		<LocCulture RFC3066Name="ar-EG" LCID="3073" EnglishName="Arabic (Egypt)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARE" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-EG"/>
		<LocCulture RFC3066Name="ar-LY" LCID="4097" EnglishName="Arabic (Libya)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARL" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-LY"/>
		<LocCulture RFC3066Name="ar-DZ" LCID="5121" EnglishName="Arabic (Algeria)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-DZ"/>
		<LocCulture RFC3066Name="ar-MA" LCID="6145" EnglishName="Arabic (Morocco)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARM" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-MA"/>
		<LocCulture RFC3066Name="ar-TN" LCID="7169" EnglishName="Arabic (Tunisia)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ART" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-TN"/>
		<LocCulture RFC3066Name="ar-OM" LCID="8193" EnglishName="Arabic (Oman)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARO" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-OM"/>
		<LocCulture RFC3066Name="ar-YE" LCID="9217" EnglishName="Arabic (Yemen)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARY" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-YE"/>
		<LocCulture RFC3066Name="ar-SY" LCID="10241" EnglishName="Arabic (Syria)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SY"/>
		<LocCulture RFC3066Name="ar-JO" LCID="11265" EnglishName="Arabic (Jordan)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARJ" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-JO"/>
		<LocCulture RFC3066Name="ar-LB" LCID="12289" EnglishName="Arabic (Lebanon)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARB" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-LB"/>
		<LocCulture RFC3066Name="ar-KW" LCID="13313" EnglishName="Arabic (Kuwait)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARK" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-KW"/>
		<LocCulture RFC3066Name="ar-AE" LCID="14337" EnglishName="Arabic (U.A.E.)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARU" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-AE"/>
		<LocCulture RFC3066Name="ar-BH" LCID="15361" EnglishName="Arabic (Bahrain)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARH" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-BH"/>
		<LocCulture RFC3066Name="ar-QA" LCID="16385" EnglishName="Arabic (Qatar)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARQ" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-QA"/>
                <LocCulture RFC3066Name="qps-plocm" LCID="2559" EnglishName="Pseudo (Mirror)" ISO639_1="ar" ISO639_2="ara" WindowsTLA="ARA" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar-SA" />
	</LocCulture>
	<LocCulture RFC3066Name="bg" LCID="2" EnglishName="Bulgarian" ISO639_1="bg" ISO639_2="bul" WindowsTLA="BGR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="bg">
		<LocCulture RFC3066Name="bg-BG" LCID="1026" EnglishName="Bulgarian (Bulgaria)" ISO639_1="bg" ISO639_2="bul" WindowsTLA="BGR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="bg-BG"/>
	</LocCulture>
	<LocCulture RFC3066Name="ca" LCID="3" EnglishName="Catalan" ISO639_1="ca" ISO639_2="cat" WindowsTLA="CAT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ca">
		<LocCulture RFC3066Name="ca-ES" LCID="1027" EnglishName="Catalan (Catalan)" ISO639_1="ca" ISO639_2="cat" WindowsTLA="CAT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ca-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="zh-CHS" LCID="4" EnglishName="Chinese (Simplified)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHS" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-CHS">
		<LocCulture RFC3066Name="zh-CN" LCID="2052" EnglishName="Chinese (PRC)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHS" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-CN"/>
		<LocCulture RFC3066Name="zh-SG" LCID="4100" EnglishName="Chinese (Singapore)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHI" ANSICodePage="936" OEMCodePage="936" MacCodePage="10008" RightToLeft="0" BuiltInCultureInfo="zh-SG"/>
	</LocCulture>
	<LocCulture RFC3066Name="cs" LCID="5" EnglishName="Czech" ISO639_1="cs" ISO639_2="ces" WindowsTLA="CSY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="cs">
		<LocCulture RFC3066Name="cs-CZ" LCID="1029" EnglishName="Czech (Czech Republic)" ISO639_1="cs" ISO639_2="ces" WindowsTLA="CSY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="cs-CZ"/>
	</LocCulture>
	<LocCulture RFC3066Name="da" LCID="6" EnglishName="Danish" ISO639_1="da" ISO639_2="dan" WindowsTLA="DAN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="da">
		<LocCulture RFC3066Name="da-DK" LCID="1030" EnglishName="Danish (Denmark)" ISO639_1="da" ISO639_2="dan" WindowsTLA="DAN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="da-DK"/>
	</LocCulture>
	<LocCulture RFC3066Name="de" LCID="7" EnglishName="German" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de">
		<LocCulture RFC3066Name="de-DE" LCID="1031" EnglishName="German (Germany)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-DE"/>
		<LocCulture RFC3066Name="de-CH" LCID="2055" EnglishName="German (Switzerland)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DES" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-CH"/>
		<LocCulture RFC3066Name="de-AT" LCID="3079" EnglishName="German (Austria)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-AT"/>
		<LocCulture RFC3066Name="de-LU" LCID="4103" EnglishName="German (Luxembourg)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-LU"/>
		<LocCulture RFC3066Name="de-LI" LCID="5127" EnglishName="German (Liechtenstein)" ISO639_1="de" ISO639_2="deu" WindowsTLA="DEC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="de-LI"/>
	</LocCulture>
	<LocCulture RFC3066Name="el" LCID="8" EnglishName="Greek" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="737" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el">
		<LocCulture RFC3066Name="el-GR" LCID="1032" EnglishName="Greek (Greece)" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="737" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el-GR"/>
		<LocCulture RFC3066Name="el-GR-2" LCID="8200" EnglishName="Greek 2 (Greece)" ISO639_1="el" ISO639_2="ell" WindowsTLA="ELL" ANSICodePage="1253" OEMCodePage="869" MacCodePage="10006" RightToLeft="0" BuiltInCultureInfo="el-GR"/>
    	</LocCulture>
	<LocCulture RFC3066Name="en" LCID="9" EnglishName="English" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en">
		<LocCulture RFC3066Name="en-US" LCID="1033" EnglishName="English (United States)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-US"/>
		<LocCulture RFC3066Name="en-GB" LCID="2057" EnglishName="English (United Kingdom)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/>
		<LocCulture RFC3066Name="en-AU" LCID="3081" EnglishName="English (Australia)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-AU"/>
		<LocCulture RFC3066Name="en-CA" LCID="4105" EnglishName="English (Canada)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-CA"/>
		<LocCulture RFC3066Name="en-NZ" LCID="5129" EnglishName="English (New Zealand)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENZ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-NZ"/>
		<LocCulture RFC3066Name="en-IE" LCID="6153" EnglishName="English (Ireland)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-IE"/>
		<LocCulture RFC3066Name="en-ZA" LCID="7177" EnglishName="English (South Africa)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENS" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-ZA"/>
		<LocCulture RFC3066Name="en-JM" LCID="8201" EnglishName="English (Jamaica)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENJ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-JM"/>
		<LocCulture RFC3066Name="en-029" LCID="9225" EnglishName="English (Caribbean)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="en-BZ" LCID="10249" EnglishName="English (Belize)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-BZ"/>
		<LocCulture RFC3066Name="en-TT" LCID="11273" EnglishName="English (Trinidad and Tobago)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-TT"/>
		<LocCulture RFC3066Name="en-ZW" LCID="12297" EnglishName="English (Zimbabwe)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENW" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-ZW"/>
		<LocCulture RFC3066Name="en-PH" LCID="13321" EnglishName="English (Republic of the Philippines)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENP" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-PH"/>
		<LocCulture RFC3066Name="en-IN" LCID="16393" EnglishName="English (India)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/> 
		<LocCulture RFC3066Name="en-MY" LCID="17417" EnglishName="English (Malaysia)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENM" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/>
		<LocCulture RFC3066Name="en-SG" LCID="18441" EnglishName="English (Singapore)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENE" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="en-GB"/> 
                <LocCulture RFC3066Name="qps-ploc" LCID="1281" EnglishName="Pseudo Language (Pseudo Country)" ISO639_1="en" ISO639_2="eng" WindowsTLA="ENU" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="en-US" />
	</LocCulture>
	<LocCulture RFC3066Name="es" LCID="10" EnglishName="Spanish" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es">
        	<LocCulture RFC3066Name="es-es_tradnl" LCID="1034" EnglishName="Spanish, Traditional Sort (Spain)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="es-MX" LCID="2058" EnglishName="Spanish (Mexico)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-MX"/>
		<LocCulture RFC3066Name="es-ES" LCID="3082" EnglishName="Spanish, International Sort (Spain)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-ES"/>
		<LocCulture RFC3066Name="es-GT" LCID="4106" EnglishName="Spanish (Guatemala)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-GT"/>
		<LocCulture RFC3066Name="es-CR" LCID="5130" EnglishName="Spanish (Costa Rica)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CR"/>
		<LocCulture RFC3066Name="es-PA" LCID="6154" EnglishName="Spanish (Panama)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PA"/>
		<LocCulture RFC3066Name="es-DO" LCID="7178" EnglishName="Spanish (Dominican Republic)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-DO"/>
		<LocCulture RFC3066Name="es-VE" LCID="8202" EnglishName="Spanish (Venezuela)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESV" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-VE"/>
		<LocCulture RFC3066Name="es-CO" LCID="9226" EnglishName="Spanish (Colombia)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CO"/>
		<LocCulture RFC3066Name="es-PE" LCID="10250" EnglishName="Spanish (Peru)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PE"/>
		<LocCulture RFC3066Name="es-AR" LCID="11274" EnglishName="Spanish (Argentina)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-AR"/>
		<LocCulture RFC3066Name="es-EC" LCID="12298" EnglishName="Spanish (Ecuador)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-EC"/>
		<LocCulture RFC3066Name="es-CL" LCID="13322" EnglishName="Spanish (Chile)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-CL"/>
		<LocCulture RFC3066Name="es-UY" LCID="14346" EnglishName="Spanish (Uruguay)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESY" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-UY"/>
		<LocCulture RFC3066Name="es-PY" LCID="15370" EnglishName="Spanish (Paraguay)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESZ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PY"/>
		<LocCulture RFC3066Name="es-BO" LCID="16394" EnglishName="Spanish (Bolivia)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-BO"/>
		<LocCulture RFC3066Name="es-SV" LCID="17418" EnglishName="Spanish (El Salvador)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-SV"/>
		<LocCulture RFC3066Name="es-HN" LCID="18442" EnglishName="Spanish (Honduras)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESH" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-HN"/>
		<LocCulture RFC3066Name="es-NI" LCID="19466" EnglishName="Spanish (Nicaragua)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-NI"/>
		<LocCulture RFC3066Name="es-PR" LCID="20490" EnglishName="Spanish (Puerto Rico)" ISO639_1="es" ISO639_2="spa" WindowsTLA="ESU" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es-PR"/>
		<LocCulture RFC3066Name="es-US" LCID="21514" EnglishName="Spanish (United States)" ISO639_1="es" ISO639_2="spa" WindowsTLA="EST" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="es"/>
	</LocCulture>
	<LocCulture RFC3066Name="fi" LCID="11" EnglishName="Finnish" ISO639_1="fi" ISO639_2="fin" WindowsTLA="FIN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fi">
		<LocCulture RFC3066Name="fi-FI" LCID="1035" EnglishName="Finnish (Finland)" ISO639_1="fi" ISO639_2="fin" WindowsTLA="FIN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fi-FI"/>
	</LocCulture>
	<LocCulture RFC3066Name="fr" LCID="12" EnglishName="French" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr">
		<LocCulture RFC3066Name="fr-FR" LCID="1036" EnglishName="French (France)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-FR"/>
		<LocCulture RFC3066Name="fr-BE" LCID="2060" EnglishName="French (Belgium)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-BE"/>
		<LocCulture RFC3066Name="fr-CA" LCID="3084" EnglishName="French (Canada)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-CA"/>
		<LocCulture RFC3066Name="fr-CH" LCID="4108" EnglishName="French (Switzerland)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-CH"/>
		<LocCulture RFC3066Name="fr-LU" LCID="5132" EnglishName="French (Luxembourg)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-LU"/>
		<LocCulture RFC3066Name="fr-MC" LCID="6156" EnglishName="French (Monaco)" ISO639_1="fr" ISO639_2="fra" WindowsTLA="FRM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="fr-MC"/>
	</LocCulture>
	<LocCulture RFC3066Name="he" LCID="13" EnglishName="Hebrew" ISO639_1="he" ISO639_2="heb" WindowsTLA="HEB" ANSICodePage="1255" OEMCodePage="862" MacCodePage="10005" RightToLeft="1" BuiltInCultureInfo="he">
		<LocCulture RFC3066Name="he-IL" LCID="1037" EnglishName="Hebrew (Israel)" ISO639_1="he" ISO639_2="heb" WindowsTLA="HEB" ANSICodePage="1255" OEMCodePage="862" MacCodePage="10005" RightToLeft="1" BuiltInCultureInfo="he-IL"/>
	</LocCulture>
	<LocCulture RFC3066Name="hu" LCID="14" EnglishName="Hungarian" ISO639_1="hu" ISO639_2="hun" WindowsTLA="HUN" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="hu">
		<LocCulture RFC3066Name="hu-HU" LCID="1038" EnglishName="Hungarian (Hungary)" ISO639_1="hu" ISO639_2="hun" WindowsTLA="HUN" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="hu-HU"/>
	</LocCulture>
	<LocCulture RFC3066Name="is" LCID="15" EnglishName="Icelandic" ISO639_1="is" ISO639_2="isl" WindowsTLA="ISL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="is">
		<LocCulture RFC3066Name="is-IS" LCID="1039" EnglishName="Icelandic (Iceland)" ISO639_1="is" ISO639_2="isl" WindowsTLA="ISL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="is-IS"/>
	</LocCulture>
	<LocCulture RFC3066Name="it" LCID="16" EnglishName="Italian" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it">
		<LocCulture RFC3066Name="it-IT" LCID="1040" EnglishName="Italian (Italy)" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it-IT"/>
		<LocCulture RFC3066Name="it-CH" LCID="2064" EnglishName="Italian (Switzerland)" ISO639_1="it" ISO639_2="ita" WindowsTLA="ITS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="it-CH"/>
	</LocCulture>
	<LocCulture RFC3066Name="ja" LCID="17" EnglishName="Japanese" ISO639_1="ja" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja">
		<LocCulture RFC3066Name="ja-JP" LCID="1041" EnglishName="Japanese (Japan)" ISO639_1="ja" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja-JP"/>
                <LocCulture RFC3066Name="qps-ploca" LCID="1534" EnglishName="Pseudo (Asia)" ISO639_1="qps" ISO639_2="jpn" WindowsTLA="JPN" ANSICodePage="932" OEMCodePage="932" MacCodePage="10001" RightToLeft="0" BuiltInCultureInfo="ja-JP" />
	</LocCulture>
	<LocCulture RFC3066Name="ko" LCID="18" EnglishName="Korean" ISO639_1="ko" ISO639_2="kor" WindowsTLA="KOR" ANSICodePage="949" OEMCodePage="949" MacCodePage="10003" RightToLeft="0" BuiltInCultureInfo="ko">
		<LocCulture RFC3066Name="ko-KR" LCID="1042" EnglishName="Korean (Korea)" ISO639_1="ko" ISO639_2="kor" WindowsTLA="KOR" ANSICodePage="949" OEMCodePage="949" MacCodePage="10003" RightToLeft="0" BuiltInCultureInfo="ko-KR"/>
	</LocCulture>
	<LocCulture RFC3066Name="nl" LCID="19" EnglishName="Dutch" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl">
		<LocCulture RFC3066Name="nl-NL" LCID="1043" EnglishName="Dutch (Netherlands)" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl-NL"/>
		<LocCulture RFC3066Name="nl-BE" LCID="2067" EnglishName="Dutch (Belgium)" ISO639_1="nl" ISO639_2="nld" WindowsTLA="NLB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nl-BE"/>
	</LocCulture>
	<LocCulture RFC3066Name="no" LCID="20" EnglishName="Norwegian" ISO639_1="no" ISO639_2="nor" WindowsTLA="NOR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="no">
		<LocCulture RFC3066Name="nb-NO" LCID="1044" EnglishName="Norwegian, Bokmål (Norway)" ISO639_1="nb" ISO639_2="nob" WindowsTLA="NOR" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nb-NO"/>
		<LocCulture RFC3066Name="nn-NO" LCID="2068" EnglishName="Norwegian, Nynorsk (Norway)" ISO639_1="nn" ISO639_2="nno" WindowsTLA="NON" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="nn-NO"/>
	</LocCulture>
	<LocCulture RFC3066Name="pl" LCID="21" EnglishName="Polish" ISO639_1="pl" ISO639_2="pol" WindowsTLA="PLK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="pl">
		<LocCulture RFC3066Name="pl-PL" LCID="1045" EnglishName="Polish (Poland)" ISO639_1="pl" ISO639_2="pol" WindowsTLA="PLK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="pl-PL"/>
	</LocCulture>
	<LocCulture RFC3066Name="pt" LCID="22" EnglishName="Portuguese" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt">
		<LocCulture RFC3066Name="pt-BR" LCID="1046" EnglishName="Portuguese (Brazil)" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt-BR"/>
		<LocCulture RFC3066Name="pt-PT" LCID="2070" EnglishName="Portuguese (Portugal)" ISO639_1="pt" ISO639_2="por" WindowsTLA="PTG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="pt-PT"/>
	</LocCulture>
	<LocCulture RFC3066Name="rm" LCID="23" EnglishName="Romansh" ISO639_1="rm" ISO639_2="roh" WindowsTLA="RMC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="rm-CH" LCID="1047" EnglishName="Romansh (Switzerland)" ISO639_1="rm" ISO639_2="roh" WindowsTLA="RMC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ro" LCID="24" EnglishName="Romanian" ISO639_1="ro" ISO639_2="ron" WindowsTLA="ROM" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="ro">
		<LocCulture RFC3066Name="ro-RO" LCID="1048" EnglishName="Romanian (Romania)" ISO639_1="ro" ISO639_2="ron" WindowsTLA="ROM" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="ro-RO"/>
	</LocCulture>
	<LocCulture RFC3066Name="ru" LCID="25" EnglishName="Russian" ISO639_1="ru" ISO639_2="rus" WindowsTLA="RUS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ru">
		<LocCulture RFC3066Name="ru-RU" LCID="1049" EnglishName="Russian (Russia)" ISO639_1="ru" ISO639_2="rus" WindowsTLA="RUS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ru-RU"/>
	</LocCulture>
	<LocCulture RFC3066Name="hr" LCID="26" EnglishName="Croatian" ISO639_1="hr" ISO639_2="hrv" WindowsTLA="HRV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr">
		<LocCulture RFC3066Name="hr-HR" LCID="1050" EnglishName="Croatian (Croatia)" ISO639_1="hr" ISO639_2="hrv" WindowsTLA="HRV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr-HR"/>
		<LocCulture RFC3066Name="hr-BA" LCID="4122" EnglishName="Croatian (Latin, Bosnia and Herzegovina)" ISO639_1="hr" ISO639_2="hrb" WindowsTLA="HRB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="hr-HR"/>
	</LocCulture>
	<LocCulture RFC3066Name="sk" LCID="27" EnglishName="Slovak" ISO639_1="sk" ISO639_2="slk" WindowsTLA="SKY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sk">
		<LocCulture RFC3066Name="sk-SK" LCID="1051" EnglishName="Slovak (Slovakia)" ISO639_1="sk" ISO639_2="slk" WindowsTLA="SKY" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sk-SK"/>
	</LocCulture>
	<LocCulture RFC3066Name="sq" LCID="28" EnglishName="Albanian" ISO639_1="sq" ISO639_2="sqi" WindowsTLA="SQI" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sq">
		<LocCulture RFC3066Name="sq-AL" LCID="1052" EnglishName="Albanian (Albania)" ISO639_1="sq" ISO639_2="sqi" WindowsTLA="SQI" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sq-AL"/>
	</LocCulture>
	<LocCulture RFC3066Name="sv" LCID="29" EnglishName="Swedish" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv">
		<LocCulture RFC3066Name="sv-SE" LCID="1053" EnglishName="Swedish (Sweden)" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv-SE"/>
		<LocCulture RFC3066Name="sv-FI" LCID="2077" EnglishName="Swedish (Finland)" ISO639_1="sv" ISO639_2="swe" WindowsTLA="SVF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sv-FI"/>
	</LocCulture>
	<LocCulture RFC3066Name="th" LCID="30" EnglishName="Thai" ISO639_1="th" ISO639_2="tha" WindowsTLA="THA" ANSICodePage="874" OEMCodePage="874" MacCodePage="10021" RightToLeft="0" BuiltInCultureInfo="th">
		<LocCulture RFC3066Name="th-TH" LCID="1054" EnglishName="Thai (Thailand)" ISO639_1="th" ISO639_2="tha" WindowsTLA="THA" ANSICodePage="874" OEMCodePage="874" MacCodePage="10021" RightToLeft="0" BuiltInCultureInfo="th-TH"/>
	</LocCulture>
	<LocCulture RFC3066Name="tr" LCID="31" EnglishName="Turkish" ISO639_1="tr" ISO639_2="tur" WindowsTLA="TRK" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="tr">
		<LocCulture RFC3066Name="tr-TR" LCID="1055" EnglishName="Turkish (Turkey)" ISO639_1="tr" ISO639_2="tur" WindowsTLA="TRK" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="tr-TR"/>
	</LocCulture>
	<LocCulture RFC3066Name="ur" LCID="32" EnglishName="Urdu" ISO639_1="ur" ISO639_2="urd" WindowsTLA="URD" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ur">
		<LocCulture RFC3066Name="ur-PK" LCID="1056" EnglishName="Urdu (Pakistan)" ISO639_1="ur" ISO639_2="urd" WindowsTLA="URD" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ur-PK"/>
	</LocCulture>
	<LocCulture RFC3066Name="id" LCID="33" EnglishName="Indonesian" ISO639_1="id" ISO639_2="ind" WindowsTLA="IND" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="id">
		<LocCulture RFC3066Name="id-ID" LCID="1057" EnglishName="Indonesian (Indonesia)" ISO639_1="id" ISO639_2="ind" WindowsTLA="IND" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="id-ID"/>
	</LocCulture>
	<LocCulture RFC3066Name="uk" LCID="34" EnglishName="Ukrainian" ISO639_1="uk" ISO639_2="ukr" WindowsTLA="UKR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10017" RightToLeft="0" BuiltInCultureInfo="uk">
		<LocCulture RFC3066Name="uk-UA" LCID="1058" EnglishName="Ukrainian (Ukraine)" ISO639_1="uk" ISO639_2="ukr" WindowsTLA="UKR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10017" RightToLeft="0" BuiltInCultureInfo="uk-UA"/>
	</LocCulture>
	<LocCulture RFC3066Name="be" LCID="35" EnglishName="Belarusian" ISO639_1="be" ISO639_2="bel" WindowsTLA="BEL" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="be">
		<LocCulture RFC3066Name="be-BY" LCID="1059" EnglishName="Belarusian (Belarus)" ISO639_1="be" ISO639_2="bel" WindowsTLA="BEL" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="be-BY"/>
	</LocCulture>
	<LocCulture RFC3066Name="sl" LCID="36" EnglishName="Slovenian" ISO639_1="sl" ISO639_2="slv" WindowsTLA="SLV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sl">
		<LocCulture RFC3066Name="sl-SI" LCID="1060" EnglishName="Slovenian (Slovenia)" ISO639_1="sl" ISO639_2="slv" WindowsTLA="SLV" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="sl-SI"/>
	</LocCulture>
	<LocCulture RFC3066Name="et" LCID="37" EnglishName="Estonian" ISO639_1="et" ISO639_2="est" WindowsTLA="ETI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="et">
		<LocCulture RFC3066Name="et-EE" LCID="1061" EnglishName="Estonian (Estonia)" ISO639_1="et" ISO639_2="est" WindowsTLA="ETI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="et-EE"/>
	</LocCulture>
	<LocCulture RFC3066Name="lv" LCID="38" EnglishName="Latvian" ISO639_1="lv" ISO639_2="lav" WindowsTLA="LVI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lv">
		<LocCulture RFC3066Name="lv-LV" LCID="1062" EnglishName="Latvian (Latvia)" ISO639_1="lv" ISO639_2="lav" WindowsTLA="LVI" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lv-LV"/>
	</LocCulture>
	<LocCulture RFC3066Name="lt" LCID="39" EnglishName="Lithuanian" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTH" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt">
		<LocCulture RFC3066Name="lt-LT" LCID="1063" EnglishName="Lithuanian (Lithuania)" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTH" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt-LT"/>
		<LocCulture RFC3066Name="lt-LT-C" LCID="2087" EnglishName="Lithuanian, Classic (Lithuania)" ISO639_1="lt" ISO639_2="lit" WindowsTLA="LTC" ANSICodePage="1257" OEMCodePage="775" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="lt-LT"/>
	</LocCulture>
	<LocCulture RFC3066Name="tg" LCID="40" EnglishName="Tajik" ISO639_1="tg" ISO639_2="tgk" WindowsTLA="TAJ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tg-Cyrl-TJ" LCID="1064" EnglishName="Tajik (Cyrillic, Tajikistan)" ISO639_1="tg" ISO639_2="tgk" WindowsTLA="TAJ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="fa" LCID="41" EnglishName="Persian" ISO639_1="fa" ISO639_2="fas" WindowsTLA="FAR" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="fa">
		<LocCulture RFC3066Name="fa-IR" LCID="1065" EnglishName="Persian (Iran)" ISO639_1="fa" ISO639_2="fas" WindowsTLA="FAR" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="fa-IR"/>
	</LocCulture>
	<LocCulture RFC3066Name="vi" LCID="42" EnglishName="Vietnamese" ISO639_1="vi" ISO639_2="vie" WindowsTLA="VIT" ANSICodePage="1258" OEMCodePage="1258" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="vi">
		<LocCulture RFC3066Name="vi-VN" LCID="1066" EnglishName="Vietnamese (Vietnam)" ISO639_1="vi" ISO639_2="vie" WindowsTLA="VIT" ANSICodePage="1258" OEMCodePage="1258" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="vi-VN"/>
	</LocCulture>
	<LocCulture RFC3066Name="hy" LCID="43" EnglishName="Armenian" ISO639_1="hy" ISO639_2="hye" WindowsTLA="HYE" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hy">
		<LocCulture RFC3066Name="hy-AM" LCID="1067" EnglishName="Armenian (Armenia)" ISO639_1="hy" ISO639_2="hye" WindowsTLA="HYE" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hy-AM"/>
	</LocCulture>
	<LocCulture RFC3066Name="az" LCID="44" EnglishName="Azeri" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZE" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="az">
		<LocCulture RFC3066Name="az-Latn-AZ" LCID="1068" EnglishName="Azeri (Latin, Azerbaijan)" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZE" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10081" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="az-Cyrl-AZ" LCID="2092" EnglishName="Azeri (Cyrillic, Azerbaijan)" ISO639_1="az" ISO639_2="aze" WindowsTLA="AZC" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="eu" LCID="45" EnglishName="Basque" ISO639_1="eu" ISO639_2="eus" WindowsTLA="EUQ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="eu">
		<LocCulture RFC3066Name="eu-ES" LCID="1069" EnglishName="Basque (Basque)" ISO639_1="eu" ISO639_2="eus" WindowsTLA="EUQ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="eu-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="wen" LCID="46" EnglishName="Sorbian" ISO639_1="hs" ISO639_2="hsb" WindowsTLA="HSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="wen-DE" LCID="1070" EnglishName="Upper Sorbian (Germany)" ISO639_1="wen" ISO639_2="wen" WindowsTLA="HSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
	    <LocCulture RFC3066Name="dsb-DE" LCID="2094" EnglishName="Lower Sorbian (Germany)" ISO639_1="dsb" ISO639_2="dsb" WindowsTLA="DSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
	</LocCulture>
	<LocCulture RFC3066Name="mk" LCID="47" EnglishName="Macedonian" ISO639_1="mk" ISO639_2="mkd" WindowsTLA="MKI" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mk">
		<LocCulture RFC3066Name="mk-MK" LCID="1071" EnglishName="Macedonian (Former Yugoslav Republic of Macedonia)" ISO639_1="mk" ISO639_2="mkd" WindowsTLA="MKI" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mk-MK"/>
	</LocCulture>
	<LocCulture RFC3066Name="st" LCID="48" EnglishName="Sutu" ISO639_1="st" ISO639_2="sot" WindowsTLA="SOT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="st-ZA" LCID="1072" EnglishName="Sutu (South Africa)" ISO639_1="st" ISO639_2="sot" WindowsTLA="SOT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="tn" LCID="50" EnglishName="Setswana" ISO639_1="tn" ISO639_2="tsn" WindowsTLA="TSN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tn-ZA" LCID="1074" EnglishName="Setswana (South Africa)" ISO639_1="tn" ISO639_2="tsn" WindowsTLA="TSN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="xh" LCID="52" EnglishName="isiXhosa" ISO639_1="xh" ISO639_2="xho" WindowsTLA="XHO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="xh-ZA" LCID="1076" EnglishName="isiXhosa (South Africa)" ISO639_1="xh" ISO639_2="xho" WindowsTLA="XHO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>    
	<LocCulture RFC3066Name="zu" LCID="53" EnglishName="isiZulu" ISO639_1="zu" ISO639_2="zul" WindowsTLA="ZUL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="zu-ZA" LCID="1077" EnglishName="isiZulu (South Africa)" ISO639_1="zu" ISO639_2="zul" WindowsTLA="ZUL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>    
	<LocCulture RFC3066Name="af" LCID="54" EnglishName="Afrikaans" ISO639_1="af" ISO639_2="afr" WindowsTLA="AFK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="af">
		<LocCulture RFC3066Name="af-ZA" LCID="1078" EnglishName="Afrikaans (South Africa)" ISO639_1="af" ISO639_2="afr" WindowsTLA="AFK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="af-ZA"/>
	</LocCulture>
	<LocCulture RFC3066Name="ka" LCID="55" EnglishName="Georgian" ISO639_1="ka" ISO639_2="kat" WindowsTLA="KAT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ka">
		<LocCulture RFC3066Name="ka-GE" LCID="1079" EnglishName="Georgian (Georgia)" ISO639_1="ka" ISO639_2="kat" WindowsTLA="KAT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ka-GE"/>
	</LocCulture>
	<LocCulture RFC3066Name="fo" LCID="56" EnglishName="Faroese" ISO639_1="fo" ISO639_2="fao" WindowsTLA="FOS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="fo">
		<LocCulture RFC3066Name="fo-FO" LCID="1080" EnglishName="Faroese (Faroe Islands)" ISO639_1="fo" ISO639_2="fao" WindowsTLA="FOS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10079" RightToLeft="0" BuiltInCultureInfo="fo-FO"/>
	</LocCulture>
	<LocCulture RFC3066Name="hi" LCID="57" EnglishName="Hindi" ISO639_1="hi" ISO639_2="hin" WindowsTLA="HIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hi">
		<LocCulture RFC3066Name="hi-IN" LCID="1081" EnglishName="Hindi (India)" ISO639_1="hi" ISO639_2="hin" WindowsTLA="HIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="hi-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="mt" LCID="58" EnglishName="Maltese" ISO639_1="mt" ISO639_2="mlt" WindowsTLA="MLT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="mt-MT" LCID="1082" EnglishName="Maltese (Malta)" ISO639_1="mt" ISO639_2="mlt" WindowsTLA="MLT" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
		<LocCulture RFC3066Name="se" LCID="59" EnglishName="Sami" ISO639_1="smi" ISO639_2="SME" WindowsTLA="SME" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="se-NO" LCID="1083" EnglishName="Sami, Northern (Norway)" ISO639_1="se" ISO639_2="sme" WindowsTLA="SME" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="se-SE" LCID="2107" EnglishName="Sami, Northern (Sweden)" ISO639_1="se" ISO639_2="smf" WindowsTLA="SMF" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="se-FI" LCID="3131" EnglishName="Sami, Northern (Finland)" ISO639_1="se" ISO639_2="smg" WindowsTLA="SMG" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smj-NO" LCID="4155" EnglishName="Sami, Lule (Norway)" ISO639_1="smj" ISO639_2="smj" WindowsTLA="SMJ" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smj-SE" LCID="5179" EnglishName="Sami, Lule (Sweden)" ISO639_1="smj" ISO639_2="smk" WindowsTLA="SMK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sma-NO" LCID="6203" EnglishName="Sami, Southern (Norway)" ISO639_1="sma" ISO639_2="sma" WindowsTLA="SMA" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sma-SE" LCID="7227" EnglishName="Sami, Southern (Sweden)" ISO639_1="sma" ISO639_2="SMB" WindowsTLA="SMB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="sms-FI" LCID="8251" EnglishName="Sami, Skolt (Finland)" ISO639_1="sms" ISO639_2="sms" WindowsTLA="SMS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="smn-FI" LCID="9275" EnglishName="Sami, Inari (Finland)" ISO639_1="smn" ISO639_2="smn" WindowsTLA="SMN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ga" LCID="60" EnglishName="Irish" ISO639_1="ga" ISO639_2="gle" WindowsTLA="IRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ga-GB" LCID="1084" EnglishName="Gaelic (Scotland)" ISO639_1="ga" ISO639_2="gle" WindowsTLA="GAE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="ga-IE" LCID="2108" EnglishName="Irish (Ireland)" ISO639_1="ga" ISO639_2="gle" WindowsTLA="IRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ms" LCID="62" EnglishName="Malay" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms">
		<LocCulture RFC3066Name="ms-MY" LCID="1086" EnglishName="Malay (Malaysia)" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms-MY"/>
		<LocCulture RFC3066Name="ms-BN" LCID="2110" EnglishName="Malay (Brunei Darussalam)" ISO639_1="ms" ISO639_2="msa" WindowsTLA="MSB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="ms-BN"/>
	</LocCulture>
	<LocCulture RFC3066Name="kk" LCID="63" EnglishName="Kazakh" ISO639_1="kk" ISO639_2="kaz" WindowsTLA="KKZ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="kk">
		<LocCulture RFC3066Name="kk-KZ" LCID="1087" EnglishName="Kazakh (Kazakhstan)" ISO639_1="kk" ISO639_2="kaz" WindowsTLA="KKZ" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="kk-KZ"/>
	</LocCulture>
	<LocCulture RFC3066Name="ky" LCID="64" EnglishName="Kyrgyz" ISO639_1="ky" ISO639_2="kir" WindowsTLA="KYR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ky">
		<LocCulture RFC3066Name="ky-KG" LCID="1088" EnglishName="Kyrgyz (Kyrgyzstan)" ISO639_1="ky" ISO639_2="kir" WindowsTLA="KYR" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="ky-KG"/>
	</LocCulture>
	<LocCulture RFC3066Name="sw" LCID="65" EnglishName="Kiswahili" ISO639_1="sw" ISO639_2="swa" WindowsTLA="SWK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sw">
		<LocCulture RFC3066Name="sw-KE" LCID="1089" EnglishName="Kiswahili (Kenya)" ISO639_1="sw" ISO639_2="swa" WindowsTLA="SWK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="sw-KE"/>
	</LocCulture>
	<LocCulture RFC3066Name="tk" LCID="66" EnglishName="Turkmen" ISO639_1="tk" ISO639_2="tuk" WindowsTLA="TUK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="tk-TM" LCID="1090" EnglishName="Turkmen (Turkmenistan)" ISO639_1="tk" ISO639_2="tuk" WindowsTLA="TUK" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="uz" LCID="67" EnglishName="Uzbek" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="uz">
		<LocCulture RFC3066Name="uz-Latn-UZ" LCID="1091" EnglishName="Uzbek (Latin, Uzbekistan)" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1254" OEMCodePage="857" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
		<LocCulture RFC3066Name="uz-Cyrl-UZ" LCID="2115" EnglishName="Uzbek (Cyrillic, Uzbekistan)" ISO639_1="uz" ISO639_2="uzb" WindowsTLA="UZB" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
  	<LocCulture RFC3066Name="tt" LCID="68" EnglishName="Tatar" ISO639_1="tt" ISO639_2="tat" WindowsTLA="TTT" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="tt">
		<LocCulture RFC3066Name="tt-RU" LCID="1092" EnglishName="Tatar (Russia)" ISO639_1="tt" ISO639_2="tat" WindowsTLA="TTT" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="tt-RU"/>
	</LocCulture>
	<LocCulture RFC3066Name="bn" LCID="69" EnglishName="Bengali" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNG" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="bn-IN" LCID="1093" EnglishName="Bengali (India)" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNG" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	        <LocCulture RFC3066Name="bn-BD" LCID="2117" EnglishName="Bengali (Bangladesh)" ISO639_1="bn" ISO639_2="bng" WindowsTLA="BNB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="pa" LCID="70" EnglishName="Punjabi" ISO639_1="pa" ISO639_2="pan" WindowsTLA="PAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="pa">
		<LocCulture RFC3066Name="pa-IN" LCID="1094" EnglishName="Punjabi (India)" ISO639_1="pa" ISO639_2="pan" WindowsTLA="PAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="pa-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="gu" LCID="71" EnglishName="Gujarati" ISO639_1="gu" ISO639_2="guj" WindowsTLA="GUJ" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="gu">
		<LocCulture RFC3066Name="gu-IN" LCID="1095" EnglishName="Gujarati (India)" ISO639_1="gu" ISO639_2="guj" WindowsTLA="GUJ" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="gu-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="or" LCID="72" EnglishName="Oriya" ISO639_1="or" ISO639_2="ori" WindowsTLA="ORI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="or-IN" LCID="1096" EnglishName="Oriya (India)" ISO639_1="or" ISO639_2="ori" WindowsTLA="ORI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	</LocCulture>
	<LocCulture RFC3066Name="ta" LCID="73" EnglishName="Tamil" ISO639_1="ta" ISO639_2="tam" WindowsTLA="TAM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ta">
		<LocCulture RFC3066Name="ta-IN" LCID="1097" EnglishName="Tamil (India)" ISO639_1="ta" ISO639_2="tam" WindowsTLA="TAM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="ta-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="te" LCID="74" EnglishName="Telugu" ISO639_1="te" ISO639_2="tel" WindowsTLA="TEL" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="te">
		<LocCulture RFC3066Name="te-IN" LCID="1098" EnglishName="Telugu (India)" ISO639_1="te" ISO639_2="tel" WindowsTLA="TEL" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="te-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="kn" LCID="75" EnglishName="Kannada" ISO639_1="kn" ISO639_2="kan" WindowsTLA="KDI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kn">
		<LocCulture RFC3066Name="kn-IN" LCID="1099" EnglishName="Kannada (India)" ISO639_1="kn" ISO639_2="kan" WindowsTLA="KDI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kn-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="ml" LCID="76" EnglishName="Malayalam" ISO639_1="ml" ISO639_2="mym" WindowsTLA="MYM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ml-IN" LCID="1100" EnglishName="Malayalam (India)" ISO639_1="ml" ISO639_2="mym" WindowsTLA="MYM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="as" LCID="77" EnglishName="Assamese" ISO639_1="as" ISO639_2="asm" WindowsTLA="ASM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="as-IN" LCID="1101" EnglishName="Assamese (India)" ISO639_1="as" ISO639_2="asm" WindowsTLA="ASM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="mr" LCID="78" EnglishName="Marathi" ISO639_1="mr" ISO639_2="mar" WindowsTLA="MAR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="mr">
		<LocCulture RFC3066Name="mr-IN" LCID="1102" EnglishName="Marathi (India)" ISO639_1="mr" ISO639_2="mar" WindowsTLA="MAR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="mr-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="sa" LCID="79" EnglishName="Sanskrit" ISO639_1="sa" ISO639_2="san" WindowsTLA="SAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="sa">
		<LocCulture RFC3066Name="sa-IN" LCID="1103" EnglishName="Sanskrit (India)" ISO639_1="sa" ISO639_2="san" WindowsTLA="SAN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="sa-IN"/>
	</LocCulture>
	<LocCulture RFC3066Name="mn" LCID="80" EnglishName="Mongolian" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNG" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn">
		<LocCulture RFC3066Name="mn-MN" LCID="1104" EnglishName="Mongolian (Cyrillic, Mongolia)" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNN" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn-MN"/>
		<LocCulture RFC3066Name="mn-Mong-CN" LCID="2128" EnglishName="Mongolian (Traditional Mongolian, PRC)" ISO639_1="mn" ISO639_2="mon" WindowsTLA="MNG" ANSICodePage="1251" OEMCodePage="1" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="mn-MN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="bo" LCID="81" EnglishName="Tibetan" ISO639_1="bo" ISO639_2="bod" WindowsTLA="BOB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="bo-CN" LCID="1105" EnglishName="Tibetan (PRC)" ISO639_1="bo" ISO639_2="bod" WindowsTLA="BOB" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
     	</LocCulture>
    	<LocCulture RFC3066Name="cy" LCID="82" EnglishName="Welsh" ISO639_1="cy" ISO639_2="cym" WindowsTLA="CYM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="cy-GB" LCID="1106" EnglishName="Welsh (United Kingdom)" ISO639_1="cy" ISO639_2="cym" WindowsTLA="CYM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="km" LCID="83" EnglishName="Khmer" ISO639_1="km" ISO639_2="khm" WindowsTLA="KHM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="km-KH" LCID="1107" EnglishName="Khmer (Cambodia)" ISO639_1="km" ISO639_2="khm" WindowsTLA="KHM" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="lo" LCID="84" EnglishName="Lao" ISO639_1="lo" ISO639_2="lao" WindowsTLA="LAO" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="lo-LA" LCID="1108" EnglishName="Lao (Lao P.D.R.)" ISO639_1="lo" ISO639_2="lao" WindowsTLA="LAO" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="gl" LCID="86" EnglishName="Galician" ISO639_1="gl" ISO639_2="glg" WindowsTLA="GLC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="gl">
		<LocCulture RFC3066Name="gl-ES" LCID="1110" EnglishName="Galician (Galician)" ISO639_1="gl" ISO639_2="glg" WindowsTLA="GLC" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="gl-ES"/>
	</LocCulture>
	<LocCulture RFC3066Name="kok" LCID="87" EnglishName="Konkani" ISO639_1="kok" ISO639_2="kok" WindowsTLA="KNK" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kok">
		<LocCulture RFC3066Name="kok-IN" LCID="1111" EnglishName="Konkani (India)" ISO639_1="kok" ISO639_2="kok" WindowsTLA="KNK" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="kok-IN"/>
	</LocCulture>
    	<LocCulture RFC3066Name="sd" LCID="89" EnglishName="Sindhi" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        	<LocCulture RFC3066Name="sd-IN" LCID="1113" EnglishName="Sindhi (India)" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
        	<LocCulture RFC3066Name="sd-PK" LCID="2137" EnglishName="Sindhi (Pakistan)" ISO639_1="sd" ISO639_2="snd" WindowsTLA="SND" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="syr" LCID="90" EnglishName="Syriac" ISO639_1="syr" ISO639_2="syr" WindowsTLA="SYR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="syr">
		<LocCulture RFC3066Name="syr-SY" LCID="1114" EnglishName="Syriac (Syria)" ISO639_1="syr" ISO639_2="syr" WindowsTLA="SYR" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="syr-SY"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="si" LCID="91" EnglishName="Sinhala" ISO639_1="si" ISO639_2="sin" WindowsTLA="SIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="si-LK" LCID="1115" EnglishName="Sinhala (Sri Lanka)" ISO639_1="si" ISO639_2="sin" WindowsTLA="SIN" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="iu" LCID="93" EnglishName="Inuktitut" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="iu-Cans-CA" LCID="1117" EnglishName="Inuktitut (Syllabics, Canada)" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUS" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        	<LocCulture RFC3066Name="iu-Latn-CA" LCID="2141" EnglishName="Inuktitut (Latin, Canada)" ISO639_1="iu" ISO639_2="iku" WindowsTLA="IUK" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="am" LCID="94" EnglishName="Amharic" ISO639_1="am" ISO639_2="amh" WindowsTLA="AMH" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="am-ET" LCID="1118" EnglishName="Amharic (Ethiopia)" ISO639_1="am" ISO639_2="amh" WindowsTLA="AMH" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    	</LocCulture>
    	<LocCulture RFC3066Name="tzm" LCID="95" EnglishName="Tamazight" ISO639_1="tzm" ISO639_2="tzm" WindowsTLA="TZM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="tzm-Latn-DZ" LCID="2143" EnglishName="Tamazight (Latin, Algeria)" ISO639_1="tzm" ISO639_2="tzm" WindowsTLA="TZM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="ne" LCID="97" EnglishName="Nepali" ISO639_1="ne" ISO639_2="nep" WindowsTLA="NEP" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="ne-NP" LCID="1121" EnglishName="Nepali (Nepal)" ISO639_1="ne" ISO639_2="nep" WindowsTLA="NEP" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="fy" LCID="98" EnglishName="Frisian" ISO639_1="fy" ISO639_2="fry" WindowsTLA="FYN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="fy-NL" LCID="1122" EnglishName="Frisian (Netherlands)" ISO639_1="fy" ISO639_2="fry" WindowsTLA="FYN" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="ps" LCID="99" EnglishName="Pashto" ISO639_1="ps" ISO639_2="pus" WindowsTLA="PAS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        	<LocCulture RFC3066Name="ps-AF" LCID="1123" EnglishName="Pashto (Afghanistan)" ISO639_1="ps" ISO639_2="pus" WindowsTLA="PAS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    	</LocCulture>
    	<LocCulture RFC3066Name="fil" LCID="100" EnglishName="Filipino" ISO639_1="fil" ISO639_2="fil" WindowsTLA="FPO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        	<LocCulture RFC3066Name="fil-PH" LCID="1124" EnglishName="Filipino (Philippines)" ISO639_1="fil" ISO639_2="fil" WindowsTLA="FPO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    	</LocCulture>
    <LocCulture RFC3066Name="dv" LCID="101" EnglishName="Divehi" ISO639_1="dv" ISO639_2="div" WindowsTLA="DIV" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="ar">
		<LocCulture RFC3066Name="dv-MV" LCID="1125" EnglishName="Divehi (Maldives)" ISO639_1="dv" ISO639_2="div" WindowsTLA="DIV" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="1" BuiltInCultureInfo="ar"/>
    </LocCulture>
    <LocCulture RFC3066Name="ha" LCID="104" EnglishName="Hausa" ISO639_1="ha" ISO639_2="hau" WindowsTLA="HAU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ha-Latn-NG" LCID="1128" EnglishName="Hausa (Latin, Nigeria)" ISO639_1="ha" ISO639_2="hau" WindowsTLA="HAU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="yo" LCID="106" EnglishName="Yoruba" ISO639_1="yo" ISO639_2="yor" WindowsTLA="YOR" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="yo-NG" LCID="1130" EnglishName="Yoruba (Nigeria)" ISO639_1="yo" ISO639_2="yor" WindowsTLA="YOR" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="quz" LCID="107" EnglishName="Quechua" ISO639_1="quz" ISO639_2="qub" WindowsTLA="QUB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="quz-BO" LCID="1131" EnglishName="Quechua (Bolivia)" ISO639_1="quz" ISO639_2="qub" WindowsTLA="QUB" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="quz-EC" LCID="2155" EnglishName="Quechua (Ecuador)" ISO639_1="quz" ISO639_2="que" WindowsTLA="QUE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="quz-PE" LCID="3179" EnglishName="Quechua (Peru)" ISO639_1="quz" ISO639_2="qup" WindowsTLA="QUP" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="nso" LCID="108" EnglishName="Sesotho sa Leboa" ISO639_1="nso" ISO639_2="nso" WindowsTLA="NSO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="nso-ZA" LCID="1132" EnglishName="Sesotho sa Leboa (South Africa)" ISO639_1="nso" ISO639_2="nso" WindowsTLA="NSO" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="ba" LCID="109" EnglishName="Bashkir" ISO639_1="ba" ISO639_2="bak" WindowsTLA="BAS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ba-RU" LCID="1133" EnglishName="Bashkir (Russia)" ISO639_1="ba" ISO639_2="bak" WindowsTLA="BAS" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="lb" LCID="110" EnglishName="Luxembourgish" ISO639_1="lb" ISO639_2="ltz" WindowsTLA="LBX" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="lb-LU" LCID="1134" EnglishName="Luxembourgish (Luxembourg)" ISO639_1="lb" ISO639_2="ltz" WindowsTLA="LBX" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="kl" LCID="111" EnglishName="Greenlandic" ISO639_1="kl" ISO639_2="kal" WindowsTLA="KAL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="kl-GL" LCID="1135" EnglishName="Greenlandic (Greenland)" ISO639_1="kl" ISO639_2="kal" WindowsTLA="KAL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="ig" LCID="112" EnglishName="Igbo" ISO639_1="ig" ISO639_2="ibo" WindowsTLA="IBO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="ig-NG" LCID="1136" EnglishName="Igbo (Nigeria)" ISO639_1="ig" ISO639_2="ibo" WindowsTLA="IBO" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="so" LCID="119" EnglishName="Somali" ISO639_1="so" ISO639_2="som" WindowsTLA="SOM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="so-SO" LCID="1143" EnglishName="Somali (Somalia)" ISO639_1="so" ISO639_2="som" WindowsTLA="SOM" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="ii" LCID="120" EnglishName="Yi" ISO639_1="ii" ISO639_2="iii" WindowsTLA="III" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="ii-CN" LCID="1144" EnglishName="Yi (PRC)" ISO639_1="ii" ISO639_2="iii" WindowsTLA="III" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="arn" LCID="122" EnglishName="Mapudungun" ISO639_1="arn" ISO639_2="arn" WindowsTLA="MPD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="arn-CL" LCID="1146" EnglishName="Mapudungun (Chile)" ISO639_1="arn" ISO639_2="arn" WindowsTLA="MPD" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="moh" LCID="124" EnglishName="Mohawk" ISO639_1="moh" ISO639_2="moh" WindowsTLA="MWK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="moh-CA" LCID="1148" EnglishName="Mohawk (Mohawk)" ISO639_1="moh" ISO639_2="moh" WindowsTLA="MWK" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="br" LCID="126" EnglishName="Breton" ISO639_1="br" ISO639_2="bre" WindowsTLA="BRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="br-FR" LCID="1150" EnglishName="Breton (France)" ISO639_1="br" ISO639_2="bre" WindowsTLA="BRE" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="ug" LCID="128" EnglishName="Uighur" ISO639_1="ug" ISO639_2="uig" WindowsTLA="UIG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar">
        <LocCulture RFC3066Name="ug-CN" LCID="1152" EnglishName="Uighur (PRC)" ISO639_1="ug" ISO639_2="uig" WindowsTLA="UIG" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/>
    </LocCulture>
    <LocCulture RFC3066Name="mi" LCID="129" EnglishName="Maori" ISO639_1="mi" ISO639_2="mri" WindowsTLA="MRI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="mi-NZ" LCID="1153" EnglishName="Maori (New Zealand)" ISO639_1="mi" ISO639_2="mri" WindowsTLA="MRI" ANSICodePage="0" OEMCodePage="1" MacCodePage="2" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="oc" LCID="130" EnglishName="Occitan" ISO639_1="oc" ISO639_2="oci" WindowsTLA="OCI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="oc-FR" LCID="1154" EnglishName="Occitan (France)" ISO639_1="oc" ISO639_2="oci" WindowsTLA="OCI" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="co" LCID="131" EnglishName="Corsican" ISO639_1="co" ISO639_2="cos" WindowsTLA="COS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="co-FR" LCID="1155" EnglishName="Corsican (France)" ISO639_1="co" ISO639_2="cos" WindowsTLA="COS" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="gsw" LCID="132" EnglishName="Alsatian" ISO639_1="gsw" ISO639_2="gsw" WindowsTLA="GSW" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="gsw-FR" LCID="1156" EnglishName="Alsatian (France)" ISO639_1="gsw" ISO639_2="gsw" WindowsTLA="GSW" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="sah" LCID="133" EnglishName="Yakut" ISO639_1="sah" ISO639_2="sah" WindowsTLA="SAH" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="sah-RU" LCID="1157" EnglishName="Yakut (Russia)" ISO639_1="sah" ISO639_2="sah" WindowsTLA="SAH" ANSICodePage="1251" OEMCodePage="866" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="qut" LCID="134" EnglishName="K'iche" ISO639_1="qut" ISO639_2="qut" WindowsTLA="QUT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="qut-GT" LCID="1158" EnglishName="K'iche (Guatemala)" ISO639_1="qut" ISO639_2="qut" WindowsTLA="QUT" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="rw" LCID="135" EnglishName="Kinyarwanda" ISO639_1="rw" ISO639_2="kin" WindowsTLA="KIN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="rw-RW" LCID="1159" EnglishName="Kinyarwanda (Rwanda)" ISO639_1="rw" ISO639_2="kin" WindowsTLA="KIN" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="wo" LCID="136" EnglishName="Wolof" ISO639_1="wo" ISO639_2="wol" WindowsTLA="WOL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"> 
	    <LocCulture RFC3066Name="wo-SN" LCID="1160" EnglishName="Wolof (Senegal)" ISO639_1="wo" ISO639_2="wol" WindowsTLA="WOL" ANSICodePage="1252" OEMCodePage="850" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="prs" LCID="140" EnglishName="Dari" ISO639_1="prs" ISO639_2="prs" WindowsTLA="PRS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"> 
	    <LocCulture RFC3066Name="prs-AF" LCID="1164" EnglishName="Dari (Afghanistan)" ISO639_1="prs" ISO639_2="prs" WindowsTLA="PRS" ANSICodePage="1256" OEMCodePage="720" MacCodePage="10004" RightToLeft="1" BuiltInCultureInfo="ar"/> 
    </LocCulture>
    <LocCulture RFC3066Name="bs" LCID="30746" EnglishName="Bosnian" ISO639_1="bs" ISO639_2="bsb" WindowsTLA="BSB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant">
        <LocCulture RFC3066Name="bs-Latn-BA" LCID="5146" EnglishName="Bosnian (Latin, Bosnia and Herzegovina)" ISO639_1="bs" ISO639_2="bsb" WindowsTLA="BSB" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
        <LocCulture RFC3066Name="bs-Cyrl-BA" LCID="8218" EnglishName="Bosnian (Cyrillic, Bosnia and Herzegovina)" ISO639_1="bs" ISO639_2="bsc" WindowsTLA="BSC" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
    <LocCulture RFC3066Name="zh-CHT" LCID="31748" EnglishName="Chinese (Traditional)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHT" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-CHT">
		<LocCulture RFC3066Name="zh-TW" LCID="1028" EnglishName="Chinese (Taiwan)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="CHT" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-TW"/>
		<LocCulture RFC3066Name="zh-HK" LCID="3076" EnglishName="Chinese (Hong Kong S.A.R.)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHH" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-HK"/>
		<LocCulture RFC3066Name="zh-MO" LCID="5124" EnglishName="Chinese (Macao S.A.R.)" ISO639_1="zh" ISO639_2="zho" WindowsTLA="ZHM" ANSICodePage="950" OEMCodePage="950" MacCodePage="10002" RightToLeft="0" BuiltInCultureInfo="zh-MO"/>
	</LocCulture>
    <LocCulture RFC3066Name="sr" LCID="31770" EnglishName="Serbian" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRB" ANSICodePage="1250" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="sr">
	<LocCulture RFC3066Name="sr-Latn-CS" LCID="2074" EnglishName="Serbian (Latin, Serbia and Montenegro)" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRL" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10029" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Cyrl-CS" LCID="3098" EnglishName="Serbian (Cyrillic, Serbia and Montenegro)" ISO639_1="sr" ISO639_2="srp" WindowsTLA="SRB" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Latn-BA" LCID="6170" EnglishName="Serbian (Latin, Bosnia and Herzegovina)" ISO639_1="sr" ISO639_2="SRS" WindowsTLA="SRS" ANSICodePage="1250" OEMCodePage="852" MacCodePage="10082" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="sr-Cyrl-BA" LCID="7194" EnglishName="Serbian (Cyrillic, Bosnia and Herzegovina)" ISO639_1="sr" ISO639_2="SRN" WindowsTLA="SRN" ANSICodePage="1251" OEMCodePage="855" MacCodePage="10007" RightToLeft="0" BuiltInCultureInfo="Invariant"/> 
    </LocCulture>
    <LocCulture RFC3066Name="neu" LCID="0" EnglishName="Neutral" ISO639_1="neu" ISO639_2="neu" WindowsTLA="NEU" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant">
	<LocCulture RFC3066Name="ned" LCID="1024" EnglishName="Neutral (Default)" ISO639_1="ned" ISO639_2="ned" WindowsTLA="NED" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
	<LocCulture RFC3066Name="nes" LCID="2048" EnglishName="Neutral (Sys. Default)" ISO639_1="nes" ISO639_2="nes" WindowsTLA="NES" ANSICodePage="1252" OEMCodePage="437" MacCodePage="10000" RightToLeft="0" BuiltInCultureInfo="Invariant"/>
    </LocCulture>
</LocCultures>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\Microsoft.LocVer.Settings.xml ===
﻿<TPSetting>
    <Owner Name="LocVer" DisplayName="Localization Verification (LocVer) Settings" Desc="Use these settings to control how Localization Verification (LocVer) is handled.">
        <Group Name="Rules" DisplayName="Rule Settings" Desc="Settings to control which localization rules (LocVer rules) should be processed.">
            <Setting Type="List" Name="Custom Rule Assemblies" DisplayName="Rule Assemblies" Value="" Desc="List of assemblies containing custom rules for LocVer.">
                <ValidValue Name="Microsoft.LocVer.Rules.dll,Microsoft.Localization.TransPlatform.Verification.Rules.CustomRules.RuleMap"/>
            </Setting>
            <Group Name="NameSpaces" DisplayName="Rule Namespaces" Desc="Settings to control which namespaces should be processed. A namespace precedes the rule name, e.g. for the rule {xsd:integer}, 'xsd' is the namespace.">
                <Setting Type="List" Name="Include" DisplayName="Include Only Rules From Namespaces" Value="" Desc="Only process rules that exist in the namespaces that are in this list.">
                </Setting>
                <Setting Type="List" Name="Exclude" DisplayName="Exclude Rules From Namespaces" Value="" Desc="Don't process any rules that exist in the namespaces that are in this list.">
                </Setting>
                <Setting Type="string" Name="Default NameSpace" DisplayName="Default Namespace" Value="LocVer" Desc="Any rule specified without a namespace, e.g. {Locked}, is in this namespace."/>
            </Group>
            <Setting Type="bool" Name="{ Adaptation }" Value="true" Desc="Rule { Adaptation = &lt;(sub)string&gt; } verifies that a &lt;(sub)string&gt; is translated according to translation found in a map file." />
            <Setting Type="bool" Name="{ AllGlobalRules }" Value="true" Desc="Rule { AllGlobalRules } forces all global rules to be run, irrespective of any other settings for LocVer." />
            <Setting Type="bool" Name="{ AllRules }" Value="true" Desc="Rule { AllRules } forces all rules for the current item to be run, irrespective of any other settings for LocVer." />
            <Setting Type="bool" Name="{ Comment }" Value="true" Desc="Rule { Comment = &lt;text&gt; } issues the &lt;text&gt; to the output." />
            <Setting Type="bool" Name="{ DataType }" Value="true" Desc="Rule { DataType = &lt;type&gt;,[&lt;facet&gt;,...] } verifies that the translation is of a specified data type and follows all supplied constraints (or facets)." />
            <Setting Type="bool" Name="{ Dependency }" Value="true" Desc="Rule { Dependency = &lt;type&gt;,[&lt;resourceId&gt;,...] } verifies that the translation matches another item." />
            <Setting Type="bool" Name="{ Duplicate }" Value="true" Desc="Rule { Duplicate = &lt;type&gt;,[&lt;resourceId&gt;,...] } verifies that the translation matches another item." />
            <Setting Type="bool" Name="{ EscapeChars }" Value="true" Desc="Rule { EscapeChars = &lt;x=yy&gt;,... } forces specified characters (x) to be escaped in the string using specified escape sequences (yy). " />
            <Setting Type="bool" Name="{ EscapePlaceholderChars }" Value="true" Desc="Rule { EscapePlaceholderChars = &lt;x=yy&gt;,... } forces specified characters (x) to be escaped in the string using specified escape sequences (yy). Does not apply to any part of the string that is covered by {Placeholder}, {NumberedPlaceholder} or {FixedPlaceholder} rules." />
            <Setting Type="bool" Name="{ FileName }" Value="true" Desc="Rule { FileName = SFNLock|SFNLocalizable/LFNLock|LFNLocalizable } verifies that a string is a correct file name." />
            <Setting Type="bool" Name="{ FixedPlaceHolder }" Value="true" Desc="Rule { FixedPlaceholder = &lt;plc1&gt;,&lt;plc2&gt;,... } verifies that the translation contains the same number of specified placeholders (&lt;plc1&gt;,...) as the source and that they are in the same order." />
            <Setting Type="bool" Name="{ Formatting }" Value="true" Desc="Rule { Formatting = parameters } verifies that a string uses the correct formatting." />
            <Setting Type="bool" Name="{ Hotkey }" Value="true" Desc="Rule { Hotkey } verifies that a string contains a hotkey." />
            <Setting Type="bool" Name="{ HTMLHotkey }" Value="true" Desc="Rule { HTMLHotkey = &lt;itemid&gt; } verifies that an accesskey item matches the hotkey in the master item (&lt;itemid&gt;)." />
            <Setting Type="bool" Name="{ InvalidChars }" Value="true" Desc="Rule { InvalidChars = &lt;chars&gt;,...} specifies that a set of characters (&lt;chars&gt;) cannot be used in the string." />
            <Setting Type="bool" Name="{ InvalidStrings }" Value="true" Desc="Rule { InvalidStrings = &lt;string1&gt;,&lt;string2&gt;... } verifies that the translation is not one of the strings (&lt;string1&gt;...) specified." />
            <Setting Type="bool" Name="{ Locked }" Value="true" Desc="Rule { Locked } reverts the translation to source and sets 'User Src Lock'." />
            <Setting Type="bool" Name="{ Map }" Value="true" Desc="Rule { Map = &lt;(sub)string&gt; } verifies that a &lt;(sub)string&gt; is translated according to translation found in a map file." />
            <Setting Type="bool" Name="{ MaxLength }" Value="true" Desc="Rule { MaxLength = &lt;X&gt;,&lt;namespace&gt; } verifies that the translation is not longer than &lt;X&gt; characters. If a &lt;namespace&gt; is specified, the rule verifies that the total length of the &lt;namespace&gt; is not longer than X. (Works Cross-EDBs)." />
            <Setting Type="bool" Name="{ Menu }" Value="true" Desc="Rule { Menu = &lt;namespace&gt; } verifies that there are no duplicate hotkeys within the &lt;namespace&gt;." />
            <Setting Type="bool" Name="{ MinLength }" Value="true" Desc="Rule { MinLength = &lt;X&gt;} verifies that the translation is at least &lt;X&gt; characters long." />
            <Setting Type="bool" Name="{ NoGlobalRules }" Value="true" Desc="Rule { NoGlobalRules } skips any global rules (specified in 'Global Rules' setting) for the current item." />
            <Setting Type="bool" Name="{ NoLocRules }" Value="true" Desc="Rule { NoLocRules } stops automatically generated restrictions on the item." />
            <Setting Type="bool" Name="{ NoRules }" Value="true" Desc="Rule { NoRules } suppresses all output for the current item, irrespective of any other settings for LocVer." />
            <Setting Type="bool" Name="{ NumberedPlaceHolder }" Value="true" Desc="Rule { NumberedPlaceholder = &lt;plc1&gt;,&lt;plc2&gt;,... } verifies that the translation contains the same placeholders (&lt;plc1&gt;,...) as the source." />
            <Setting Type="bool" Name="{ PlaceHolder }" Value="true" Desc="Rule { Placeholder = &lt;plc1&gt;,&lt;plc2&gt;,... } verifies that the translation contains the same number of specified placeholders (&lt;plc1&gt;,...) as the source." />
            <Setting Type="bool" Name="{ RegEx }" Value="true" Desc="Rule { RegEx = &lt;expr&gt;,[&lt;expr&gt;] } verifies that the translation matches the specified regular expression." />
            <Setting Type="bool" Name="{ RegExe }" Value="true" Desc="Deprecated: Rule { RegExe = &lt;expr&gt; } verifies that the translation matches the specified regular expression." />
            <Setting Type="bool" Name="{ RevertBinary }" Value="true" Desc="Deprecated: Rule { RevertBinary } reverts the binary translation to source." />
            <Setting Type="bool" Name="{ Split }" Value="true" Desc="Rule { Split = &lt;value&gt;,... } splits a string according to the parameter(s) supplied." />
            <Setting Type="bool" Name="{ StrBegins }" Value="true" Desc="Rule { StrBegins = &lt;value&gt; } ensures that a string begins with a certain sub string (value)." />
            <Setting Type="bool" Name="{ StrContains }" Value="true" Desc="Rule { StrContains = &lt;value&gt;,... } ensures that a string contains a certain sub string (value)." />
            <Setting Type="bool" Name="{ StrEnds }" Value="true" Desc="Rule { StrEnds = &lt;value&gt; } ensures that a string ends with a certain sub string (value)." />
            <Setting Type="bool" Name="{ StringCategory }" Value="true" Desc="Rule { StringCategory = &lt;category&gt; } sets the category of the string to specified value (&lt;category&gt;)." />
            <Setting Type="bool" Name="{ StringContains }" Value="true" Desc="Rule { StringContains = &lt;tla/lcid&gt; } verifies that the translation contains the LCID or TLA of the current target culture." />
            <Setting Type="bool" Name="{ SubString }" Value="true" Desc="Rule { SubString = &lt;value&gt;,... } allows only part of a string (&lt;value&gt;) to be localized. " />
            <Setting Type="bool" Name="{ TabOrder }" Value="true" Desc="Rule { TabOrder } is used to maintain TabOrder information per language." />
            <Setting Type="bool" Name="{ TransLocked }" Value="true" Desc="Rule { TransLocked } sets 'User Trans Lock' if localization status is set to Localized." />
            <Setting Type="bool" Name="{ Trx }" Value="true" Desc="Rule { Trx } forces the translation to be different than the source." />
            <Setting Type="bool" Name="{ ValidChars }" Value="true" Desc="Rule { ValidChars = &lt;chars&gt;,... } specifies that only a set of characters (&lt;chars&gt;) can be used in the string." />
            <Setting Type="bool" Name="{ ValidStrings }" Value="true" Desc="Rule { ValidStrings = &lt;string1&gt;,&lt;string2&gt;,... } verifies that only the strings (&lt;string1&gt;,...) specified are used as translations." />
            <Setting Type="bool" Name="{ ValidWordSeparators }" Value="true" Desc="Rule { ValidWordSeparators = &lt;wordsep&gt;} verifies that the only word separators used in the translation are those specified in &lt;wordsep&gt;." />
            <Setting Type="bool" Name="{ Words }" Value="true" Desc="Rule { Words = &lt;X&gt; } verifies that the Translation contains &lt;X&gt; number of words." />
            <Setting Type="bool" Name="{ UniqueInNameSpace }" Value="true" Desc="Rule { UniqueInNameSpace = &lt;namespace&gt; } verifies that the translation is unique within the &lt;namespace&gt;." />
            <Setting Type="bool" Name="{ __VerCodePage }" Value="true" Desc="Rule { __VerCodePage = codepage } verifies that the translation only contains characters valid on the specified codepage." />
            <Group Name="Centum Rules" DisplayName="Centum Rules" Desc="Settings for centum specific rules.">
                <Setting Type="bool" Name="{ Centum:BinLocked }" Value="false" Desc="Rule { Centum:BinLocked } ensures that the binary translation is the same as the source language (Centum specific, behaves like {Binary:Locked} )." />
                <Setting Type="bool" Name="{ Centum:BinTransLocked }" Value="false" Desc="Rule { Centum:BinTransLocked } ensures that the binary translation is not changed (Centum specific, behaves like {Binary:TransLocked} )." />
                <Setting Type="bool" Name="{ Centum:Locked }" Value="false" Desc="Rule { Centum:Locked } ensures that the translation is the same as the source language (Centum specific, behaves like {Locked} )." />
                <Setting Type="bool" Name="{ Centum:TransLocked }" Value="false" Desc="Rule { Centum:TransLocked } ensures that the translation is not changed (Centum specific, behaves like {TransLocked} )." />
            </Group>
            <Group Name="Binary Rules" DisplayName="Binary Rules" Desc="Settings for rules that affect the binary value of an item.">
                <Setting Type="bool" Name="{ Binary:Locked }" Value="true" Desc="Rule { Binary:Locked } ensures that the binary translation is the same as the source language." />
                <Setting Type="bool" Name="{ Binary:TransLocked }" Value="true" Desc="Rule { Binary:TransLocked } ensures that the binary translation is not changed." />
                <Setting Type="bool" Name="{ Binary:Trx }" Value="true" Desc="Rule { Binary:Trx } ensures that the binary translation is different from the source." />
            </Group>
            <Group Name="Logging Rules" DisplayName="Logging Rules" Desc="Settings for rules that affect the messages issued for an item.">
                <Setting Type="bool" Name="{ Log:Error }" Value="true" Desc="Rule { Log:Error } sets the severity of messages for the item to 'Error'." />
                <Setting Type="bool" Name="{ Log:Ignore }" Value="true" Desc="Rule { Log:Ignore } suppresses messages for the item." />
                <Setting Type="bool" Name="{ Log:Info }" Value="true" Desc="Rule { Log:Info } sets the severity of messages for the item to 'Info'." />
                <Setting Type="bool" Name="{ Log:Warning }" Value="true" Desc="Rule { Log:Warning } sets the severity of messages for the item to 'Warning'." />
            </Group>
            <Setting Type="string" Name="Global Rules" DisplayName="Global Rules" Value="" Desc="Specifies rules that will be evaluated against every item that LocVer runs on." />
            <Setting Type="List" Name="Keywords to ignore" DisplayName="Keywords To Ignore" Value="" Desc="All keywords in this list will be ignored. Example: If the list contains 'MyRule' and 'Locked', the rules '{MyRule}' and '{Locked}' will be ignored."/>
            <Setting Type="bool" Name="Invalid characters in translation" DisplayName="Check For Invalid Characters" Value="false" Desc="Check translations for invalid characters on the target language codepage."/>
            <Setting Type="bool" Name="Default parameters behave as LocVer 4.6" DisplayName="Default Parameters Behave As LocVer 4.6" Value="false" Desc="Use literal (false) or regular expression (true) parameters as default for rules {FixedPlaceholder}, {NumberedPlaceholder}, {Split}, {StrBegins}, {StrContains} and {StrEnds}"/>
        </Group>
        <Group Name="Messages" DisplayName="Message Settings" Desc="Settings for messages reported by LocVer.">
            <Setting Type="bool" Name="Report Unknown Rules" DisplayName="Report Unknown Rules" Value="true" Desc="Issue messages when LocVer encounters unknown rules."/>
            <Setting Type="bool" Name="Report Syntax Errors" DisplayName="Report Syntax Errors" Value="true" Desc="Issue messages when LocVer encounters errors in the syntax of instructions."/>
            <Setting Type="bool" Name="Report Source Messages" DisplayName="Report Source Messages" Value="true" Desc="Issue messages when LocVer encounters errors on the source item."/>
            <Setting Type="PickList" Name="Report messages as" DisplayName="Message Severity" Value="Default" Desc="The severity of all messages will be changed to the value specified in this setting. This setting overrides the settings 'Error Messages', 'Warning Messages', 'Informational Messages' and 'Ignore Messages' unless the value is 'Default'.">
                <ValidValue Name="Default" />
                <ValidValue Name="Error" />
                <ValidValue Name="Warning" />
                <ValidValue Name="Info" />
            </Setting>
            <Setting Type="List" Name="Error" DisplayName="Error Messages" Value="" Desc="Force severity to 'Error' for any messages with the same ID as listed in this setting."></Setting>
            <Setting Type="List" Name="Ignore" DisplayName="Ignore Messages" Value="" Desc="Ignore any messages with the same ID as listed in this setting."></Setting>
            <Setting Type="List" Name="Info" DisplayName="Informational Messages" Value="" Desc="Force severity to 'Info' for any messages with the same ID as listed in this setting."></Setting>
            <Setting Type="List" Name="Warning" DisplayName="Warning Messages" Value="" Desc="Force severity to 'Warning' for any messages with the same ID as listed in this setting."></Setting>
        </Group>
        <Group Name="Macros" DisplayName="Macro Settings" Desc="Settings for macros used by LocVer.">
            <Setting Type="string" Name="Macro File" DisplayName="Macro File" Value="" EditorType="FileNameEditor" Desc="Configuration file containing macros for LocVer." />
            <Setting Type="bool" Name="Skip Parameter Expansion" DisplayName="Skip Parameter Expansion" Value="false" Desc="If on, parameters with macros will not be expanded. @ symbols will be interpreted literary." />
        </Group>
        <Group Name="Language" DisplayName="Language Settings" Desc="Settings specific to the language being processed.">
            <Setting Type="string" Name="Behaves Like Lcid" DisplayName="Behaves Like Language" Value="" Desc="If this is set to a culture (other than 'x-neutral'), LocVer will consider the culture specified as being a substitute for the current target language when evaluating language specific rules. The culture will be used unless the current target language has been explicitly stated in an rule." />
            <Setting Type="string" Name="Valid Hotkeys" DisplayName="Valid Hotkeys" Value="" Desc="List of hotkeys that can be used for this language (case-insensitive)."/>
        </Group>
        <Group Name="Processing" DisplayName="Instruction Settings" Desc="Settings to control which instructions should be processed.">
            <Setting Type="bool" Name="Exclude Generated Instructions" DisplayName="Exclude Generated Instructions" Value="false" Desc="If on, do not process any instructions that have been auto generated (name ends with 'Gen' or the comment is enclosed by '&lt;&lt;' and '&gt;&gt;' or enclosed by &lt;gen&gt; and &lt;/gen&gt; tags)."/>
            <Setting Type="bool" Name="Only Developer Instructions" DisplayName="Include Only Developer Instructions" Value="false" Desc="Only process instructions from source files, i.e. enclosed by &lt;Dev&gt; and &lt;/Dev&gt;"/>
            <Setting Type="List" Name="Include Only From Tags" DisplayName="Include Only Instructions In Tags" Value="" Desc="Include only instructions within the list of tags.">
            </Setting>
            <Setting Type="List" Name="Exclude From Tags" DisplayName="Exclude Instructions In Tags" Value="" Desc="Exclude any instructions within the list of tags.">
            </Setting>
            <Setting Type="bool" Name="Term Note" DisplayName="Include Instructions From Term Note Field" Value="false" Desc="Include instructions from the term note field." />
            <Setting Type="int" Name="Custom Field" DisplayName="Include Instructions From Custom Field" Value="0" Desc="Specifies a custom field that instructions should be added from. Valid values are 0 to 6. If the value is 0, no instructions are added from a custom field." />
        </Group>
        <Group Name="Lookup and Namespaces" DisplayName="Lookup And Namespace Settings" Desc="Settings for namespace and lookup rules.">
            <Setting Type="bool" Name="Process lookups and namespaces" DisplayName="Process Lookups And Namespaces" Value="true" Desc="Should namespace and lookup rules be processed."/>
            <Setting Type="string" Name="Cached File" DisplayName="Cached File" Value="%TEMP%\@rfc3066@.lcx" EditorType="FileNameEditor" Desc="Path to cache file used for cross-file processing"></Setting>
        </Group>
    </Owner>
</TPSetting>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\FactorySettings.config.xml ===
<?xml version="1.0" encoding="utf-8"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="Config.xsd">
 <html>
  <localizable>
   <tags>
    <tag name="%"/>
    <tag name="A"/>
    <tag name="B"/>
    <tag name="BIG"/>
    <tag name="BLINK"/>
    <tag name="BR"/>
    <tag name="CITE"/>
    <tag name="CODE"/>
    <tag name="DFN"/>
    <tag name="EM"/>
    <tag name="FONT"/>
    <tag name="I"/>
    <tag name="IMG"/>
    <tag name="KBD"/>
    <tag name="NOBR"/>
    <tag name="RT"/>
    <tag name="RUBY"/>
    <tag name="S"/>
    <tag name="SAMP"/>
    <tag name="SMALL"/>
    <tag name="SPAN"/>
    <tag name="STRIKE"/>
    <tag name="STRONG"/>
    <tag name="SUB"/>
    <tag name="SUP"/>
    <tag name="TT"/>
    <tag name="U"/>
    <tag name="VAR"/>
    <tag name="WBR"/>
   </tags>
   <attributes>
    <tag name="!--">
     <attribute name="(IncludeFile)" category="File Name"/>
    </tag>
    <tag name="(Default)">
     <attribute name="accessKey" category="Accelerator"/>
     <attribute name="align" category="Property"/>
     <attribute name="alt" category="Alternative Text"/>
     <attribute name="Title" category="HTML Title"/>
    </tag>
    <tag name="A">
     <attribute name="href" category="Address"/>
     <attribute name="URN" category="Address"/>
    </tag>
    <tag name="APPLET">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="AREA">
     <attribute name="href" category="Address"/>
    </tag>
    <tag name="BASE">
     <attribute name="href" category="Address"/>
    </tag>
    <tag name="BASEFONT">
     <attribute name="face" category="Font Name"/>
     <attribute name="size" category="Number"/>
    </tag>
    <tag name="BGSOUND">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="BODY">
     <attribute name="Background" category="File Name"/>
    </tag>
    <tag name="CAPTION">
     <attribute name="Background" category="File Name"/>
    </tag>
    <tag name="EMBED">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="EVENT">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="FONT">
     <attribute name="face" category="Font Name"/>
     <attribute name="size" category="Number"/>
    </tag>
    <tag name="FRAME">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="HR">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="IFRAME">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="IMG">
     <attribute name="dynSrc" category="File Name"/>
     <attribute name="lowsrc" category="File Name"/>
     <attribute name="src" category="File Name"/>
     <attribute name="useMap" category="File Name"/>
     <attribute name="vrml" category="File Name"/>
    </tag>
    <tag name="INPUT">
     <attribute name="defaultValue" category="Static Text"/>
     <attribute name="size" category="Number"/>
     <attribute name="src" category="File Name"/>
     <attribute name="Value" category="Static Text"/>
    </tag>
    <tag name="LINK">
     <attribute name="href" category="Address"/>
     <attribute name="URN" category="Address"/>
    </tag>
    <tag name="META">
     <attribute name="URL" category="Address"/>
    </tag>
    <tag name="OBJECT">
     <attribute name="Standby" category="Message"/>
    </tag>
    <tag name="OPTION">
     <attribute name="Value" category="Static Text"/>
    </tag>
    <tag name="PARAM">
     <attribute name="Value" category="Static Text"/>
    </tag>
    <tag name="SCRIPT">
     <attribute name="src" category="File Name"/>
    </tag>
    <tag name="TD">
     <attribute name="Background" category="File Name"/>
    </tag>
    <tag name="TEXTAREA">
     <attribute name="defaultValue" category="Static Text"/>
    </tag>
    <tag name="TH">
     <attribute name="Background" category="File Name"/>
    </tag>
    <tag name="UL">
     <attribute name="src" category="File Name"/>
    </tag>
   </attributes>
   <properties>
    <property name="font-family" category="Font Name"/>
    <property name="font-size" category="Number"/>
    <property name="height" category="Number"/>
    <property name="left" category="Number"/>
    <property name="line-height" category="Number"/>
    <property name="top" category="Number"/>
    <property name="width" category="Number"/>
   </properties>
  </localizable>
  <known>
   <tags/>
  </known>
  <locked>
   <tags/>
  </locked>
 </html>
 <options>
   <general>
    <option AllowUnderscoresInCSSIdentifiers="false"/>
    <option AttributeExtractionLevel="ExtractLocalizableItems"/>
    <option ContentLocking="false"/>
    <option CustomValidationDLLs=""/>
    <option DisableMessagesForNonLocCSSProperties="true"/>
    <option DisableXMLValidation="false"/>
    <option ExtractOnlyTermsWithRealResIds="false"/>
    <option ExtractScripting="true"/>
    <option IncludeHiddenAttrValues="false"/>
    <option LOOMConfigLastModifiedDateTime="2006-03-08T11:43:26"/>
    <option PropertyExtractionLevel="ExtractLocalizableItems"/>
    <option ReverseLocking="false"/>
    <option ScriptingResourceModel="true"/>
    <option ServerSideScripting="true"/>
   </general>
   <disabledMessages>
    <disabledMessage id="1043" type="Information">
     <description><![CDATA[Term does not have a real Resource Identifier.]]></description>
    </disabledMessage>
    <disabledMessage id="3002" type="Warning">
     <description><![CDATA[Style Sheet Syntax Error. Illegal semicolon ';' found.]]></description>
    </disabledMessage>
    <disabledMessage id="3010" type="Warning">
     <description><![CDATA[Style Sheet Syntax. Quotes used around non-String Value %s of "%s" Property.]]></description>
    </disabledMessage>
    <disabledMessage id="3011" type="Warning">
     <description><![CDATA[Non-terminated Comment in Style Sheet. Skipping rest of Style Sheet.]]></description>
    </disabledMessage>
    <disabledMessage id="3013" type="Warning">
     <description><![CDATA[Style Sheet Property Name is an extension to CSS1: "%s"]]></description>
    </disabledMessage>
    <disabledMessage id="3017" type="Warning">
     <description><![CDATA[Unexpected "@import" in the middle of Style Sheet.]]></description>
    </disabledMessage>
    <disabledMessage id="3019" type="Warning">
     <description><![CDATA[CSS1 Style Sheet Syntax. '=' used instead of ':']]></description>
    </disabledMessage>
    <disabledMessage id="3021" type="Warning">
     <description><![CDATA[Style Sheet Property Value "%s" for "%s" Property is an extension to CSS1.]]></description>
    </disabledMessage>
    <disabledMessage id="3025" type="Warning">
     <description><![CDATA[Non-standard (CSS1) Character '%c' (Unicode 0x%X) in Style Sheet Value.]]></description>
    </disabledMessage>
    <disabledMessage id="3026" type="Warning">
     <description><![CDATA[Style Sheet: Non-standard HTML comment used: "%s". Expected "<!--" or "-->" for CSS1.]]></description>
    </disabledMessage>
    <disabledMessage id="3029" type="Warning">
     <description><![CDATA[Negative Margin Value "%s" used for "%s" Property. This may result in illegible output in CSS compliant browsers.]]></description>
    </disabledMessage>
    <disabledMessage id="4015" type="Information">
     <description><![CDATA[Unassigned Quoted String found in Script: "%s" ]]></description>
    </disabledMessage>
    <disabledMessage id="9017" type="Information">
     <description><![CDATA[Resource Identifier: "res_id"  Instruction: "instr".]]></description>
    </disabledMessage>
   </disabledMessages>
   <fileExtensions>
    <fileExtension name="HTML Files" extensions="HTM ALX ASA ASP ASPX AST DLG HFM HTML HTP HTR HTS HTT HTX PGI PPG SHTML SMP STM STML XWT HTA HTC"/>
    <fileExtension name="CSS Style Sheet Files" extensions="CSS STY"/>
    <fileExtension name="JavaScript Files" extensions="JS CS CPP H"/>
    <fileExtension name="Visual Basic Script Files" extensions="VBS FRM BAS INC VB"/>
    <fileExtension name="HTML Help Table of Contents Files" extensions="HHC"/>
    <fileExtension name="HTML Help Index Files" extensions="HHK"/>
    <fileExtension name="Java Files" extensions="JAVA JAV"/>
    <fileExtension name="XML Files" extensions="XML XQL CML ENT MATH MTX RDF SMIL SVG UI WML XDR XHTML DVT XSF XSD XAML XFP"/>
    <fileExtension name="XML Stylesheet Files" extensions="XSL XSLT"/>
    <fileExtension name="RAW Files" extensions="GIF JPG"/>
    <fileExtension name="CeX Files" extensions="CEX CIX"/>
    <fileExtension name="REG or DEF Files" extensions="REG DEF"/>
   </fileExtensions>
   <update>
    <option AdditionCost="3"/>
    <option DeletionCost="1"/>
    <option MoveCost="2"/>
    <option MaxFormattingWeight="20"/>
    <option MinSimilarity="50"/>
   </update>
 </options>
</config>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\TPSettings.xml ===
<TPSetting>
	<Owner Name="TransPlatform" DisplayName="Translation Engine Settings" Category="TranslationPlatform" Desc="Provides Translation Platform settings for validation on translation engine results. For example, you can select to enable LocAgent or select alternate settings for various components.">
		<Group Name="Components" Desc="Provides a way to define the Translation Platform programs to use." Visible="false">
			<Group Name="PseudoTransEngine" Desc="Select the Pseudo Translation engine and settings.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ITransEngine" Desc="Select the Pseudo Translation engine to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load Pseudo Translation Engine" Value="false" Desc="Select On to load the Pseudo Translation engine during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.Pseudo.PseudoTransEngine,PseudoTransEngine" Desc="Set the URT type for the Pseudo Translation engine." />
			</Group>
			<Group Name="LocRuleAgent" Desc="Select the LocRuleAgent and settings.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ILocAgent" Desc="Select the LocRuleAgent to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load LocRule Agent" Value="true" Desc="Select On to load the LocRuleAgent during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.LocRule.LocRuleAgent,LocRuleAgent" Desc="Set the URT type for the LocRuleAgent." />
				<Group Name="CustomRules" Desc="Enter any custom rules for the LocRuleAgent.">
				</Group>
			</Group>
			<Group Name="LocVer" Desc="Select the LocVerAgent and settings.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ILocAgent" Desc="Select the type of agent to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load LocVer Agent" Value="true" Desc="Select On to load the LocVerAgent during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.Verification.Engine,Microsoft.LocVer.Engine" Desc="Set the URT type for LocVerAgent." />
			</Group>
			<Group Name="LockAndMapCorrector" Desc="Select the LockAndMapCorrector engine.">
				<Setting Type="string" Name="Type" DisplayName="Type of the component" Value="ICorrectionEngine" Desc="Select the type of agent to use." />
				<Setting Type="bool" Name="Load" DisplayName="Load LockAndMapCorrector" Value="true" Desc="Select On to load the LockAndMapCorrection engine during startup." />
				<Setting Type="string" Name="URTType" DisplayName="URT Type" Value="Microsoft.Localization.TransPlatform.Corrector.LockAndMapCorrector,LockAndMapCorrector" Desc="Set the URT type for LockAndMapCorrector." />
			</Group>
		</Group>
	</Owner>
</TPSetting>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\Microsoft.LocVer.Settings.xml ===
﻿<TPSetting>
    <Owner Name="LocVer" DisplayName="Localization Verification (LocVer) Settings" Desc="Use these settings to control how Localization Verification (LocVer) is handled.">
        <Group Name="Rules" DisplayName="Rule Settings" Desc="Settings to control which localization rules (LocVer rules) should be processed.">
            <Setting Type="List" Name="Custom Rule Assemblies" DisplayName="Rule Assemblies" Value="" Desc="List of assemblies containing custom rules for LocVer.">
                <ValidValue Name="Microsoft.LocVer.Rules.dll,Microsoft.Localization.TransPlatform.Verification.Rules.CustomRules.RuleMap"/>
            </Setting>
            <Group Name="NameSpaces" DisplayName="Rule Namespaces" Desc="Settings to control which namespaces should be processed. A namespace precedes the rule name, e.g. for the rule {xsd:integer}, 'xsd' is the namespace.">
                <Setting Type="List" Name="Include" DisplayName="Include Only Rules From Namespaces" Value="" Desc="Only process rules that exist in the namespaces that are in this list.">
                </Setting>
                <Setting Type="List" Name="Exclude" DisplayName="Exclude Rules From Namespaces" Value="" Desc="Don't process any rules that exist in the namespaces that are in this list.">
                </Setting>
                <Setting Type="string" Name="Default NameSpace" DisplayName="Default Namespace" Value="LocVer" Desc="Any rule specified without a namespace, e.g. {Locked}, is in this namespace."/>
            </Group>
            <Setting Type="bool" Name="{ Adaptation }" Value="true" Desc="Rule { Adaptation = &lt;(sub)string&gt; } verifies that a &lt;(sub)string&gt; is translated according to translation found in a map file." />
            <Setting Type="bool" Name="{ AllGlobalRules }" Value="true" Desc="Rule { AllGlobalRules } forces all global rules to be run, irrespective of any other settings for LocVer." />
            <Setting Type="bool" Name="{ AllRules }" Value="true" Desc="Rule { AllRules } forces all rules for the current item to be run, irrespective of any other settings for LocVer." />
            <Setting Type="bool" Name="{ Comment }" Value="true" Desc="Rule { Comment = &lt;text&gt; } issues the &lt;text&gt; to the output." />
            <Setting Type="bool" Name="{ DataType }" Value="true" Desc="Rule { DataType = &lt;type&gt;,[&lt;facet&gt;,...] } verifies that the translation is of a specified data type and follows all supplied constraints (or facets)." />
            <Setting Type="bool" Name="{ Dependency }" Value="true" Desc="Rule { Dependency = &lt;type&gt;,[&lt;resourceId&gt;,...] } verifies that the translation matches another item." />
            <Setting Type="bool" Name="{ Duplicate }" Value="true" Desc="Rule { Duplicate = &lt;type&gt;,[&lt;resourceId&gt;,...] } verifies that the translation matches another item." />
            <Setting Type="bool" Name="{ EscapeChars }" Value="true" Desc="Rule { EscapeChars = &lt;x=yy&gt;,... } forces specified characters (x) to be escaped in the string using specified escape sequences (yy). " />
            <Setting Type="bool" Name="{ EscapePlaceholderChars }" Value="true" Desc="Rule { EscapePlaceholderChars = &lt;x=yy&gt;,... } forces specified characters (x) to be escaped in the string using specified escape sequences (yy). Does not apply to any part of the string that is covered by {Placeholder}, {NumberedPlaceholder} or {FixedPlaceholder} rules." />
            <Setting Type="bool" Name="{ FileName }" Value="true" Desc="Rule { FileName = SFNLock|SFNLocalizable/LFNLock|LFNLocalizable } verifies that a string is a correct file name." />
            <Setting Type="bool" Name="{ FixedPlaceHolder }" Value="true" Desc="Rule { FixedPlaceholder = &lt;plc1&gt;,&lt;plc2&gt;,... } verifies that the translation contains the same number of specified placeholders (&lt;plc1&gt;,...) as the source and that they are in the same order." />
            <Setting Type="bool" Name="{ Formatting }" Value="true" Desc="Rule { Formatting = parameters } verifies that a string uses the correct formatting." />
            <Setting Type="bool" Name="{ Hotkey }" Value="true" Desc="Rule { Hotkey } verifies that a string contains a hotkey." />
            <Setting Type="bool" Name="{ HTMLHotkey }" Value="true" Desc="Rule { HTMLHotkey = &lt;itemid&gt; } verifies that an accesskey item matches the hotkey in the master item (&lt;itemid&gt;)." />
            <Setting Type="bool" Name="{ InvalidChars }" Value="true" Desc="Rule { InvalidChars = &lt;chars&gt;,...} specifies that a set of characters (&lt;chars&gt;) cannot be used in the string." />
            <Setting Type="bool" Name="{ InvalidStrings }" Value="true" Desc="Rule { InvalidStrings = &lt;string1&gt;,&lt;string2&gt;... } verifies that the translation is not one of the strings (&lt;string1&gt;...) specified." />
            <Setting Type="bool" Name="{ Locked }" Value="true" Desc="Rule { Locked } reverts the translation to source and sets 'User Src Lock'." />
            <Setting Type="bool" Name="{ Map }" Value="true" Desc="Rule { Map = &lt;(sub)string&gt; } verifies that a &lt;(sub)string&gt; is translated according to translation found in a map file." />
            <Setting Type="bool" Name="{ MaxLength }" Value="true" Desc="Rule { MaxLength = &lt;X&gt;,&lt;namespace&gt; } verifies that the translation is not longer than &lt;X&gt; characters. If a &lt;namespace&gt; is specified, the rule verifies that the total length of the &lt;namespace&gt; is not longer than X. (Works Cross-EDBs)." />
            <Setting Type="bool" Name="{ Menu }" Value="true" Desc="Rule { Menu = &lt;namespace&gt; } verifies that there are no duplicate hotkeys within the &lt;namespace&gt;." />
            <Setting Type="bool" Name="{ MinLength }" Value="true" Desc="Rule { MinLength = &lt;X&gt;} verifies that the translation is at least &lt;X&gt; characters long." />
            <Setting Type="bool" Name="{ NoAutoRules }" Value="true" Desc="Rule { NoAutoRules } stops automatically generated rules (specified in 'Zero-Effort Commenting Settings') on the current item." />
            <Setting Type="bool" Name="{ NoGlobalRules }" Value="true" Desc="Rule { NoGlobalRules } skips any global rules (specified in 'Global Rules' setting) for the current item." />
            <Setting Type="bool" Name="{ NoLocRules }" Value="true" Desc="Rule { NoLocRules } stops automatically generated restrictions on the item." />
            <Setting Type="bool" Name="{ NoRules }" Value="true" Desc="Rule { NoRules } suppresses all output for the current item, irrespective of any other settings for LocVer." />
            <Setting Type="bool" Name="{ NumberedPlaceHolder }" Value="true" Desc="Rule { NumberedPlaceholder = &lt;plc1&gt;,&lt;plc2&gt;,... } verifies that the translation contains the same placeholders (&lt;plc1&gt;,...) as the source." />
            <Setting Type="bool" Name="{ PlaceHolder }" Value="true" Desc="Rule { Placeholder = &lt;plc1&gt;,&lt;plc2&gt;,... } verifies that the translation contains the same number of specified placeholders (&lt;plc1&gt;,...) as the source." />
            <Setting Type="bool" Name="{ RegEx }" Value="true" Desc="Rule { RegEx = &lt;expr&gt;,[&lt;expr&gt;] } verifies that the translation matches the specified regular expression." />
            <Setting Type="bool" Name="{ RegExe }" Value="true" Desc="Deprecated: Rule { RegExe = &lt;expr&gt; } verifies that the translation matches the specified regular expression." />
            <Setting Type="bool" Name="{ RevertBinary }" Value="true" Desc="Deprecated: Rule { RevertBinary } reverts the binary translation to source." />
            <Setting Type="bool" Name="{ Split }" Value="true" Desc="Rule { Split = &lt;value&gt;,... } splits a string according to the parameter(s) supplied." />
            <Setting Type="bool" Name="{ StrBegins }" Value="true" Desc="Rule { StrBegins = &lt;value&gt; } ensures that a string begins with a certain sub string (value)." />
            <Setting Type="bool" Name="{ StrContains }" Value="true" Desc="Rule { StrContains = &lt;value&gt;,... } ensures that a string contains a certain sub string (value)." />
            <Setting Type="bool" Name="{ StrEnds }" Value="true" Desc="Rule { StrEnds = &lt;value&gt; } ensures that a string ends with a certain sub string (value)." />
            <Setting Type="bool" Name="{ StringCategory }" Value="true" Desc="Rule { StringCategory = &lt;category&gt; } sets the category of the string to specified value (&lt;category&gt;)." />
            <Setting Type="bool" Name="{ StringContains }" Value="true" Desc="Rule { StringContains = &lt;tla/lcid&gt; } verifies that the translation contains the LCID or TLA of the current target culture." />
            <Setting Type="bool" Name="{ SubString }" Value="true" Desc="Rule { SubString = &lt;value&gt;,... } allows only part of a string (&lt;value&gt;) to be localized. " />
            <Setting Type="bool" Name="{ TabOrder }" Value="true" Desc="Rule { TabOrder } is used to maintain TabOrder information per language." />
            <Setting Type="bool" Name="{ TransLocked }" Value="true" Desc="Rule { TransLocked } sets 'User Trans Lock' if localization status is set to Localized." />
            <Setting Type="bool" Name="{ Trx }" Value="true" Desc="Rule { Trx } forces the translation to be different than the source." />
            <Setting Type="bool" Name="{ ValidChars }" Value="true" Desc="Rule { ValidChars = &lt;chars&gt;,... } specifies that only a set of characters (&lt;chars&gt;) can be used in the string." />
            <Setting Type="bool" Name="{ ValidStrings }" Value="true" Desc="Rule { ValidStrings = &lt;string1&gt;,&lt;string2&gt;,... } verifies that only the strings (&lt;string1&gt;,...) specified are used as translations." />
            <Setting Type="bool" Name="{ ValidWordSeparators }" Value="true" Desc="Rule { ValidWordSeparators = &lt;wordsep&gt;} verifies that the only word separators used in the translation are those specified in &lt;wordsep&gt;." />
            <Setting Type="bool" Name="{ Words }" Value="true" Desc="Rule { Words = &lt;X&gt; } verifies that the Translation contains &lt;X&gt; number of words." />
            <Setting Type="bool" Name="{ UniqueInNameSpace }" Value="true" Desc="Rule { UniqueInNameSpace = &lt;namespace&gt; } verifies that the translation is unique within the &lt;namespace&gt;." />
            <Setting Type="bool" Name="{ __VerCodePage }" Value="true" Desc="Rule { __VerCodePage = codepage } verifies that the translation only contains characters valid on the specified codepage." />
            <Group Name="Centum Rules" DisplayName="Centum Rules" Desc="Settings for centum specific rules.">
                <Setting Type="bool" Name="{ Centum:BinLocked }" Value="false" Desc="Rule { Centum:BinLocked } ensures that the binary translation is the same as the source language (Centum specific, behaves like {Binary:Locked} )." />
                <Setting Type="bool" Name="{ Centum:BinTransLocked }" Value="false" Desc="Rule { Centum:BinTransLocked } ensures that the binary translation is not changed (Centum specific, behaves like {Binary:TransLocked} )." />
                <Setting Type="bool" Name="{ Centum:Locked }" Value="false" Desc="Rule { Centum:Locked } ensures that the translation is the same as the source language (Centum specific, behaves like {Locked} )." />
                <Setting Type="bool" Name="{ Centum:TransLocked }" Value="false" Desc="Rule { Centum:TransLocked } ensures that the translation is not changed (Centum specific, behaves like {TransLocked} )." />
            </Group>
            <Group Name="Binary Rules" DisplayName="Binary Rules" Desc="Settings for rules that affect the binary value of an item.">
                <Setting Type="bool" Name="{ Binary:Locked }" Value="true" Desc="Rule { Binary:Locked } ensures that the binary translation is the same as the source language." />
                <Setting Type="bool" Name="{ Binary:TransLocked }" Value="true" Desc="Rule { Binary:TransLocked } ensures that the binary translation is not changed." />
                <Setting Type="bool" Name="{ Binary:Trx }" Value="true" Desc="Rule { Binary:Trx } ensures that the binary translation is different from the source." />
            </Group>
            <Group Name="Logging Rules" DisplayName="Logging Rules" Desc="Settings for rules that affect the messages issued for an item.">
                <Setting Type="bool" Name="{ Log:Error }" Value="true" Desc="Rule { Log:Error } sets the severity of messages for the item to 'Error'." />
                <Setting Type="bool" Name="{ Log:HighPriority }" Value="true" Desc="Rule { Log:HighPriority = &lt;priorityString&gt; } specifies that messages reported on the item has high priority and any error messages are prepended with the text defined by &lt;priorityString&gt;." />
                <Setting Type="bool" Name="{ Log:Ignore }" Value="true" Desc="Rule { Log:Ignore } suppresses messages for the item." />
                <Setting Type="bool" Name="{ Log:Info }" Value="true" Desc="Rule { Log:Info } sets the severity of messages for the item to 'Info'." />
                <Setting Type="bool" Name="{ Log:Warning }" Value="true" Desc="Rule { Log:Warning } sets the severity of messages for the item to 'Warning'." />
            </Group>
            <Setting Type="string" Name="Global Rules" DisplayName="Global Rules" Value="" Desc="Specifies rules that will be evaluated against every item that LocVer runs on." />
            <Setting Type="List" Name="Keywords to ignore" DisplayName="Keywords To Ignore" Value="" Desc="All keywords in this list will be ignored. Example: If the list contains 'MyRule' and 'Locked', the rules '{MyRule}' and '{Locked}' will be ignored."/>
            <Setting Type="bool" Name="Invalid characters in translation" DisplayName="Check For Invalid Characters" Value="false" Desc="Check translations for invalid characters on the target language codepage."/>
            <Setting Type="bool" Name="Default parameters behave as LocVer 4.6" DisplayName="Default Parameters Behave As LocVer 4.6" Value="false" Desc="Use literal (false) or regular expression (true) parameters as default for rules {FixedPlaceholder}, {NumberedPlaceholder}, {Split}, {StrBegins}, {StrContains} and {StrEnds}"/>
        </Group>
        <Group Name="Messages" DisplayName="Message Settings" Desc="Settings for messages reported by LocVer.">
            <Setting Type="bool" Name="Report Unknown Rules" DisplayName="Report Unknown Rules" Value="true" Desc="Issue messages when LocVer encounters unknown rules."/>
            <Setting Type="bool" Name="Report Syntax Errors" DisplayName="Report Syntax Errors" Value="true" Desc="Issue messages when LocVer encounters errors in the syntax of instructions."/>
            <Setting Type="bool" Name="Report Source Messages" DisplayName="Report Source Messages" Value="true" Desc="Issue messages when LocVer encounters errors on the source item."/>
            <Setting Type="bool" Name="Only High Priority As Errors" DisplayName="Only High Priority As Errors" Value="false" Desc="Only issue messages as errors if they occurr on items specified as having high priority."/>
            <Setting Type="PickList" Name="Report messages as" DisplayName="Message Severity" Value="Default" Desc="The severity of all messages will be changed to the value specified in this setting. This setting overrides the settings 'Error Messages', 'Warning Messages', 'Informational Messages' and 'Ignore Messages' unless the value is 'Default'.">
                <ValidValue Name="Default" />
                <ValidValue Name="Error" />
                <ValidValue Name="Warning" />
                <ValidValue Name="Info" />
            </Setting>
            <Setting Type="List" Name="Error" DisplayName="Error Messages" Value="" Desc="Force severity to 'Error' for any messages with the same ID as listed in this setting."></Setting>
            <Setting Type="List" Name="Ignore" DisplayName="Ignore Messages" Value="" Desc="Ignore any messages with the same ID as listed in this setting."></Setting>
            <Setting Type="List" Name="Info" DisplayName="Informational Messages" Value="" Desc="Force severity to 'Info' for any messages with the same ID as listed in this setting."></Setting>
            <Setting Type="List" Name="Warning" DisplayName="Warning Messages" Value="" Desc="Force severity to 'Warning' for any messages with the same ID as listed in this setting."></Setting>
        </Group>
        <Group Name="Macros" DisplayName="Macro Settings" Desc="Settings for macros used by LocVer.">
            <Setting Type="string" Name="Macro File" DisplayName="Macro File" Value="" EditorType="FileNameEditor" Desc="Configuration file containing macros for LocVer." />
            <Setting Type="bool" Name="Skip Parameter Expansion" DisplayName="Skip Parameter Expansion" Value="false" Desc="If on, parameters with macros will not be expanded. @ symbols will be interpreted literary." />
        </Group>
        <Group Name="Language" DisplayName="Language Settings" Desc="Settings specific to the language being processed.">
            <Setting Type="string" Name="Behaves Like Lcid" DisplayName="Behaves Like Language" Value="" Desc="If this is set to a culture (other than 'x-neutral'), LocVer will consider the culture specified as being a substitute for the current target language when evaluating language specific rules. The culture will be used unless the current target language has been explicitly stated in an rule." />
            <Setting Type="string" Name="Valid Hotkeys" DisplayName="Valid Hotkeys" Value="" Desc="List of hotkeys that can be used for this language (case-insensitive)."/>
        </Group>
        <Group Name="Processing" DisplayName="Instruction Settings" Desc="Settings to control which instructions should be processed.">
            <Setting Type="bool" Name="Exclude Generated Instructions" DisplayName="Exclude Generated Instructions" Value="false" Desc="If on, do not process any instructions that have been auto generated (name ends with 'Gen' or the comment is enclosed by '&lt;&lt;' and '&gt;&gt;' or enclosed by &lt;gen&gt; and &lt;/gen&gt; tags)."/>
            <Setting Type="bool" Name="Only Developer Instructions" DisplayName="Include Only Developer Instructions" Value="false" Desc="Only process instructions from source files, i.e. enclosed by &lt;Dev&gt; and &lt;/Dev&gt;"/>
            <Setting Type="List" Name="Include Only From Tags" DisplayName="Include Only Instructions In Tags" Value="" Desc="Include only instructions within the list of tags.">
            </Setting>
            <Setting Type="List" Name="Exclude From Tags" DisplayName="Exclude Instructions In Tags" Value="" Desc="Exclude any instructions within the list of tags.">
            </Setting>
            <Setting Type="bool" Name="Term Note" DisplayName="Include Instructions From Term Note Field" Value="false" Desc="Include instructions from the term note field." />
            <Setting Type="int" Name="Custom Field" DisplayName="Include Instructions From Custom Field" Value="0" Desc="Specifies a custom field that instructions should be added from. Valid values are 0 to 6. If the value is 0, no instructions are added from a custom field." />
        </Group>
        <Group Name="Lookup and Namespaces" DisplayName="Lookup And Namespace Settings" Desc="Settings for namespace and lookup rules.">
            <Setting Type="bool" Name="Process lookups and namespaces" DisplayName="Process Lookups And Namespaces" Value="true" Desc="Should namespace and lookup rules be processed."/>
            <Setting Type="string" Name="Cached File" DisplayName="Cached File" Value="%TEMP%\@rfc3066@.lcx" EditorType="FileNameEditor" Desc="Path to cache file used for cross-file processing"></Setting>
        </Group>
        <Group Name="AutoCommenting" DisplayName="Zero-Effort Commenting Settings" Desc="Use these settings to apply automatic LocVer instructions. Do not change these settings without the help of the LocStudio team.">
          <Group Name="AutoRule01" DisplayName="AutoRule 01" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule02" DisplayName="AutoRule 02" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule03" DisplayName="AutoRule 03" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule04" DisplayName="AutoRule 04" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule05" DisplayName="AutoRule 05" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule06" DisplayName="AutoRule 06" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule07" DisplayName="AutoRule 07" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule08" DisplayName="AutoRule 08" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule09" DisplayName="AutoRule 09" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule10" DisplayName="AutoRule 10" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule11" DisplayName="AutoRule 11" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule12" DisplayName="AutoRule 12" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule13" DisplayName="AutoRule 13" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule14" DisplayName="AutoRule 14" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule15" DisplayName="AutoRule 15" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule16" DisplayName="AutoRule 16" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule17" DisplayName="AutoRule 17" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule18" DisplayName="AutoRule 18" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule19" DisplayName="AutoRule 19" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule20" DisplayName="AutoRule 20" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule21" DisplayName="AutoRule 21" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule22" DisplayName="AutoRule 22" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule23" DisplayName="AutoRule 23" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule24" DisplayName="AutoRule 24" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule25" DisplayName="AutoRule 25" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule26" DisplayName="AutoRule 26" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule27" DisplayName="AutoRule 27" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule28" DisplayName="AutoRule 28" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule29" DisplayName="AutoRule 29" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule30" DisplayName="AutoRule 30" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule31" DisplayName="AutoRule 31" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule32" DisplayName="AutoRule 32" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule33" DisplayName="AutoRule 33" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule34" DisplayName="AutoRule 34" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule35" DisplayName="AutoRule 35" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule36" DisplayName="AutoRule 36" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule37" DisplayName="AutoRule 37" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule38" DisplayName="AutoRule 38" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule39" DisplayName="AutoRule 39" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule40" DisplayName="AutoRule 40" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule41" DisplayName="AutoRule 41" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule42" DisplayName="AutoRule 42" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule43" DisplayName="AutoRule 43" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule44" DisplayName="AutoRule 44" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule45" DisplayName="AutoRule 45" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule46" DisplayName="AutoRule 46" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule47" DisplayName="AutoRule 47" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule48" DisplayName="AutoRule 48" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule49" DisplayName="AutoRule 49" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule50" DisplayName="AutoRule 50" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule51" DisplayName="AutoRule 51" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule52" DisplayName="AutoRule 52" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule53" DisplayName="AutoRule 53" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule54" DisplayName="AutoRule 54" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule55" DisplayName="AutoRule 55" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule56" DisplayName="AutoRule 56" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule57" DisplayName="AutoRule 57" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule58" DisplayName="AutoRule 58" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule59" DisplayName="AutoRule 59" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule60" DisplayName="AutoRule 60" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule61" DisplayName="AutoRule 61" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule62" DisplayName="AutoRule 62" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule63" DisplayName="AutoRule 63" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule64" DisplayName="AutoRule 64" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule65" DisplayName="AutoRule 65" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule66" DisplayName="AutoRule 66" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule67" DisplayName="AutoRule 67" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule68" DisplayName="AutoRule 68" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule69" DisplayName="AutoRule 69" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule70" DisplayName="AutoRule 70" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule71" DisplayName="AutoRule 71" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule72" DisplayName="AutoRule 72" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule73" DisplayName="AutoRule 73" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule74" DisplayName="AutoRule 74" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule75" DisplayName="AutoRule 75" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule76" DisplayName="AutoRule 76" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule77" DisplayName="AutoRule 77" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule78" DisplayName="AutoRule 78" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule79" DisplayName="AutoRule 79" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule80" DisplayName="AutoRule 80" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule81" DisplayName="AutoRule 81" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule82" DisplayName="AutoRule 82" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule83" DisplayName="AutoRule 83" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule84" DisplayName="AutoRule 84" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule85" DisplayName="AutoRule 85" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule86" DisplayName="AutoRule 86" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule87" DisplayName="AutoRule 87" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule88" DisplayName="AutoRule 88" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule89" DisplayName="AutoRule 89" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule90" DisplayName="AutoRule 90" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule91" DisplayName="AutoRule 91" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule92" DisplayName="AutoRule 92" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule93" DisplayName="AutoRule 93" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule94" DisplayName="AutoRule 94" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule95" DisplayName="AutoRule 95" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule96" DisplayName="AutoRule 96" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule97" DisplayName="AutoRule 97" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule98" DisplayName="AutoRule 98" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
          <Group Name="AutoRule99" DisplayName="AutoRule 99" Desc="Use these settings to specify an automatic LocVer instruction.">
            <Setting Type="string" Name="Description" DisplayName="Description" Value="" Desc="Enter a short description of the automatic instruction." />
            <Setting Type="bool" Name="Enabled" DisplayName="Enabled" Value="false" Desc="To validate strings according to this automatic instruction, select On. To stop validation with this instruction, select Off." />
            <Setting Type="string" Name="RegEx" DisplayName="Expression" Value="" Desc="Enter a regular expression to identify information or characters in the string." />
            <Setting Type="string" Name="Instruction" DisplayName="Instruction" Value="" Desc="Enter the instruction that will be automatically applied if all conditions are met. Backreferences from the 'Expression' setting are replaced in the instruction." />
            <Group Name="Conditions" DisplayName="Conditions" Desc="Use these settings to specify additional conditions for the automatic LocVer instruction." >
              <Setting Type="List" Name="CodePageType" DisplayName="Codepage Type" Value="" Desc="Enter the codepage types this instruction will affect. If left blank, all codepages are affected by this instruction." />
              <Setting Type="List" Name="DocumentType" DisplayName="Document Type" Value="" Desc="Enter the parser IDs this instruction will affect. If left blank, files parsed by any parser are affected by this instruction." />
              <Setting Type="List" Name="FileExtension" DisplayName="File Extension" Value="" Desc="Enter the file extensions of the file types this instruction will affect. If left blank, all file types are affected by this instruction." />
              <Setting Type="List" Name="Lcid" DisplayName="LCID" Value="" Desc="Enter the LCIDs this instruction will affect. If left blank, all LCIDs are affected by this instruction." />
              <Setting Type="string" Name="NumericID" DisplayName="Numeric ID" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item ID contained in the Resource ID. If left blank, all numeric item IDs are affected by this instruction." />
              <Setting Type="string" Name="NumericType" DisplayName="Numeric Type" Value="" Desc="Enter a range, minimum to maximum, to match against the numeric part of the item type contained in the Resource ID. If left blank, all numeric item types are affected by this instruction." />
              <Setting Type="List" Name="StringCategory" DisplayName="String Category" Value="" Desc="Enter the string categories this rule will affect. If left blank, all string categories are affected by this instruction." />
              <Setting Type="string" Name="StringID" DisplayName="String ID" Value="" Desc="Enter a regular expression to match against the string part of the item ID contained in the Resource ID. If left blank, all item IDs are affected by this instruction." />
              <Setting Type="string" Name="StringType" DisplayName="String Type" Value="" Desc="Enter a regular expression to match against the string part of the item type contained in the Resource ID. If left blank, all item types are affected by this instruction." />
            </Group>
          </Group>
        </Group>
      </Owner>
</TPSetting>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\pombaml.xml ===
<BamlLocalization>
    <Group Name="Misc">
        <Localizability Target="*.*" />

     <Group Name="Language">
        <Localizability Target="*.Language" Category="Text" Readable="True" Modifiable="True"/>
     </Group>  

     <Group Name="Font">
          <Localizability Target="*.FontFamily"/>
          <Localizability Target="*.FontSize"/>
          <Localizability Target="*.FontStretch"/>
          <Localizability Target="*.FontStyle"/>
          <Localizability Target="*.FontWeight"/>
      </Group>     

      <Group Name="Height">
           <Localizability Target="*.Height" Category="None" Modifiable="False" Readable="True"/>
      </Group>

      <Group Name="Width">
           <Localizability Target="*.Width" Category="None" Modifiable="False" Readable="True"/>
      </Group>         

      <Group Name="Margin">
           <Localizability Target="*.Margin"  Category="None" Modifiable="False" Readable="True"/>
           <Localizability Target="*.Padding" Category="None" Modifiable="False" Readable="True"/>
      </Group>

      <Group Name="Hyperlink">
           <Localizability Target="*.NavigateUri" />
      </Group>    

      <Group Name="Alignment">
           <Localizability Target="*.VerticalAlignment"    Category="None" Modifiable="False" Readable="True"/>
           <Localizability Target="*.HorizontalAlignment"  Category="None" Modifiable="False" Readable="True"/>
           <Localizability Target="*.TextAlignment"        Readable="True" Modifiable="False"/>
      </Group>         

      <Group Name="Text">
          <Localizability Target="*.Text" Category="Text"/>
          <Localizability Target="*.Title" Category="Text"/> 
          <Localizability Target="*.ToolTip"/>
          <Localizability Target="*.Gesture"/>
          <Localizability Target="*.Header" />
          <Localizability Target="*.WindowTitle"/> 
      </Group>

      <Namespace Name="System.Windows" Alias="">
         <Group Name="Misc">
             <Localizability Target="Window.$Content" Readable="True"/>
        </Group>
      </Namespace> 

 
      <Namespace Name="System.Windows.Controls" Alias="">
        <Group Name="Text">
           <Localizability Target="Button.$Content" RecognizesAccessKey="true"/>
           <Localizability Target="Button.Content"  RecognizesAccessKey="true"/>
           <Localizability Target="ToggleButton.$Content" RecognizesAccessKey="true"/>
           <Localizability Target="ToggleButton.Content"  RecognizesAccessKey="true"/>
           <Localizability Target="RepeatButton.$Content" RecognizesAccessKey="true"/>
           <Localizability Target="RepeatButton.Content"  RecognizesAccessKey="true"/>
           <Localizability Target="HeaderedContentControl.Header" RecognizesAccessKey="true"/>
           <Localizability Target="Label.$Content" RecognizesAccessKey="true"/>
           <Localizability Target="Label.Content" RecognizesAccessKey="true"/>
           <Localizability Target="TextBlock.$Content" />
           <Localizability Target="TextBlock.Text" />
           <Localizability Target="TextBox.$Content" />
           <Localizability Target="TextBox.Text" />
           <Localizability Target="ToolTip.$Content"/>
           <Localizability Target="AccessText.Text" RecognizesAccessKey="True" />
           <Localizability Target="AccessText.$Content" RecognizesAccessKey="True" />
           <Localizability Target="CheckBox.$Content" RecognizesAccessKey="true"/>
           <Localizability Target="CheckBox.Content"  RecognizesAccessKey="true"/>
           <Localizability Target="ComboBox.$Content"/>
           <Localizability Target="ComboBoxItem.$Content"/>
           <Localizability Target="ContextMenu.$Content" RecognizesAccessKey="True"/>
           <Localizability Target="ContextMenu.Header" RecognizesAccessKey="True"/>
           <Localizability Target="MenuItem.InputGestureText"/>	   
           <Localizability Target="MenuItem.$Content" RecognizesAccessKey="True"/>	   
           <Localizability Target="MenuItem.Header" RecognizesAccessKey="True"/>
           <Localizability Target="Menu.Header" RecognizesAccessKey="True"/>
           <Localizability Target="RadioButton.$Content" RecognizesAccessKey="True"/>
           <Localizability Target="RadioButton.Content" RecognizesAccessKey="True"/>
           <Localizability Target="TabItem.Header" RecognizesAccessKey="True"/>
           <Localizability Target="HeaderedContentControl.$Content"/>
           <Localizability Target="HeaderedContentControl.Content"/>
           <Localizability Target="HeaderedItemsControl.Header" RecognizesAccessKey="True"/>
           <Localizability Target="HeaderedItemsControl.$Content"/>
        </Group>
        <Group Name="Controls">
           <Localizability Target="Border.$Content" Category="None" Readable="True"/>	
           <Localizability Target="ContentControl.$Content" Readable="True"/>
           <Localizability Target="ControlTemplate.$Content" Readable="True"/>
           <Localizability Target="DockPanel.$Content" Category="None" Readable="True"/>
           <Localizability Target="ScrollViewer.$Content" Readable="True"/>
           <Localizability Target="Grid.$Content" Category="None" Readable="True"/>
       </Group>
       <Group Name="Font">
           <Localizability Target="*.TextDecorations"/>
       </Group>  
      </Namespace>

      <Namespace Name="System.Windows.Controls.Primitives" Alias="">	
          <Group Name="Controls">
            <Localizability Target="Popup.$Content" />
          </Group>
          <Group Name="Text">
            <Localizability Target="*.ToolTip" />
          </Group>
      </Namespace>

      <Namespace Name="System" Alias="">
         <Localizability Target="Double.$Content" Readable="False" Modifiable="False"/>
         
        <Group Name="Text">
           <Localizability Target="String.$Content" Category="Text" Modifiable="True" Readable="True"/>  	         

        </Group> 
      </Namespace>         
      
      <Namespace Name="System.Windows.Documents" Alias="">
        <Group Name="Text">
           <Localizability Target="TextPanel.$Content" /> 
        </Group>
      </Namespace>  
  </Group>
</BamlLocalization>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\parserconfig.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   e n c o d i n g = " u t f - 1 6 " ? > 
 
 < P a r s e r s > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " D O S   7 "   F i l e N a m e = " d o s 7 p a r s . d l l "   H e l p T e x t = " W i n d o w s   9 x   M S - D O S   p r o m p t   f i l e s   ( . b i n ,   . c n f ,   . c o m ,   . e x e ,   . s y s ) "   P a r s e r I d = " 1 0 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " e x e "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c o m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s y s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " b i n "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c n f "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " L D F   P a r s e r "   F i l e N a m e = " l d f p a r s e . d l l "   H e l p T e x t = " L D A P   f o r m a t   f i l e s   ( * . l d f ) "   P a r s e r I d = " 1 0 3 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " l d f "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " S Q L :   p a r s e r   f o r   t h e   s q l   f i l e "   F i l e N a m e = " s q l p a r s e . d l l "   H e l p T e x t = " S Q L :   p a r s e r   f o r   t h e   s q l   f i l e "   P a r s e r I d = " 1 0 4 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " s q l "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " B L T :   T e m p l a t e   F i l e "   F i l e N a m e = " b l t p a r s e . d l l "   H e l p T e x t = " A p p l i c a t i o n   a n d   s y s t e m   c o n f i g u r a t i o n   s e t t i n g s   ( . b l t ) "   P a r s e r I d = " 1 0 7 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " b l t "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " M a c i n t o s h   O S   X   x m l - c o n t e n t   f i l e s "   F i l e N a m e = " m a c h e a t . d l l "   H e l p T e x t = " P a r s e r   f o r   M a c O S   X   p r o p e r t y   l i s t   f i l e s   ( X M L   c o n t e n t ) .   D e r i v e d   f r o m   H E A T   p a r s e r . "   P a r s e r I d = " 1 0 8 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " x i b "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p l i s t "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " N e t w o r k "   F i l e N a m e = " n e t p a r s e . d l l "   H e l p T e x t = " N e t w o r k - r e l a t e d   W i n d o w s   f i l e s   ( . e x e ,   . s y s ) "   P a r s e r I d = " 1 1 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " s y s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " e x e "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " V x D "   F i l e N a m e = " v x d p a r s e . d l l "   H e l p T e x t = " W i n d o w s   V x D   f o r m a t   f i l e s   ( . 3 8 6 ,   . p d r ,   . v x d ) "   P a r s e r I d = " 1 2 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " v x d "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " 3 8 6 "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p d r "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " n w 4 "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " S c a n D i s k "   F i l e N a m e = " s c a n p a r s . d l l "   H e l p T e x t = " T h e   f i l e   n a m e d   S C A N D I S K . S T R . "   P a r s e r I d = " 1 3 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " s t r "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " M e s s a g e "   F i l e N a m e = " m s g p a r s e . d l l "   H e l p T e x t = " C o m m a n d   P r o m p t   b i n a r y   m e s s a g e   f i l e s   ( . m s g ) "   P a r s e r I d = " 1 4 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " m s g "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " W i n B o o t "   F i l e N a m e = " w i n b o o t . d l l "   H e l p T e x t = " T h e   W i n d o w s   9 5   f i l e   n a m e d   W I N B O O T . S Y S . "   P a r s e r I d = " 1 5 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " s y s "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " R P L   B o o t "   F i l e N a m e = " r p l b o o t . d l l "   H e l p T e x t = " T h e   W i n d o w s   9 5   f i l e   n a m e d   R P L B O O T . S Y S . "   P a r s e r I d = " 1 6 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " s y s "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " M a c i n t o s h   T o k e n "   F i l e N a m e = " m a c t o k . d l l "   H e l p T e x t = " M a c i n t o s h   t o k e n   t e x t   f i l e s   f r o m   A c c e s s ,   E x c e l ,   a n d   W o r d . "   P a r s e r I d = " 1 7 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " m o k "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m t f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m t k "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " P o s t s c r i p t "   F i l e N a m e = " p p d p a r s e . d l l "   H e l p T e x t = " P o s t s c r i p t   P r i n t e r   D e s c r i p t i o n s . "   P a r s e r I d = " 1 8 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " p p d "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " B M P / I c o n / C u r s o r   P a r s e r "   F i l e N a m e = " b m p i c o n . d l l "   H e l p T e x t = " S t a n d a r d   W i n d o w s   b i t m a p   ( . b m p ,   . d i b ) ,   c u r s o r   ( . c u r ) ,   a n d   i c o n   ( . i c o )   f i l e s "   P a r s e r I d = " 1 9 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " b m p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d i b "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " i c o "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c u r "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < P O M P a r s e r   D e s c r i p t i o n = " P O M H T M L & l t ; P O M P A R S E R & g t ; "   F i l e N a m e = " p o m h t m l . d l l "   H e l p T e x t = " W e b   F i l e s   ( P O M H T M L ) "   P a r s e r I d = " 2 2 "   C L S I D = " 1 7 d 0 5 9 e e - 6 5 b 3 - 4 d 0 d - 9 c a a - a d 0 d 3 c c a e 8 b 5 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " a l x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a s a "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a s c x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a s p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a s p x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a s t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " b a s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c s s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d l g "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d v t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " e n t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " f r m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h f m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h h c "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h h k "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t a "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t c "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t r "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " h t x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " i n c "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " j a v "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " j a v a "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " j s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " j s l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m a t h "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m t x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p g i "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p p g "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r d f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s h t m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s m i l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s m p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s t m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s t m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s t y "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s v g "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " u i "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " v b "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " v b s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " w m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x a m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x d r "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x f p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x h t m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x q l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s d "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s l t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x w t "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / P O M P a r s e r > 
 
     < P O M P a r s e r   D e s c r i p t i o n = " P O M X M L & l t ; P O M P A R S E R & g t ; "   F i l e N a m e = " p o m x m l . d l l "   H e l p T e x t = " P O M   p a r s e r   f o r   X M L   f i l e s "   P a r s e r I d = " 2 1 0 "   C L S I D = " 2 2 3 4 7 0 b b - 8 c 8 6 - 4 6 a 5 - b 4 6 6 - 3 4 9 6 8 e d d f a 8 3 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " x m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m s c "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " w s c "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " g d f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " w p l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a d m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p l a x m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x q l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " e n t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m a t h "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m t x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r d f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s m i l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s v g "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " u i "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " w m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x d r "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x h t m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d v t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s d "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x a m l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x f p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " x s l t "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / P O M P a r s e r > 
 
     < P O M P a r s e r   D e s c r i p t i o n = " M a n a g e d   R e s o u r c e   P a r s e r & l t ; P O M P A R S E R & g t ; "   F i l e N a m e = " M a n a g e d P a r s e r . d l l "   H e l p T e x t = " M a n a g e d   R e s o u r c e   f i l e s . "   P a r s e r I d = " 2 1 1 "   C L S I D = " f a 5 5 b 4 6 5 - d e 9 e - 4 a e c - 9 e 2 c - 3 9 e e 7 6 8 c 7 e c d " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " d l l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " e x e "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r e s o u r c e s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r e s x "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / P O M P a r s e r > 
 
     < P O M P a r s e r   D e s c r i p t i o n = " B A M L   P a r s e r & l t ; P O M P A R S E R & g t ; "   F i l e N a m e = " P O M B A M L . d l l "   H e l p T e x t = " P a r s e s   . b a m l   f i l e s . "   P a r s e r I d = " 2 2 3 "   C L S I D = " 0 5 5 2 0 8 a c - c 5 f 1 - 4 e 8 4 - 9 2 e a - 1 b c 3 c e 2 5 0 d 5 e " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " b a m l "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / P O M P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " W i n 3 2 "   F i l e N a m e = " w i n 3 2 . d l l "   H e l p T e x t = " W i n 3 2   f o r m a t   f i l e s   ( . e x e ,   . d l l ,   . . . ) "   P a r s e r I d = " 3 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " a c m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c p l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d l l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d r v "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " e x e "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " f l t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " n a v "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " n e d "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " o c x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " o l b "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r c t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r e s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s c r "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " v t r "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " w p c "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p k g "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a x "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c n v "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " d s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " n w 4 "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s y s "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " a x p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " b i n "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " c o m "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " t s p "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m s t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " m u i "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " r l l "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " e f i "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
         < L S 4 5 P a r s e r   D e s c r i p t i o n = " S D M "   F i l e N a m e = " w i n 3 2 s d m . d l l "   H e l p T e x t = " S D M   d i a l o g   r e s o u r c e s   ( W i n 3 2   s u b - p a r s e r ) . "   P a r s e r I d = " 1 " > 
 
             < F i l e E x t e n s i o n s   / > 
 
         < / L S 4 5 P a r s e r > 
 
         < L S 4 5 P a r s e r   D e s c r i p t i o n = " O f f i c e "   F i l e N a m e = " w i n 3 2 o 9 6 . d l l "   H e l p T e x t = " O f f i c e   s t r i n g   t a b l e s   ( W i n 3 2   s u b - p a r s e r ) . "   P a r s e r I d = " 2 " > 
 
             < F i l e E x t e n s i o n s   / > 
 
         < / L S 4 5 P a r s e r > 
 
         < L S 4 5 P a r s e r   D e s c r i p t i o n = " M U I S u b P a r s e r "   F i l e N a m e = " M U I S u b P a r s e r . d l l "   H e l p T e x t = " M U I S u b P a r s e r "   P a r s e r I d = " 4 " > 
 
             < F i l e E x t e n s i o n s   / > 
 
         < / L S 4 5 P a r s e r > 
 
         < L S 4 5 P a r s e r   D e s c r i p t i o n = " W e b   F i l e s   ( H E A T ) "   F i l e N a m e = " h e a t 4 2 s . d l l "   H e l p T e x t = " H T M L   f i l e s ,   X M L   f i l e s ,   S t y l e   S h e e t s ,   V i s u a l   B a s i c   S c r i p t ,   J a v a S c r i p t   a n d   J a v a   ( H E A T   W i n 3 2   s u b - p a r s e r ) "   P a r s e r I d = " 7 " > 
 
             < F i l e E x t e n s i o n s   / > 
 
         < / L S 4 5 P a r s e r > 
 
         < L S 4 5 P a r s e r   D e s c r i p t i o n = " G i f J p e g   S u b   P a r s e r "   F i l e N a m e = " g i f j p e g s . d l l "   H e l p T e x t = " G i f J p e g   S u b   P a r s e r "   P a r s e r I d = " 9 7 " > 
 
             < F i l e E x t e n s i o n s   / > 
 
         < / L S 4 5 P a r s e r > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " I N I :   C o n f i g u r a t i o n   S e t t i n g s "   F i l e N a m e = " i n i p a r s e . d l l "   H e l p T e x t = " A p p l i c a t i o n   a n d   s y s t e m   c o n f i g u r a t i o n   s e t t i n g s   ( . i n i ) "   P a r s e r I d = " 4 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " i n i "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " l s t "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " s i f "   / > 
 
             < F i l e E x t e n s i o n   N a m e = " p d f "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " S e t u p   R e g i s t r y "   F i l e N a m e = " s r g p a r s e . d l l "   H e l p T e x t = " S e t u p   r e g i s t r y   o p t i o n s   t e x t   f i l e   ( . s r g ) "   P a r s e r I d = " 2 1 " > 
 
         < F i l e E x t e n s i o n s > 
 
             < F i l e E x t e n s i o n   N a m e = " s r g "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " W i n 1 6 "   F i l e N a m e = " w i n 1 6 . d l l "   H e l p T e x t = " W i n d o w s   3 . x   f o r m a t   f i l e s   ( . e x e ,   . d l l ,   . . . ) "   P a r s e r I d = " 5 " > 
 
         < F i l e E x t e n s i o n s > 
 
 	 < F i l e E x t e n s i o n   N a m e = " b i n "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " c n v "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " c p l "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " d l l "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " d o s "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " d r v "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " e x e "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " f i l "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " n e w "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " o c x "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " m o d "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " r e s "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " s c r "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " t s p "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " 3 1 "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " n w 4 "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " W i n d o w s   T o k e n "   F i l e N a m e = " t o k p a r s e . d l l "   H e l p T e x t = " W i n d o w s   t o k e n   t e x t   f i l e s   f r o m   A c c e s s ,   E x c e l ,   a n d   W o r d "   P a r s e r I d = " 6 " > 
 
         < F i l e E x t e n s i o n s > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d a "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d b "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d c "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d m "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d s "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d w "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d z "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " s t m "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " t o k "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " I N F :   S e t u p   I n f o r m a t i o n "   F i l e N a m e = " i n f p a r s e . d l l "   H e l p T e x t = " T h e   [ S t r i n g s ]   s e c t i o n   i n   s e t u p   i n f o r m a t i o n   f i l e s   ( . a d m ,   . i n f ,   . c d f ) "   P a r s e r I d = " 7 " > 
 
         < F i l e E x t e n s i o n s > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i n f "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i n f _ l o c "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " c d f "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " a d m "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " d d b "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i n x "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " c d x "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " s e d "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " c i x "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " e c f "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i n s "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " t x t "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i e m "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " R I F F "   F i l e N a m e = " r i f f p a r s . d l l "   H e l p T e x t = " R e s o u r c e   I n t e r c h a n g e   F i l e   F o r m a t   ( . a v i ,   . w a v ) "   P a r s e r I d = " 8 " > 
 
         < F i l e E x t e n s i o n s > 
 
 	 < F i l e E x t e n s i o n   N a m e = " a n i "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " a v i "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " i d f "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " r m i "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " w a v "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
     < L S 4 5 P a r s e r   D e s c r i p t i o n = " M S I   P a r s e r "   F i l e N a m e = " m s i p a r s e . d l l "   H e l p T e x t = " W i n d o w s   I n s t a l l e r   d a t a b a s e s   ( * . m s i ,   * . m i p ,   * . m s m ) "   P a r s e r I d = " 8 3 " > 
 
         < F i l e E x t e n s i o n s > 
 
 	 < F i l e E x t e n s i o n   N a m e = " m s i "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " m i p "   / > 
 
 	 < F i l e E x t e n s i o n   N a m e = " m s m "   / > 
 
         < / F i l e E x t e n s i o n s > 
 
     < / L S 4 5 P a r s e r > 
 
 < / P a r s e r s > 
 
 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\MICROSOFT LS4.8QFE9 LSBT1.5QFE9 Readme.docx ===
[Content_Types].xml  ^,YVWUwU ~sX@< _rels/.rels  word/_rels/document.xml.rels  x??i( )^,?V m=>_+F! 4N1Vz :=]R) word/document.xml hL&fp oM}oD GkX?n5# 5fmH]L #OR^h V$udd -,DY3, U#pWF usJKn (%HYS `\|Htw ;X,NQ k4e>K<'x fol)c O&'Es. NhJHz 45v=( X*!?N XDf$d RWh:v -nF2* .#Q,0 De5'K XA1NV )V,FQ/ Yv0u`0 4p$<< kZNi9uV (PC{2 ,Mt0I >Inh~ ;xdQN ac(yt {=iD*= ~[5RJ c9wX{ e]>dN L_&Jd N|-@lK mim+- {Ppds word/footer3.xml word/footer2.xml word/footer1.xml word/header2.xml EM*A@ I+!(gs l6!VFqp word/header1.xml EM*A@ I+!(gs l6!VFqp word/endnotes.xml cQK#$ word/footnotes.xml ZX'A'$ g:c%h m7`3c word/header3.xml EM*A@ I+!(gs l6!VFqp word/theme/theme1.xml w toc'v 3Vq%'#q :\TZaG IqbJ#x T[XF64 word/settings.xml zzR^,r nxzX$]w87 .^DC[^ ghtX* %ZUBPK R$Ec-4 ?V;Jh @{A;),Zo word/webSettings.xml Oo>F5 Xq"1f,/ docProps/custom.xml  #D41^ |bvMY word/styles.xml -n(BKRq &~;?2n szg";D (.C4P4Q) wg&CG t,^vPM ?C9 <_ l]ES3 mYv|6 word/numbering.xml wu5H= :NVecP 3CDD=$J; #Zaq* 32]9L `<rg}zd 4W_(@0 A`xpg #r}Dn: X*v#T T9[B` *`5M` 5<nu< @o%H1kj docProps/core.xml  F>p#yi MAzCc word/fontTable.xml PQV.w >a*nL/ docProps/app.xml  ;+Z*& ]GiRd >jZd4; q#wEJF _PFgd [Content_Types].xmlPK _rels/.relsPK word/_rels/document.xml.relsPK word/document.xmlPK word/footer3.xmlPK word/footer2.xmlPK word/footer1.xmlPK word/header2.xmlPK word/header1.xmlPK word/endnotes.xmlPK word/footnotes.xmlPK word/header3.xmlPK word/theme/theme1.xmlPK word/settings.xmlPK word/webSettings.xmlPK docProps/custom.xmlPK word/styles.xmlPK word/numbering.xmlPK docProps/core.xmlPK word/fontTable.xmlPK docProps/app.xmlPK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\m4\readme.txt ===
GNU m4 v1.4 from http://sourceforge.net/project/showfiles.php?group_id=23617&release_id=62660

Source code, win32 binaries, and documentation for m4 are available at that link.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\m4\state\readme.txt ===
corext.m4f is a "freeze" file for M4, defining the starting state of the M4 processor
state.m4 is the file used to generate this freeze file.

This is used to uniformly change M4's quoting characters from `' to {}, to avoid SQL conflicts.

Generate the state file using 

    m4.cmd --prefix-builtins -F corext.m4f state.m4f
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\magellan\4.74\x86\EULA.txt ===
Magellan ("Software Component") is for INTERNAL MICROSOFT USE ONLY.  It is intended for use with
software that is still in development and is not intended for external distribution.  Features
of this tool may not be an accurate representation of the final product.  Microsoft assumes no
responsibility for any damages that might occur directly or indirectly from use of this tool.
DISTRIBUTION OF THIS PRODUCT OUTSIDE OF MICROSOFT CORPORATION IS PROHIBITED.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\magellan\4.74sp2\x86\EULA.txt ===
Magellan ("Software Component") is for INTERNAL MICROSOFT USE ONLY.  It is intended for use with
software that is still in development and is not intended for external distribution.  Features
of this tool may not be an accurate representation of the final product.  Microsoft assumes no
responsibility for any damages that might occur directly or indirectly from use of this tool.
DISTRIBUTION OF THIS PRODUCT OUTSIDE OF MICROSOFT CORPORATION IS PROHIBITED.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\magellan\4.74\x86\MagellanSdk.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MagellanSdk</name>
    </assembly>
    <members>
        <member name="T:MS.Magellan.Reporting.Arc">
            <summary>
            When the execution flow jumps from a block to another, we call that pair of blocks an arc.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Arc.GetTraces">
            <summary>
            Returns a collection of traces which hit this arc.
            Affected by traces.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.Index">
            <summary>
            The index of the arc in the arc vector of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.IsCovered">
            <summary>
            True = covered by tests. False = not covered by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.FromBlock">
            <summary>
            The source block of the arc.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.ToBlock">
            <summary>
            The destination block of the arc.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BinaryFile">
            <summary>
            A binary is a portable executable which can be instrumented by Magellan for code coverage.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.CoverageObject">
            <summary>
            Object that has coverage properties like BlockCount, HitBlockCount etc.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.NamedObject">
            <summary>
            Object that has a property called Name.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.NamedObject.Name">
            <summary>
            Name.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.BlockCount">
            <summary>
            Number of blocks in this object. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.HitBlockCount">
            <summary>
            Number of blocks in this object which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.MissedBlockCount">
            <summary>
            Number of blocks in this object which were missed by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.ArcCount">
            <summary>
            Number of arcs in this object. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.HitArcCount">
            <summary>
            Number of arcs in this object which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.MissedArcCount">
            <summary>
            Number of arcs in this object which were missed by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.Id">
            <summary>
            Unique id that distinguishes this object from others of the same type.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetClasses">
            <summary>
            Returns a collection of all the classes in this binary, excluding the classes from static libraries.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetFunctions">
            <summary>
            Returns a collection of all the functions in this binary, including functions from static libraries.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetSourceFiles">
            <summary>
            Returns a collection of all the source files in this binary, excluding the files from static libraries.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetStaticLibraries">
            <summary>
            Returns a collection of all the static libraries in this binary.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetTraces">
            <summary>
            Returns a collection of all the traces for this binary accross all data sources.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Directory">
            <summary>
            Directory of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.UniqueId">
            <summary>
            Unique identifier used to differentiate binaries with the same name.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Checksum">
            <summary>
            
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.FileVersion">
            <summary>
            File version extracted from the original uninstrumented binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.ProductVersion">
            <summary>
            Product version extracted from the original uninstrumented binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.ImageDateTimestamp">
            <summary>
            The creation date of the original uninstrumented binary by the linker.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.TargetPlatform">
            <summary>
            The target platform of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.CoverageType">
            <summary>
            The coverage granularity level at which the binary was instrumented.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.MagellanVersion">
            <summary>
            The version of the Magellan toolset that was used to extract coverage symbols from this binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Build">
            <summary>
            The build to which this binary belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.MergedTrace">
            <summary>
            Trace obtained from merging all the traces from all the datasources for this binary.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Id">
            <summary>
            Returns an object that uniquely identifies this binary.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageType">
            <summary>
            The coverage granularity level at which the binary was instrumented.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.CoverageType.None">
            <summary>
            Undefined 
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.CoverageType.BlocksOnly">
            <summary>
            This option means that only blocks are available in the coverage data.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.CoverageType.BlocksAndArcs">
            <summary>
            This option means that both blocks and arcs are available in the coverage data.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BinaryTargetPlatform">
            <summary>
            Specifies what platform the binary was built for.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.None">
            <summary>
            Undefined 
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.NativeI386">
            <summary>
            Native executable for i386 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.Native64">
            <summary>
            Native executable for 64-bit platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.Managed">
            <summary>
            Managed executable
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.PreJitEverett">
            <summary>
            
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.PreJitWhidbey">
            <summary>
            
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.MixedMode">
            <summary>
            Mixed mode executable for i386 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.NativeAmd64">
            <summary>
            Native executable for AMD64 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.Managed64">
            <summary>
            Managed executable for AMD64 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.MixedMode64">
            <summary>
            Mixed mode executable for AMD64 platform
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Block">
            <summary>
            A block, also known as a basic block, is the set of contiguous code instructions in the
            physical layout of a binary that has exactly one entry point and one exit point. 
            Calls, jumps, and branches mark the end of a block. A block typically consists 
            of multiple machine-code instructions.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Block.GetTraces">
            <summary>
            Returns a collection of traces which hit this block.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.Address">
            <summary>
            The address of the block inside the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.Index">
            <summary>
            The index of the block in the block vector of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.IsCovered">
            <summary>
            True = covered by tests. False = not covered by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.AssemblyCodeLines">
            <summary>
            Assembly code of this block.
            </summary>
            <exception cref="T:System.IO.InvalidDataException">Thrown when the covsym file does not contain assembly code information or is corrupt.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.StartSourceLineNumber">
            <summary>
            Line number in the source file where this block starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.EndSourceLineNumber">
            <summary>
             Line number in the source file where this block ends.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.Binary">
            <summary>
            The binary to which this block belongs to.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Build">
            <summary>
            A build represents a collection of binaries which have the same custom version.
            Different versions of the same binary should be instrumented with a different
            custom version so that they can be distinguised when viewing coverage data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Build.GetBinaries">
            <summary>
            Returns a collection of binaries from this build. 
            Filters affect the results returned by this method.
            </summary>
            <returns>Collection of binaries.</returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Build.GetMergedStaticLibraries">
            <summary>
            Merges the coverage of static libraries accross all the binaries in this build. 
            For example if two binaries bin1.exe and bin2.exe link to the same static library 
            bin3.lib, the coverage of bin3.lib from bin1.exe is merged with the coverage 
            of bin3.lib from bin2.exe and returned in this collection. Static libraries are
            uniquely identified by full path, not just file name.
            </summary>
            <returns>Collection of merged static libraries accross all binaries.</returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Build.GetMergedSourceFiles">
            <summary>
            Merges the coverage of source files accross all the binaries in this build. 
            For example if two binaries bin1.exe and bin2.exe compile the same source file
            file.cpp, the coverage of file.cpp from bin1.exe is merged with the coverage 
            of file.cpp from bin2.exe and returned in this collection. Source files are
            uniquely identified by full path, not just file name.
            </summary>
            <returns>Collection of merged soure files across all binaries.</returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Build.Name">
            <summary>
            Custom version specified at instrumentation time and which is used to group
            binaries into builds.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Build.CustomVersion">
            <summary>
            Custom version specified at instrumentation time and which is used to group
            binaries into builds.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Build.Project">
            <summary>
            The project to which this build belongs to.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Class">
            <summary>
            Represents the object oriented concept of class which contains metods and data members.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Class.GetFunctions">
            <summary>
            Returns a collection of all the functions in this class.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Class.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this class 
            accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.Namespace">
            <summary>
            Namespace of the class.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.AccessModifier">
            <summary>
            Access modifier. E.g. public.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.Binary">
            <summary>
            The binary this class belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.StaticLibrary">
            <summary>
            The static library this class belongs to. Can be null.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.Id">
            <summary>
            Returns an object that uniquely identifies this class.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.ClassAccessModifier">
            <summary>
            Access modifiers for a class.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NotPublic">
            <summary>
            Class/struct does not have public type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.Public">
            <summary>
            Class/struct has public type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedPublic">
            <summary>
            Class/struct has nested public type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedPrivate">
            <summary>
            Class/struct has nested private type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedFamily">
            <summary>
            Class/struct has nested family (protected) type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedAssembly">
            <summary>
            Class/struct has nested assembly type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedFamilyAndAssembly">
            <summary>
            Class/struct has nested family (protected) and assembly type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedFamilyOrAssembly">
            <summary>
            Class/struct has nested family (protected) or assembly type visibility
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BuildCollection">
            <summary>
            Collection of Build objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BinaryFileCollection">
            <summary>
            Collection of BinaryFile objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.StaticLibraryCollection">
            <summary>
            Collection of StaticLibrary objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.ClassCollection">
            <summary>
            Collection of Class objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceFileCollection">
            <summary>
            Collection of SourceFile objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionCollection">
            <summary>
            Collection of Function objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.TraceCollection">
            <summary>
            Collection of Trace objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionParameterCollection">
            <summary>
            Collection of FunctionParameter objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLineCollection">
            <summary>
            Collection of SourceLine objects. The collection is sorted ascending by the field SourceLine.Number.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BlockCollection">
            <summary>
            Collection of Block objects. The collection is sorted ascending by the field Block.Index.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.ArcCollection">
            <summary>
            Collection of Arc objects. The collection is sorted ascending by the field Arc.Index.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageSymbolSourceCollection">
            <summary>
            Collection of data sources. Adding or removing data sources to this collection
            clears the Project hierarchy of all data, so accessing existing objects in the
            hierarchy has undefined behavior. After removing or adding data sources
            the method Project.GetBuilds needs to be called again to refresh the data.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.EventCollection`1">
            <summary>
            A collection that raises events when is changed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.RemoveItem(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.ClearItems">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.SetItem(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolSourceCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of these data sources.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolSourceCollection.LoadFrom(System.String)">
            <summary>
            Loads datasources from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataSourceCollection">
            <summary>
            Collection of data sources. Adding or removing data sources to this collection
            clears the Project hierarchy of all data, so accessing existing objects in the
            hierarchy has undefined behavior. After removing or adding data sources
            the method Project.GetBuilds needs to be called again to refresh the data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataSourceCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of these data sources.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataSourceCollection.LoadFrom(System.String)">
            <summary>
            Loads datasources from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="T:MS.Magellan.Reporting.StringPatternCollection">
            <summary>
            Collection of string patterns to match symbols against, when using a Filter.
            A string pattern can contain the character * as wildcard.
            The * character cannot be escaped.
            Samples: *.dll, foo.*, ATL::*, *.*, *\dir\dir\foo.*
            If multiple string patterns are added they are applied like in an OR clause.
            For example if the two patterns are added "foo*" and "boo*" it means 
            all strings that start with foo OR boo will be matched.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterCollection">
            <summary>
            Collection used to build complex filters that need to be applied at the same time.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of these filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterCollection.LoadFrom(System.String)">
            <summary>
            Loads filters from an xml representation.
            </summary>
            <param name="xml"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.PathMappingCollection">
            <summary>
            Collection of PathMapping objects.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMappingCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of the path mappings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMappingCollection.LoadFrom(System.String)">
            <summary>
            Loads path mappings from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageTrace">
            <summary>
            When users save their coverage they can choose a trace name to be associated with it. This 
            helps identifying what test or set of tests generated that particular coverage. So in a sense
            a trace is similar with a test but the user controls its granularity. It can range from a 
            small part of a test to multiple tests. It all depends on how often the coverage is saved.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageTrace.GetHitFunctions">
            <summary>
            Returns a collection of functions which are hit by this trace.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageTrace.RuntimeTimeSpan">
            <summary>
            The runtime execution time of this trace.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageTrace.BlockVector">
            <summary>
            Contains the bit vector associated with blocks.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageTrace.ArcVector">
            <summary>
            Contains the bit vector associated with arcs.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageVector">
            <summary>
            Encodes coverage in the form of a bit vector.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageVector.Bits">
            <summary>
            Array of bits.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageSymbolSource">
            <summary>
            Abstract class for the concept of coverage symbol source. One example is covsym file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolSource.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Source of coverage symbols. Can have different meaning in derived classes.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageSymbolSource.Source">
            <summary>
            Source of coverage symbols. Can have different meaning in derived classes.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageSymbolPath">
            <summary>
            A relative or full path towards a location with covsym files. 
            The filename can contain wildcards which are accepted by the file system when searching files.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolPath.#ctor(System.String,System.IO.SearchOption)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Path to covsym files.</param>
            <param name="searchOption">Search in top directory or all subdirectories.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageSymbolPath.SearchOption">
            <summary>
            Search in top directory or all subdirectories.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataSource">
            <summary>
            Abstract class for the concept of coverage data source. One example is covdata file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataSource.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Source of coverage data. Can have different meaning in derived classes.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageDataSource.Source">
            <summary>
            Source of coverage data. Can have different meaning in derived classes.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataPath">
            <summary>
            A relative or full path towards a location with covdata files. 
            The filename can contain wildcards which are accepted by the file system when searching files.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataPath.#ctor(System.String,System.IO.SearchOption)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Path to covdata files.</param>
            <param name="searchOption">Search in top directory or all subdirectories.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageDataPath.SearchOption">
            <summary>
            Search in top directory or all subdirectories.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataService">
            <summary>
            Encapsulates the concept of a machine where the coverage service is running and collecting coverage data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataService.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Machine name, or "localhost" or IP of a machine.</param>
        </member>
        <member name="T:MS.Magellan.Reporting.TraceSource">
            <summary>
            A coverage data file (.covdata) contains coverage information for
            a binary and is created at runtime when the instrumented binary
            is executed.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.TraceSource.#ctor(MS.Magellan.Reporting.Project)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.CovsymSource">
            <summary>
            A coverage symbol file (.covsym) contains information that describes
            the content of a binary. For example: classes, files, functions, etc.
            Covsym files are usually created at instrumentation time from the 
            uninstrumented binary and pdb files.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.CovsymSource.#ctor(MS.Magellan.Reporting.Project)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CovsymSource.CoverageSymbolPaths">
            <summary>
            Collection of coverage symbol paths. Allows both read and write operations.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.CovdataSource">
            <summary>
            A coverage data file (.covdata) contains coverage information for
            a binary and is created at runtime when the instrumented binary
            is executed.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.CovdataSource.#ctor(MS.Magellan.Reporting.Project)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CovdataSource.CoverageDataPaths">
            <summary>
            Collection of coverage data paths. Allows both read and write operations.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.LiveTraceSource.CoverageDataServices">
            <summary>
            Collection of services that can generate traces.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Filter">
            <summary>
            Abstract class from which all filters derive.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Filter.ToXml">
            <summary>
            Returns a string containing the xml representaion of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Filter.LoadFrom(System.String)">
            <summary>
            Loads a filter from an xml representation.
            </summary>
            <param name="xml"></param>
        </member>
        <member name="P:MS.Magellan.Reporting.Filter.Targets">
            <summary>
            A filter can be applied on the entire project, on specific builds or on specific binaries.
            Targets can be used to specify what objects to apply the filter on.
            It can only contain FilterBuild and FilterBinary filters.
            </summary>
            <remarks>
            If Targets is empty the filter applies to the entire Project.
            If Targets contains a FilterBuild it means the filter will apply only to builds
            which match that build filter.
            If Targets contains a FilterBinary it means the filter will apply only to binaries
            which match that binary filter.
            If Targets contains both FilterBuild and FilterBinary it means the filter will apply
            only to builds and binaries which match those filters.
            </remarks>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterSymbol">
            <summary>
            Abstract class that represents a symbol filter. Examples of symbols are binary, function, class.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.#ctor">
            <summary>
            Creates an empty filter. Use the filter properties to specify more data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a symbol filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.ToXml">
            <summary>
            Returns a string containing the xml representaion of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.LoadFrom(System.String)">
            <summary>
            Loads a filter from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSymbol.StringPatterns">
            <summary>
            Collection of string patterns to match symbols against.
            A string pattern can contain the character * as wildcard.
            The * character cannot be escaped.
            Samples: *.dll, foo.*, ATL::*, *.*, *\dir\dir\foo.*
            If multiple string patterns are added they are applied like in an OR clause.
            For example if the two patterns are added "foo*" and "boo*" it means 
            all strings that start with foo OR boo will be matched.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSymbol.StringPatternOperator">
            <summary>
            Operator that specifies how the filter is applied: inclusive or exclusive.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterBuild">
            <summary>
            Filter that matches builds by CustomVersion.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBuild.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBuild.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a build filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterBinary">
            <summary>
            Filter that matches binaries by Directory and Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBinary.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBinary.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a binary filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterClass">
            <summary>
            Filter that matches classes by Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterClass.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterClass.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a class filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterSourceFile">
            <summary>
            Filter that matches source files by Directory and Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceFile.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceFile.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a source file filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterFunction">
            <summary>
            Filter that matches functions by Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterFunction.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterFunction.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a function filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterStaticLibrary">
            <summary>
            Filter that matches static libraries by Directory and Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterStaticLibrary.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterStaticLibrary.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a static library filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterTrace">
            <summary>
            Filter that matches traces by Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterTrace.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterTrace.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a trace filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.StringPatternOperator">
            <summary>
            Filter operator to use when matching symbols.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.StringPatternOperator.Like">
            <summary>
            The filter includes all symbols that match any of the 
            regular expressions added to the filter.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.StringPatternOperator.Unlike">
            <summary>
            The filter excludes all symbols that match any of the
            regular expressions added to the filter.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLineRange">
            <summary>
            Represnts a range of source lines.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceLineRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a line range with the give start and end lines.
            </summary>
            <param name="startLine"></param>
            <param name="endLine"></param>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLineRange.StartLine">
            <summary>
            The start line of the range.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLineRange.EndLine">
            <summary>
            The end line of the range.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterSourceLines">
            <summary>
            This type of filter can be used to filter specific lines of code from source files.
            It provides various ways to specify what to filter, like bbpacks, diff files resulting from 
            the source depot command "sd diff -dn".
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.AddSourceLines(System.String,System.Int32,System.Int32)">
            <summary>
            Add a file path and a range of lines from that file which will be included 
            when calculating blocks. The file path can be incomplete, it doens't have to be a
            fully qualified path. Examples: "foo.cpp, "c:\folder\foo.cpp", "folder\foo.cpp".
            When more than the file name is specified, the directory in front of the filename
            must match the directory of the file from the pdb. So if a source file was compiled
            at location c:\sourcedepot\folder\foo.cpp, this is what needs to be passed to the
            filter in order to uniquely identify the file foo.cpp. Even if this path no longer
            exists on the machine, this is just a way to uniquely identify files. If the full
            path used at compile time is forgotten, you can enumerate all the files in the 
            BinaryFile class and get a look at the Directory and Name properties.
            </summary>
            <param name="filePath">The file path to use when filtering data.</param>
            <param name="startLine">Start line from where to display code.</param>
            <param name="endLine">End line up to where to display code.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when filePath is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when endLine is less than startLine.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.AddBbpack(System.String)">
            <summary>
            Adds a bbpack ".cmd" file that contains the files and line ranges to display.
            </summary>
            <param name="bbpackPath">The bbpack file to use to filter data.</param>
            <exception cref="T:System.ArgumentException">Thrown when bbpackPath is an empty string ("").</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when bbpackPath is null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when bbpackPath cannot be found.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when bbpackPath has an invalid path.</exception>
            <exception cref="T:System.IO.IOException">Thrown when bbpackPath has an incorrect or invalid syntax.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when the content of the bbpack file is invalid or corrupt.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.AddDiff(System.String)">
            <summary>
            Add a diff file generated by the source depot command "sd diff -dn".
            The SDDIFF, SDUDIFF and SDPDIFF environment variables need to be unset
            in order to get the output of "sd diff -dn" to console so it can be redirected to a file.
            The data will be filtered based on the content of the diff file.
            </summary>
            <param name="diffPath">The diff file to use to filter data.</param>
            <exception cref="T:System.ArgumentException">Thrown when diffPath is an empty string ("").</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when diffPath is null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when diffPath cannot be found.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when diffPath has an invalid path.</exception>
            <exception cref="T:System.IO.IOException">Thrown when diffPath has an incorrect or invalid syntax.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when the content of the diff file is invalid or corrupt.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.ToXml">
            <summary>
            Returns a string containing the xml representaion of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.LoadFrom(System.String)">
            <summary>
            Loads a filter from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSourceLines.SourceFileLines">
            <summary>
            Dictionary with file paths and line ranges which will be used to filter code.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSourceLines.BbpackPaths">
            <summary>
            The names of the the bbpack ".cmd" files used to filter code.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSourceLines.DiffPaths">
            <summary>
            The names of the files created with a source depot "sd diff" command, used to filter code.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Function">
            <summary>
            Generic term for all posible types of functions in a binary. 
            E.g. C runtime functions, class methods, compiler generated functions.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetParameters">
            <summary>
            Returns a collection of all the parameters of this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetSourceLines">
            <summary>
            Returns a collection of all the source lines in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetBlocks">
            <summary>
            Returns a collection of all the blocks in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetArcs">
            <summary>
            Returns a collection of all the arcs in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block from this function.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Name">
            <summary>
            Name of this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.DecoratedName">
            <summary>
            Decorated name of the function. This should ensure uniqueness across all functions in a binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.ReturnDataType">
            <summary>
            Data type returned by the function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.CallingConvention">
            <summary>
            Calling convention.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.AccessModifier">
            <summary>
            Access modifier.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.CyclomaticComplexity">
            <summary>
            The cyclomatic complexity of the function is calculated by looking
            at the conditionals and counting the blocks with more than one edge.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Address">
            <summary>
            The relative address at which the function is located in the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.StartSourceLineNumber">
            <summary>
            The line number at which the body of the function starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.EndSourceLineNumber">
            <summary>
            The line number at which the body of the function ends.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.StartBlockIndex">
            <summary>
            The block index in the block vector at which the function starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.StartArcIndex">
            <summary>
            The arc index in the arc vector at which the function starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.BlockCount">
            <summary>
            Number of blocks in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.ArcCount">
            <summary>
            Number of arcs in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.HitBlockCount">
            <summary>
            Number of blocks that are hit by tests in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.HitArcCount">
            <summary>
            Number of arcs that are hit by tests in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Binary">
            <summary>
            The binary this function belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Class">
            <summary>
            The class this function belongs to.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.SourceFile">
            <summary>
            The source file this function belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Id">
            <summary>
            Returns an object that uniquely identifies this function.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionAccessModifier">
            <summary>
            Access modifier for a function.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.PrivateScope">
            <summary>
            Function has private scope protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Private">
            <summary>
            Function has private protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.FamilyAndAssembly">
            <summary>
            Function has family (protected) and assembly protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Assembly">
            <summary>
            Function has assembly protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Family">
            <summary>
            Function has family (protected) protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.FamilyOrAssembly">
            <summary>
            Function has family (protected) or assembly protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Public">
            <summary>
            Function has public protection
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionParameter">
            <summary>
            Represents a parameter of a function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FunctionParameter.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FunctionParameter.DataType">
            <summary>
            Data type of the parameter.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.MagellanToolsetVersion">
            <summary>
            Represents a version of the Magellan toolset.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.MagellanToolsetVersion.ToString">
            <summary>
            Returns a string representation of this object in the form Major.Minor.BuildNumber.Revision
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.Major">
            <summary>
            Returns the major database version (Major.#.#.#)
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.Minor">
            <summary>
            Returns the minor database version (#.Minor.#.#)
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.BuildNumber">
            <summary>
            Returns the build number portion of the database version (#.#.BuildNumber.#)
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.Revision">
            <summary>
            Returns the revision portion of the database version (#.#.#.Revision)
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedArc.GetTraces">
            <summary>
            Returns a collection of traces which hit this block.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedBlock.GetTraces">
            <summary>
            Returns a collection of traces which hit this block.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Design.MergedClass">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedClass.GetFunctions">
            <summary>
            Returns a collection of all the functions in this class.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedClass.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this class 
            accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.BlockCount">
            <summary>
            Number of blocks in this class. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.HitBlockCount">
            <summary>
            Number of blocks in this class which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.ArcCount">
            <summary>
            Number of arcs in this class. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.HitArcCount">
            <summary>
            Number of arcs in this class which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Design.MergedFunction">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetSourceLines">
            <summary>
            Returns a collection of all the source lines in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetBlocks">
            <summary>
            Returns a collection of all the blocks in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetArcs">
            <summary>
            Returns a collection of all the arcs in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block from this function.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.BlockCount">
            <summary>
            Number of blocks in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.ArcCount">
            <summary>
            Number of arcs in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.HitBlockCount">
            <summary>
            Number of blocks in this function which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.HitArcCount">
            <summary>
            Number of arcs in this function which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.Class">
            <summary>
            The class this function belongs to.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.SourceFile">
            <summary>
            The source file this function belongs to.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.MergedSourceFile">
            <summary>
            
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceFile">
            <summary>
            Represents a source file. E.g. foo.h, foo.cpp.
            </summary>
            <remarks>
            Sometimes a source file can have the name '{N/A}' meaning that this is a virtual source file
            that doesn't exist, but was created by the Magellan toolset so that compiler generated functions 
            which are not associated to any source file, can belong to a source file.
            </remarks>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceFile.GetFunctions">
            <summary>
            Returns a collection of all the functions in this source file.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceFile.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this 
            source file accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.Directory">
            <summary>
            Directory of the file.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.Binary">
            <summary>
            The binary this source file belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.StaticLibrary">
            <summary>
            The static library this class belongs to. Can be null.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.Id">
            <summary>
            Returns an object that uniquely identifies this file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedSourceFile.GetFunctions">
            <summary>
            Returns a collection of all the functions in this source file.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedSourceFile.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this 
            source file accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.BlockCount">
            <summary>
            Number of blocks in this source file. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.HitBlockCount">
            <summary>
            Number of blocks in this source file which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.ArcCount">
            <summary>
            Number of arcs in this source file. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.HitArcCount">
            <summary>
            Number of arcs in this source file which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Reporting.StaticLibrary">
            <summary>
            Represents a static library. E.g. foo.obj, foo.lib.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetClasses">
            <summary>
            Returns a collection of all the classes in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetFunctions">
            <summary>
            Returns a collection of all the functions in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetSourceFiles">
            <summary>
            Returns a collection of all the source files in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block in this 
            static library accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.StaticLibrary.Directory">
            <summary>
            Directory of the static library.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.StaticLibrary.Binary">
            <summary>
             The binary this static library belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.StaticLibrary.Id">
            <summary>
            Returns an object that uniquely identifies this static library.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetClasses">
            <summary>
            Returns a collection of all the classes in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetFunctions">
            <summary>
            Returns a collection of all the functions in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetSourceFiles">
            <summary>
            Returns a collection of all the source files in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block in this 
            static library accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.BlockCount">
            <summary>
            Number of blocks in this static library. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.HitBlockCount">
            <summary>
            Number of blocks in this static library which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.ArcCount">
            <summary>
            Number of arcs in this static library. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.HitArcCount">
            <summary>
            Number of arcs in this static library which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Design.SimplifiedRegex">
            <summary>
            Simplified regular expression for patterns that can contain * as wildcard.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.SimplifiedRegex.#ctor(System.String)">
            <summary>
            Creates a regular expression with the given pattern.
            </summary>
            <param name="pattern"></param>
        </member>
        <member name="M:MS.Magellan.Design.SimplifiedRegex.IsMatch(System.String)">
            <summary>
            Returns true is the input matches the internal pattern.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Reporting.PathMapping">
            <summary>
            A path mapping is used when trying to open source files that are no longer available in their original location
            so a replace path is needed to load the files from a new location. Also see Project.PathMappings for more info.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMapping.#ctor">
            <summary>
            Create a path mapping.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMapping.#ctor(System.String,System.String)">
            <summary>
            Create a path mapping with the given original and replace paths.
            </summary>
            <param name="originalPath"></param>
            <param name="replacePath"></param>
        </member>
        <member name="P:MS.Magellan.Reporting.PathMapping.OriginalPath">
            <summary>
            The original path that where source files used to be located. 
            This must match a path or a prefix of a path from the PDB file.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.PathMapping.ReplacePath">
            <summary>
            The path that will be used to replace the original path when looking for source files.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Project">
            <summary>
            Project class is the entry point for browsing code coverage data. 
            It provides ways to load data sources and return a list of builds
            that were found in the coverage data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.#ctor">
            <summary>
            Creates an empty project.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.#ctor(System.String)">
            <summary>
            Create a Project object and loads its configuration from a file.
            Can throw the same exceptions as Project.Open.
            </summary>
            <param name="filePath">Path of the project file.</param>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.SetName(System.String)">
            <summary>
            Set the name of the project.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.Open(System.String)">
            <summary>
            Open a project file.
            </summary>
            <param name="filePath">Path of the project file.</param>
            <exception cref="T:System.ArgumentException">Thrown when the filePath is not a valid path.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when filePath is null.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when filePath points to a directory that does not exist.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the filePath specified cannot be found.</exception>
            <exception cref="T:System.IO.IOException">Thrown when other IO exceptions occur.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when filePath has an invalid format.</exception>
            <exception cref="T:System.OutOfMemoryException">Thrown when there is not enough memory to load all the coverage data.</exception>
            <exception cref="T:System.IO.PathTooLongException">Thrown when filePath is too long.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown when the user does not have required permissions to filePath.</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when the user doesn't have access to filePath.</exception>
            <exception cref="T:System.Xml.XmlException">Thrown when the xml inside the given file is not well formed.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.Save(System.String)">
            <summary>
            Save the configuration of the project to a file. 
            This configuration contains data source paths, connection strings, etc.
            </summary>
            <param name="filePath">Path of the project file.</param>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when the user doesn't have access to filePath.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the filePath is not a valid path.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when filePath is null.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when filePath points to a directory that does not exist.</exception>
            <exception cref="T:System.IO.PathTooLongException">Thrown when filePath is too long.</exception>
            <exception cref="T:System.IO.IOException">Thrown when other IO exceptions occur.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown when the user does not have required permissions to filePath.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.filters_OnChanged(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null filter is added to the collection of filters.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.covsymSources_OnChanged(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null data source is added to the collection of data sources.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.covdataSources_OnChanged(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null data source is added to the collection of data sources.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.GetBuilds">
            <summary>
            Returns a collection of builds that were found in the coverage data sources
            that were added to the project. Filters affect the results returned by this method.
            </summary>
            <returns>
            Collection of builds from the data sources added to the project. 
            If the same build exists in different data sources their coverage data is merged
            for binaries which are identical (same name and same unique id).
            </returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when a covsym or covdata path that was specified as data source does not exist.</exception>
            <exception cref="T:System.IO.IOException">Thrown when other IO exceptions occur.</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when the user doesn't have access to the covsym or covdata files specified as data source.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when a covsym or covdata file cannot be found.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown when the user does not have required permissions to covsym or covdata files.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when a covsym or covdata file is corrupt or invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when no data source was added to the Project before calling Project.GetBuilds.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.CoverageSymbolSources">
            <summary>
            Sources of coverage symbols like covsym files.
            Add instances of classes derived from CoverageSymbolSource.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.CoverageDataSources">
            <summary>
            Sources of coverage data like covdata files.
            Add instances of classes derived from CoverageDataSource.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.Filters">
            <summary>
            Collection of filters to apply to the project.
            Adding or removing filters will clear the entire hierarchy of objects and
            Project.GetBuilds will need to be called to refresh the data.
            Filters that are added to the Filters collection are applied as if there was an AND operator between them.
            When multiple strings are added inside the same Filter object, those strings are applied as if there
            was an OR operator between them.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.PathMappings">
            <summary>
            Imagine the following scenario: User1 builds code on Machine1 so all the source files paths embedded
            in the coverage files will be local to Machine1. Now, User2 wants to view the coverage files from User1
            but the source code is now on Machine2 at a different local location. These PathMappings can be used
            to remap the location of the source files so that they can be viewed on Machine2. So this collection
            is a way to facilitate Coverage viewers (like MagellanStudio) to automatically load code from 
            mapped locations on a different machine.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLine">
            <summary>
            Represents a line of code in a source file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceLine.GetTraces">
            <summary>
            Returns a collection of traces which hit at least one block from this line.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLine.Number">
            <summary>
            Number of the line in the source file.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLine.LineCoverage">
            <summary>
            Calculates the coverage of the line by evaluating the coverage of each block
            that belongs to this line.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLine.Blocks">
            <summary>
            Returns a collection of blocks that belong to this line.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLineCoverage">
            <summary>
            Defines the possible coverage values that a source line can have.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.None">
            <summary>
            Coverage is unspecified for this line.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.NotCovered">
            <summary>
            Line is not covered by tests.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.PartiallyCovered">
            <summary>
            Some blocks from the line are covered by tests but not all of them.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.Covered">
            <summary>
            Line is fully covered by tests.
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\magellan\4.74\x86\MagellanAPI.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MagellanAPI</name>
    </assembly>
    <members>
        <member name="T:MSInternal.Magellan.Build">
            <summary>
            Class to retrieve build information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Build.GetDataSet(System.String)">
            <summary>
            Returns a data set containing a list of distinct CustomVersion values
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Build.Query(MSInternal.Magellan.Database)">
            <summary>
            Returns an array of Build objects for the corresponding database
            </summary>
            <param name="database">Object representing open database connection</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.Build.CustomVersion">
            <summary>
            String used to associate a set of executables with a given build
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.ClassStruct">
            <summary>
            Class to retrieve class/struct information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.GetDataSet(System.String,System.Int32)">
            <summary>
            Returns a data set containing a list of classes
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.GetDataSet(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a data set containing a list of functions
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="idComponentInfo">Component to which functions correspond</param>
            <param name="idFunctionInfo">Optionally filter against specified function</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Component)">
            <summary>
            Returns an array of ClassStruct objects for the corresponding component
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myComponent">Component for which to return class objects</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Function)">
            <summary>
            Returns an array of ClassStruct objects for the corresponding component
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myFunction">Function for which to return class objects</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.ClassName">
            <summary>
            Name of class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.NameSpace">
            <summary>
            NameSpace of class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountFunctions">
            <summary>
            The number of functions (methods) contained in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountBlocks">
            <summary>
            The sum of the block counts for all methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountArcs">
            <summary>
            The sum of the arc counts for all methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.ByteSize">
            <summary>
            The sum of the compiled byte sizes of the methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.Complexity">
            <summary>
            The sum of the complexity of the methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.AccessModifier">
            <summary>
            The access modifier of the class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountInheritanceDepth">
            <summary>
            Inheritance depth is the maximum depth of inheritance for this
            class. This is calculated by computing the inheritance depth of
            each of the base classes and by taking the maximum inheritance
            depth.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountBaseClasses">
            <summary>
            The number of immediate base classes. Base classes through the
            inheritance hierarchy are not counted.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountSubClasses">
            <summary>
            The number of classes directly inheriting from a given parent class
            in a module. This doesn’t count classes with several inheritance.
            For example, class A is the base class of class B which is the base
            class for class C. Class/struct A will be flagged as containing one
            sub class and class B will be flagged as containing one sub class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountTotalMethods">
            <summary>
            Number of methods in this class. This includes public, private and
            protected methods.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPrivateMethods">
            <summary>
            Number of class methods denoted as being private.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountProtectedMethods">
            <summary>
            Number of class methods denoted as being protected.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPublicMethods">
            <summary>
            Number of class methods denoted as being public.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountCompilerGeneratedProcs">
            <summary>
            Number of compiler generated functions
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountTotalMemberVariables">
            <summary>
            Number of data fields present in the class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPrivateMemberVariables">
            <summary>
            Number of private data members in a given class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountProtectedMemberVariables">
            <summary>
            Number of protected data members in a given class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPublicMemberVariables">
            <summary>
            Number of public data members in a given class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountTotalCoupling">
            <summary>
            Coupling to other classes through (a) class member variables,
            (b) function parameters, (c) classes defined locally in class
            member method bodies, (d) immediate base classes, and (e) return
            type. A class that is not visible through the PDB because of
            compiler optimization is not counted. Also a class is not counted
            twice, so if a class is coupled as a member variable and then
            through the method parameter, it is counted only once.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountMemberVariableCoupling">
            <summary>
            Coupling to other classes through class member variables.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountMethodLocalCoupling">
            <summary>
            Coupling to other classes through local variables defined in the
            stack of functions.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountMethodParameterCoupling">
            <summary>
            Coupling to other classes through parameters that are passed into
            the method.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountReturnValueCoupling">
            <summary>
            Coupling to other classes through the return value. For example,
            ClassA can return ClassB and there can be implicit conversions.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountBaseClassCoupling">
            <summary>
            Coupling through base classes. For example, ClassC may inherit from
            ClassA and ClassB. In this case the coupling number will be two.
            The sum of the above coupling numbers could be greater than the
            total. This is because a class is not counted twice for the overall
            number.
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.ClassStruct.ClassAccessModifier">
            <summary>
            The set of possible class access modifiers
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NotPublic">
            <summary>
            Class/struct does not have public type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.Public">
            <summary>
            Class/struct has public type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedPublic">
            <summary>
            Class/struct has nested public type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedPrivate">
            <summary>
            Class/struct has nested private type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedFamily">
            <summary>
            Class/struct has nested family (protected) type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedAssembly">
            <summary>
            Class/struct has nested assembly type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedFamilyAndAssembly">
            <summary>
            Class/struct has nested family (protected) and assembly type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedFamilyOrAssembly">
            <summary>
            Class/struct has nested family (protected) or assembly type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.Unknown">
            <summary>
            Class/struct has unknown type visibility
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Component">
            <summary>
            Class to retrieve component information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Component.GetDataSet(System.String)">
            <summary>
            Returns a data set containing a list of components
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Component.GetDataSet(System.String,System.String)">
            <summary>
            Returns a data set containing a list of components
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="customVersion">Optionally filter against specified Custom Version</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Component.Query(MSInternal.Magellan.Database)">
            <summary>
            Returns an array of Component objects for the corresponding database
            </summary>
            <param name="database">Object representing open database connection</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Component.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Build)">
            <summary>
            Returns an array of Component objects for the corresponding Build
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myBuild">Build to filter against</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.Component.NameDirectory">
            <summary>
            Drive and directory portion of component path specified during
            static data import
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.NameFile">
            <summary>
            File name and extension portion of component path specified during
            static data import
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.GuidComponent">
            <summary>
            GUID (globally unique identifier) calculated against all of the
            bytes of the executable using the MD5 encryption algorithm
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.FileVersion">
            <summary>
            File version number extracted from the version resource of the
            executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ProductVersion">
            <summary>
            Product version number extracted from the version resource of the
            executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CustomVersion">
            <summary>
            String used to associate a set of executables with a given build
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.IdCoverageType">
            <summary>
            Type of coverage collected for this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountFiles">
            <summary>
            Number of source files contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountClasses">
            <summary>
            Number of classes contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountFunctions">
            <summary>
            Number of functions contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountBlocks">
            <summary>
            Number of procedure blocks contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountArcs">
            <summary>
            Number of arcs in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.FileSize">
            <summary>
            The size, in bytes, of the executable file on disk
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ByteSize">
            <summary>
            The size, in bytes, of this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ImageSize">
            <summary>
            The size, in bytes, of the component in memory
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ImageDateTimestamp">
            <summary>
            Time stamp of the image. This represents the date and time the
            image was created by the linker. The value is represented in the
            number of seconds elapsed since midnight (00:00:00), January 1,
            1970, Universal Coordinated Time, according to the system clock.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ComplexityCyclomatic">
            <summary>
            The sum of the cyclomatic complexity of all functions within this
            component. The cyclomatic complexity of a function is calculated by
            looking at the conditionals and counting the blocks with more than
            one edge.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.TimeImported">
            <summary>
            The date and time that the static data for this component was
            imported into the coverage database
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.TimeModified">
            <summary>
            The date and time that the executable image was writen
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.Checksum">
            <summary>
            Image file checksum found in the optional PE header
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.PlatformType">
            <summary>
            Platform type of executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountCyclicClassCoupling">
            <summary>
            Measures "a depends on b" and "b depends on a"
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountGlobalVariables">
            <summary>
            Total number of global variables present in the executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxBlocks">
            <summary>
            Maximum number of blocks found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxArcs">
            <summary>
            Maximum number of arcs found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxComplexity">
            <summary>
            Maximum complexity found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPaths">
            <summary>
            Maximum number of paths found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPaths">
            <summary>
            Total number of paths found in all functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxComplexityMcCabe">
            <summary>
            Maximum McCabe cyclomatic complexity found in a function in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountComplexityMcCabe">
            <summary>
            Total McCabe cyclomatic complexity found in all the functions in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxParameters">
            <summary>
            Maximum number of parameters in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountParameters">
            <summary>
            Total number of parameters found in all the functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxIncomingCalls">
            <summary>
            Total number of other functions calling the given function in a
            given module. The maximum for a given function in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountIncomingCalls">
            <summary>
            Accumulated tally of incoming calls for all functions in the given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxOutgoingCalls">
            <summary>
            The other functions that are being called from a given function in
            the given module. This counter gives the maximum such calls being
            made from a given function.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountOutgoingCalls">
            <summary>
            Total number of other functions being called from the given
            function in a given module. The maximum for a given function in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxSourceLines">
            <summary>
            Maximum number of lines found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountSourceLines">
            <summary>
            Total number of lines found in all functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxLocals">
            <summary>
            Maximum number of local variables found in a function in the given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountLocals">
            <summary>
            Total number of locals found in all the functions in the given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxReadCoupling">
            <summary>
            Maximum coupling of global variables through read in a function in
            the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountReadCoupling">
            <summary>
            Total coupling of global variables through read using all the
            functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxWriteCoupling">
            <summary>
            Maximum coupling of global variables through write in a function in
            a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountWriteCoupling">
            <summary>
            Total coupling of global variables through write through all
            functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxAddressCoupling">
            <summary>
            Total coupling where address of  a global variable is taken in a
            function in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountAddressCoupling">
            <summary>
            Total coupling of global variables for all functions in a given
            module where address of a global variable is taken.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxProcCoupling">
            <summary>
            Coupling between procedures through global variables. Shows the
            function that has the maximum coupling to other functions in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountProcCoupling">
            <summary>
            Coupling between procedures counted as aggregated for all the
            functions in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxInheritanceDepth">
            <summary>
            Maximum inheritance depth when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountInheritanceDepth">
            <summary>
            Total inheritance depth when combining all the classes in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxBaseClasses">
            <summary>
            Maximum number of base classes when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountBaseClasses">
            <summary>
            Total number of base classes when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxSubClasses">
            <summary>
            Maximum number of sub classes given a class when looking at all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountSubClasses">
            <summary>
            Total number of sub classes when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxTotalMethods">
            <summary>
            Total number of methods in a given class compared to all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountTotalMethods">
            <summary>
            Total number of class methods when aggregated over all the classes
            in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPrivateMethods">
            <summary>
            Maximum number of private methods when looking at all the classes
            in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPrivateMethods">
            <summary>
            Total number of private methods when looking at all the classes in
            a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxProtectedMethods">
            <summary>
            Maximum number of protected methods when looking at all the classes
            in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountProtectedMethods">
            <summary>
            Total number of protected methods when aggregated for all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPublicMethods">
            <summary>
            Maximum number of public methods in a given class when looking at
            all the classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPublicMethods">
            <summary>
            Total number of public methods when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxCompilerGeneratedProcs">
            <summary>
            Maximum number of compiler generated methods when looking at all
            the classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountCompilerGeneratedProcs">
            <summary>
            Total number of compiler generated methods when looking at all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxTotalMemberVariables">
            <summary>
            Maximum number of data members for a given class in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountTotalMemberVariables">
            <summary>
            Total number of class data members when aggregated across an entire
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPrivateMemberVariables">
            <summary>
            Maximum number of private data members for a given class in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPrivateMemberVariables">
            <summary>
            Total number of private data members for all the classes in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxProtectedMemberVariables">
            <summary>
            Maximum number of protected data members for a given class in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountProtectedMemberVariables">
            <summary>
            Total number of protected data members for all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPublicMemberVariables">
            <summary>
            Maximum number of public data members for a given class in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPublicMemberVariables">
            <summary>
            Total number of public data members for all the classes in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxTotalCoupling">
            <summary>
            Maximum class coupling for a given class when looking at all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountTotalCoupling">
            <summary>
            Total number for coupling when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxMemberVariableCoupling">
            <summary>
            Maximum coupling to other classes through class data fields.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountMemberVariableCoupling">
            <summary>
            Sum of all data field coupling found in all classes in the module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxMethodLocalCoupling">
            <summary>
            Maximum coupling to other classes through local variables defined
            in the function stack found in all classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountMethodLocalCoupling">
            <summary>
            Total function local coupling for all classes in the module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxMethodParameterCoupling">
            <summary>
            Maximum coupling to other classes through parameters that are
            passed into the function.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountMethodParameterCoupling">
            <summary>
            Sum of the coupling to other classes through parameters that are
            passed into the function.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxReturnValueCoupling">
            <summary>
            Coupling to other classes through return value. For example, ClassA
            can return ClassB and there can be implicit conversions.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountReturnValueCoupling">
            <summary>
            Total coupling to all the other classes through return value found
            for all the classes in the module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxBaseClassCoupling">
            <summary>
            Coupling through base classes. For example, ClassC may inherit from
            ClassA and ClassB. In this case the coupling number will be two.
            The maximum value of such coupling is returned through this metric.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountBaseClassCoupling">
            <summary>
            Total coupling through bases classes when aggregated for all the
            classes in the module.
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Component.CoverageType">
            <summary>
            The set of possible coverage types
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.CoverageType.Block">
            <summary>
            Block coverage is collected. A block, also known as a basic
            block, is the set of contiguous code instructions in the
            physical layout of a binary that has exactly one entry point
            and one exit point. Calls, jumps, and branches mark the end of
            a block. A block typically consists of multiple machine-code
            instructions.
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.CoverageType.Arc">
            <summary>
            Arc coverage is collected. The arcs of a basic block specify
            the basic blocks that call the entry point of the block, and
            the basic blocks that are called by the exit point of the
            block. Thus, the arcs of a block are all possible execution
            paths through the block.
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Component.ComponentPlatformType">
            <summary>
            The set of possible platform types
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.NotUsed">
            <summary>
            Undefined type
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Native_i386">
            <summary>
            Native executable for i386 platform
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Native_64">
            <summary>
            Native executable for 64-bit platform
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Managed">
            <summary>
            Managed executable
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.PreJIT_Everett">
            <summary>
            
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.PreJIT_Whidbey">
            <summary>
            
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.MixedMode">
            <summary>
            Mixed mode executable for i386 platform
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Native_AMD64">
            <summary>
            Native executable for AMD64 platform
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Database">
            <summary>
            Class to maintain a database connection
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Database.GetDataSet(System.String,System.String,System.String)">
            <summary>
            Returns a data set fulfilling the specified query
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Database.Dispose">
            <summary>
            Releases all resources used by the Database object
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Database.#ctor(System.String)">
            <summary>
            Database object constructor opens a connection to the database
            specified by the connection string
            </summary>
            <param name="connectionString">Connection string used to connect to SQL server</param>
        </member>
        <member name="P:MSInternal.Magellan.Database.Timeout">
            <summary>
            The time (in seconds) to wait for the command to execute
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Database.ConnectionString">
            <summary>
            Connection string used to connect to the database
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Database.Connection">
            <summary>
            Connection object that maintains the connection string keys and values
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Database.Name">
            <summary>
            Returns the database name
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Function">
            <summary>
            Class to retrieve function information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Function.GetDataSet(System.String,System.Int32)">
            <summary>
            Returns a data set containing a list of functions
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="idComponentInfo">Component to which functions correspond</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Function.GetDataSet(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a data set containing a list of functions
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="idComponentInfo">Component to which functions correspond</param>
            <param name="idClassInfo">Optionally filter against specified class</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Function.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Component)">
            <summary>
            Returns an array of Function objects for the corresponding component
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myComponent">Component for which to return function objects</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Function.Query(MSInternal.Magellan.Database,MSInternal.Magellan.ClassStruct)">
            <summary>
            Returns an array of Function objects for the corresponding Class
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myClassStruct">Class/struct for which to return function objects</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.Function.FunctionName">
            <summary>
            Name of function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CallingConvention">
            <summary>
            Function calling convention
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.ReturnDataType">
            <summary>
            Function return value data type
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountBlocks">
            <summary>
            Count of blocks in function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountArcs">
            <summary>
            Count of arcs in function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.ByteSize">
            <summary>
            The compiled byte size of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.Complexity">
            <summary>
            The cyclomatic complexity of the function is calculated by looking
            at the conditionals and counting the blocks with more than one edge
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.Address">
            <summary>
            The address of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.LineNumberStart">
            <summary>
            The line number in the source file at which the function begins
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.LineNumberEnd">
            <summary>
            The line number in the source file at which the function ends
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.DecoratedName">
            <summary>
            The decorated name of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.AccessModifier">
            <summary>
            The access modifier of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountPaths">
            <summary>
            The count of paths as defined in "Efficient Path Profiling" by
            T. Ball and J. Larus - MICRO 1996, section 3.1
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.ComplexityMcCabe">
            <summary>
            The McCabe cyclomatic complexity is defined as e-n+2p, where
            e is the number of edges, n is the number of nodes, and p is the
            number of unconnected parts of the graph
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountParameters">
            <summary>
            The number of parameters the function accepts
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountIncomingCalls">
            <summary>
            The number of other functions calling this function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountOutgoingCalls">
            <summary>
            The number of other functions being called by this function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountSourceLines">
            <summary>
            The number of source lines contributing to the definition of this
            function. Multiple source files can contribute to a single
            function. Source lines that don't produce code, such as comments,
            will not be included in this count.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountLocals">
            <summary>
            Number of local variables. This is determined by binary analysis,
            so compiler optimizations might report a different number of local
            variables than defined in source code.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountReadCoupling">
            <summary>
            Number of global variables read by a function and thus coupled to
            the global variable through the read operation.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountWriteCoupling">
            <summary>
            Number of global variables written by a function and thus coupled
            to the global variable through the write operation.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountAddressCoupling">
            <summary>
            Number of global variables whose address is taken by a function.
            The function is coupled to the global variable as it takes the
            address of the variable.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountProcCoupling">
            <summary>
            Calculated using global variables. If a global variable is set in
            FunctionA() and is modified in FunctionB() and FunctionC(), a
            coupling value of two is shown for FunctionA().
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Function.FunctionAccessModifier">
            <summary>
            The set of possible function access modifiers
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.PrivateScope">
            <summary>
            Function has private scope protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Private">
            <summary>
            Function has private protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.FamilyAndAssembly">
            <summary>
            Function has family (protected) and assembly protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Assembly">
            <summary>
            Function has assembly protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Family">
            <summary>
            Function has family (protected) protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.FamilyOrAssembly">
            <summary>
            Function has family (protected) or assembly protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Public">
            <summary>
            Function has public protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Unknown">
            <summary>
            Function has unknown protection
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Sage">
            <summary>
            The Sage class provides a unified messaging system
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Sage.Severity">
            <summary>
            Enumeration representing message severity
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Success">
            <summary>
            Success messages are informative and displayed when current
            operation is successfully proceeding
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Warning">
            <summary>
            Warnings are displayed when current operation can continue but
            should be corrected
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Error">
            <summary>
            Errors are displayed when the current operation cannot continue
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Fatal">
            <summary>
            Fatal errors are displayed when program execution cannot continue
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Sage.SageException">
            <summary>
            Class to encapsulate Sage message and throw object as exception
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Severity">
            <summary>
            The severity of the message: Success, Warning, Error, Fatal
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Code">
            <summary>
            Four digit code associated with the message
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Text">
            <summary>
            Text of the message with place holders filled in
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Description">
            <summary>
            Additional description text associated with the message
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Actions">
            <summary>
            Suggested actions to take to resolve issue
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.FormattedMessage">
            <summary>
            Fully formatted message containing severity, prefix, code, and text
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Version">
            <summary>
            Class to retrieve the Magellan coverage database version
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Version.GetDataSet(System.String)">
            <summary>
            Returns a data set containing the Magellan coverage database version
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Version.Query(MSInternal.Magellan.Database)">
            <summary>
            Constructs a Version object containing the Magellan coverage
            database version.
            </summary>
            <param name="database">Object representing open database connection</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Version class constructor of format (Major.Minor.BuildNumber.Revision)
            </summary>
            <param name="major">Major version number</param>
            <param name="minor">Minor version number</param>
            <param name="buildNumber">Version build number</param>
            <param name="revision">Version revision</param>
        </member>
        <member name="M:MSInternal.Magellan.Version.HasValue">
            <summary>
            Has a value been assigned to the Version object?
            </summary>
            <returns>False if all parts have a 0 value, otherwise true</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.op_LessThan(MSInternal.Magellan.Version,MSInternal.Magellan.Version)">
            <summary>
            Version comparison operator
            </summary>
            <param name="left">Left-hand side version object</param>
            <param name="right">Right-hand side version object</param>
            <returns>True if the left-hand side version is smaller than the right-hand side version</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.op_GreaterThan(MSInternal.Magellan.Version,MSInternal.Magellan.Version)">
            <summary>
            Version comparison operator
            </summary>
            <param name="left">Left-hand side version object</param>
            <param name="right">Right-hand side version object</param>
            <returns>True if the left-hand side version is greater than the right-hand side version</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.Compare(MSInternal.Magellan.Version,MSInternal.Magellan.Version)">
            <summary>
            Compares two Version objects
            </summary>
            <param name="left">Left-hand side version object</param>
            <param name="right">Right-hand side version object</param>
            <returns>-1 if left is smaller, 1 if right is smaller, 0 if same</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.ToString">
            <summary>
            String representation of Version object
            </summary>
            <returns>String in format Major.Minor.BuildNumber.Revision.</returns>
        </member>
        <member name="P:MSInternal.Magellan.Version.Major">
            <summary>
            Returns the major database version (Major.#.#.#)
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Version.Minor">
            <summary>
            Returns the minor database version (#.Minor.#.#)
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Version.BuildNumber">
            <summary>
            Returns the build number portion of the database version (#.#.BuildNumber.#)
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Version.Revision">
            <summary>
            Returns the revision portion of the database version (#.#.#.Revision)
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\magellan\4.74sp2\x86\MagellanAPI.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MagellanAPI</name>
    </assembly>
    <members>
        <member name="T:MSInternal.Magellan.Build">
            <summary>
            Class to retrieve build information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Build.GetDataSet(System.String)">
            <summary>
            Returns a data set containing a list of distinct CustomVersion values
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Build.Query(MSInternal.Magellan.Database)">
            <summary>
            Returns an array of Build objects for the corresponding database
            </summary>
            <param name="database">Object representing open database connection</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.Build.CustomVersion">
            <summary>
            String used to associate a set of executables with a given build
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.ClassStruct">
            <summary>
            Class to retrieve class/struct information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.GetDataSet(System.String,System.Int32)">
            <summary>
            Returns a data set containing a list of classes
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.GetDataSet(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a data set containing a list of functions
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="idComponentInfo">Component to which functions correspond</param>
            <param name="idFunctionInfo">Optionally filter against specified function</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Component)">
            <summary>
            Returns an array of ClassStruct objects for the corresponding component
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myComponent">Component for which to return class objects</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.ClassStruct.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Function)">
            <summary>
            Returns an array of ClassStruct objects for the corresponding component
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myFunction">Function for which to return class objects</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.ClassName">
            <summary>
            Name of class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.NameSpace">
            <summary>
            NameSpace of class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountFunctions">
            <summary>
            The number of functions (methods) contained in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountBlocks">
            <summary>
            The sum of the block counts for all methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountArcs">
            <summary>
            The sum of the arc counts for all methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.ByteSize">
            <summary>
            The sum of the compiled byte sizes of the methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.Complexity">
            <summary>
            The sum of the complexity of the methods in this class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.AccessModifier">
            <summary>
            The access modifier of the class
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountInheritanceDepth">
            <summary>
            Inheritance depth is the maximum depth of inheritance for this
            class. This is calculated by computing the inheritance depth of
            each of the base classes and by taking the maximum inheritance
            depth.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountBaseClasses">
            <summary>
            The number of immediate base classes. Base classes through the
            inheritance hierarchy are not counted.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountSubClasses">
            <summary>
            The number of classes directly inheriting from a given parent class
            in a module. This doesn’t count classes with several inheritance.
            For example, class A is the base class of class B which is the base
            class for class C. Class/struct A will be flagged as containing one
            sub class and class B will be flagged as containing one sub class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountTotalMethods">
            <summary>
            Number of methods in this class. This includes public, private and
            protected methods.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPrivateMethods">
            <summary>
            Number of class methods denoted as being private.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountProtectedMethods">
            <summary>
            Number of class methods denoted as being protected.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPublicMethods">
            <summary>
            Number of class methods denoted as being public.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountCompilerGeneratedProcs">
            <summary>
            Number of compiler generated functions
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountTotalMemberVariables">
            <summary>
            Number of data fields present in the class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPrivateMemberVariables">
            <summary>
            Number of private data members in a given class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountProtectedMemberVariables">
            <summary>
            Number of protected data members in a given class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountPublicMemberVariables">
            <summary>
            Number of public data members in a given class.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountTotalCoupling">
            <summary>
            Coupling to other classes through (a) class member variables,
            (b) function parameters, (c) classes defined locally in class
            member method bodies, (d) immediate base classes, and (e) return
            type. A class that is not visible through the PDB because of
            compiler optimization is not counted. Also a class is not counted
            twice, so if a class is coupled as a member variable and then
            through the method parameter, it is counted only once.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountMemberVariableCoupling">
            <summary>
            Coupling to other classes through class member variables.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountMethodLocalCoupling">
            <summary>
            Coupling to other classes through local variables defined in the
            stack of functions.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountMethodParameterCoupling">
            <summary>
            Coupling to other classes through parameters that are passed into
            the method.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountReturnValueCoupling">
            <summary>
            Coupling to other classes through the return value. For example,
            ClassA can return ClassB and there can be implicit conversions.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.ClassStruct.CountBaseClassCoupling">
            <summary>
            Coupling through base classes. For example, ClassC may inherit from
            ClassA and ClassB. In this case the coupling number will be two.
            The sum of the above coupling numbers could be greater than the
            total. This is because a class is not counted twice for the overall
            number.
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.ClassStruct.ClassAccessModifier">
            <summary>
            The set of possible class access modifiers
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NotPublic">
            <summary>
            Class/struct does not have public type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.Public">
            <summary>
            Class/struct has public type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedPublic">
            <summary>
            Class/struct has nested public type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedPrivate">
            <summary>
            Class/struct has nested private type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedFamily">
            <summary>
            Class/struct has nested family (protected) type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedAssembly">
            <summary>
            Class/struct has nested assembly type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedFamilyAndAssembly">
            <summary>
            Class/struct has nested family (protected) and assembly type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.NestedFamilyOrAssembly">
            <summary>
            Class/struct has nested family (protected) or assembly type visibility
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.ClassStruct.ClassAccessModifier.Unknown">
            <summary>
            Class/struct has unknown type visibility
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Component">
            <summary>
            Class to retrieve component information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Component.GetDataSet(System.String)">
            <summary>
            Returns a data set containing a list of components
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Component.GetDataSet(System.String,System.String)">
            <summary>
            Returns a data set containing a list of components
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="customVersion">Optionally filter against specified Custom Version</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Component.Query(MSInternal.Magellan.Database)">
            <summary>
            Returns an array of Component objects for the corresponding database
            </summary>
            <param name="database">Object representing open database connection</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Component.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Build)">
            <summary>
            Returns an array of Component objects for the corresponding Build
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myBuild">Build to filter against</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.Component.NameDirectory">
            <summary>
            Drive and directory portion of component path specified during
            static data import
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.NameFile">
            <summary>
            File name and extension portion of component path specified during
            static data import
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.GuidComponent">
            <summary>
            GUID (globally unique identifier) calculated against all of the
            bytes of the executable using the MD5 encryption algorithm
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.FileVersion">
            <summary>
            File version number extracted from the version resource of the
            executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ProductVersion">
            <summary>
            Product version number extracted from the version resource of the
            executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CustomVersion">
            <summary>
            String used to associate a set of executables with a given build
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.IdCoverageType">
            <summary>
            Type of coverage collected for this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountFiles">
            <summary>
            Number of source files contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountClasses">
            <summary>
            Number of classes contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountFunctions">
            <summary>
            Number of functions contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountBlocks">
            <summary>
            Number of procedure blocks contained in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountArcs">
            <summary>
            Number of arcs in this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.FileSize">
            <summary>
            The size, in bytes, of the executable file on disk
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ByteSize">
            <summary>
            The size, in bytes, of this component
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ImageSize">
            <summary>
            The size, in bytes, of the component in memory
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ImageDateTimestamp">
            <summary>
            Time stamp of the image. This represents the date and time the
            image was created by the linker. The value is represented in the
            number of seconds elapsed since midnight (00:00:00), January 1,
            1970, Universal Coordinated Time, according to the system clock.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.ComplexityCyclomatic">
            <summary>
            The sum of the cyclomatic complexity of all functions within this
            component. The cyclomatic complexity of a function is calculated by
            looking at the conditionals and counting the blocks with more than
            one edge.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.TimeImported">
            <summary>
            The date and time that the static data for this component was
            imported into the coverage database
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.TimeModified">
            <summary>
            The date and time that the executable image was writen
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.Checksum">
            <summary>
            Image file checksum found in the optional PE header
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.PlatformType">
            <summary>
            Platform type of executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountCyclicClassCoupling">
            <summary>
            Measures "a depends on b" and "b depends on a"
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountGlobalVariables">
            <summary>
            Total number of global variables present in the executable
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxBlocks">
            <summary>
            Maximum number of blocks found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxArcs">
            <summary>
            Maximum number of arcs found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxComplexity">
            <summary>
            Maximum complexity found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPaths">
            <summary>
            Maximum number of paths found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPaths">
            <summary>
            Total number of paths found in all functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxComplexityMcCabe">
            <summary>
            Maximum McCabe cyclomatic complexity found in a function in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountComplexityMcCabe">
            <summary>
            Total McCabe cyclomatic complexity found in all the functions in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxParameters">
            <summary>
            Maximum number of parameters in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountParameters">
            <summary>
            Total number of parameters found in all the functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxIncomingCalls">
            <summary>
            Total number of other functions calling the given function in a
            given module. The maximum for a given function in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountIncomingCalls">
            <summary>
            Accumulated tally of incoming calls for all functions in the given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxOutgoingCalls">
            <summary>
            The other functions that are being called from a given function in
            the given module. This counter gives the maximum such calls being
            made from a given function.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountOutgoingCalls">
            <summary>
            Total number of other functions being called from the given
            function in a given module. The maximum for a given function in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxSourceLines">
            <summary>
            Maximum number of lines found in a function in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountSourceLines">
            <summary>
            Total number of lines found in all functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxLocals">
            <summary>
            Maximum number of local variables found in a function in the given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountLocals">
            <summary>
            Total number of locals found in all the functions in the given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxReadCoupling">
            <summary>
            Maximum coupling of global variables through read in a function in
            the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountReadCoupling">
            <summary>
            Total coupling of global variables through read using all the
            functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxWriteCoupling">
            <summary>
            Maximum coupling of global variables through write in a function in
            a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountWriteCoupling">
            <summary>
            Total coupling of global variables through write through all
            functions in the given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxAddressCoupling">
            <summary>
            Total coupling where address of  a global variable is taken in a
            function in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountAddressCoupling">
            <summary>
            Total coupling of global variables for all functions in a given
            module where address of a global variable is taken.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxProcCoupling">
            <summary>
            Coupling between procedures through global variables. Shows the
            function that has the maximum coupling to other functions in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountProcCoupling">
            <summary>
            Coupling between procedures counted as aggregated for all the
            functions in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxInheritanceDepth">
            <summary>
            Maximum inheritance depth when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountInheritanceDepth">
            <summary>
            Total inheritance depth when combining all the classes in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxBaseClasses">
            <summary>
            Maximum number of base classes when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountBaseClasses">
            <summary>
            Total number of base classes when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxSubClasses">
            <summary>
            Maximum number of sub classes given a class when looking at all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountSubClasses">
            <summary>
            Total number of sub classes when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxTotalMethods">
            <summary>
            Total number of methods in a given class compared to all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountTotalMethods">
            <summary>
            Total number of class methods when aggregated over all the classes
            in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPrivateMethods">
            <summary>
            Maximum number of private methods when looking at all the classes
            in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPrivateMethods">
            <summary>
            Total number of private methods when looking at all the classes in
            a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxProtectedMethods">
            <summary>
            Maximum number of protected methods when looking at all the classes
            in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountProtectedMethods">
            <summary>
            Total number of protected methods when aggregated for all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPublicMethods">
            <summary>
            Maximum number of public methods in a given class when looking at
            all the classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPublicMethods">
            <summary>
            Total number of public methods when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxCompilerGeneratedProcs">
            <summary>
            Maximum number of compiler generated methods when looking at all
            the classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountCompilerGeneratedProcs">
            <summary>
            Total number of compiler generated methods when looking at all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxTotalMemberVariables">
            <summary>
            Maximum number of data members for a given class in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountTotalMemberVariables">
            <summary>
            Total number of class data members when aggregated across an entire
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPrivateMemberVariables">
            <summary>
            Maximum number of private data members for a given class in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPrivateMemberVariables">
            <summary>
            Total number of private data members for all the classes in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxProtectedMemberVariables">
            <summary>
            Maximum number of protected data members for a given class in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountProtectedMemberVariables">
            <summary>
            Total number of protected data members for all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxPublicMemberVariables">
            <summary>
            Maximum number of public data members for a given class in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountPublicMemberVariables">
            <summary>
            Total number of public data members for all the classes in a given
            module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxTotalCoupling">
            <summary>
            Maximum class coupling for a given class when looking at all the
            classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountTotalCoupling">
            <summary>
            Total number for coupling when looking at all the classes in a
            given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxMemberVariableCoupling">
            <summary>
            Maximum coupling to other classes through class data fields.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountMemberVariableCoupling">
            <summary>
            Sum of all data field coupling found in all classes in the module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxMethodLocalCoupling">
            <summary>
            Maximum coupling to other classes through local variables defined
            in the function stack found in all classes in a given module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountMethodLocalCoupling">
            <summary>
            Total function local coupling for all classes in the module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxMethodParameterCoupling">
            <summary>
            Maximum coupling to other classes through parameters that are
            passed into the function.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountMethodParameterCoupling">
            <summary>
            Sum of the coupling to other classes through parameters that are
            passed into the function.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxReturnValueCoupling">
            <summary>
            Coupling to other classes through return value. For example, ClassA
            can return ClassB and there can be implicit conversions.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountReturnValueCoupling">
            <summary>
            Total coupling to all the other classes through return value found
            for all the classes in the module.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.MaxBaseClassCoupling">
            <summary>
            Coupling through base classes. For example, ClassC may inherit from
            ClassA and ClassB. In this case the coupling number will be two.
            The maximum value of such coupling is returned through this metric.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Component.CountBaseClassCoupling">
            <summary>
            Total coupling through bases classes when aggregated for all the
            classes in the module.
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Component.CoverageType">
            <summary>
            The set of possible coverage types
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.CoverageType.Block">
            <summary>
            Block coverage is collected. A block, also known as a basic
            block, is the set of contiguous code instructions in the
            physical layout of a binary that has exactly one entry point
            and one exit point. Calls, jumps, and branches mark the end of
            a block. A block typically consists of multiple machine-code
            instructions.
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.CoverageType.Arc">
            <summary>
            Arc coverage is collected. The arcs of a basic block specify
            the basic blocks that call the entry point of the block, and
            the basic blocks that are called by the exit point of the
            block. Thus, the arcs of a block are all possible execution
            paths through the block.
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Component.ComponentPlatformType">
            <summary>
            The set of possible platform types
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.NotUsed">
            <summary>
            Undefined type
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Native_i386">
            <summary>
            Native executable for i386 platform
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Native_64">
            <summary>
            Native executable for 64-bit platform
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Managed">
            <summary>
            Managed executable
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.PreJIT_Everett">
            <summary>
            
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.PreJIT_Whidbey">
            <summary>
            
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.MixedMode">
            <summary>
            Mixed mode executable for i386 platform
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Component.ComponentPlatformType.Native_AMD64">
            <summary>
            Native executable for AMD64 platform
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Database">
            <summary>
            Class to maintain a database connection
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Database.GetDataSet(System.String,System.String,System.String)">
            <summary>
            Returns a data set fulfilling the specified query
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Database.Dispose">
            <summary>
            Releases all resources used by the Database object
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Database.#ctor(System.String)">
            <summary>
            Database object constructor opens a connection to the database
            specified by the connection string
            </summary>
            <param name="connectionString">Connection string used to connect to SQL server</param>
        </member>
        <member name="P:MSInternal.Magellan.Database.Timeout">
            <summary>
            The time (in seconds) to wait for the command to execute
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Database.ConnectionString">
            <summary>
            Connection string used to connect to the database
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Database.Connection">
            <summary>
            Connection object that maintains the connection string keys and values
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Database.Name">
            <summary>
            Returns the database name
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Function">
            <summary>
            Class to retrieve function information
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Function.GetDataSet(System.String,System.Int32)">
            <summary>
            Returns a data set containing a list of functions
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="idComponentInfo">Component to which functions correspond</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Function.GetDataSet(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a data set containing a list of functions
            </summary>
            <param name="connectionString">String used to connect to the database</param>
            <param name="idComponentInfo">Component to which functions correspond</param>
            <param name="idClassInfo">Optionally filter against specified class</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Function.Query(MSInternal.Magellan.Database,MSInternal.Magellan.Component)">
            <summary>
            Returns an array of Function objects for the corresponding component
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myComponent">Component for which to return function objects</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Function.Query(MSInternal.Magellan.Database,MSInternal.Magellan.ClassStruct)">
            <summary>
            Returns an array of Function objects for the corresponding Class
            </summary>
            <param name="database">Object representing open database connection</param>
            <param name="myClassStruct">Class/struct for which to return function objects</param>
            <returns></returns>
        </member>
        <member name="P:MSInternal.Magellan.Function.FunctionName">
            <summary>
            Name of function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CallingConvention">
            <summary>
            Function calling convention
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.ReturnDataType">
            <summary>
            Function return value data type
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountBlocks">
            <summary>
            Count of blocks in function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountArcs">
            <summary>
            Count of arcs in function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.ByteSize">
            <summary>
            The compiled byte size of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.Complexity">
            <summary>
            The cyclomatic complexity of the function is calculated by looking
            at the conditionals and counting the blocks with more than one edge
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.Address">
            <summary>
            The address of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.LineNumberStart">
            <summary>
            The line number in the source file at which the function begins
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.LineNumberEnd">
            <summary>
            The line number in the source file at which the function ends
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.DecoratedName">
            <summary>
            The decorated name of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.AccessModifier">
            <summary>
            The access modifier of the function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountPaths">
            <summary>
            The count of paths as defined in "Efficient Path Profiling" by
            T. Ball and J. Larus - MICRO 1996, section 3.1
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.ComplexityMcCabe">
            <summary>
            The McCabe cyclomatic complexity is defined as e-n+2p, where
            e is the number of edges, n is the number of nodes, and p is the
            number of unconnected parts of the graph
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountParameters">
            <summary>
            The number of parameters the function accepts
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountIncomingCalls">
            <summary>
            The number of other functions calling this function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountOutgoingCalls">
            <summary>
            The number of other functions being called by this function
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountSourceLines">
            <summary>
            The number of source lines contributing to the definition of this
            function. Multiple source files can contribute to a single
            function. Source lines that don't produce code, such as comments,
            will not be included in this count.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountLocals">
            <summary>
            Number of local variables. This is determined by binary analysis,
            so compiler optimizations might report a different number of local
            variables than defined in source code.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountReadCoupling">
            <summary>
            Number of global variables read by a function and thus coupled to
            the global variable through the read operation.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountWriteCoupling">
            <summary>
            Number of global variables written by a function and thus coupled
            to the global variable through the write operation.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountAddressCoupling">
            <summary>
            Number of global variables whose address is taken by a function.
            The function is coupled to the global variable as it takes the
            address of the variable.
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Function.CountProcCoupling">
            <summary>
            Calculated using global variables. If a global variable is set in
            FunctionA() and is modified in FunctionB() and FunctionC(), a
            coupling value of two is shown for FunctionA().
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Function.FunctionAccessModifier">
            <summary>
            The set of possible function access modifiers
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.PrivateScope">
            <summary>
            Function has private scope protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Private">
            <summary>
            Function has private protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.FamilyAndAssembly">
            <summary>
            Function has family (protected) and assembly protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Assembly">
            <summary>
            Function has assembly protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Family">
            <summary>
            Function has family (protected) protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.FamilyOrAssembly">
            <summary>
            Function has family (protected) or assembly protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Public">
            <summary>
            Function has public protection
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Function.FunctionAccessModifier.Unknown">
            <summary>
            Function has unknown protection
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Sage">
            <summary>
            The Sage class provides a unified messaging system
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Sage.Severity">
            <summary>
            Enumeration representing message severity
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Success">
            <summary>
            Success messages are informative and displayed when current
            operation is successfully proceeding
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Warning">
            <summary>
            Warnings are displayed when current operation can continue but
            should be corrected
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Error">
            <summary>
            Errors are displayed when the current operation cannot continue
            </summary>
        </member>
        <member name="F:MSInternal.Magellan.Sage.Severity.Fatal">
            <summary>
            Fatal errors are displayed when program execution cannot continue
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Sage.SageException">
            <summary>
            Class to encapsulate Sage message and throw object as exception
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Severity">
            <summary>
            The severity of the message: Success, Warning, Error, Fatal
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Code">
            <summary>
            Four digit code associated with the message
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Text">
            <summary>
            Text of the message with place holders filled in
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Description">
            <summary>
            Additional description text associated with the message
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.Actions">
            <summary>
            Suggested actions to take to resolve issue
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Sage.SageException.FormattedMessage">
            <summary>
            Fully formatted message containing severity, prefix, code, and text
            </summary>
        </member>
        <member name="T:MSInternal.Magellan.Version">
            <summary>
            Class to retrieve the Magellan coverage database version
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Version.GetDataSet(System.String)">
            <summary>
            Returns a data set containing the Magellan coverage database version
            </summary>
        </member>
        <member name="M:MSInternal.Magellan.Version.Query(MSInternal.Magellan.Database)">
            <summary>
            Constructs a Version object containing the Magellan coverage
            database version.
            </summary>
            <param name="database">Object representing open database connection</param>
            <returns></returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Version class constructor of format (Major.Minor.BuildNumber.Revision)
            </summary>
            <param name="major">Major version number</param>
            <param name="minor">Minor version number</param>
            <param name="buildNumber">Version build number</param>
            <param name="revision">Version revision</param>
        </member>
        <member name="M:MSInternal.Magellan.Version.HasValue">
            <summary>
            Has a value been assigned to the Version object?
            </summary>
            <returns>False if all parts have a 0 value, otherwise true</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.op_LessThan(MSInternal.Magellan.Version,MSInternal.Magellan.Version)">
            <summary>
            Version comparison operator
            </summary>
            <param name="left">Left-hand side version object</param>
            <param name="right">Right-hand side version object</param>
            <returns>True if the left-hand side version is smaller than the right-hand side version</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.op_GreaterThan(MSInternal.Magellan.Version,MSInternal.Magellan.Version)">
            <summary>
            Version comparison operator
            </summary>
            <param name="left">Left-hand side version object</param>
            <param name="right">Right-hand side version object</param>
            <returns>True if the left-hand side version is greater than the right-hand side version</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.Compare(MSInternal.Magellan.Version,MSInternal.Magellan.Version)">
            <summary>
            Compares two Version objects
            </summary>
            <param name="left">Left-hand side version object</param>
            <param name="right">Right-hand side version object</param>
            <returns>-1 if left is smaller, 1 if right is smaller, 0 if same</returns>
        </member>
        <member name="M:MSInternal.Magellan.Version.ToString">
            <summary>
            String representation of Version object
            </summary>
            <returns>String in format Major.Minor.BuildNumber.Revision.</returns>
        </member>
        <member name="P:MSInternal.Magellan.Version.Major">
            <summary>
            Returns the major database version (Major.#.#.#)
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Version.Minor">
            <summary>
            Returns the minor database version (#.Minor.#.#)
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Version.BuildNumber">
            <summary>
            Returns the build number portion of the database version (#.#.BuildNumber.#)
            </summary>
        </member>
        <member name="P:MSInternal.Magellan.Version.Revision">
            <summary>
            Returns the revision portion of the database version (#.#.#.Revision)
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\magellan\4.74sp2\x86\MagellanSdk.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MagellanSdk</name>
    </assembly>
    <members>
        <member name="T:MS.Magellan.Reporting.Arc">
            <summary>
            When the execution flow jumps from a block to another, we call that pair of blocks an arc.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Arc.GetTraces">
            <summary>
            Returns a collection of traces which hit this arc.
            Affected by traces.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.Index">
            <summary>
            The index of the arc in the arc vector of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.IsCovered">
            <summary>
            True = covered by tests. False = not covered by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.FromBlock">
            <summary>
            The source block of the arc.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Arc.ToBlock">
            <summary>
            The destination block of the arc.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BinaryFile">
            <summary>
            A binary is a portable executable which can be instrumented by Magellan for code coverage.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.CoverageObject">
            <summary>
            Object that has coverage properties like BlockCount, HitBlockCount etc.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.NamedObject">
            <summary>
            Object that has a property called Name.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.NamedObject.Name">
            <summary>
            Name.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.BlockCount">
            <summary>
            Number of blocks in this object. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.HitBlockCount">
            <summary>
            Number of blocks in this object which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.MissedBlockCount">
            <summary>
            Number of blocks in this object which were missed by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.ArcCount">
            <summary>
            Number of arcs in this object. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.HitArcCount">
            <summary>
            Number of arcs in this object which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.MissedArcCount">
            <summary>
            Number of arcs in this object which were missed by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CoverageObject.Id">
            <summary>
            Unique id that distinguishes this object from others of the same type.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetClasses">
            <summary>
            Returns a collection of all the classes in this binary, excluding the classes from static libraries.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetFunctions">
            <summary>
            Returns a collection of all the functions in this binary, including functions from static libraries.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetSourceFiles">
            <summary>
            Returns a collection of all the source files in this binary, excluding the files from static libraries.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetStaticLibraries">
            <summary>
            Returns a collection of all the static libraries in this binary.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.BinaryFile.GetTraces">
            <summary>
            Returns a collection of all the traces for this binary accross all data sources.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Directory">
            <summary>
            Directory of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.UniqueId">
            <summary>
            Unique identifier used to differentiate binaries with the same name.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Checksum">
            <summary>
            
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.FileVersion">
            <summary>
            File version extracted from the original uninstrumented binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.ProductVersion">
            <summary>
            Product version extracted from the original uninstrumented binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.ImageDateTimestamp">
            <summary>
            The creation date of the original uninstrumented binary by the linker.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.TargetPlatform">
            <summary>
            The target platform of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.CoverageType">
            <summary>
            The coverage granularity level at which the binary was instrumented.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.MagellanVersion">
            <summary>
            The version of the Magellan toolset that was used to extract coverage symbols from this binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Build">
            <summary>
            The build to which this binary belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.MergedTrace">
            <summary>
            Trace obtained from merging all the traces from all the datasources for this binary.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.BinaryFile.Id">
            <summary>
            Returns an object that uniquely identifies this binary.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageType">
            <summary>
            The coverage granularity level at which the binary was instrumented.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.CoverageType.None">
            <summary>
            Undefined 
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.CoverageType.BlocksOnly">
            <summary>
            This option means that only blocks are available in the coverage data.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.CoverageType.BlocksAndArcs">
            <summary>
            This option means that both blocks and arcs are available in the coverage data.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BinaryTargetPlatform">
            <summary>
            Specifies what platform the binary was built for.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.None">
            <summary>
            Undefined 
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.NativeI386">
            <summary>
            Native executable for i386 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.Native64">
            <summary>
            Native executable for 64-bit platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.Managed">
            <summary>
            Managed executable
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.PreJitEverett">
            <summary>
            
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.PreJitWhidbey">
            <summary>
            
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.MixedMode">
            <summary>
            Mixed mode executable for i386 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.NativeAmd64">
            <summary>
            Native executable for AMD64 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.Managed64">
            <summary>
            Managed executable for AMD64 platform
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.BinaryTargetPlatform.MixedMode64">
            <summary>
            Mixed mode executable for AMD64 platform
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Block">
            <summary>
            A block, also known as a basic block, is the set of contiguous code instructions in the
            physical layout of a binary that has exactly one entry point and one exit point. 
            Calls, jumps, and branches mark the end of a block. A block typically consists 
            of multiple machine-code instructions.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Block.GetTraces">
            <summary>
            Returns a collection of traces which hit this block.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.Address">
            <summary>
            The address of the block inside the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.Index">
            <summary>
            The index of the block in the block vector of the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.IsCovered">
            <summary>
            True = covered by tests. False = not covered by tests.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.AssemblyCodeLines">
            <summary>
            Assembly code of this block.
            </summary>
            <exception cref="T:System.IO.InvalidDataException">Thrown when the covsym file does not contain assembly code information or is corrupt.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.StartSourceLineNumber">
            <summary>
            Line number in the source file where this block starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.EndSourceLineNumber">
            <summary>
             Line number in the source file where this block ends.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Block.Binary">
            <summary>
            The binary to which this block belongs to.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Build">
            <summary>
            A build represents a collection of binaries which have the same custom version.
            Different versions of the same binary should be instrumented with a different
            custom version so that they can be distinguised when viewing coverage data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Build.GetBinaries">
            <summary>
            Returns a collection of binaries from this build. 
            Filters affect the results returned by this method.
            </summary>
            <returns>Collection of binaries.</returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Build.GetMergedStaticLibraries">
            <summary>
            Merges the coverage of static libraries accross all the binaries in this build. 
            For example if two binaries bin1.exe and bin2.exe link to the same static library 
            bin3.lib, the coverage of bin3.lib from bin1.exe is merged with the coverage 
            of bin3.lib from bin2.exe and returned in this collection. Static libraries are
            uniquely identified by full path, not just file name.
            </summary>
            <returns>Collection of merged static libraries accross all binaries.</returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Build.GetMergedSourceFiles">
            <summary>
            Merges the coverage of source files accross all the binaries in this build. 
            For example if two binaries bin1.exe and bin2.exe compile the same source file
            file.cpp, the coverage of file.cpp from bin1.exe is merged with the coverage 
            of file.cpp from bin2.exe and returned in this collection. Source files are
            uniquely identified by full path, not just file name.
            </summary>
            <returns>Collection of merged soure files across all binaries.</returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Build.Name">
            <summary>
            Custom version specified at instrumentation time and which is used to group
            binaries into builds.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Build.CustomVersion">
            <summary>
            Custom version specified at instrumentation time and which is used to group
            binaries into builds.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Build.Project">
            <summary>
            The project to which this build belongs to.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Class">
            <summary>
            Represents the object oriented concept of class which contains metods and data members.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Class.GetFunctions">
            <summary>
            Returns a collection of all the functions in this class.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Class.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this class 
            accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.Namespace">
            <summary>
            Namespace of the class.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.AccessModifier">
            <summary>
            Access modifier. E.g. public.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.Binary">
            <summary>
            The binary this class belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.StaticLibrary">
            <summary>
            The static library this class belongs to. Can be null.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Class.Id">
            <summary>
            Returns an object that uniquely identifies this class.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.ClassAccessModifier">
            <summary>
            Access modifiers for a class.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NotPublic">
            <summary>
            Class/struct does not have public type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.Public">
            <summary>
            Class/struct has public type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedPublic">
            <summary>
            Class/struct has nested public type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedPrivate">
            <summary>
            Class/struct has nested private type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedFamily">
            <summary>
            Class/struct has nested family (protected) type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedAssembly">
            <summary>
            Class/struct has nested assembly type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedFamilyAndAssembly">
            <summary>
            Class/struct has nested family (protected) and assembly type visibility.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.ClassAccessModifier.NestedFamilyOrAssembly">
            <summary>
            Class/struct has nested family (protected) or assembly type visibility
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BuildCollection">
            <summary>
            Collection of Build objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BinaryFileCollection">
            <summary>
            Collection of BinaryFile objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.StaticLibraryCollection">
            <summary>
            Collection of StaticLibrary objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.ClassCollection">
            <summary>
            Collection of Class objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceFileCollection">
            <summary>
            Collection of SourceFile objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionCollection">
            <summary>
            Collection of Function objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.TraceCollection">
            <summary>
            Collection of Trace objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionParameterCollection">
            <summary>
            Collection of FunctionParameter objects. The collection is not sorted in any particular order.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLineCollection">
            <summary>
            Collection of SourceLine objects. The collection is sorted ascending by the field SourceLine.Number.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.BlockCollection">
            <summary>
            Collection of Block objects. The collection is sorted ascending by the field Block.Index.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.ArcCollection">
            <summary>
            Collection of Arc objects. The collection is sorted ascending by the field Arc.Index.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageSymbolSourceCollection">
            <summary>
            Collection of data sources. Adding or removing data sources to this collection
            clears the Project hierarchy of all data, so accessing existing objects in the
            hierarchy has undefined behavior. After removing or adding data sources
            the method Project.GetBuilds needs to be called again to refresh the data.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.EventCollection`1">
            <summary>
            A collection that raises events when is changed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.RemoveItem(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.ClearItems">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.EventCollection`1.SetItem(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolSourceCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of these data sources.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolSourceCollection.LoadFrom(System.String)">
            <summary>
            Loads datasources from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataSourceCollection">
            <summary>
            Collection of data sources. Adding or removing data sources to this collection
            clears the Project hierarchy of all data, so accessing existing objects in the
            hierarchy has undefined behavior. After removing or adding data sources
            the method Project.GetBuilds needs to be called again to refresh the data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataSourceCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of these data sources.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataSourceCollection.LoadFrom(System.String)">
            <summary>
            Loads datasources from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="T:MS.Magellan.Reporting.StringPatternCollection">
            <summary>
            Collection of string patterns to match symbols against, when using a Filter.
            A string pattern can contain the character * as wildcard.
            The * character cannot be escaped.
            Samples: *.dll, foo.*, ATL::*, *.*, *\dir\dir\foo.*
            If multiple string patterns are added they are applied like in an OR clause.
            For example if the two patterns are added "foo*" and "boo*" it means 
            all strings that start with foo OR boo will be matched.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterCollection">
            <summary>
            Collection used to build complex filters that need to be applied at the same time.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of these filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterCollection.LoadFrom(System.String)">
            <summary>
            Loads filters from an xml representation.
            </summary>
            <param name="xml"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.PathMappingCollection">
            <summary>
            Collection of PathMapping objects.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMappingCollection.ToXml">
            <summary>
            Returns a string containing the xml representaion of the path mappings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMappingCollection.LoadFrom(System.String)">
            <summary>
            Loads path mappings from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageTrace">
            <summary>
            When users save their coverage they can choose a trace name to be associated with it. This 
            helps identifying what test or set of tests generated that particular coverage. So in a sense
            a trace is similar with a test but the user controls its granularity. It can range from a 
            small part of a test to multiple tests. It all depends on how often the coverage is saved.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageTrace.GetHitFunctions">
            <summary>
            Returns a collection of functions which are hit by this trace.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageTrace.RuntimeTimeSpan">
            <summary>
            The runtime execution time of this trace.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageTrace.BlockVector">
            <summary>
            Contains the bit vector associated with blocks.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageTrace.ArcVector">
            <summary>
            Contains the bit vector associated with arcs.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageVector">
            <summary>
            Encodes coverage in the form of a bit vector.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageVector.Bits">
            <summary>
            Array of bits.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageSymbolSource">
            <summary>
            Abstract class for the concept of coverage symbol source. One example is covsym file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolSource.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Source of coverage symbols. Can have different meaning in derived classes.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageSymbolSource.Source">
            <summary>
            Source of coverage symbols. Can have different meaning in derived classes.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageSymbolPath">
            <summary>
            A relative or full path towards a location with covsym files. 
            The filename can contain wildcards which are accepted by the file system when searching files.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageSymbolPath.#ctor(System.String,System.IO.SearchOption)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Path to covsym files.</param>
            <param name="searchOption">Search in top directory or all subdirectories.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageSymbolPath.SearchOption">
            <summary>
            Search in top directory or all subdirectories.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataSource">
            <summary>
            Abstract class for the concept of coverage data source. One example is covdata file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataSource.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Source of coverage data. Can have different meaning in derived classes.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageDataSource.Source">
            <summary>
            Source of coverage data. Can have different meaning in derived classes.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataPath">
            <summary>
            A relative or full path towards a location with covdata files. 
            The filename can contain wildcards which are accepted by the file system when searching files.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataPath.#ctor(System.String,System.IO.SearchOption)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Path to covdata files.</param>
            <param name="searchOption">Search in top directory or all subdirectories.</param>
        </member>
        <member name="P:MS.Magellan.Reporting.CoverageDataPath.SearchOption">
            <summary>
            Search in top directory or all subdirectories.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.CoverageDataService">
            <summary>
            Encapsulates the concept of a machine where the coverage service is running and collecting coverage data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.CoverageDataService.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="source">Machine name, or "localhost" or IP of a machine.</param>
        </member>
        <member name="T:MS.Magellan.Reporting.TraceSource">
            <summary>
            A coverage data file (.covdata) contains coverage information for
            a binary and is created at runtime when the instrumented binary
            is executed.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.TraceSource.#ctor(MS.Magellan.Reporting.Project)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.CovsymSource">
            <summary>
            A coverage symbol file (.covsym) contains information that describes
            the content of a binary. For example: classes, files, functions, etc.
            Covsym files are usually created at instrumentation time from the 
            uninstrumented binary and pdb files.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.CovsymSource.#ctor(MS.Magellan.Reporting.Project)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CovsymSource.CoverageSymbolPaths">
            <summary>
            Collection of coverage symbol paths. Allows both read and write operations.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.CovdataSource">
            <summary>
            A coverage data file (.covdata) contains coverage information for
            a binary and is created at runtime when the instrumented binary
            is executed.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.CovdataSource.#ctor(MS.Magellan.Reporting.Project)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.CovdataSource.CoverageDataPaths">
            <summary>
            Collection of coverage data paths. Allows both read and write operations.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.LiveTraceSource.CoverageDataServices">
            <summary>
            Collection of services that can generate traces.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Filter">
            <summary>
            Abstract class from which all filters derive.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Filter.ToXml">
            <summary>
            Returns a string containing the xml representaion of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Filter.LoadFrom(System.String)">
            <summary>
            Loads a filter from an xml representation.
            </summary>
            <param name="xml"></param>
        </member>
        <member name="P:MS.Magellan.Reporting.Filter.Targets">
            <summary>
            A filter can be applied on the entire project, on specific builds or on specific binaries.
            Targets can be used to specify what objects to apply the filter on.
            It can only contain FilterBuild and FilterBinary filters.
            </summary>
            <remarks>
            If Targets is empty the filter applies to the entire Project.
            If Targets contains a FilterBuild it means the filter will apply only to builds
            which match that build filter.
            If Targets contains a FilterBinary it means the filter will apply only to binaries
            which match that binary filter.
            If Targets contains both FilterBuild and FilterBinary it means the filter will apply
            only to builds and binaries which match those filters.
            </remarks>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterSymbol">
            <summary>
            Abstract class that represents a symbol filter. Examples of symbols are binary, function, class.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.#ctor">
            <summary>
            Creates an empty filter. Use the filter properties to specify more data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a symbol filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.ToXml">
            <summary>
            Returns a string containing the xml representaion of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSymbol.LoadFrom(System.String)">
            <summary>
            Loads a filter from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSymbol.StringPatterns">
            <summary>
            Collection of string patterns to match symbols against.
            A string pattern can contain the character * as wildcard.
            The * character cannot be escaped.
            Samples: *.dll, foo.*, ATL::*, *.*, *\dir\dir\foo.*
            If multiple string patterns are added they are applied like in an OR clause.
            For example if the two patterns are added "foo*" and "boo*" it means 
            all strings that start with foo OR boo will be matched.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSymbol.StringPatternOperator">
            <summary>
            Operator that specifies how the filter is applied: inclusive or exclusive.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterBuild">
            <summary>
            Filter that matches builds by CustomVersion.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBuild.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBuild.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a build filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterBinary">
            <summary>
            Filter that matches binaries by Directory and Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBinary.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterBinary.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a binary filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterClass">
            <summary>
            Filter that matches classes by Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterClass.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterClass.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a class filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterSourceFile">
            <summary>
            Filter that matches source files by Directory and Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceFile.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceFile.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a source file filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterFunction">
            <summary>
            Filter that matches functions by Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterFunction.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterFunction.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a function filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterStaticLibrary">
            <summary>
            Filter that matches static libraries by Directory and Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterStaticLibrary.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterStaticLibrary.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a static library filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterTrace">
            <summary>
            Filter that matches traces by Name.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterTrace.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterTrace.#ctor(MS.Magellan.Reporting.StringPatternOperator)">
            <summary>
            Creates a trace filter with the given filter operator.
            </summary>
            <param name="stringPatternOperator"></param>
        </member>
        <member name="T:MS.Magellan.Reporting.StringPatternOperator">
            <summary>
            Filter operator to use when matching symbols.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.StringPatternOperator.Like">
            <summary>
            The filter includes all symbols that match any of the 
            regular expressions added to the filter.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.StringPatternOperator.Unlike">
            <summary>
            The filter excludes all symbols that match any of the
            regular expressions added to the filter.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLineRange">
            <summary>
            Represnts a range of source lines.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceLineRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a line range with the give start and end lines.
            </summary>
            <param name="startLine"></param>
            <param name="endLine"></param>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLineRange.StartLine">
            <summary>
            The start line of the range.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLineRange.EndLine">
            <summary>
            The end line of the range.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FilterSourceLines">
            <summary>
            This type of filter can be used to filter specific lines of code from source files.
            It provides various ways to specify what to filter, like bbpacks, diff files resulting from 
            the source depot command "sd diff -dn".
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.AddSourceLines(System.String,System.Int32,System.Int32)">
            <summary>
            Add a file path and a range of lines from that file which will be included 
            when calculating blocks. The file path can be incomplete, it doens't have to be a
            fully qualified path. Examples: "foo.cpp, "c:\folder\foo.cpp", "folder\foo.cpp".
            When more than the file name is specified, the directory in front of the filename
            must match the directory of the file from the pdb. So if a source file was compiled
            at location c:\sourcedepot\folder\foo.cpp, this is what needs to be passed to the
            filter in order to uniquely identify the file foo.cpp. Even if this path no longer
            exists on the machine, this is just a way to uniquely identify files. If the full
            path used at compile time is forgotten, you can enumerate all the files in the 
            BinaryFile class and get a look at the Directory and Name properties.
            </summary>
            <param name="filePath">The file path to use when filtering data.</param>
            <param name="startLine">Start line from where to display code.</param>
            <param name="endLine">End line up to where to display code.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when filePath is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when endLine is less than startLine.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.AddBbpack(System.String)">
            <summary>
            Adds a bbpack ".cmd" file that contains the files and line ranges to display.
            </summary>
            <param name="bbpackPath">The bbpack file to use to filter data.</param>
            <exception cref="T:System.ArgumentException">Thrown when bbpackPath is an empty string ("").</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when bbpackPath is null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when bbpackPath cannot be found.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when bbpackPath has an invalid path.</exception>
            <exception cref="T:System.IO.IOException">Thrown when bbpackPath has an incorrect or invalid syntax.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when the content of the bbpack file is invalid or corrupt.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.AddDiff(System.String)">
            <summary>
            Add a diff file generated by the source depot command "sd diff -dn".
            The SDDIFF, SDUDIFF and SDPDIFF environment variables need to be unset
            in order to get the output of "sd diff -dn" to console so it can be redirected to a file.
            The data will be filtered based on the content of the diff file.
            </summary>
            <param name="diffPath">The diff file to use to filter data.</param>
            <exception cref="T:System.ArgumentException">Thrown when diffPath is an empty string ("").</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when diffPath is null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when diffPath cannot be found.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when diffPath has an invalid path.</exception>
            <exception cref="T:System.IO.IOException">Thrown when diffPath has an incorrect or invalid syntax.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when the content of the diff file is invalid or corrupt.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.ToXml">
            <summary>
            Returns a string containing the xml representaion of this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.FilterSourceLines.LoadFrom(System.String)">
            <summary>
            Loads a filter from an xml representation.
            </summary>
            <param name="xml"></param>
            <exception cref="T:System.Xml.XmlException">Thrown when then xml is not of legal form.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSourceLines.SourceFileLines">
            <summary>
            Dictionary with file paths and line ranges which will be used to filter code.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSourceLines.BbpackPaths">
            <summary>
            The names of the the bbpack ".cmd" files used to filter code.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FilterSourceLines.DiffPaths">
            <summary>
            The names of the files created with a source depot "sd diff" command, used to filter code.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Function">
            <summary>
            Generic term for all posible types of functions in a binary. 
            E.g. C runtime functions, class methods, compiler generated functions.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetParameters">
            <summary>
            Returns a collection of all the parameters of this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetSourceLines">
            <summary>
            Returns a collection of all the source lines in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetBlocks">
            <summary>
            Returns a collection of all the blocks in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetArcs">
            <summary>
            Returns a collection of all the arcs in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.Function.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block from this function.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Name">
            <summary>
            Name of this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.DecoratedName">
            <summary>
            Decorated name of the function. This should ensure uniqueness across all functions in a binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.ReturnDataType">
            <summary>
            Data type returned by the function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.CallingConvention">
            <summary>
            Calling convention.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.AccessModifier">
            <summary>
            Access modifier.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.CyclomaticComplexity">
            <summary>
            The cyclomatic complexity of the function is calculated by looking
            at the conditionals and counting the blocks with more than one edge.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Address">
            <summary>
            The relative address at which the function is located in the binary.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.StartSourceLineNumber">
            <summary>
            The line number at which the body of the function starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.EndSourceLineNumber">
            <summary>
            The line number at which the body of the function ends.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.StartBlockIndex">
            <summary>
            The block index in the block vector at which the function starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.StartArcIndex">
            <summary>
            The arc index in the arc vector at which the function starts.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.BlockCount">
            <summary>
            Number of blocks in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.ArcCount">
            <summary>
            Number of arcs in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.HitBlockCount">
            <summary>
            Number of blocks that are hit by tests in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.HitArcCount">
            <summary>
            Number of arcs that are hit by tests in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Binary">
            <summary>
            The binary this function belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Class">
            <summary>
            The class this function belongs to.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.SourceFile">
            <summary>
            The source file this function belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Function.Id">
            <summary>
            Returns an object that uniquely identifies this function.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionAccessModifier">
            <summary>
            Access modifier for a function.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.PrivateScope">
            <summary>
            Function has private scope protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Private">
            <summary>
            Function has private protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.FamilyAndAssembly">
            <summary>
            Function has family (protected) and assembly protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Assembly">
            <summary>
            Function has assembly protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Family">
            <summary>
            Function has family (protected) protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.FamilyOrAssembly">
            <summary>
            Function has family (protected) or assembly protection
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.FunctionAccessModifier.Public">
            <summary>
            Function has public protection
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.FunctionParameter">
            <summary>
            Represents a parameter of a function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FunctionParameter.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.FunctionParameter.DataType">
            <summary>
            Data type of the parameter.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.MagellanToolsetVersion">
            <summary>
            Represents a version of the Magellan toolset.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.MagellanToolsetVersion.ToString">
            <summary>
            Returns a string representation of this object in the form Major.Minor.BuildNumber.Revision
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.Major">
            <summary>
            Returns the major database version (Major.#.#.#)
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.Minor">
            <summary>
            Returns the minor database version (#.Minor.#.#)
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.BuildNumber">
            <summary>
            Returns the build number portion of the database version (#.#.BuildNumber.#)
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.MagellanToolsetVersion.Revision">
            <summary>
            Returns the revision portion of the database version (#.#.#.Revision)
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedArc.GetTraces">
            <summary>
            Returns a collection of traces which hit this block.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedBlock.GetTraces">
            <summary>
            Returns a collection of traces which hit this block.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Design.MergedClass">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedClass.GetFunctions">
            <summary>
            Returns a collection of all the functions in this class.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedClass.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this class 
            accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.BlockCount">
            <summary>
            Number of blocks in this class. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.HitBlockCount">
            <summary>
            Number of blocks in this class which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.ArcCount">
            <summary>
            Number of arcs in this class. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedClass.HitArcCount">
            <summary>
            Number of arcs in this class which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Design.MergedFunction">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetSourceLines">
            <summary>
            Returns a collection of all the source lines in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetBlocks">
            <summary>
            Returns a collection of all the blocks in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetArcs">
            <summary>
            Returns a collection of all the arcs in this function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedFunction.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block from this function.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.BlockCount">
            <summary>
            Number of blocks in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.ArcCount">
            <summary>
            Number of arcs in this function.
            </summary>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.HitBlockCount">
            <summary>
            Number of blocks in this function which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.HitArcCount">
            <summary>
            Number of arcs in this function which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.Class">
            <summary>
            The class this function belongs to.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedFunction.SourceFile">
            <summary>
            The source file this function belongs to.
            </summary>
        </member>
        <member name="T:MS.Magellan.Design.MergedSourceFile">
            <summary>
            
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceFile">
            <summary>
            Represents a source file. E.g. foo.h, foo.cpp.
            </summary>
            <remarks>
            Sometimes a source file can have the name '{N/A}' meaning that this is a virtual source file
            that doesn't exist, but was created by the Magellan toolset so that compiler generated functions 
            which are not associated to any source file, can belong to a source file.
            </remarks>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceFile.GetFunctions">
            <summary>
            Returns a collection of all the functions in this source file.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceFile.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this 
            source file accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.Directory">
            <summary>
            Directory of the file.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.Binary">
            <summary>
            The binary this source file belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.StaticLibrary">
            <summary>
            The static library this class belongs to. Can be null.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceFile.Id">
            <summary>
            Returns an object that uniquely identifies this file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedSourceFile.GetFunctions">
            <summary>
            Returns a collection of all the functions in this source file.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedSourceFile.GetTraces">
            <summary>
            Returns a collection of all the traces which cover at least one block in this 
            source file accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.BlockCount">
            <summary>
            Number of blocks in this source file. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.HitBlockCount">
            <summary>
            Number of blocks in this source file which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.ArcCount">
            <summary>
            Number of arcs in this source file. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedSourceFile.HitArcCount">
            <summary>
            Number of arcs in this source file which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Reporting.StaticLibrary">
            <summary>
            Represents a static library. E.g. foo.obj, foo.lib.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetClasses">
            <summary>
            Returns a collection of all the classes in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetFunctions">
            <summary>
            Returns a collection of all the functions in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetSourceFiles">
            <summary>
            Returns a collection of all the source files in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Reporting.StaticLibrary.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block in this 
            static library accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.StaticLibrary.Directory">
            <summary>
            Directory of the static library.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.StaticLibrary.Binary">
            <summary>
             The binary this static library belongs to.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.StaticLibrary.Id">
            <summary>
            Returns an object that uniquely identifies this static library.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetClasses">
            <summary>
            Returns a collection of all the classes in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetFunctions">
            <summary>
            Returns a collection of all the functions in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetSourceFiles">
            <summary>
            Returns a collection of all the source files in this static library.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MS.Magellan.Design.MergedStaticLibrary.GetTraces">
            <summary>
            Returns a collection of all the traces which hit at least one block in this 
            static library accross all data sources. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.BlockCount">
            <summary>
            Number of blocks in this static library. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.HitBlockCount">
            <summary>
            Number of blocks in this static library which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.ArcCount">
            <summary>
            Number of arcs in this static library. Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Design.MergedStaticLibrary.HitArcCount">
            <summary>
            Number of arcs in this static library which are covered by tests.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Design.SimplifiedRegex">
            <summary>
            Simplified regular expression for patterns that can contain * as wildcard.
            </summary>
        </member>
        <member name="M:MS.Magellan.Design.SimplifiedRegex.#ctor(System.String)">
            <summary>
            Creates a regular expression with the given pattern.
            </summary>
            <param name="pattern"></param>
        </member>
        <member name="M:MS.Magellan.Design.SimplifiedRegex.IsMatch(System.String)">
            <summary>
            Returns true is the input matches the internal pattern.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Reporting.PathMapping">
            <summary>
            A path mapping is used when trying to open source files that are no longer available in their original location
            so a replace path is needed to load the files from a new location. Also see Project.PathMappings for more info.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMapping.#ctor">
            <summary>
            Create a path mapping.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.PathMapping.#ctor(System.String,System.String)">
            <summary>
            Create a path mapping with the given original and replace paths.
            </summary>
            <param name="originalPath"></param>
            <param name="replacePath"></param>
        </member>
        <member name="P:MS.Magellan.Reporting.PathMapping.OriginalPath">
            <summary>
            The original path that where source files used to be located. 
            This must match a path or a prefix of a path from the PDB file.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.PathMapping.ReplacePath">
            <summary>
            The path that will be used to replace the original path when looking for source files.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.Project">
            <summary>
            Project class is the entry point for browsing code coverage data. 
            It provides ways to load data sources and return a list of builds
            that were found in the coverage data.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.#ctor">
            <summary>
            Creates an empty project.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.#ctor(System.String)">
            <summary>
            Create a Project object and loads its configuration from a file.
            Can throw the same exceptions as Project.Open.
            </summary>
            <param name="filePath">Path of the project file.</param>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.SetName(System.String)">
            <summary>
            Set the name of the project.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.Open(System.String)">
            <summary>
            Open a project file.
            </summary>
            <param name="filePath">Path of the project file.</param>
            <exception cref="T:System.ArgumentException">Thrown when the filePath is not a valid path.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when filePath is null.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when filePath points to a directory that does not exist.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the filePath specified cannot be found.</exception>
            <exception cref="T:System.IO.IOException">Thrown when other IO exceptions occur.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when filePath has an invalid format.</exception>
            <exception cref="T:System.OutOfMemoryException">Thrown when there is not enough memory to load all the coverage data.</exception>
            <exception cref="T:System.IO.PathTooLongException">Thrown when filePath is too long.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown when the user does not have required permissions to filePath.</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when the user doesn't have access to filePath.</exception>
            <exception cref="T:System.Xml.XmlException">Thrown when the xml inside the given file is not well formed.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.Save(System.String)">
            <summary>
            Save the configuration of the project to a file. 
            This configuration contains data source paths, connection strings, etc.
            </summary>
            <param name="filePath">Path of the project file.</param>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when the user doesn't have access to filePath.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the filePath is not a valid path.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when filePath is null.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when filePath points to a directory that does not exist.</exception>
            <exception cref="T:System.IO.PathTooLongException">Thrown when filePath is too long.</exception>
            <exception cref="T:System.IO.IOException">Thrown when other IO exceptions occur.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown when the user does not have required permissions to filePath.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.filters_OnChanged(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null filter is added to the collection of filters.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.covsymSources_OnChanged(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null data source is added to the collection of data sources.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.covdataSources_OnChanged(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null data source is added to the collection of data sources.</exception>
        </member>
        <member name="M:MS.Magellan.Reporting.Project.GetBuilds">
            <summary>
            Returns a collection of builds that were found in the coverage data sources
            that were added to the project. Filters affect the results returned by this method.
            </summary>
            <returns>
            Collection of builds from the data sources added to the project. 
            If the same build exists in different data sources their coverage data is merged
            for binaries which are identical (same name and same unique id).
            </returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when a covsym or covdata path that was specified as data source does not exist.</exception>
            <exception cref="T:System.IO.IOException">Thrown when other IO exceptions occur.</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when the user doesn't have access to the covsym or covdata files specified as data source.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when a covsym or covdata file cannot be found.</exception>
            <exception cref="T:System.Security.SecurityException">Thrown when the user does not have required permissions to covsym or covdata files.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when a covsym or covdata file is corrupt or invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when no data source was added to the Project before calling Project.GetBuilds.</exception>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.CoverageSymbolSources">
            <summary>
            Sources of coverage symbols like covsym files.
            Add instances of classes derived from CoverageSymbolSource.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.CoverageDataSources">
            <summary>
            Sources of coverage data like covdata files.
            Add instances of classes derived from CoverageDataSource.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.Filters">
            <summary>
            Collection of filters to apply to the project.
            Adding or removing filters will clear the entire hierarchy of objects and
            Project.GetBuilds will need to be called to refresh the data.
            Filters that are added to the Filters collection are applied as if there was an AND operator between them.
            When multiple strings are added inside the same Filter object, those strings are applied as if there
            was an OR operator between them.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.Project.PathMappings">
            <summary>
            Imagine the following scenario: User1 builds code on Machine1 so all the source files paths embedded
            in the coverage files will be local to Machine1. Now, User2 wants to view the coverage files from User1
            but the source code is now on Machine2 at a different local location. These PathMappings can be used
            to remap the location of the source files so that they can be viewed on Machine2. So this collection
            is a way to facilitate Coverage viewers (like MagellanStudio) to automatically load code from 
            mapped locations on a different machine.
            </summary>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLine">
            <summary>
            Represents a line of code in a source file.
            </summary>
        </member>
        <member name="M:MS.Magellan.Reporting.SourceLine.GetTraces">
            <summary>
            Returns a collection of traces which hit at least one block from this line.
            Affected by filters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLine.Number">
            <summary>
            Number of the line in the source file.
            </summary>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLine.LineCoverage">
            <summary>
            Calculates the coverage of the line by evaluating the coverage of each block
            that belongs to this line.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MS.Magellan.Reporting.SourceLine.Blocks">
            <summary>
            Returns a collection of blocks that belong to this line.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MS.Magellan.Reporting.SourceLineCoverage">
            <summary>
            Defines the possible coverage values that a source line can have.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.None">
            <summary>
            Coverage is unspecified for this line.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.NotCovered">
            <summary>
            Line is not covered by tests.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.PartiallyCovered">
            <summary>
            Some blocks from the line are covered by tests but not all of them.
            </summary>
        </member>
        <member name="F:MS.Magellan.Reporting.SourceLineCoverage.Covered">
            <summary>
            Line is fully covered by tests.
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\MICROSOFT LS 6.11 RTM README.docx ===
[Content_Types].xml  ^,YVWUwU ~sX@< _rels/.rels  word/_rels/document.xml.rels  x$n:( KQc@U `%U2R ~Kn8\ word/document.xml #>O,C X.mzw8 }o`ys \:M-x |]{OYH k0AGc U{aEm hR|bS Z=LBy mWKw|a LzzgI Jvi&! ;Ff~Qh fp9xD K_D3H^F8O K\9Nk t*VbW <^M[/ b`%(/ \UpJ" A9:-F$ |($THHf k"h95 ;(uFw q?ij6 Y>98j{z ^pQhh (U;rm (f6Wb 3[Z.e6 =zS0u Q6l9<my VvJ?N;#}K word/footer3.xml ]H;J41 %k@+#] word/footer2.xml ]H;J41 %k@+#] word/footer1.xml ]H;J41 %k@+#] word/header2.xml word/header1.xml word/endnotes.xml A]W}| word/footnotes.xml word/header3.xml word/theme/theme1.xml w toc'v 3Vq%'#q :\TZaG IqbJ#x T[XF64 word/settings.xml jy%Ge LQ{_dOEL l8FSG $Fn_l fA{#$ bO#M; ul`7Zf Wd"C= ~/a]G\ %=WR|'w n>LX#a5 f\8y9t i[|!| word/webSettings.xml !@ ms Gp68JL 3R&8& x9 D= docProps/custom.xml  |s"wN kS|Of Zpj(d word/styles.xml -n(BKRq oX(r2 %&B"7 }\$L` <?wLU f6txYJ~ (.G4P =/p24 ]^hPL &*Eq9 pR}JBX4. bewUcN ne9=( 6iKW@ a/KH} UIPR! word/numbering.xml %Y?vPO #5:/8 ct5Gx >_oOU 0A-W0 pD#<NE 5'&di" ilo4k l=jY' @#yw# b6^w$ docProps/core.xml  aIzCk /u38> word/fontTable.xml >a*nL/ docProps/app.xml  1Ji!91 ^CIF8 .ac@WU r:'+n:D [Content_Types].xmlPK _rels/.relsPK word/_rels/document.xml.relsPK word/document.xmlPK word/footer3.xmlPK word/footer2.xmlPK word/footer1.xmlPK word/header2.xmlPK word/header1.xmlPK word/endnotes.xmlPK word/footnotes.xmlPK word/header3.xmlPK word/theme/theme1.xmlPK word/settings.xmlPK word/webSettings.xmlPK x9 D= docProps/custom.xmlPK word/styles.xmlPK word/numbering.xmlPK docProps/core.xmlPK word/fontTable.xmlPK docProps/app.xmlPK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\lsbuild\6.11\MICROSOFT LS 6.10 RTM Release Notes.docx ===
[Content_Types].xml  _rels/.rels  word/_rels/document.xml.rels  M2/N|Q> j#W F word/document.xml ^[iPj% N\J#g li@t# ;C&52 <O;iH 3oPo~ @|>R9 Wv~P` V'I)>Q Q+iI&` XIc;2 8YjY) S9YMwb ,`<&. n7ZY( [cxgF fPainE& 9{/,D ~B9$0} MsnL>"r ]7b&G Vmk!S BNF6g YzKck pPkHo k2]yC ?HtUA; I7+\. p<;x! %$B)> @;DwE bKw_l @3Y5+ y}gf`\); }LJB. #=(Dn /=7&x 2InS_) cdZ;d cp\;p 2X#Z/ oGF0F z\,Jr JvXW\. j5Jp~ d&~.L 480`y(L oY<Y+ y]0cd BPDdW ~%M:: ed{1P r/7(? $LvEV_ e$oe$} =Y"i@ pE;A,~ fh[/h;> Qc`z' Td`Z3` XOb=) oGf5|) 9387xN\ ($_EOyz L(<j}=_( %.`Mx fhUG[ 8(Q,- oi-k7 tASda &uW/GU ~^$eL g@}9gS07 Ep:,v 8<|^)p qGre%U (cGBr +m!T( ^< CL AK6.t jeq~M aL~gO 0R?pk word/footnotes.xml QxL{| rB5~q word/endnotes.xml FQTuc M//6] k2b ! word/theme/theme1.xml w toc'v 3Vq%'#q :\TZaG IqbJ#x T[XF64 word/settings.xml \qf,d BNd}p 2I0:^ r}%vT q3TG-D im`fE 2-2|:gt qWls, o>M3g D2c4< jZ}|C word/webSettings.xml 9cZK]* tb&<  word/styles.xml =wA{N %2M{| o^S Lm "*Eq&* "N6?| $Yh\k b!<u( y]8,7 cq^]A 8fZUms= nf3!\ docProps/custom.xml  #D41^ |bvMY docProps/core.xml  word/numbering.xml ,CVwo ?FOk@ zNgn@> FEZH] 7wK;Q vwjbz G7$  R  PLPI :UOf#v 4955\-Vv h.LBja IckRo J"0hg. Ud/!ZB jY?vN /$%GF {-ufl c!B&DC a;{jlm8 )fAOT &Lz-j word/fontTable.xml GE"S& +"RRHA @5zX| bdSP; (h#'" )dWI; Hbi:2<w docProps/app.xml  ]j-O=O etNV\w 5k/'L [Content_Types].xmlPK _rels/.relsPK word/_rels/document.xml.relsPK word/document.xmlPK word/footnotes.xmlPK word/endnotes.xmlPK word/theme/theme1.xmlPK word/settings.xmlPK word/webSettings.xmlPK word/styles.xmlPK docProps/custom.xmlPK docProps/core.xmlPK word/numbering.xmlPK word/fontTable.xmlPK docProps/app.xmlPK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MMF\4.0\Debug\Microsoft.MMF.XML ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.MMF</name>
    </assembly>
    <members>
        <member name="T:Microsoft.MMF.StateMachine.ReportGenerator">
            <summary>
            This class is used to generate HTML reports of failed tests.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.ReportGenerator.mXslTransform">
            <summary>
            This is the XSLT file that is used to generate the logs.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ReportGenerator.#cctor">
            <summary>
            Loads the xslt file.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ReportGenerator.GetTestMethodNameFromStackTrace">
            <summary>
            This method looks at the stack trace from the currently executing method.  It traverses down the list until 
            it finds a method that has the TestMethodAttribute defined in its metadata.
            </summary>
            <returns>The name of the test</returns>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ReportGenerator.GenerateMockReport(System.String,Microsoft.MMF.StateMachine.AutomataState,System.Collections.Generic.List{Microsoft.MMF.StateMachine.ExpectationLogEntry})">
            <summary>
            Generates a mock report, which is an HTML document that can be used to view the mock state machine
            and all of the methods and states that it inspected during a replay.
            </summary>
            <param name="testName">The name of the test to generate a report on</param>
            <param name="initialState">The initial state of the recorded state machine</param>
            <param name="logEntries">A list of log entries for each state</param>
            <returns>An HTML report illustrating the failure</returns>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ReportGenerator.GenerateStubReport(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Boolean})">
            <summary>
            Generates a stub report.
            </summary>
            <param name="testName">The name of the test</param>
            <param name="validationMessages">A list of validation messages</param>
            <param name="results">A list of validation results</param>
            <returns>An HTML report illustrating the failure</returns>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ReportGenerator.TransformDocumentIntoHTML(System.Xml.XmlDocument)">
            <summary>
            Transforms an XML document into HTML.
            </summary>
            <param name="document">The document to transform</param>
            <returns>An HTML document in string form</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineVarTranslator">
            <summary>
            Translates the inlinevar instruction.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.Translator">
            <summary>
            A translator is an object that is used to translate a target method into 
            a redirected method.  The translator operates based on the operand type.  
            Depending on the operand type, the translator will do different things.  The 
            redirection context object is used keep track of the data between translator 
            invocations.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.Translator.#ctor">
            <summary>
            Default constructor does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.Translator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the current instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
            
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.Translator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            All subclaases must know how to emit the opcodes that they generated.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator to emit the code for</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.Translator.ExtractIntAt(System.Byte[],System.Int32)">
            <summary>
            Extracts the first four bytes from the byte array starting at the specified index.
            </summary>
            <param name="bytes">The byte array</param>
            <param name="offset">The starting offset</param>
            <returns>An integer</returns>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.Translator.ResolveModule">
            <summary>
            This module is used to resolve tokens.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.Translator.GenericTypeArguments">
            <summary>
            These are the generic type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.Translator.GenericMethodArguments">
            <summary>
            These are the generic method arguments.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.Translator.ShouldRedirect">
            <summary>
            When true, subclasses should redirect all method calls, stfld and ldfld calls.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineVarTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineVarTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the inlinevar instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineVarTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inline var instruction.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.ExpectationViolationException">
            <summary>
            Defines an exception that signifies that an expectation was not met.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.ExpectationViolationException.#ctor(System.String)">
            <summary>
            Creates an expectation violation exception with a specific message.
            </summary>
            <param name="message">The message to create the exception from.</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.ExpectationViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.ExpectationViolationException.SaveReport">
            <summary>
            Saves the report to the current directory.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Exceptions.ExpectationViolationException.HTMLReport">
            <summary>
            Getting this property in the debugger will allow you to view the HTML report without 
            having to save it to disc.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.ObjectWrapper`2">
            <summary>
            Defines the base class for the object wrapper library.
            </summary>
            <typeparam name="T">This is the type that we're wrapping</typeparam>
            <typeparam name="U">This is the type that we refer to T by. They can be different if we are mimicking</typeparam>
        </member>
        <member name="M:Microsoft.MMF.ObjectWrapper`2.#ctor(`1)">
            <summary>
            Creates the mock object wrapper.
            </summary>
            <param name="target">The target object</param>
        </member>
        <member name="M:Microsoft.MMF.ObjectWrapper`2.op_Implicit(Microsoft.MMF.ObjectWrapper{`0,`1})~`1">
            <summary>
            Used to cast the wrapper as an instance of U.
            </summary>
            <param name="wrapper">The object to cast.</param>
            <returns>An instance of U.</returns>
        </member>
        <member name="P:Microsoft.MMF.ObjectWrapper`2.Target">
            <summary>
            Returns the actual mock or stub object that this class wraps.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.ITestHarness">
            <summary>
            Defines a test harness.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedInstances">
            <summary>
            These are the instances that the test harness is redirecting
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedNewTypes">
            <summary>
            This is a collection of types that, when newed, we should redirect.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedNewTypesCallConstructors">
            <summary>
            This dictionary keeps track of whether or not the constructors should
            be called when a dynamically created type is created.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedNewTypesReturnUninitializedObjects">
            <summary>
            This dictionary stores bools that determine whether we should return an uninitialized
            object for a given type when it's being redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedStaticTypes">
            <summary>
            Keeps track of all the static types that should be redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedTypes">
            <summary>
            Keeps track of all the types that are redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.RedirectedAssemblies">
            <summary>
            A list of all of the assemblies that a test harness is redirecting into.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.ITestHarness.Scope">
            <summary>
            This is the scope of the redirection test.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.TypeGenerationCache">
            <summary>
            This class is used to cache generated object types that are created from the dynamic type factory.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TypeGenerationCache.mInstance">
            <summary>
            The one and only instance of the cache.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TypeGenerationCache.mCacheEntries">
            <summary>
            This is a list of all the cache entries.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TypeGenerationCache.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TypeGenerationCache.#ctor">
            <summary>
            Creates the cache.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TypeGenerationCache.RegisterType(Microsoft.MMF.Generation.EClassTemplateTypes,Microsoft.MMF.Generation.EMethodTemplateTypes,System.Boolean,System.Type,System.Type,System.Type)">
            <summary>
            Registers a generated object wrapper with the cache.
            </summary>
            <param name="classTemplateType">The class template type</param>
            <param name="methodTemplateType">The method template type</param>
            <param name="includesPrivateMethods">True if the generated type includes private methods</param>
            <param name="interfaceType">The interface type</param>
            <param name="baseClassType">The base class type</param>        
            <param name="generatedType">The generated type</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.TypeGenerationCache.Lookup(Microsoft.MMF.Generation.EClassTemplateTypes,Microsoft.MMF.Generation.EMethodTemplateTypes,System.Boolean,System.Type,System.Type)">
            <summary>
            Looks up a template from the cache.  If it doesn't exist, then it returns null.
            </summary>
            <param name="classTemplateType">The class template type</param>
            <param name="methodTemplateType">The method template type</param>
            <param name="includesPrivateMethods">True if the generated type includes private methods</param>
            <param name="interfaceType">The interface type</param>
            <param name="baseClassType">The base class type</param>
            <returns>The type that was generated, or null if nothing could be found</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry">
            <summary>
            This class represents an entry in the generation cache.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.#ctor">
            <summary>
            Creates the cache entry.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.ClassTemplateType">
            <summary>
            This is the class template type.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.MethodTemplateType">
            <summary>
            This is the method template type.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.BaseType">
            <summary>
            This is the base class type.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.InterfaceType">
            <summary>
            This is the interface type.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.IncludesPrivateMethods">
            <summary>
            Determines whether the generated type includes private methods.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TypeGenerationCache.CacheEntry.GeneratedType">
            <summary>
            This is the generated type.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Templates.StubAssertingListAttribute">
            <summary>
            Defines an attribute that marks a field as a list of assertions for a stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubAssertingListAttribute.#ctor">
            <summary>
            Creates the attribute.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.CallBaseMethodPatch">
            <summary>
            Patches a method so that the base methods gets called at the specific point.  The method 
            that is called is assumed to not have a return value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.IPatch">
            <summary>
            This is the base interface for the generic IPatch interface.  This defines an object that is 
            able to patch the current instruction in a translated method with method-specific, dynamic
            data.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.IPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Defines a patch that can patch code in a dynamically generated method.
            </summary>
            <param name="tracker">The opcode tracker</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.CallBaseMethodPatch.#ctor">
            <summary>
            Creates the patch.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.CallBaseMethodPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the method to call the base class.
            </summary>
            <param name="tracker">The track to patch the template with</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patcher">
            <summary>
            The patch class is used to mark a point in a template where something should be patched.  The generic parameters 
            in the Patch static method supply the translation API with the data neccessary to figure out which class should be 
            called in order to patch the template with dynamically generated code.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patcher.#ctor">
            <summary>
            Can't be instantiated.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patcher.PatchWithNoReturnValue``1">
            <summary>
            Instructs the translation API to insert dynamic code at a particlar point in the code.
            </summary>
            <typeparam name="T">The type of patch object</typeparam>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patcher.PatchWithNoReturnValue``2(``1)">
            <summary>
            Instructs the translation API to insert dynamic code at a particlar point in the code.  This 
            patch overload operates in cases where the patch needs to do something with an value on the top 
            of the stack.  Passing an argument into this method allows it the patched code to operate on 
            whatever is on the top of the stack, which will always be an argument into this method.
            </summary>
            <typeparam name="T">The type of patch object</typeparam>
            <typeparam name="U">The type of the parameter to patch</typeparam>
            <param name="u">An instance of U</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patcher.PatchWithReturnValue``2">
            <summary>
            Defines a point in a template where a patch with a return value should be used.  Type T is an IPatch object
            that has a default constructor.  The translation API will dynamically create type T when it is cloning the code,
            and will ask it to patch the code with dynamically generated code.
            
            Type U is the return value from the patched code.  This allows the method to compile as though it were a function call.
            </summary>
            <typeparam name="T">The type of the patch to insert</typeparam>
            <typeparam name="U">The type that the patch will leave on the top of the stack when it's completed</typeparam>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patcher.PatchWithReturnValue``3(``2)">
            <summary>
            Sometimes we need a patch that operates on whatever is at the top of the stack.  In order 
            to compile a method so that this object is on the top of the stack when the patch is 
            applied, we need a method argument into the Patch method.  That's where this overload comes 
            in.  The template methods pass the argument into the patch method, and what we end up with 
            is something like this:
            
            ldarg.2
            call Patcher.Patch
            
            The patch can then emit code that does something with whatever was in ldarg.2, such as casting it.
            </summary>
            <typeparam name="T">The patch type</typeparam>
            <typeparam name="U">The return value of the patch</typeparam>
            <typeparam name="V">The argument type of the patch</typeparam>
            <param name="v">An instance of type V</param>
            <returns>An instance of type U</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.FrequentlyUsedMethodCache">
            <summary>
            This class is used to cache frequently used methods in one place, so that we don't need 
            to keep calling GetMethod again and again to get the same commonly used methods.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.GetMethodFromHandleMethod">
            <summary>
            This method is called to get a MethodBase from a method handle.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.GetTypeFromHandleMethod">
            <summary>
            This method gets a type from a handle.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.GetFieldFromHandleMethod">
            <summary>
            This method is used to get a field from runtime type handles.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.GetCurrentMethodMethod">
            <summary>
            This method that returns the MethodInfo from whatever method is currently executing.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.MakeGenericMethodMethod">
            <summary>
            This method is used to make a method generic.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.IsBeingParameterizedMethod">
            <summary>
            This method is used to tell us when we should rethrow an exception in a redirected method-in-test.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.IsDoneMethod">
            <summary>
            This method is used within a parameterized loop to see whether or not we should break back to 
            the top for another iteration.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.MethodInvokeMethodTwoParams">
            <summary>
            This is the invoke method on the MethodBase class that takes just two parameters.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.MethodInvokeMethodFiveParams">
            <summary>
            This is the invoke method on the MethodBase class that takes five parameters.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.ConstructorInvokeOneParam">
            <summary>
            This is the basic invoke method for constructors that takes one parameter.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.ConstructorInvokeFourParams">
            <summary>
            This is the other constructor info override, which is used to invoke a constructor on a specific instance.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.TypeGetTypeOneParam">
            <summary>
            This is the GetType override that takes one parameter.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.TypeGetTypeTwoParams">
            <summary>
            This is the GetType override that takes two parameters.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.TypeGetTypeThreeParams">
            <summary>
            This is the GetType override that takes three parameters.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.FrequentlyUsedMethodCache.#ctor">
            <summary>
            Can't be instantiated.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.EClassTemplateTypes">
            <summary>
            This enumeration defines the types of class templates that we can define.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EClassTemplateTypes.Mock">
            <summary>
            The class is a mock object template.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EClassTemplateTypes.Stub">
            <summary>
            The class is a stub object template.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EClassTemplateTypes.Patch">
            <summary>
            The class is a patch class.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.EMethodTemplateTypes">
            <summary>
            This enumeration defines the characteristics of a template method.
            The enumeration allows clients to search for a specific template based on
            specific characteristics.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.NoReturnValue">
            <summary>
            Indicates a template that has no return value.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.ReturnValue">
            <summary>
            Indicates a template that has a return value.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.Static">
            <summary>
            The template method is static.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.Mimic">
            <summary>
            The template method is a mimic method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.Partial">
            <summary>
            The template method is for a partial mock.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.Default">
            <summary>
            Indicates that this is the default template.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EMethodTemplateTypes.Constructor">
            <summary>
            Indicates that this template intercepts constructors.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.EThisPointerLocation">
            <summary>
            When we are redirecting new objects, we need to have a way to tell the API where
            the this pointer is.  It could be at the beginning, at the end, or not there at all
            depending on what instruction was used.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EThisPointerLocation.None">
            <summary>
            There is no this pointer.  This occurs when we get a newobj opcode (the most common occurance).
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EThisPointerLocation.AtStart">
            <summary>
            This occurs either when we are newing a value type (via initobj), or when we are invoking a constructor
            from another constructor.  In that case, the this pointer is explicit.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EThisPointerLocation.AtEnd">
            <summary>
            This occurs in a rare fringe case when we are newing a value type via newobj instead of via initobj.  In these cases,
            the MMF needs to add a byref argument to the end of the arg list so that we can set it by reference.  But this is not
            how the compiler does it for us; it won't use a byref arg at all.  We need these because of the blasted 
            visibility checks in CLR4.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.ECallType">
            <summary>
            When we are redirecting into methods, we need to know whether the call was virtual or not.  Otherwise,
            we won't have any idea which method to call: do we call the method on the current instance, or it's base class?
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ECallType.Virtual">
            <summary>
            Signals that the method is being called virtually.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ECallType.NonVirtual">
            <summary>
            Signals that the method is being called directly.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ECallType.MockCall">
            <summary>
            Signals that the method call is coming from a mock or stub.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.EExceptionClauseType">
            <summary>
            This enumeration is a special case that the OpCodeTracker uses to know when patched methods
            should define exception blocks.  This allows a patcher to insert an exception block as part
            of their patch.  To do so, Patch with OpCodes.nop and one of these values.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.StartOfBlock">
            <summary>
            Indicates the start of an exception block.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.StartExceptionHandler">
            <summary>
            Indicates the start of an exception block handler.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.StartExceptionFilter">
            <summary>
            Indicates the start of an exception filter.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.StartExceptionFilterHandler">
            <summary>
            After an exception filter, this value declares the portion of the code that will
            handle the exception should the filter pass.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.StartFaultHandler">
            <summary>
            Indicates the start of a fault block handler.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.StartFinallyHandler">
            <summary>
            Indicates the start of a finally handler.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.EExceptionClauseType.EndHandler">
            <summary>
            Indicates the end of an exception block handler.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.AutomataState">
            <summary>
            This class represents a state in the finite automata.  When validating the 
            next method call in the mock framework, we try to move from state to state
            using MethodExpectations.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.AutomataState.mIsFinalState">
            <summary>
            This 
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.AutomataState.mLinks">
            <summary>
            A list of links to other automata states.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.AutomataState.mExpectations">
            <summary>
            A list of method expectations that map to each link.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.AutomataState.#ctor">
            <summary>
            Create the AutomataState object and initialize the lists.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.AutomataState.Link(Microsoft.MMF.StateMachine.MethodExpectation,Microsoft.MMF.StateMachine.AutomataState)">
            <summary>
            Links two automata together using a method expectation.
            </summary>
            <param name="expectation">The expectation that moves from one state to the next.</param>
            <param name="state">The state that the expectation, if true, moves us the finate automata to.</param>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.AutomataState.MoveToNextState(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>
            Attempts to move to the next method in the automata using the method expectations 
            to pre validate the method call and ensure that it's valid.
            </summary>
            <param name="mockedObject">The type of object that is being mocked</param>
            <param name="calledMethod">The method that is being called</param>
            <param name="args">The arguments of the method</param>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.AutomataState.Expectations">
            <summary>
            This is a list of method expectations.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.AutomataState.Links">
            <summary>
            This is a list of states.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.AutomataState.IsFinalState">
            <summary>
            Returns true if this is the final state.  If we are backpatching, however, then this property
            will get and set the backpatched states final state value instead of ours.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.AutomataState.StateNumber">
            <summary>
            Gets / sets the state number.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.AutomataState.BackpatchState">
            <summary>
            In cases where we embed ordered expectations inside of unordered expectations,
            we end up in a situation where the last state in the ordered list needs to
            act as if it's TWO states.  
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.TemplateMemberAttribute">
            <summary>
            Defines a field, method or property on a template class that should be cloned as part of that template.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TemplateMemberAttribute.#ctor">
            <summary>
            Creates the attribute.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.MethodInvokeSpecialCase">
            <summary>
            This special case allows us to handle method invocations via reflection
            using redirection.  When we see a method call to MethodBase.Invoke, we instead
            redirect the call to a trap method on the RedirectionHelper class.  There we can 
            intercept the call and potentially redirect the method 
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.ISpecialCase">
            <summary>
            This interface defines a class that can handle a special case.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.ISpecialCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Returns true if this special case applies to a particular method.
            </summary>
            <param name="method">The method to match</param>
            <returns>True if it matches, otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.ISpecialCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the redirected method using custom code.
            </summary>
            <param name="matchingMethod">The method that matched the special case</param>
            <param name="tracker">The tracker to use to patch the code</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.MethodInvokeSpecialCase.#ctor">
            <summary>
            Creates the special case.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.MethodInvokeSpecialCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Returns true if a method matches this special case.
            </summary>
            <param name="method">The method to match</param>
            <returns>True if it matches; otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.MethodInvokeSpecialCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code so that this method gets redirected to the API.
            </summary>
            <param name="matchingMethod">The method that matched the special case</param>
            <param name="tracker">The tracker to use to patch</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.BeginInvokeSpecialCase">
            <summary>
            Handles calls the Delegate.BeginInvoke.  The runtime doesn't allow a redirected method 
            to be invoked asynchronously via BeginInvoke, so we need to handle it seperately.
            
            Note that BeginInvoke is not defined in Delegate, it's defined on their derivatives.  So we need
            to search for this method by comparing the base type and the method name since there 
            are an unlimited number of defined BeginInvoke methods with different parameters for each of them.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.BeginInvokeSpecialCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Matches any method whose base type is Delegate and whose method name is "BeginInvoke".
            </summary>
            <param name="method">The method to match</param>
            <returns>True if the method matches, otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.BeginInvokeSpecialCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code to call the RedirectionHelper class where we can handle asynchronous calling on
            our own.
            </summary>
            <param name="matchingMethod">The method that we matched</param>
            <param name="tracker">The tracker to patch the code</param>
        </member>
        <member name="T:Microsoft.MMF.Constraints.RegexConstraint">
            <summary>
            This is a constraint that will match a regular expression.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Constraints.Constraint">
            <summary>
            Defines a class that can validate a single argument value using a constraint.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.Constraint.#ctor(System.Int32)">
            <summary>
            Creates the constraint.
            </summary>
            <param name="argIndex">The index of the argument</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.Constraint.Validate(System.Object)">
            <summary>
            Validates the argument.
            </summary>
            <param name="argValue">The argument to validate</param>
            <returns>True if the argument satisfies the constraint.  Otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.MMF.Constraints.Constraint.Index">
            <summary>
            Defines a property that holds the argument index of the argument to accept a constraint on.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constraints.RegexConstraint.mRegEx">
            <summary>
            The regular expression to match
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.RegexConstraint.#ctor(System.Int32,System.String)">
            <summary>
            Creates the regular expression constraint.
            </summary>
            <param name="index">The index of the constraint</param>
            <param name="regex">The regex to match</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.RegexConstraint.Validate(System.Object)">
            <summary>
            Validates the object matches the regular expression.
            </summary>
            <param name="argValue">The argument value to match</param>
            <returns>True if it matches; otherwise false</returns>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.StartUnorderedRecording">
            <summary>
            Starts an unordered recording.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.StartRecording">
            <summary>
            Allows for a more convinient syntax using the using keyword.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.StartRecording.#ctor">
            <summary>
            When created, tells the recorder to start.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.StartRecording.Dispose">
            <summary>
            Tells the Recorder to stop.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.StartRecording.IsOrdered">
            <summary>
            Subclasses need to define for us whether they are ordered or not.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.StartUnorderedRecording.IsOrdered">
            <summary>
            Since this is an unordered recording, this value is false.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineTokTranslator">
            <summary>
            Translates an inline token instruction.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineTokTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineTokTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline token instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineTokTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inline tok operand.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineNoneTranslator">
            <summary>
            Translates an inline none instruction.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineNoneTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineNoneTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline none instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineNoneTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits the opcode.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.MockExtensionMethods">
            <summary>
            This class contains all of the extension methods used by the mock system.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``2(Microsoft.MMF.MockObjectWrapper{``0,``1},System.Action{``0})">
            <summary>
            Creates an expectation on the method invoked by handler.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="mock">The mock object to create the expectation on</param>
            <param name="handler">The handler to call</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ExpectsNew``2(Microsoft.MMF.MockObjectWrapper{``0,``1},System.Func{``0})">
            <summary>
            Creates an expectation on a constructor of this mock object.
            </summary>
            <param name="mock">The mock object to create the expectation on</param>
            <param name="handler">A lambda expression that invokes a constructor</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects(Microsoft.MMF.MockObjectWrapper{Microsoft.MMF.MMFStatic},System.Action)">
            <summary>
            Creates an expectation on the static method invoked by the handler.
            </summary>
            <param name="mock">The mock object to create the expectation on</param>
            <param name="handler">A handler to call</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``2(Microsoft.MMF.MockObjectWrapper{``0,``1},System.String,System.Object[])">
            <summary>
            Creates an expectation on any non-public methods by passing in the name of the method to
            set an expectation on.  This will attempt to find the method on the mock object by its name; if it can't find 
            a method by that name, a MockRecordingException exception will be thrown.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="mock">The mock object</param>
            <param name="methodName">The name of the method that we're invoking</param>
            <param name="args">The arguments to the method</param>
            <returns>The next state</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.MockRecordingException">Thrown if no method can be found on the mock object by the name passed in by methodName</exception>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``2(Microsoft.MMF.MockObjectWrapper{``0,``1},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Creates an expectation on any method with no return value that is defined on the mock object.  Use this 
            method in cases where you want to set an expectation on a mock object, but that method is not public and 
            can't be discovered using just it's name.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="mock">The mock object</param>
            <param name="methodBase">The method to invoke</param>
            <param name="args">The arguments to the method</param>
            <returns>The next state</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.MockRecordingException">Thrown if the method invoked by calling methodInfo did not actually call the mock object</exception>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``3(Microsoft.MMF.MockObjectWrapper{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates an expectation on the method invoked by the handler that has a return value.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method that we're mocking</typeparam>
            <typeparam name="V">The return type of the method we're setting an expectation on</typeparam>
            <param name="mock">The mock object to create the expectation on</param>
            <param name="handler">The function that has a return value</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``1(Microsoft.MMF.MockObjectWrapper{Microsoft.MMF.MMFStatic},System.Func{``0})">
            <summary>
            Creates an expectation on the static method invoked by the handler that has a return value.
            </summary>
            <typeparam name="V">The return type of the method we're setting an expectation on</typeparam>
            <param name="mock">The mock object to create the expectation on</param>
            <param name="handler">The function that has a return value</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``3(Microsoft.MMF.MockObjectWrapper{``0,``1},System.String,System.Object[])">
            <summary>
            Creates an expectation on any public or non-public method that has a return value by passing in the name of the method to
            set an expectation on.  This will attempt to find the method on the mock object by its name and the types passed into
            this method.  If it can't find a method by that name which takes those types, a MockRecordingException 
            exception will be thrown.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type</typeparam>
            <typeparam name="V">The return type for this method</typeparam>
            <param name="mock">The mock object</param>
            <param name="methodName">The name of the method to set an expectation on</param>
            <param name="args">The arguments to the method</param>
            <returns>The next state</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.MockRecordingException">Thrown when no method by methodName could be found on the mock object</exception>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.Expects``3(Microsoft.MMF.MockObjectWrapper{``0,``1},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Creates an expectation on any method with a return value that is defined on the mock object.  Use this 
            method in cases where you want to set an expectation on a mock object, but that method is not public and 
            can't be discovered using just it's name.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type</typeparam>
            <typeparam name="V">The return type from the method</typeparam>
            <param name="mock">The mock object</param>
            <param name="methodBase">The method to invoke</param>
            <param name="args">The arguments to the method</param>
            <returns>The next state</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.MockRecordingException">Thrown if the method invoked by calling methodInfo did not actually call the mock object</exception>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledOneTime``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum and maximum number of times in the current expectation to equal 1.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledOneTime``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the minimum and maximum number of times in the current expectation to equal 1.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledTwoTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum and maximum number of times in the current expectation to equal 2.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledTwoTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times in the current expectation to equal 2.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledThreeTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum and maximum number of times in the current expectation to equal 3.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledThreeTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times in the current expectation to equal 3.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledFourTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum and maximum number of times in the current expectation to equal 4.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledFourTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times in the current expectation to equal 4.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledXTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Int32)">
            <summary>
            Sets the maximum number of times in the current expectation to equal X.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <param name="x">The number of times this method should be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledXTimes``1(Microsoft.MMF.States.VoidState2{``0},System.Int32)">
            <summary>
            Sets the minimum and maximum number of times in the current expectation to equal x.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="x">The number of times we expect this method to be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastOneTime``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum number of times to 1, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastOneTime``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the minimum number of times to 1, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastTwoTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum number of times to 2, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastTwoTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the minimum number of times to 2, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastThreeTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum number of times to 3, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastThreeTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the minimum number of times to 3, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastFourTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the minimum number of times to 4, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastFourTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the minimum number of times to 4, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastXTimes``1(Microsoft.MMF.States.VoidState2{``0},System.Int32)">
            <summary>
            Sets the minimum number of times to x, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="x">The minimum number of times that this can be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAtLeastXTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Int32)">
            <summary>
            Sets the minimum number of times to x, and the max to anything.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <param name="x">The minimum number of times that this can be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanOneTime``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the maximum number of times to 1, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanOneTime``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times to 1, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanTwoTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the maximum number of times to 2, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanTwoTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times to 2, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanThreeTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the maximum number of times to 3, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanThreeTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times to 3, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanFourTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Sets the maximum number of times to 4, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanFourTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Sets the maximum number of times to 4, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanXTimes``1(Microsoft.MMF.States.VoidState2{``0},System.Int32)">
            <summary>
            Sets the maximum number of times to x, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="x">The maximum number of times that this can be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledNoMoreThanXTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Int32)">
            <summary>
            Sets the maximum number of times to x, and the minimum to 0.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method or property</typeparam>
            <param name="state2">The previous state</param>
            <param name="x">The maximum number of times that this can be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledBetweenXAndYTimes``1(Microsoft.MMF.States.VoidState2{``0},System.Int32,System.Int32)">
            <summary>
            Creates an expectation that the current method will be called between x and y times.
            </summary>
            <param name="state2">The previous state</param>
            <param name="x">The minimum number of times the current method can be called</param>
            <param name="y">The maximum number of times the current method can be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledBetweenXAndYTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Int32,System.Int32)">
            <summary>
            Creates an expectation that the current method will be called between x and y times.
            </summary>
            <param name="state2">The previous state</param>
            <param name="x">The minimum number of times the current method can be called</param>
            <param name="y">The maximum number of times the current method can be called</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAnyNumberOfTimes``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Allows the method to be called any number of times.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ToBeCalledAnyNumberOfTimes``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Allows the method to be called any number of times.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturns``2(Microsoft.MMF.States.ReturnState2{``0,``1},``1)">
            <summary>
            Sets the return value for an expectation.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="returnValue">The return value</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state2">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturnsByCalling``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Func{System.Object[],``1})">
            <summary>
            Sets a delegate that can supply a return value when the expected method is called.  The delegate 
            can return custom values depending on the methods' arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property that we're mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="returnHandler">A delegate that will supply the return value for this expectation depending on the methods' arguments</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``1(Microsoft.MMF.States.VoidState2{``0},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the mocked method</typeparam>
            <param name="state2">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``1(Microsoft.MMF.States.VoidState3{``0},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state3">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``2(Microsoft.MMF.States.ReturnState3{``0,``1},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the mocked method</typeparam>
            <param name="state3">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``1(Microsoft.MMF.States.VoidState4{``0},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state4">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``2(Microsoft.MMF.States.ReturnState4{``0,``1},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the mocked method</typeparam>
            <param name="state4">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``1(Microsoft.MMF.States.VoidState5{``0},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state5">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.ButThrows``2(Microsoft.MMF.States.ReturnState5{``0,``1},System.Exception)">
            <summary>
            Sets an exception to be thrown if the expectation is matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the mocked method</typeparam>
            <param name="state5">The previous state</param>
            <param name="e">The exception to throw</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringArgumentsAt``1(Microsoft.MMF.States.VoidState2{``0},System.Int32[])">
            <summary>
            Tells the expectation to ignore arguments at specific indexes.  The indexes are 0-based.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>        
            <param name="indexes">The indexes of the arguments to ignore</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringArgumentsAt``2(Microsoft.MMF.States.ReturnState2{``0,``1},System.Int32[])">
            <summary>
            Tells the expectation to ignore arguments at specific indexes.  The indexes are 0-based.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>        
            <param name="indexes">The indexes of the arguments to ignore</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringAllArguments``1(Microsoft.MMF.States.VoidState2{``0})">
            <summary>
            Tells the expectation to ignore all arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringAllArguments``2(Microsoft.MMF.States.ReturnState2{``0,``1})">
            <summary>
            Tells the expectation to ignore all arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.WithValidatingCallback``1(Microsoft.MMF.States.VoidState2{``0},Microsoft.MMF.CallbackHandler)">
            <summary>
            Sets a callback method for the current method expectation.  This callback is invoked in order to validate
            the arguments that were passed into the method.  If the CallbackHandler returns true, the API assumes
            that the expectation was matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="callback">A callback that validates the arguments of the expectation</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.WithValidatingCallback``2(Microsoft.MMF.States.ReturnState2{``0,``1},Microsoft.MMF.CallbackHandler)">
            <summary>
            Sets a callback method for the current method expectation.  This callback is invoked in order to validate
            the arguments that were passed into the method.  If the CallbackHandler returns true, the API assumes
            that the expectation was matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>    
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
            <param name="callback">A callback that validates the arguments of the expectation</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturns``2(Microsoft.MMF.States.ReturnState3{``0,``1},``1)">
            <summary>
            Sets the return value for this expectation.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state3">The previous state</param>
            <param name="returnValue">The return value</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``2(Microsoft.MMF.States.ReturnState3{``0,``1})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state3">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``1(Microsoft.MMF.States.VoidState3{``0})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state3">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturnsByCalling``2(Microsoft.MMF.States.ReturnState3{``0,``1},System.Func{System.Object[],``1})">
            <summary>
            Sets a delegate that can supply a return value when the expected method is called.  The delegate 
            can return custom values depending on the methods' arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property that we're mocking</typeparam>
            <param name="state3">The previous state</param>
            <param name="returnHandler">A delegate that will supply the return value for this expectation depending on the methods' arguments</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringArgumentsAt``1(Microsoft.MMF.States.VoidState3{``0},System.Int32[])">
            <summary>
            Tells the expectation to ignore arguments at specific indexes.  The indexes are 0-based.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state3">The previous state</param>        
            <param name="indexes">The indexes of the arguments to ignore</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringArgumentsAt``2(Microsoft.MMF.States.ReturnState3{``0,``1},System.Int32[])">
            <summary>
            Tells the expectation to ignore arguments at specific indexes.  The indexes are 0-based.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The previous state</param>        
            <param name="indexes">The indexes of the arguments to ignore</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringAllArguments``1(Microsoft.MMF.States.VoidState3{``0})">
            <summary>
            Tells the expectation to ignore all arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state3">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.IgnoringAllArguments``2(Microsoft.MMF.States.ReturnState3{``0,``1})">
            <summary>
            Tells the expectation to ignore all arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The previous state</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.WithValidatingCallback``1(Microsoft.MMF.States.VoidState3{``0},Microsoft.MMF.CallbackHandler)">
            <summary>
            Sets a callback method for the current method expectation.  This callback is invoked in order to validate
            the arguments that were passed into the method.  If the CallbackHandler returns true, the API assumes
            that the expectation was matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state3">The previous state</param>
            <param name="callback">A callback that validates the arguments of the method</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.WithValidatingCallback``2(Microsoft.MMF.States.ReturnState3{``0,``1},Microsoft.MMF.CallbackHandler)">
            <summary>
            Sets a callback method for the current method expectation.  This callback is invoked in order to validate
            the arguments that were passed into the method.  If the CallbackHandler returns true, the API assumes
            that the expectation was matched.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The previous state</param>
            <param name="callback">A callback that validates the arguments of the method</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturns``2(Microsoft.MMF.States.ReturnState4{``0,``1},``1)">
            <summary>
            Sets the return value for this expectation.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state4">The previous state</param>
            <param name="returnValue">The return value</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``2(Microsoft.MMF.States.ReturnState4{``0,``1})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``1(Microsoft.MMF.States.VoidState4{``0})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturnsByCalling``2(Microsoft.MMF.States.ReturnState4{``0,``1},System.Func{System.Object[],``1})">
            <summary>
            Sets a delegate that can supply a return value when the expected method is called.  The delegate 
            can return custom values depending on the methods' arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property that we're mocking</typeparam>
            <param name="state4">The previous state</param>
            <param name="returnHandler">A delegate that will supply the return value for this expectation depending on the methods' arguments</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturns``2(Microsoft.MMF.States.ReturnState5{``0,``1},``1)">
            <summary>
            Sets the return value for this expectation.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state5">The previous state</param>
            <param name="returnValue">The return value</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``2(Microsoft.MMF.States.ReturnState5{``0,``1})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property we're mocking</typeparam>
            <param name="state5">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndDoesDefault``1(Microsoft.MMF.States.VoidState5{``0})">
            <summary>
            Tells the mock to do the default action when the expectation is met.  If the mock
            is mocking a concrete method, then that method will be called.  Otherwise, the 
            default value will be returned or the method will be eaten.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <param name="state5">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.AndReturnsByCalling``2(Microsoft.MMF.States.ReturnState5{``0,``1},System.Func{System.Object[],``1})">
            <summary>
            Sets a delegate that can supply a return value when the expected method is called.  The delegate 
            can return custom values depending on the methods' arguments.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The return type of the method / property that we're mocking</typeparam>
            <param name="state5">The previous state</param>
            <param name="returnHandler">A delegate that will supply the return value for this expectation depending on the methods' arguments</param>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.InvokeMockMethod``2(Microsoft.MMF.MockObjectWrapper{``0,``1},System.Delegate)">
            <summary>
            This is a private method that invokes a delegate which sets an expectation on a particular
            method on the mock object.
            </summary>
            <typeparam name="T">The object type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="mock">The mock object to invoke the handler on</param>
            <param name="handler">The handler to invoke</param>        
            <exception cref="T:Microsoft.MMF.Exceptions.MockRecordingException">Thrown if the mock method was not actually called.  This can happen if the mock is not being redirected, or if the mocked method is not virtual.</exception>
        </member>
        <member name="M:Microsoft.MMF.MockExtensionMethods.FindNonPublicMethod(System.String,System.Object[],System.Object)">
            <summary>
            This private method is used to search the mock object for a method by its name and parameter types.
            If no method by that name, with those parameters, can be found, then a MockRecordingException is thrown.
            </summary>
            <param name="methodName">The name of the method to find</param>
            <param name="args">The arguments of the method</param>
            <param name="mock">The mock object</param>
            <returns>A MethodInfo that can be used to set an expectation on the mock object</returns>
        </member>
        <member name="T:Microsoft.MMF.ExtensionMethods">
            <summary>
            This class has a number of extension methods used throughout the application.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.ExtensionMethods.Append(System.String,System.String)">
            <summary>
            Used for easy syntax in creating strings with string builder.
            </summary>
            <param name="s">The string to append to.</param>
            <param name="appendedString">This is the string that gets appended to s</param>
            <returns>A new string builder.</returns>
        </member>
        <member name="M:Microsoft.MMF.ExtensionMethods.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The default foreach extension method does not work with anything other than lists.
            </summary>
            <typeparam name="T">The type of object to enumerate through.</typeparam>
            <param name="enumerable">The enumerable to iterate through.</param>
            <param name="handler">The handler to invoke for each item.</param>
        </member>
        <member name="M:Microsoft.MMF.ExtensionMethods.ToTypeArray(System.Reflection.ParameterInfo[])">
            <summary>
            This helpful utility method converts an array of parameter info's into an
            array of Types.
            </summary>
            <param name="parameters">An array of ParameterInfos</param>
            <returns>An array of Types</returns>
        </member>
        <member name="M:Microsoft.MMF.ExtensionMethods.ReturnType(System.Reflection.MethodBase)">
            <summary>
            The method base class has no ReturnType property.  So, to make parity between
            ConstructorInfo's and MethodBase's, we have this extension method - which 
            returns void if the method base is a ConstructorInfo, or it returns the actual MethodInfo's
            return type if it's a MethodInfo.
            </summary>
            <param name="methodBase">The method base to get a return type for</param>
            <returns>Void if the method is a constructor.  Otherwise, the type returned from the MethodInfo</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.VarArgsParameters">
            <summary>
            This class contains the parameters neccessary for emitting a varargs call.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.VarArgsParameters.#ctor(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Creates the varargs parameters class.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.VarArgsParameters.Method">
            <summary>
            gets / sets the method.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.VarArgsParameters.CallTypes">
            <summary>
            Gets / sets an array of call types.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.TestHarnessAssemblyGenerator">
            <summary>
            This singleton creates and stores the assembly builder that is used to create all of the types
            used by the TestHarness class.  We need to create a singleton instance of the assembly builder so 
            that we can have a single dynamic assembly with a static name  Otherwise, we wouldn't be able to 
            support the InternalsVisibleTo attribute.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.DynamicTypeFactory">
            <summary>
            This is the base class for all factory objects.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.DynamicTypeFactory.mAssemblyName">
            <summary>
            This is the name of the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.DynamicTypeFactory.mAssemblyBuilder">
            <summary>
            The assembly builder is used to create the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.DynamicTypeFactory.mModuleBuilder">
            <summary>
            The module builder creates the module.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.#ctor(System.String)">
            <summary>
            Only subclasses can create this class.
            </summary>
            <param name="name">The name of the dynamic assembly to create</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.Finalize">
            <summary>
            Implement a finalizer that writes the dynamic assembly to disk when the program exits.  This is 
            not the ideal way to do this, but we can't expect individual tests to save this (or know when to,
            since they will run in a random order).
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.RegularMethods(System.Type)">
            <summary>
            Returns an enumerable list of methods that should be mocked or stubbed.
            </summary>
            <param name="type">The type to find methods for</param>
            <returns>An enumerable of methods</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.PrivateMethods(System.Type)">
            <summary>
            Returns an enumerable list of private methods to be mocked or stubbed.  Only private methods
            on the declared type are returned.
            </summary>
            <param name="type">The type to enumerate through</param>
            <returns>An enumerable of methods to mock or stub</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.PublicStaticMethods(System.Type[])">
            <summary>
            Returns an enumerable of public static methods to mock from an array of static types.
            </summary>
            <param name="staticTypes">An array of types to mock</param>
            <returns>An enumerable of public static methods from each of these types to mock</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.PrivateStaticMethods(System.Type[])">
            <summary>
            Returns an enumerable of private static methods to mock from an array of static types.
            </summary>
            <param name="staticTypes">An array of types to mock</param>
            <returns>An enumerable of private static methods from each of these types to mock</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.DynamicTypeFactory.GenerateTypeFromTemplate``2(Microsoft.MMF.Generation.EClassTemplateTypes,Microsoft.MMF.Generation.EMethodTemplateTypes,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Object[])">
            <summary>
            This is the code that will generate a mock or stub object using the template of a particular type.
            </summary>
            <typeparam name="T">The type of object to generate a mock for</typeparam>
            <typeparam name="U">The base class of the object</typeparam>
            <param name="templateType">The class template type to use</param>
            <param name="methodTemplateType">The method template type to use</param>
            <param name="includePrivateMethods">True if the type that's generated includes private methods</param>
            <param name="methods">A sequence of methods to mock</param>
            <param name="args">The arguments to the constructor</param>
            <returns>An instance of U</returns>
        </member>
        <member name="F:Microsoft.MMF.Generation.TestHarnessAssemblyGenerator.mInstance">
            <summary>
            The one and only instance of this generator.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TestHarnessAssemblyGenerator.#cctor">
            <summary>
            Creates the singleton instance.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TestHarnessAssemblyGenerator.#ctor">
            <summary>
            Creates the test harness assembly and make it debuggable!
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TestHarnessAssemblyGenerator.AssemblyBuilder">
            <summary>
            Returns the assembly builder object.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TestHarnessAssemblyGenerator.ModuleBuilder">
            <summary>
            Returns the module builder object.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.TypeSpecialCase">
            <summary>
            Handles the special cases where the code calls Type.GetType(...).
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.TypeSpecialCase.#ctor">
            <summary>
            Creates the special case.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.TypeSpecialCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Returns true if a method matches this special case.
            </summary>
            <param name="method">The method to match</param>
            <returns>True if it matches; otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.TypeSpecialCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code to handle Type.GetType(...).  We need to do this because dynamic assemblies aren't able 
            to resolve modules, so we need to intercept the calls and do it manually.
            </summary>
            <param name="matchingMethod">The method base that was matched</param>
            <param name="tracker">The opcode tracker to use to patch</param>
        </member>
        <member name="T:Microsoft.MMF.Recorder">
            <summary>
            The UnorderedRecording class is defined inside the Recorder class to make sure 
            it can only be created using the StartUnorderedRecording method.
            </summary>
            <summary>
            The OrderedRecording class is defined inside the Recorder class to make sure 
            it can only be created using the StartOrderedRecording method.
            </summary>
            <summary>
            The Recorder class is a singleton that is used to build and walk the state machine that is created
            during mock recordings and replays.  Because the Recorder class is a singleton, only one test can execute 
            at any given time within a single AppDomain.  The Recorder class is currently not thread-safe.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mInstance">
            <summary>
            This is the one and only instance of the recorder.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mIsRecording">
            <summary>
            This is true when the recorder is recording method calls.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mIsOrdered">
            <summary>
            When true, the recorder will record methods in an ordered fashion.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mWasCalled">
            <summary>
            This bool is used to ensure that mocked or mimicked methods 
            actually call the Recorder.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mReturnValueWasSet">
            <summary>
            This bool is set to true when an expectations return value is set.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mInitialState">
            <summary>
            This is the initial state of the state machine.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mCurrentState">
            <summary>
            This is the current state of the state machine.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mPreviousState">
            <summary>
            The previous state.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mCurrentExpectation">
            <summary>
            This is the current expectation.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mStateCount">
            <summary>
            These are the number of states created in the recorder.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mLog">
            <summary>
            This log records all of the method comparisons that took place during a replay.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mRecordingTypeStack">
            <summary>
            This stack keeps track of whether we are doing ordered or unordered recordings.
            True values indicate that yes, this is an ordered recording.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Recorder.mTransitionStack">
            <summary>
            Whenever we make a transition from one type of recording to another, we
            put the current state on the top of this stack so that we can refer to it later.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.#cctor">
            <summary>
            The static constructor creates the singleton instance of the Recorder object.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.#ctor">
            <summary>
            Only one of these.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.Ordered">
            <summary>
            Returns a new ordered recording.  Any method expectations set before the object returned
            from this method is disposed will have their order recorded.
            </summary>
            <returns>An ordered recording object.</returns>
        </member>
        <member name="M:Microsoft.MMF.Recorder.Unordered">
            <summary>
            Returns a new unordered recording.  Any method expectations set before the object returned
            from this method is disposed will not have their order recorded.
            </summary>
            <returns>An unordered recording object.</returns>
        </member>
        <member name="M:Microsoft.MMF.Recorder.StartOrderedRecording">
            <summary>
            Starts an ordered recording.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.StartUnorderedRecording">
            <summary>
            Starts an unordered recording.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.ValidateReplay">
            <summary>
            Validates that the current state is a final state.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.ValidateReplay(System.Boolean)">
            <summary>
            Validates the replay and saves the replay log to disk.
            </summary>
            <param name="saveReport">When true, a report XML file will be saved in the output directory</param>
        </member>
        <member name="M:Microsoft.MMF.Recorder.Reset">
            <summary>
            Resets the state machine to it's initial state before anything gets recorded.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.RecordMethodCall(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>
            Records a method call into the state machine.  This method is called from
            inside the the mock objects, and only during the recording phase.  Calling it creates a new expectation
            on the current state machine.
            </summary>
            <param name="callingObject">The object that we are recording</param>
            <param name="callingMethod">The method that we are recording</param>
            <param name="args">The arguments of the method</param>
        </member>
        <member name="M:Microsoft.MMF.Recorder.BacktrackCurrentExpectation">
            <summary>
            In cases where an expectation is set where the min # of times is 0,
            this method will backtrack the expectation so that it's as though the current
            expectation is an unordered expectation on the previous expectation.  This way something
            like:
            
            mock1.Expects(m => m.Whatever()).ToBeCalledAnyNumberOfTimes();
            mock1.Expects(m => m.Whatever());
            
            Can work properly.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.CheckThatReturnValueWasSet">
            <summary>
            Checks that, if applicable, the last method that had an expectation set on it had its return value set.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.IsOrdered">
            <summary>
            The recorder will record in an ordered fashion when this is true.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.IsRecording">
            <summary>
            True when the recorder is recording.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.WasCalled">
            <summary>
            This is set to true after the RecordNextMethodCall is called,
            and after the AutomataState.MoveToNextState method is called.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.ReturnValueWasSet">
            <summary>
            This is set to true after an expectations return value is set.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.InitialState">
            <summary>
            Gets / sets the initial expectation that is created once a recording begins.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.CurrentExpectation">
            <summary>
            Returns the current method expectation.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.CurrentState">
            <summary>
            Gets / sets the current state.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.PreviousState">
            <summary>
            Gets / sets the previous state.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.StateCount">
            <summary>
            This is the number of states that have been created in the state machine.  
            It should be reset when a new recording begins, and then incremented when a new state
            is added to the recorder.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.ExpectationLog">
            <summary>
            Returns the expectation log.  The log can be used to debug failed tests and to view the history
            of method calls that came into the Recorder class.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.RecordingTypeStack">
            <summary>
            Returns the recording type stack.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Recorder.TransitionStack">
            <summary>
            Returns the transition stack.  These are the states that were current 
            when the order switched from Ordered to Unordered, or vice versa.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Recorder.UnorderedRecording">
            <summary>
            This class is used in using statements to tell the recorder when to 
            switch to unordered method calls.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.UnorderedRecording.#ctor">
            <summary>
            Creates the ordered recorder.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.UnorderedRecording.Dispose">
            <summary>
            When this is disposed of manually, revert to the original value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Recorder.OrderedRecording">
            <summary>
            This class is used in using statements to tell the recorder when to 
            switch to ordered method calls.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.OrderedRecording.#ctor">
            <summary>
            Creates the ordered recorder.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Recorder.OrderedRecording.Dispose">
            <summary>
            When this is disposed of manually, revert to the original value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.ShortInlineBrTargetTranslator">
            <summary>
            Translates an short inline br instruction.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineBrTargetTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineBrTargetTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the ShortInlineBr instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineBrTargetTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an ShortInlineBr operand.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineBrTargetTranslator">
            <summary>
            Translates an inline break statement.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineBrTargetTranslator.#ctor">
            <summary>
            Constructor does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineBrTargetTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline break statement using the specific context.  To make this work, 
            we need to define a label that can be used later for break statements.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineBrTargetTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an opcode whose operand type is InlineBr.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Instruction">
            <summary>
            This is the base class for all instruction objects.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Instruction.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Instruction.OpCode">
            <summary>
            Gets / sets the opcode.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.ExpectationLogEntry">
            <summary>
            This is a data structure that represents a method expecation match or failure.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ExpectationLogEntry.#ctor">
            <summary>
            Creates the expectation log entry.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.FromState">
            <summary>
            This is the state number where we are where we make the comparison.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.ToState">
            <summary>
            This is the state number where we are comparing where we go to.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.Method">
            <summary>
            This is the method that we expected to be called.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.IterationNumber">
            <summary>
            This is the iteration that this method was compared against.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.IsDefaultRange">
            <summary>
            To handle cases where we have expectations that loop back
            on themselves, this bool is set to false to indicate that 
            we should print it out for debug logs.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.Succeeded">
            <summary>
            This is the result of the expectation matching.  True if successful, otherwise,
            false.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLogEntry.ErrorMessage">
            <summary>
            This is the error message that explains why the comparison didn't succeed.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.ArgumentObjectArrayPatch">
            <summary>
            This patch generates an object array and pushes the values of the arguments 
            of the mocked method into the array.  The value left on the top of the stack 
            is an object array filled with the arguments' values.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.ArgumentObjectArrayPatch.#ctor">
            <summary>
            Creates the patch.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.ArgumentObjectArrayPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code with an object array that is filled with the arguments of the translated method.
            </summary>
            <param name="tracker">The opcode tracker</param>
        </member>
        <member name="T:Microsoft.MMF.States.VoidState2`1">
            <summary>
            Represents the second state in the expectation building process.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.VoidState3`1">
            <summary>
            Represents the third state in the expectation building process.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.VoidState4`1">
            <summary>
            Represents the fourth state in the expectation building process.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.VoidState5`1">
            <summary>
            Represents the fifth state in the expectation building process.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.VoidState6`1">
            <summary>
            Represents the sixth state in the expectation building process.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.StubVoidState2`2">
            <summary>
            Represents the second state in a stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
        </member>
        <member name="T:Microsoft.MMF.States.StubState`2">
            <summary>
            This is the base class for all stub states.  It has a number of properties that are 
            used to set up the stub during the arrange and assert stages.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.StubState`2.#ctor(`1)">
            <summary>
            Creates the stub state.
            </summary>
            <param name="stubbedObject">The object that is stubbed</param>
        </member>
        <member name="P:Microsoft.MMF.States.StubState`2.StubbedObject">
            <summary>
            Allow the void states to hold a reference to the stubbed object.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.StubState`2.IgnoresAllArguments">
            <summary>
            Allows the void states to hold 
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.StubState`2.ArgumentsToIgnore">
            <summary>
            Gets / sets the arguments to ignore array.  
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.StubState`2.Callback">
            <summary>
            Gets / sets a callback delegate that is used to assert each
            method call on a stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.StubVoidState2`2.#ctor(`1)">
            <summary>
            Creates an instance of StubVoidState2.
            </summary>
            <param name="stubbedObject">The obhect that we're stubbings</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubVoidState3`2">
            <summary>
            This is the third state in the stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubVoidState3`2.#ctor(`1)">
            <summary>
            Creates an instance of state3.
            </summary>
            <param name="stubbedObject">The object that we are stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubVoidState4`2">
            <summary>
            This is the fourth state in the stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubVoidState4`2.#ctor(`1)">
            <summary>
            Creates an instance of state4
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubVoidState5`2">
            <summary>
            This is the fifth state in the stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubVoidState5`2.#ctor(`1)">
            <summary>
            Creates an instance of state5.
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubVoidState6`2">
            <summary>
            This is the sixth state in the stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubVoidState6`2.#ctor(`1)">
            <summary>
            Creates an instance of state6.
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.StartOrderedRecording">
            <summary>
            Starts an ordered recording.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.StartOrderedRecording.IsOrdered">
            <summary>
            The ordered recording is ... ordered.  So this is true.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineStringTranslator">
            <summary>
            Translates an inline string.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineStringTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineStringTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline string.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineStringTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inline string opcode.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineMethodTranslator">
            <summary>
            Translates an inline method.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineMethodTranslator.#ctor">
            <summary>
            Default constructor does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineMethodTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline method call.  This is where a lot of the magic happens.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineMethodTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a method call.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.IMock">
            <summary>
            An interface that all mocks implement.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.IGeneratedObject">
            <summary>
            Defines an object that is generated from the MMF.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IGeneratedObject.IsDoneConstructing">
            <summary>
            True when the constructor is done constructing.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IGeneratedObject.AggregatedObject">
            <summary>
            In cases where we are generating a partial mock, this allows 
            us to call an agregated object instead of the base class.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.StackCounter">
            <summary>
            The stack counter object maintains the number of objects that are on the stack,
            based on the instruction that comes into the Increment method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.StackCounter.mResolveModule">
            <summary>
            This is the module that we use to resolve tokens.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.StackCounter.mGenericTypeArguments">
            <summary>
            These are the types of the generic type arguments.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.StackCounter.mGenericMethodTypeArguments">
            <summary>
            These are the types of the generic method arguments.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.StackCounter.#ctor(System.Reflection.Module,System.Type[],System.Type[])">
            <summary>
            Creates the stack counter.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.StackCounter.Update(Microsoft.MMF.Generation.ILInstruction)">
            <summary>
            Updates the count based on the instruction before it operates.
            </summary>
            <param name="instruction">The instruction to update on</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.StackCounter.Reset">
            <summary>
            Resets the counter
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.StackCounter.StackCount">
            <summary>
            Gets / sets the current count.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.NameManager">
            <summary>
            The name manager class helps us generate unique names for auto-generated types.  It's a singleton
            to make sure that in any given app domain, there are no name conflicts between types.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.NameManager.mInstance">
            <summary>
            This is the singleton instance of the manager.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.NameManager.mTypeNameToCountMap">
            <summary>
            This dictionary maps types to the number of instances of a type to make sure that 
            we never generate the same type twice.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.NameManager.#cctor">
            <summary>
            The static constructor creates the NameManager instance.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.NameManager.#ctor">
            <summary>
            Private constructor is only instantiated one time.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.NameManager.GetNameForType(System.Type,Microsoft.MMF.Generation.EClassTemplateTypes)">
            <summary>
            Returns a unique name for a mock or stub of a particular type.
            </summary>
            <param name="type">The type to generate a name for</param>
            <param name="classTemplate">The class template to generate a name for</param>
            <returns>A unique name for this type</returns>
        </member>
        <member name="T:Microsoft.MMF.Constraints.IsOneOfConstraint`1">
            <summary>
            Checks to see the argument value is one of a list of values.
            </summary>
            <typeparam name="T">The type that the argument value must be one of</typeparam>
        </member>
        <member name="F:Microsoft.MMF.Constraints.IsOneOfConstraint`1.mValues">
            <summary>
            A list of values to check against.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.IsOneOfConstraint`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates the constraint out of the specified index and list of values.
            </summary>
            <param name="argIndex">The argument index to check</param>
            <param name="values">An enumerable list of values to check against</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.IsOneOfConstraint`1.Validate(System.Object)">
            <summary>
            Checks to see if the arg value is in the argument array.
            </summary>
            <param name="argValue">The arg value to check</param>
            <returns>True if the argument value is contained inside the array</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineRTranslator">
            <summary>
            Translates an inline R instruction.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineRTranslator.#ctor">
            <summary>
            Nothing to do
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineRTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline R instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineRTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a double.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.SymbolDocumentFactory">
            <summary>
            Much of this class was taken from Mike Stalls debugging blog at:
            
            http://blogs.msdn.com/jmstall/pages/sample-pdb2xml.aspx
            
            The code here instantiates some COM objects that can read symbol information for us and return
            instances of the right objects so that we can read debugging information from the pdb
            files.  But, this stuff is super messy!
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SymbolDocumentFactory.mDispenserClassID">
            <summary>
            This is the GUID for the dispenser class iD (CLSID_CorMetaDataDispenser)
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SymbolDocumentFactory.mDispenserIID">
            <summary>
            This is the GUID for the dispenser metadata class ID (IID_IMetaDataDispenser)
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SymbolDocumentFactory.mImporterIID">
            <summary>
            This is the GUID for the importer ID (IID_IMetaDataImport)
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SymbolDocumentFactory.mDispenserObject">
            <summary>
            This is the dispenser COM object.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SymbolDocumentFactory.#ctor">
            <summary>
            Creates the symbol document factory.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SymbolDocumentFactory.GetReader(System.String)">
            <summary>
            Returns a symbol reader for a particular assembly file.
            </summary>
            <param name="assemblyFilePath">The file path to the assembly that we should load debug information from</param>
            <returns>The symbol reader</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.SymbolDocumentFactory.IMetaDataDispenser">
            <summary>
            One of the interfaces needed to read debug information.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SymbolDocumentFactory.IMetaDataDispenser.DefineScope_Placeholder">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SymbolDocumentFactory.IMetaDataDispenser.OpenScope(System.String,System.Int32,System.Guid@,System.Object@)">
            <summary>
            
            </summary>
            <param name="szScope"></param>
            <param name="dwOpenFlags"></param>
            <param name="riid"></param>
            <param name="punk"></param>
        </member>
        <member name="T:Microsoft.MMF.Generation.SymbolDocumentFactory.IMetadataImport">
            <summary>
            One of the interfaces needed to read debug information.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SymbolDocumentFactory.IMetadataImport.Placeholder">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Configuration.MMFConfigurationSection">
            <summary>
            This is the configuration section for the MMF project.  Users can add this to to 
            their app.config in order to configure the MMF library to behave a certain way in their tests.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Configuration.MMFConfigurationSection.#ctor">
            <summary>
            Creates the Configuration section.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFConfigurationSection.StrongNameGeneratedAssemblies">
            <summary>
            Determines whether the generated assemblies should be strong-named or not.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFConfigurationSection.CleanupExceptions">
            <summary>
            Determines whether exceptions thrown from redirected methods should be cleaned up so that they
            are more readable.  For debug builds, the default value is true.  For release builds, it is false.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFConfigurationSection.WriteRecordingLogByDefault">
            <summary>
            Determinse whether the recording logs are saved to disk or not on validation failures.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFConfigurationSection.SaveGeneratedAssembliesToDisk">
            <summary>
            Determinse whether the recording logs are saved to disk or not on validation failures.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.MimicTestExtensionMethods">
            <summary>
            This class contains the extension methods for the Test class.  This is where we run
            tests using the redirection API.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MimicTestExtensionMethods.ByCalling``3(Microsoft.MMF.States.MimicTestState1{``0,``1},Microsoft.MMF.ObjectWrapper{``1,``2})">
            <summary>
            Tells the test to call a specific mock object in order to redirect a particular object instance or type
            </summary>
            <typeparam name="T">The type of object that the test is testing</typeparam>
            <typeparam name="U">The type of object that we are mocking</typeparam>
            <typeparam name="V">The type that we refer to U by</typeparam>
            <param name="state1">The previous state</param>
            <param name="wrapper">An object wrapper that aggregates the actual mock object</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTestExtensionMethods.ByCalling``2(Microsoft.MMF.States.MimicTestState1{``0,``1},``1)">
            <summary>
            Tells the test to redirect a call to a particular object instance.  This does not need to be an MMF 
            generated mock or stub - it could be anything!
            </summary>
            <typeparam name="T">The type we are testing</typeparam>
            <typeparam name="U">The type we are redirecting</typeparam>
            <param name="state1">The previous state</param>
            <param name="objectInstance">The instance to call when the redirected object or type is invoked</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTestExtensionMethods.ByReturning``2(Microsoft.MMF.States.MimicTestState2{``0,``1},Microsoft.MMF.ObjectWrapper{``1,``1})">
            <summary>
            Tells the test to return a strongly typed mock or stub when a new object of type U is created.  The wrapper
            can be null, but cannot be a mimic as the return value will be cast as whatever type the constructor creates.
            </summary>
            <typeparam name="T">The type of object that the test is testing</typeparam>
            <typeparam name="U">The type of object that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="wrapper">An object wrapper that aggregates the actual mock object</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTestExtensionMethods.ByReturning``2(Microsoft.MMF.States.MimicTestState2{``0,``1},``1)">
            <summary>
            Tells the test to return a particular object or stub when a new object of type U is created.
            </summary>
            <typeparam name="T">The type of object that the test is testing</typeparam>
            <typeparam name="U">The type of object that we are mocking</typeparam>
            <param name="state2">The previous state</param>
            <param name="returnObject">An object to return when a new object is created</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTestExtensionMethods.ByReturning``2(Microsoft.MMF.States.MimicTestState2{``0,``1},Microsoft.MMF.IMimicObjectWrapper{``1})">
            <summary>
            Tells the test to return a mimic when a new object is newed up.
            </summary>
            <typeparam name="T">The type we are testing</typeparam>
            <typeparam name="U">The type we are returning</typeparam>
            <param name="state2">The second state</param>
            <param name="mimicWrapper">The object that wraps the mimic</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTestExtensionMethods.ByReturningUninitializedObjects``2(Microsoft.MMF.States.MimicTestState2{``0,``1})">
            <summary>
            Tells the test to return an uninitialized object whenever a new instance of type U is created.  Uninitialized
            objects are dynamically created types, but their constructors have not been invoked.  This method is very useful for
            cases where you want to stub a call to constructors of type U but still want to have an object instance returned 
            from the new call.
            </summary>
            <typeparam name="T">The type of object that the test is testing</typeparam>
            <typeparam name="U">The type of object that we are mocking</typeparam>
            <param name="state2">The previous state</param>
        </member>
        <member name="T:Microsoft.MMF.MMFType">
            <summary>
            Defines the base class for all mmf types.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MMFType.#ctor">
            <summary>
            Creates the base type for all MMFTypes.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.MMFStatic">
            <summary>
            This class is a placeholder for creating mocks and stubs that can set expectations on static methods.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MMFStatic.#ctor">
            <summary>
            The default constructor.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.MMFStatic.StaticTypes">
            <summary>
            This is an array of all of the types that this static object inherits from.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.MMFMimic">
            <summary>
            This is a placeholder for creating expectations on mimics.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.StoreRefAndOutParametersPatch">
            <summary>
            This patch is used to store out arguments by assigning them to the specified argument indexes.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.StoreRefAndOutParametersPatch.#ctor">
            <summary>
            Creates the store out parameters patch.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.StoreRefAndOutParametersPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code so that the out parameters array that's on top of the stack has it's indexes at 
            various points assigned to the out parameters that were passed into the method.
            </summary>
            <param name="tracker">The tracker object</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.GetCurrentTypePatch">
            <summary>
            Returns the type that we are currently generating.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetCurrentTypePatch.#ctor">
            <summary>
            Creates the patch.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetCurrentTypePatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code so that the current type is left on the stack.
            </summary>
            <param name="tracker">The tracker to use to patch the method</param>
        </member>
        <member name="T:Microsoft.MMF.StubFactory">
            <summary>
            This class is used to generate stub objects.  Stubs can be used to follow the arrange / act / assert pattern.
            In the first stage of a unit test a stubs behavior is defined.  In the second phase, the test code is executed,
            and in the third stage, the test asserts (optionally) that certain methods were called a certain number of times 
            and with certain argument values.  By default, stubs do not have any behavior defined at all.  A call to a stubbed 
            method simply calls into the base class, or returns the default value of that method if it is abstract.  Specific 
            behavior must be programmed into the stub during the arrangement phase.  At the same time, stubs will not throw
            any exceptions if they were called without an arrangement set on them.  Stubs do not need to be asserted.  It is up
            to the tester to decide whether they want to assert that a method was called or not.
            
            Stubs do not have any concept of order to them; that is, it is not possible to assert that method A() was called
            on stub 1 before method B() was called on stub 2.  It is also not possible to assert that A was called before B on
            the same object.  To do that sort of testing, use the mock framework.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StubFactory.mInstance">
            <summary>
            This is the one and only instance of the stub factory.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.#cctor">
            <summary>
            The static constructor will create the dyanmic assembly.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.#ctor">
            <summary>
            Can't be instantiated.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.Create``1(System.Object[])">
            <summary>
            Creates a stub object that extends or implements type T.  Any method calls to virtual methods 
            on type T will be automatically redirected to the stub.  In order to redirect method calls to 
            non-virtual methods, the stub will need to be used within a Test.
            </summary>
            <typeparam name="T">The type to generate and return</typeparam>
            <param name="args">These are the arguments for the constructor of the stub</param>
            <returns>A stub object wrapper</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.DynamicTypeCreationException">Thrown if T is sealed</exception>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.CreateMimic``1">
            <summary>
            Creates a stub mimic object of type T.  The mimic will not inherit from T in any way.  Instead,
            it will simply copy all of the method signatures and names from T and implement stubbed
            versions of them instead.  The dynamic keyword in .NET 4.0 allows stub mimics to be used in place
            of the objects they are stubbing since the method calls are determined dynamically at runtime.
            MimicTests also allow users to manually map object instances to mimics that define the same 
            methods.
            </summary>
            <typeparam name="T">The type we are stubbing</typeparam>
            <returns>A stub object wrapper</returns>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.CreateMimic``1(System.Boolean)">
            <summary>
            Creates a stub mimic out of object T. The extra boolean in the method parameters determines whether the 
            mimic also implements the private methods of the target type T.  By default, the mimic not implement private 
            methods, but you can change this behavior by passing true into this method.
            </summary>
            <typeparam name="T">The type to mimic</typeparam>
            <param name="includePrivateMethods">Determines whether the mimic should also mock private methods on type T</param>
            <returns>A stub object wrapper</returns>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.CreateMimic``1(``0)">
            <summary>
            Creates a stub mimic object of type T that aggregates another object.  Normally, when a mimic is created,
            any non-stubbed method will return the default value of that method type - or just stub the call by default. 
            That happens because the mimic does not inherit from what it's mimicking.  So in order to have a default implementation
            called in the event that a method isn't stubbed, this overload will create a mimic that aggregates another object of
            type T which will be called in these cases.
            </summary>
            <typeparam name="T">The type we are stubbing</typeparam>
            <param name="aggregatedObject">An instance of T to be called for all non-stubbed method calls</param>
            <returns>A stub object wrapper</returns>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.CreateMimic``1(System.Boolean,``0)">
            <summary>
            Creates a new partial mimic of type T that optionally implements the private methods on type T.
            </summary>
            <typeparam name="T">The type to mimic</typeparam>
            <param name="includePrivateMethods">Determines whether the mimic should also mock private methods on type T</param>
            <param name="aggregatedObject">An instance of T to be called for all non-stubbed method calls</param>
            <returns>A stub object wrapper</returns>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.CreateStatic(System.Type[])">
            <summary>
            Creates a stub object wrapper that can be used to stub the static methods on the types that are passed 
            into this method.  If the invoked method has not been stubbed, the stub will call the static method
            instead.
            </summary>
            <param name="staticTypes">A list of static types to stub</param>
            <returns>A stub object wrapper that can stub each of these types</returns>
        </member>
        <member name="M:Microsoft.MMF.StubFactory.CreateStatic(System.Boolean,System.Type[])">
            <summary>
            Creates a stub object wrapper that can be used to stub the static methods on the types that are passed in.
            The includePrivateMethods bool allows users to stub private methods as well as public ones.
            </summary>
            <param name="includePrivateMethods">When true, the stub will include the private methods on the types that passed in</param>
            <param name="staticTypes">An array of types to stub</param>
            <returns>A stub object wrapper that can stub each of these types</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.TranslatorFactory">
            <summary>
            This class is used to return a specific factory for a specific operand type.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TranslatorFactory.mShouldRedirect">
            <summary>
            When true, the translators should redirect method calls.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TranslatorFactory.mResolveModule">
            <summary>
            This is the module used to resolve fields, methods, etc.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TranslatorFactory.mGenericTypeArguments">
            <summary>
            These are the generic type arguments.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TranslatorFactory.mGenericMethodArguments">
            <summary>
            These are the generic method types.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TranslatorFactory.#ctor(System.Reflection.Module,System.Type[],System.Type[],System.Boolean)">
            <summary>
            Creates the factory.
            </summary>
            <param name="resolveModule">The module used to resolve tokens</param>
            <param name="genericOwnerTypes">The type params for the generic type</param>
            <param name="genericMethodTypes">The type params for the generic method</param>
            <param name="shouldRedirect">When true, the translators will redirect code to use reflection instead of what it was compiled against</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.TranslatorFactory.GetTranslator(Microsoft.MMF.Generation.Instruction)">
            <summary>
            Returns a specific translator for a given operand type.
            </summary>
            <param name="instruction">The instruction to get a translator for</param>
            <returns>An ITranslator object that can translate the current instruction</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.RedirectionHelper">
            <summary>
            This class contains a number of helper methods that the redirection API will call instead 
            of the compiled opcodes.  This allows us to get around some issues with visibility checks
            that cropped up in CLR4.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_ISINST">
            <summary>
            This is the IsInst method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_NEWARR">
            <summary>
            This is the newarr method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_THROW">
            <summary>
            This method traps calls to the throw opcode.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_BOX">
            <summary>
            This is the box method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_UNBOX">
            <summary>
            This is the unbox method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_LDFLD">
            <summary>
            This method traps all ldfld calls.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_LDFLDA">
            <summary>
            This traps all ldflda calls so that we can compute the address of a field.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_STFLD">
            <summary>
            This method traps all stfld calls.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_LDFTN">
            <summary>
            This method traps all ldftn calls.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_LDVIRTFTN">
            <summary>
            This method traps all ldvirtldftn calls.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_START_REDIRECTION">
            <summary>
            This method is called when a profiled method starts.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_END_REDIRECTION">
            <summary>
            This method is called when a profiled method ends.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_METHOD">
            <summary>
            This method is used to trap method calls for redirected methods.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_METHOD_INVOKE_METHOD">
            <summary>
            This method is used to trap method calls to the reflection API.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_TYPE_GETTYPE_METHOD">
            <summary>
            This is the method that is used to handle calls to Type.GetType(string).
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_DELEGATE_BEGIN_INVOKE">
            <summary>
            This is the method that is used to handle calls to Delegate.BeginInvoke(...)
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.TRAP_NEW">
            <summary>
            This method is used to trap new object calls for redirected methods.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.#cctor">
            <summary>
            Creates the redirection helper.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.#ctor">
            <summary>
            Nothing to do.  can't be instantiated.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapIsInst(System.Object,System.RuntimeTypeHandle)">
            <summary>
            This method replaces the isinst opcode, which now checks visibility of the type
            when it executes.  Instead of emitting isinst, redirection will emit ldtoken and a 
            method call to this method.  ldtoken is allowed in the CLR4 rules, and this method 
            checks whether o1 is an instance of a given type using reflection.
            </summary>
            <param name="instance">The instance to check</param>
            <param name="typeHandle">The type handle to check</param>
            <returns>True if the object can be assigned to a given type</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapNewarr(System.Int32,System.RuntimeTypeHandle)">
            <summary>
            Instantiates an array of a certain type with a certain dimension using reflection.
            </summary>
            <param name="size">The size of the array</param>
            <param name="typeHandle">The type of the array to create</param>
            <returns>An array of a certain size that contains a certain type</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapBox()">
            <summary>
            Boxes a value type programatically to avoid visibility checks.
            </summary>        
            <returns>A boxed version of the value type that was passed in</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapUnbox()">
            <summary>
            Allows us to unbox an object and set the value directly.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapLdfld()">
            <summary>
            Grabs the value of a field.  If the field is a reference type, then it is returned.
            Otherwise, this method expects the value type to be passed in by reference, where it will
            be set.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapStfld()">
            <summary>
            Stores the value of a field into the object passed into this method.  The object can be a reference 
            or value type, it doesn't matter.  
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapLdflda()">
            <summary>
            Traps the ldflda opcodes.  The first arg should be the instance, or null if the field is static.
            The second arg should either be an IntPtr or an object reference.
            </summary>
            <returns>A pointer to the field</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapLdftn(System.Reflection.MethodBase)">
            <summary>
            Traps a call to the ldftn opcode and determines whether the method should be redirected 
            or not.
            </summary>
            <param name="methodBase">A method to return the address for</param>
            <returns>The address of a method to invoke</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapLdvirtftn(System.Object,System.Reflection.MethodBase)">
            <summary>
            Traps a call to the ldvirtftn method, which occurs when we are loading a function 
            pointer to a virtual method.
            </summary>
            <param name="target">The object where the method is being loaded from</param>
            <param name="methodBase">The method to load</param>
            <returns>A function pointer to the method</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapStartRedirection()">
            <summary>
            This method is called to redirect a root method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapEndRedirection()">
            <summary>
            This method is called when a profiled method ends.  This is how we will notify any listeners via the 
            profiler API that the method is finished.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapMethod()">
            <summary>
            Traps a method call from a redirected method.  The arglist parameter allows us to handle any number of 
            arbitrary arguments.  The last method should always be the MethodBase that we're trapping.
            </summary>        
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapReflectionInvocation()">
            <summary>
            Traps a method call to a reflection invocation.  There are a number of methods that this helper traps, 
            depending on the overridden method.  ConstructorInfo objects define their own overrides, while MethodInfo
            uses the default methods defined in the MethodBase class.
            
            Trapping reflection calls with this method allows us to redirect them, even if they are late-bound calls.
            </summary>
            <returns>The result of invoking the method</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapTypeGetTypeMethod()">
            <summary>
            Type.GetType does not return any values from redirected methods.  It's not entirely clear why, but to 
            get around this, we need to handle it manually.
            
            The first argument is the typename to load.  The second is the original methodbase from which the call was
            compiled into.  From this, we can get the method's assembly and use that to resolve the type.
            </summary>
            <returns>The result of the operation</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapDelegateBeginInvoke()">
            <summary>
            Handles calling begin method delegates asynchronously.
            </summary>
            <returns>The IAsyncResult from calling the delegate</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapThrow(System.Exception)">
            <summary>
            Traps a call to throw, allowing us to send an event to the profiler API before we throw the exception.
            </summary>
            <param name="exception">The exception that's about to be thrown</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.TrapNew()">
            <summary>
            Traps a call to a constructor that is newing an object or value type.
            </summary>
            <returns>The new instance of the object.  Or, if it's a valud type, null (in those cases, the value is passed in byref)</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.RedirectionHelper.IUnboxHelper">
            <summary>
            We need to be able to reference the UnboxHelper via an abstraction
            so that we can call SetValue without using reflection.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.IUnboxHelper.UnboxAndStoreValue(System.Object,System.TypedReference)">
            <summary>
            Gets the value of the local field and assigns it to the typed reference.
            </summary>
            <param name="boxedValue">The boxed value of a type</param>
            <param name="typedReference">The typed reference to write the value to</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.RedirectionHelper.UnboxHelper`1">
            <summary>
            This class is used to help us unbox objects by reference.  Because we create it via the reflection API,
            we don't get visibility checking issues when SetValue and GetValue are called!  This way, we can write 
            the value of a boxed value type to a TypedReference - IE, a managed pointer - easily, and unbox whatever 
            we need to.  
            </summary>
            <typeparam name="T">The type to unbox</typeparam>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.UnboxHelper`1.UnboxAndStoreValue(System.Object,System.TypedReference)">
            <summary>
            Store the value of a boxed value type into a typedReference.
            </summary>
            <param name="boxedValue">The boxed value to unbox</param>
            <param name="typedReference">The place to store the unboxed value</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1">
            <summary>
            Another sad scenario.  Occasionally, the compiler compiles methods such that objects of type 
            IEnumerator get assigned to fields of type IEnumerator(T).  This principly happens with arrays,
            which for whatever reason, don't implement IEnumerator(T) - just IEnumerator.
            
            So we need some help so that we can set this field through reflection.  To make it happen, we've got this
            helper class that basically just wraps an IEnumerator.
            </summary>
            <typeparam name="T">The type that we are wrapping</typeparam>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.mEnumerator">
            <summary>
            This is the original enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.#ctor(System.Collections.IEnumerator)">
            <summary>
            Creates the enumerator helper.
            </summary>
            <param name="enumerator">The enumerator</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.MoveNext">
            <summary>
            Returns the result from movenext.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.Reset">
            <summary>
            Resets the enumerator.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.Current">
            <summary>
            Returns the current enumerator.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.RedirectionHelper.EnumeratorWrapper`1.System#Collections#IEnumerator#Current">
            <summary>
            Returns the current value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.TemplateMethodAttribute">
            <summary>
            Marks a method as a template method of a certain type.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TemplateMethodAttribute.#ctor(Microsoft.MMF.Generation.EMethodTemplateTypes)">
            <summary>
            Creates a new template method attribute that templates the specified type.
            </summary>
            <param name="methodType">The type of template method</param>
        </member>
        <member name="P:Microsoft.MMF.Generation.TemplateMethodAttribute.Type">
            <summary>
            Gets / sets the method template type.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.GetMethodBasePatch">
            <summary>
            This is the abstract base class for any patch that needs to create generic methods.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetMethodBasePatch.#ctor">
            <summary>
            Default constructor does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetMethodBasePatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Subclasses will still need to provide this.
            </summary>
            <param name="tracker">The tracker object</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetMethodBasePatch.MakeGenericMethod(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Adds IL to the method that makes a concrete method out of a generic method definition.
            </summary>
            <param name="method">The method to make generic</param>
            <param name="tracker">The opcode tracker</param>
        </member>
        <member name="T:Microsoft.MMF.States.MimicTestState`1">
            <summary>
            Defines an object that can be a test state.
            </summary>
            <typeparam name="T">The type that we're testing.</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState`1.#ctor">
            <summary>
            Creates the mimic test state.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState`1.#ctor(Microsoft.MMF.States.MimicTestState{`0})">
            <summary>
            This is the copy constructor.  Clones the variables on the previous state.
            </summary>
            <param name="stateToClone">The state to clone</param>
        </member>
        <member name="P:Microsoft.MMF.States.MimicTestState`1.RedirectedInstance">
            <summary>
            This is the instance that's being redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.MimicTestState`1.RedirectedType">
            <summary>
            This is the type that's being redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.MimicTestState`1.RedirectConstructor">
            <summary>
            True if the constructor for a given type should be redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.MimicTestState`1.CallConstructorAnyway">
            <summary>
            True if the constructor for a given type should be called even if 
            it's being redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.MimicTestState`1.ReturnUninitializedObject">
            <summary>
            When true, a redirected constructor should return a blank object.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.States.MimicTestState`1.Test">
            <summary>
            Gets / sets the test harness.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.MimicTestState`2">
            <summary>
            This is the base class for all test states that have a mock type defined already.
            </summary>
            <typeparam name="T">The type that we're testing</typeparam>
            <typeparam name="U">The type that we're mocking</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState`2.#ctor">
            <summary>
            Blank constructor.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState`2.#ctor(Microsoft.MMF.States.MimicTestState{`0})">
            <summary>
            This is the copy constructor.
            </summary>
            <param name="stateToClone">The state to clone</param>
        </member>
        <member name="T:Microsoft.MMF.States.MimicTestState1`2">
            <summary>
            This is the first state for the test syntax.
            </summary>
            <typeparam name="T">The object that we're testing</typeparam>
            <typeparam name="U">The object that we're redirecting</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState1`2.#ctor">
            <summary>
            Creates an instance of mimic test state1.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState1`2.#ctor(Microsoft.MMF.States.MimicTestState{`0})">
            <summary>
            Creates an instance of state1 out of another state.
            </summary>
            <param name="stateToClone">The state to clone</param>
        </member>
        <member name="T:Microsoft.MMF.States.MimicTestState2`2">
            <summary>
            This is the second state for the test syntax.
            </summary>
            <typeparam name="T">The object that we're testing</typeparam>
            <typeparam name="U">The object that we're redirecting</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState2`2.#ctor">
            <summary>
            Creates an instance of mimic test state2.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState2`2.#ctor(Microsoft.MMF.States.MimicTestState{`0})">
            <summary>
            Creates an instance of state2 out of another state.
            </summary>
            <param name="stateToClone">The state to clone</param>
        </member>
        <member name="T:Microsoft.MMF.States.MimicTestState3`2">
            <summary>
            This is the second state for the test syntax.
            </summary>
            <typeparam name="T">The object that we're testing</typeparam>
            <typeparam name="U">The object that we're redirecting</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState3`2.#ctor">
            <summary>
            Creates an instance of mimic test state3.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState3`2.#ctor(Microsoft.MMF.States.MimicTestState{`0})">
            <summary>
            Creates an instance of state3 out of another state.
            </summary>
            <param name="stateToClone">The state to clone</param>
        </member>
        <member name="T:Microsoft.MMF.States.MimicTestState4`2">
            <summary>
            This is the second state for the test syntax.
            </summary>
            <typeparam name="T">The object that we're testing</typeparam>
            <typeparam name="U">The object that we're redirecting</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState4`2.#ctor">
            <summary>
            Creates an instance of mimic test state4.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.States.MimicTestState4`2.#ctor(Microsoft.MMF.States.MimicTestState{`0})">
            <summary>
            Creates an instance of state4 out of another state.
            </summary>
            <param name="stateToClone">The state to clone</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineTypeTranslator">
            <summary>
            Translates an inline type.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineTypeTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineTypeTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the inline type instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineTypeTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inline type opcode.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.TranslatedInstruction">
            <summary>
            This is a data structure that we use to track translated opcodes and patches.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TranslatedInstruction.#ctor(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Creates the translated instruction.
            </summary>
            <param name="opCode">The opcode</param>
            <param name="argument">The argument</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.TranslatedInstruction.ToString">
            <summary>
            Override to string so that we can get some useful diagnostic information in the debugger.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.MMF.Generation.TranslatedInstruction.Argument">
            <summary>
            This is the argument of that opcode.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TranslatedInstruction.IsExceptionHandlingClause">
            <summary>
            Returns true if the argument is an exception handling clause.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.TranslatedInstruction.IsMarkLabel">
            <summary>
            Returns true if this instruction should mark a point in the IL
            stream where a label should be marked.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.MockFactory">
            <summary>
            Used to create MockObjectWrapper objects.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.MockFactory.mInstance">
            <summary>
            Create an instance of this so that we get an object in the finalizer queue.  OK, not
            neccessarily the greatest way to write the generated assembly - but the safest.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.#cctor">
            <summary>
            The static constructor will create the dyanmic assembly.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.#ctor">
            <summary>
            Allows us to potentially write the assemblies to disk when the factory is unloaded and disposed of.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.Create``1(System.Object[])">
            <summary>
            Creates a mock object by subclassing type T.  Any virtual method on T will be redirected to a mock method 
            on the mock object.  Non-virtual methods can only be mocked if they are redirected using a Test.  
            
            If T is an interface, then the mock will extend object and implement T.  If the methods in T are invoked
            outside of a Recorder.StartOrderedRecording() block, then the methods will attempt to validate
            the method call using the MMF API.  If you want any non-recorded methods to call the base class,
            use a partial mock instead.
            </summary>
            <typeparam name="T">The type of object to mock.</typeparam>
            <param name="args">A list arguments for the constructor on type T</param>
            <returns>A mock object wrapper that encapsulates the mocked object</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.DynamicTypeCreationException">Thrown if T is sealed</exception>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreatePartial``1(System.Object[])">
            <summary>
            This method creates a partial mock.  Partial mocks are like regular mocks, except that methods
            are only validated on partial mocks if they've had expectations set against them.  If a method 
            is not invoked on a partial mock inside a Recorder.StartOrderedRecording() block, then that method
            call is automatically passed down to the base class.  
            
            Like regular mock objects, partial mocks extend or implement type T.  The argument list passed into
            this method are the arguments for the constructor on type T that you want invoked when the object is 
            created.
            </summary>
            <typeparam name="T">The type of object to mock</typeparam>
            <param name="args">A list of arguments for the constructor on the base class</param>
            <returns>A mock object wrapper that encapsulates the mocked object</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.DynamicTypeCreationException">Thrown if T is sealed</exception>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreateStatic(System.Type[])">
            <summary>
            Creates a mock object that can be used to set expectations on static methods of certain types.  Static
            mocks can only be used within MimicTests.  
            
            For each type that is passed into this method, the MMF API will iterate through each of those types' 
            static methods.  For each of them, it will create an indentical static method that has the same method
            signature on a dynamically generated type.  These methods can be then be swapped for the static types' 
            methods so that all of the arguments and return values match regardless of the type that declared the method.
            </summary>
            <param name="staticTypes">A list of the types of object that whose static methods you want to mock</param>
            <returns>A mock object wrapper that encapsulates the mocked object</returns>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreateStatic(System.Boolean,System.Type[])">
            <summary>
            Generates a static mock out of an array of types, with the option of including private methods in the 
            generated type.  
            </summary>
            <param name="includePrivateMethods">When true, the stub will include the private methods on the types that passed in</param>
            <param name="staticTypes">A list of the types of object that whose static methods you want to mock</param>
            <returns>A mock object wrapper that encapsulates the mocked object</returns>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreateMimic``1">
            <summary>
            Creates a mimic object for a particular type.  Mimics are objects that have identical methods to
            the type they are mimicking, exception that the mimic does not inherit from type T.  In .NET 4.0,
            the dynamic keyword allows mimics to be used interchangeably with the type they are mimicking,
            even though the two types are not polymorphically equivalent.  Mimics can also be used within a 
            MimicTest by mapping one type to a mimic.  Mimics can be used to test any object, including sealed
            types and objects that can't be constructed.
            </summary>
            <typeparam name="T">The type that we are mimicking</typeparam>
            <returns>An object wrapper that is used to set expectations on mimics</returns>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreateMimic``1(System.Boolean)">
            <summary>
            Creates a mimic object for a particular type, optionally including the private methods of that 
            type.
            </summary>
            <typeparam name="T">The type that we are mimicking</typeparam>
            <param name="includePrivateMethods">When true, the mimic will include private methods</param>
            <returns>An object wrapper that is used to set expectations on mimics</returns>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreateMimic``1(``0)">
            <summary>
            Creates a mimic object for a particular type that calls the aggregated class in cases where an 
            expectation is not set on the mimic.  This creates an object that has similar behavior to a 
            partial mock, except it does not inherit from the class it is mimicking.  
            </summary>
            <typeparam name="T">The type to mimic</typeparam>
            <param name="aggregatedInstance">The aggregated instance</param>
            <returns>An object wrapper that is used to set expectations on mimics</returns>
        </member>
        <member name="M:Microsoft.MMF.MockFactory.CreateMimic``1(System.Boolean,``0)">
            <summary>
            Creates a partial mimic and optionally includes the target types' private methods.
            </summary>
            <typeparam name="T">The type to mimic</typeparam>
            <param name="includePrivateMethods">When true, the mimic will include private methods</param>
            <param name="aggregatedInstance">The aggregated instance</param>
            <returns>An object wrapper that is used to set expectations on mimics</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.OpCodeTracker">
            <summary>
            The opcode tracker is used to track the translation of old opcodes to new ones.  This is 
            neccessary because as we alter the opcodes during the translation, there is no garunatee
            that the new method will be identical in length to the old one.  In order for us to deal 
            with this discrepency, we need an object that can keep track fo the old opcodes as well as 
            the new ones and allow us to refer to them the same way.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mNewInstructions">
            <summary>
            This is a list of opcodes that we use to translate.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mLocalBuilderMap">
            <summary>
            Before we write out info, we need to keep track of the local variables
            so that we can determine what their scope is in the translated method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTempBuilderMap">
            <summary>
            This dictionary is used to keep track of temp variables, which we use 
            to box and unbox non-visible types.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mOffsets">
            <summary>
            This is a list of offsets, using the original opcodes.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mGenerator">
            <summary>
            This is the ILGenerator that we are using to generate the translated opcodes.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mMethod">
            <summary>
            This is the method that we're currently cloning.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTypeBuilder">
            <summary>
            This is the type builder that we are using to build the current type.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mLabelLookup">
            <summary>
            This dictionary helps us track the location of labels.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mPatchLookup">
            <summary>
            This is a dictionary where we match patch indexes to lists of patches.  When an index 
            in an opcode sequence has been patched we will keep the overwritten sequence stored in this dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mPrependedLookup">
            <summary>
            This is a dictionay where we match indexes to patches that should come before an instruction is emitted.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mExceptions">
            <summary>
            This is a list of exception handling clauses that we need
            to define when we're emitting opcodes.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetSymbolReader">
            <summary>
            This is the symbol reader for the target method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetSymbolMethod">
            <summary>
            This is the target symbol method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodSymbolDocs">
            <summary>
            These are the symbol documents for the target method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodSymbolDocWriters">
            <summary>
            The document writers allow symbol information to be written while we are emitting code.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodOffsets">
            <summary>
            These are the offsets to the test method.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodStartColumns">
            <summary>
            These are the test method start columns.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodEndColumns">
            <summary>
            These are the test method end columns.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodStartLines">
            <summary>
            These are the test method start lines.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTargetMethodEndLines">
            <summary>
            These are the test method end lines.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.OpCodeTracker.mTestMethodLocalSymbols">
            <summary>
            This is a list of the test method local symbols.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.#ctor">
            <summary>
            The protected constructor is used for testing purposes.
            This should never be called by anybody else!
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.#ctor(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>
            Creates an opcode tracker that will not emit any debug information.
            </summary>
            <param name="generator">The ILGenerator that will be used to emit the opcodes.</param>
            <param name="method">The method that we're cloning</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.#ctor(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase,System.Reflection.MethodBase,System.Reflection.Emit.TypeBuilder)">
            <summary>
            Creates an opcode tracker that knows about the type it is creating.  This constructor is 
            neccessary when creating templated types, because those types require local fields to be defined as 
            they are being templated.  This opcode tracker is created with a type builder that can be used
            to define those local fields.
            </summary>
            <param name="generator">The generator to emit method calls with</param>
            <param name="method">The method that we are cloning</param>
            <param name="templateMethod">The method that the template is based off of</param>
            <param name="typeBuilder">The type that we're cloning the method into</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.#ctor(System.Reflection.Module,System.Reflection.MethodBase,System.Reflection.Emit.ModuleBuilder,System.Reflection.Emit.ILGenerator)">
            <summary>
            Creates an opcode tracker that will also emit debug information.
            </summary>
            <param name="module">The module where the method is defined</param>
            <param name="methodInfo">The method that we're redirecting</param>
            <param name="moduleBuilder">The module builder</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.AppendInstruction(Microsoft.MMF.Generation.ILInstruction)">
            <summary>
            Appends an instruction to the tracker.
            </summary>
            <param name="ilInstruction">The ILInstruction to append</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.SetArgument(System.Object)">
            <summary>
            Sets the argument for the current translated instruction.
            </summary>
            <param name="argument">The argument for the current instruction</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.GetLabel">
            <summary>
            Defines a label and returns it.
            </summary>
            <returns>A new label that the user can break to</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.MarkLabelAt(System.Int32)">
            <summary>
            Tells the tracker to mark a label at the specified break target, which is the IL offset in the 
            original code where a label should be marked during translation.
            </summary>
            <param name="breakTarget">The offset in the original code where we should mark a label</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.ClearPatchesAt(System.Int32)">
            <summary>
            This will clear patches at the specified index.
            </summary>
            <param name="index">The index to clear patches from</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Prepend(System.Reflection.Emit.OpCode)">
            <summary>
            Prepends an instruction at the current index.
            </summary>
            <param name="opCode">The opcode to prepend</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Prepend(Microsoft.MMF.Generation.EExceptionClauseType)">
            <summary>
            Prepends a portion of an exception handling clause.
            </summary>
            <param name="clauseType">The clause type</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Prepend(System.Reflection.Emit.Label)">
            <summary>
            Prepends an instruction that will mark the given label.
            </summary>
            <param name="label">The label that is prepended</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Prepend(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Prepends an instruction at the current index with a specific argument.
            </summary>
            <param name="opCode">The opcode to prepend</param>
            <param name="argument">The argument of the opcode</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.PrependAt(System.Reflection.Emit.OpCode,System.Object,System.Int32)">
            <summary>
            Prepends an instruction at the specific index.
            </summary>
            <param name="opCode">The opcode to prepend</param>
            <param name="argument">The argument of the opcode</param>
            <param name="index">The index to prepend the instruction at</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Patch(Microsoft.MMF.Generation.EExceptionClauseType)">
            <summary>
            Patches the code so that at this particular instruction, the tracker 
            will define a part of an exception handling clause.
            </summary>
            <param name="clauseType">The type of clause to patch</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Patch(System.Reflection.Emit.Label)">
            <summary>
            Patches the code with a special instruction that tells the tracker to mark a label
            at this point in the IL stream.
            </summary>
            <param name="label">The label to mark in the patch</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Patch(System.Reflection.Emit.OpCode)">
            <summary>
            Patches the most current instruction with an opcode that has no arguments.
            </summary>
            <param name="opCode">The opcode to patch</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.Patch(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Patches the most current instruction.
            </summary>
            <param name="opCode">The opcode to patch with</param>
            <param name="argument">The argument to patch</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.PatchAt(System.Int32,System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            This will patch the opcode stream at the specified index.  If a patch already exists
            at that index, this method will append the opcode and argument to that patch.
            </summary>
            <param name="index">The index to patch</param>
            <param name="opCode">The opcode to patch</param>
            <param name="argument">The argument to patch</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.AddDebugInfoForLocalBuilder(System.Reflection.LocalVariableInfo,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Since the opcode tracker contains debug info for the method we're testing,
            it also has the debug info for local variables.  This is where we add them.
            </summary>
            <param name="variableInfo">The variable info from the method we're cloning</param>
            <param name="localBuilder">The local builder of the method we're building</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.GetTempForType(System.Type)">
            <summary>
            Returns the local index of a temporary variable for a particular type.
            </summary>
            <param name="tempType">The type to get a temp for</param>
            <returns>The index of the temp's type</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.EmitExceptionClause(Microsoft.MMF.Generation.TranslatedInstruction)">
            <summary>
            This utility method makes it easier for us to emit exception handling blocks, since
            it's done in a few locations.
            </summary>
            <param name="instruction">The instruction whose clause type we should emit</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.OpCodeTracker.GetOffsetIncrement(Microsoft.MMF.Generation.TranslatedInstruction)">
            <summary>
            This private utility method returns the number of additional bytes that the given
            transalted instruction will add to the current offset.  We need this value to define the 
            lexical scope of local variables!
            </summary>
            <param name="instruction">A translated instruction</param>
            <returns>The number of bytes that this instruction will increment the offset by</returns>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.Generator">
            <summary>
            Returns the ILGenerator that is being used to generate this method.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.Method">
            <summary>
            Returns the method that's currently being cloned.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.TypeBuilder">
            <summary>
            Returns the type builder that is being used to create this type.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.CurrentOffset">
            <summary>
            Returns the current offset at this location.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.ConstrainedType">
            <summary>
            When instrumenting a method, if we come across a Constrained opcode, we nop it and store the 
            type here for later so that we can emit a proper method instead.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.CurrentIndex">
            <summary>
            Returns the current index in the original opcode stream.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.AlteredInstructions">
            <summary>
            This enumerator is used to iterate through all of the opcodes that we have translated and altered.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.OpCodeTracker.RawAlteredInstructions">
            <summary>
            This is primary used for debugging purposes.  It returns an array of the altered opcodes with their 
            arugments in an object array.  This property does not generate the method and its debug information - 
            it simply allows us to look at the translated opcodes and their arguments.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.RedirectionRepository">
            <summary>
            This class serves as registry for all of the types and instances that should be redirected.  When a
            redirected method is invoked, all of the methods that are invoked within that method end up getting 
            passed into this classes Redirect method.  The redirect method checks to see if the invoked object is 
            a mock or a stub.  If it is, then it invokes the method on the mock directly.  This is how we get non-virtual
            methods to be invoked on the mock objects instead of on the subclasses.
            
            Another thing we do however, is check the type of the object that's passed in.  If the type has been redirected,
            then we invoke the equivelent method on the type's mock instead.  This allows us to mock sealed types, types with
            inaccessable constructors, and dynamically new'ed objects.
            
            Static methods also come in here.  For those cases, we just allow mappings between the type that is being redirected
            and the mock object that has the equivelent mocked static methods. 
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionRepository.mInstance">
            <summary>
            The one and only instance.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionRepository.mTestHarness">
            <summary>
            This is the test harness that we are currently redirecting.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.RedirectionRepository.mObjectTypeInTest">
            <summary>
            This is the type of the object that is currently being tested.  We need this instance
            to determine the recursive scope.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.#cctor">
            <summary>
            The static constructor creates the singleton instance.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.#ctor">
            <summary>
            Cannot be created.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.SetTestHarness(Microsoft.MMF.ITestHarness,System.Type)">
            <summary>
            Resets the redirection mappings.
            </summary>
            <param name="harness">The test harness to redirect</param>
            <param name="methodInTestType">The type that we are testing</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.Redirect(System.Object@,System.Reflection.MethodBase,System.Object[]@,Microsoft.MMF.Generation.ECallType)">
            <summary>
            Checks the mappings and determines whether the given method, invoked on the given object
            with the given arguments, should be redirected.  If the object instance passed in is a
            mock object, we will automatically redirect it.  Otherwise, we will check the type of the instance
            and determine whether it should be redirected.  If the instance is null, we will instead check
            the type that method was declared on.
            
            This method is called from within redirected methods.
            </summary>
            <param name="instance">The instance that the method was invoked on</param>
            <param name="methodBase">The method that was invoked</param>
            <param name="args">The arguments of the method</param>
            <param name="callType">The call type; needed to determine which method to redirect recursively into</param>
            <returns>The return value of the method, or null if nothing was returned</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.RedirectNew(System.Reflection.ConstructorInfo,System.Object[]@)">
            <summary>
            Redirects a constructor.  If the constructor's type is being redirected, then we will 
            invoke it only if it was set up to be invoked.  Otherwise, we will bypass the constructor entirely.
            In either case, we will return the mock object instead of whatever the constructor returned.
            </summary>
            <param name="constructor">The constructor to invoke</param>
            <param name="args">The arguments for the constructor</param>
            <returns>Either the dynamically created object, or a mock object</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.IsInRedirectedContextAndShouldBeRedirected(System.Object,System.Type,System.Reflection.MethodBase,System.Object[])">
            <summary>
            Checks the current call stack to determine whether a method should redirect recursively.
            </summary>
            <param name="target">The target object</param>
            <param name="type">The type to get the actual method from</param>
            <param name="currentMethod">The current method</param>
            <param name="args">The arguments</param>
            <returns>True if the method should be redirected.  Otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.RedirectFromMockOrStub(System.Object,System.Type,System.Reflection.MethodBase,System.Object[]@)">
            <summary>
            Either calls the method on the target object, or redirects the call recursively.
            </summary>
            <param name="target">The target object.  This is the object which the method gets invoked on.</param>
            <param name="targetType">The target type</param>
            <param name="currentMethod">The current method which was invoked on the mock object</param>
            <param name="args">The arguments of the method</param>
            <returns>The result of the method call</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.ShouldRedirectInto(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>
            This method will check whether a method call to method from the typeInTest should be redirected.
            This decision is based on the ScopeFlags that were passed into the repository before the test 
            started.  This method is called whenever a call to the Redirect method comes in, and when we're 
            instrumenting a method and we need to determine whether a delegate should be redirected as well.
            </summary>
            <param name="instance">The instance that the method was invoked on</param>
            <param name="method">The method to check against</param>
            <param name="arguments">The arguments of the method</param>
            <returns>True if the method should be redirected.  Otherwise, false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.GetEventArgs(System.Reflection.MethodBase,System.Object[],System.Object,System.Exception)">
            <summary>
            Returns a fresh RedirectionArgs object with the right parameters.
            </summary>
            <param name="method">The method that was invoked</param>
            <param name="arguments">The arguments of the method</param>
            <param name="returnValue">The return value of the method, or null if there was none</param>
            <param name="exception">The exception that was thrown</param>
            <returns>A new RedirectionArgs object with the right properties</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.InvokeExactMethod(System.Object,System.Reflection.MethodInfo,System.Object[]@)">
            <summary>
            Invokes the exact method on the instance object.  This is only neccessary if the method is being called is virtual.
            </summary>
            <param name="instance">The instance to invoke the method on</param>
            <param name="method">The method to invoke</param>
            <param name="args">The arguments</param>
            <returns>The result of the method invocation</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.GetBoxedDefaultValue``1">
            <summary>
            This utility method is used in a few fringe cases where we need the runtime to tell us what the default
            value of a particular type is. This method will return the default, boxed value of a particular type.
            </summary>
            <typeparam name="T">The type to get the default value for</typeparam>
            <returns>The boxed default value of type T</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.GetDefaultBoxedValue(System.Type)">
            <summary>
            Using reflection, this method will generate an instance of the method above and execute it.  This is how we can
            generate a default boxed instance of a particular type.
            </summary>
            <param name="type">The type to get the default value for</param>
            <returns>A boxed version of the particular type</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.InsertThisPointerIntoArray(System.Object,System.Object[]@)">
            <summary>
            Inserts the object instance into the front of the array.  This method alters the args array in place.
            </summary>
            <param name="instance">The instance to insert</param>
            <param name="args">The argument array</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.RedirectionRepository.RemoveThisPointerFromArray(System.Object[]@)">
            <summary>
            Resizes the array so that the first argument at index 0 is removed.
            </summary>
            <param name="args">The argument array to modify</param>
        </member>
        <member name="T:Microsoft.MMF.IProfilerObserver">
            <summary>
            Gets notified whenever an event is fired on the profiler.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnMethodInTestStarted(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when the method-in-test is executed.
            </summary>
            <param name="instance">The instance of the method</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnMethodInTestFinished(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when the method-in-test finishes executing.
            </summary>
            <param name="instance">The object that the method was invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnMethodStarted(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when a new method is invoked.
            </summary>
            <param name="instance">The instance that the method was invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnMethodFinished(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when a method finishes.
            </summary>
            <param name="instance">The instance that the method finished on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnRedirectionConsidered(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when the framework is considering whether or not to redirect
            into a particular method.  The arguments contain all of the information neccessary
            for the tester to determine whether they should redirect into a method or not.  This 
            event gives the user the option to override the default scope of a test.
            </summary>
            <param name="instance">The instance that is being redirected into</param>
            <param name="args">The arguments of the redirection</param>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnNewObject(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when a new object is created.
            </summary>
            <param name="instance">The instance that the method was invoked on (always null)</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.IProfilerObserver.OnException(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is fired whenever an exception is thrown.
            </summary>
            <param name="instance">The instance that the method was invoked on (always null)</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="T:Microsoft.MMF.WhereArgument">
            <summary>
            This class contains a number of methods that can be used to insert constraints into an expectation, 
            arrangement or assertion.  The methods in this class can be embedded in a method call.  When the API
            sees a method call to this class, it will automatically add the constraint to the MethodExpectation
            class.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.WhereArgument.mInstance">
            <summary>
            This is the one and only instance.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.WhereArgument.mSetConstraints">
            <summary>
            This is a list of all the constraints that have been set.  Because the order is such that these constraints are 
            set and created before an expectation or assertion is made, we need to cache them somewhere so that they can be 
            consumed later on.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.#cctor">
            <summary>
            Creates the singleton instance.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.#ctor">
            <summary>
            This is the one and only constructor.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Reset">
            <summary>
            Resets the indexes of the constraints.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.IsAnyValue">
            <summary>
            Sets a constraint that the argument at the current index can be of any 
            value for the expectation to be validated.  The argument must be a reference
            type for this to work.
            </summary>
            <returns>Null</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.IsAnyValue(System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda on an 
            expectation, arrangement or assertion.
            </summary>
            <param name="index">The index to set the constraint at</param>
            <returns>Null</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.IsAnyValue``1">
            <summary>
            Sets a constraint that the argument at the current index can be of any value for the 
            expectation to be validated.
            </summary>
            <typeparam name="T">The type</typeparam>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.IsAnyValue``1(System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda 
            on an expectation, arrangement, or assertion.
            </summary>
            <typeparam name="T">The type to return</typeparam>
            <param name="index">The index to set the constraint at</param>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.StartsWith(System.String)">
            <summary>
            Sets a constraint that the string argument at the current index starts with the specified text.
            </summary>
            <param name="startsWithString">The string to check against</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.StartsWith(System.String,System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda 
            on an expectation, arrangement, or assertion.
            </summary>
            <param name="startsWithString">The string to check against</param>
            <param name="index">The index to set the constraint at</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Contains(System.String)">
            <summary>
            Sets a constraint that the string argument at the current index contains the specified text.
            </summary>
            <param name="containsString">The string to check against</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Contains(System.String,System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda 
            on an expectation, arrangement, or assertion.
            </summary>
            <param name="containsString">The string to check against</param>
            <param name="index">The index to add the constraint at</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.EndsWith(System.String)">
            <summary>
            Sets a constraint that the string argument at the current index ends with the specified text.
            </summary>
            <param name="endsWithString">The string to check against</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.EndsWith(System.String,System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda 
            on an expectation, arrangement, or assertion.
            </summary>
            <param name="endsWithString">The string to check against</param>
            <param name="index">The index to add the constraint at</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Matches(System.String)">
            <summary>
            Creates a constraint that matches a regular expression.
            </summary>
            <param name="regEx">The regular expression to match</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Matches(System.String,System.Int32)">
            <summary>
            This is the private method that traps the matches call.
            </summary>
            <param name="regEx">The regular expression to match</param>
            <param name="index">The index of the constraint</param>
            <returns>A default string</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.IsOneOf``1(``0[])">
            <summary>
            Creates a constraint that matches any values of type T in the expectation at the current argument index.
            </summary>
            <typeparam name="T">The type to check against</typeparam>
            <param name="values">An enumerable list of values</param>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.IsOneOf``1(``0[],System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda 
            on an expectation, arrangement, or assertion.
            </summary>
            <typeparam name="T">The type to check against</typeparam>
            <param name="values">An array of values to check</param>
            <param name="index">The index to add the constraint at</param>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Satisfies``1(System.Func{``0,System.Boolean})">
            <summary>
            Creates a constraint that invokes a callback to match the argument value at the current index.
            </summary>
            <typeparam name="T">The type to check against</typeparam>
            <param name="callback">The callback</param>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.WhereArgument.Satisfies``1(System.Func{``0,System.Boolean},System.Int32)">
            <summary>
            This is the method that is actually invoked from inside the lambda 
            on an expectation, arrangement, or assertion.
            </summary>
            <typeparam name="T">The type to pass into the callback</typeparam>
            <param name="callback">The callback delegate</param>
            <param name="index">The index to add the constraint at</param>
            <returns>The default value of T</returns>
        </member>
        <member name="P:Microsoft.MMF.WhereArgument.SetConstraints">
            <summary>
            This is a little hokey, but it's the easiest way to handle this.  When setting constraints, the WhereArgument
            class will add a constraint to this list.  When a method expectation is created, it will copy the contents of 
            this array into its list and then empty this list.  It does this because expectations are created from multiple 
            places and at different times, and it is difficult to use a different paradigm.  
            
            This list serves as a bit of cache where the constraints of a method expectation can be stored until 
            the expectation is created.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.ShortInlineITranslator">
            <summary>
            Translates the ShortInlineI opperand.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineITranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineITranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the ShortInlineI instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineITranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a short inline I instruction.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.MimicTest`1">
            <summary>
            The mimic test class allows methods to be tested by mimicking their IL. 
            The test class is a starting point for tests that use the redirection API.  
            </summary>
        </member>
        <member name="T:Microsoft.MMF.TestHarness`1">
            <summary>
            The test harness class is the base class for all types of mimic tests.  
            </summary>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.#ctor(`0)">
            <summary>
            Creates a test harness that can be used to clone the IL of a target method so that its
            compiled methods call mock objects instead.
            </summary>
            <param name="testTarget">The target that we're testing.  If we're testing static methods, this should be MMFStatic</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.Redirects``1(System.Func{`0,``0})">
            <summary>
            Tells the Test to redirect a a property of the object that it is testing.  The delegate
            passed into this method will be invoked so that we can determine the instance to redirect.
            </summary>
            <typeparam name="U">The object to redirect</typeparam>
            <param name="propertyAction">A delegate that returns the object to redirect</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.Redirects``1(``0)">
            <summary>
            Tells the Test to redirect a particular instance of an object.  All calls to this object will be 
            redirected to the mock or stub that is assigned to it via the ByCalling method.
            </summary>
            <typeparam name="U">The type we will redirect</typeparam>
            <param name="objectInstance">An instance of an object to redirect</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.Redirects``1">
            <summary>
            Tells the mimic test to redirect all calls to type U by calling a mock object 
            that has mock implementations of that type.
            </summary>
            <typeparam name="U">The type to redirect</typeparam>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.RedirectsNewObjectsOfType``1">
            <summary>
            Instructs the test to redirect all calls to new objects of type U by returning a mock
            object instead of what the constructor would otherwise return.  By default, the constructor 
            will not be invoked.  The overloaded method allows this behavior to be supressed.
            </summary>
            <typeparam name="U">The type to redirect</typeparam>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.RedirectsNewObjectsOfType``1(System.Boolean)">
            <summary>
            Instructs the test to redirect all calls to new objects of type U by returning a mock
            object instead of what the constructor would otherwise return.  This overload allows 
            users to specify whether the constructor on U is invoked, even if it's not the object
            that's returned.
            </summary>
            <typeparam name="U">The type to redirect</typeparam>
            <param name="callConstructorAnyway">When true, the constructor will be called even if it's not the object that gets returned</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.RedirectsStaticMethodsByCalling``1(Microsoft.MMF.ObjectWrapper{``0,Microsoft.MMF.MMFStatic})">
            <summary>
            Tells the test to redirect calls to static methods by invoking equivalent methods on the mock object
            contained within the staticWrapper class.  The staticWrapper may mock static methods on more than one type.  This
            method may be called more than once for each type one wants to redirect; or, there could be a single mock object
            that handles all static methods and this method could be called just one time.
            </summary>
            <typeparam name="U">The type that we are mocking</typeparam>
            <param name="staticWrapper">An object wrapper that aggregates the actual mock object</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.RedirectsInto(System.Reflection.Assembly)">
            <summary>
            Tells the test harness to redirect into a particular assembly.  By default, the test will not redirect into 
            any assembly other than the one under test.  However, this method allows users to tell the API to explicitly 
            redirect into a particular assembly.
            
            Keep in mind that some classes in some assemblies can't be redirected because the IL for their methods is 
            unretrievable.  But this is usually only prevelant in core assemblies such as mscorlib.
            </summary>
            <param name="assembly">An additional assembly to redirect into</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.Reset">
            <summary>
            Resets the state of the test harness so that all of the redirections are erased.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.AddDefaultAssembly(System.Reflection.MethodBase)">
            <summary>
            Adds the default assembly to the redirected assemblies list so that the method in test's 
            assembly is automatically added to the list.
            </summary>
            <param name="methodInTest"></param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.Test(System.Delegate)">
            <summary>
            This method is used to invoke statements by duplicating their IL, but replacing calls to the 
            methods that it was compiled against with calls to mock objects instead.  
            </summary>
            <param name="testExpression">A delegate that invokes a method that should be redirected</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.Test(System.Reflection.MethodBase,System.Object[])">
            <summary>
            This method override allows users to test private / protected methods by passing us a MethodBase
            instead of a lambda.  Note that methods invoked through this method can't be parameterized.
            </summary>
            <param name="methodInTest">The method to test under redirection</param>
            <param name="args">The arguments of the method</param>
            <returns>The result of the test</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnMethodInTestStarted(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Called when the method-in-test starts.
            </summary>
            <param name="instance">The instance that the method was invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnMethodInTestFinished(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when the method-in-test finishes executing.
            </summary>
            <param name="instance">The object that the method was invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnMethodStarted(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Called when a method started event is fired.
            </summary>
            <param name="instance">The instance that the event was fired on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnMethodFinished(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Called when a method finished event is fired.
            </summary>
            <param name="instance">The instance that the event was fired on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnRedirectionConsidered(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Called right before a method is cloned (or skipped over) for redirection.  This event
            allows users to override the default behavior.
            </summary>
            <param name="instance">The instance that the method was invoked on</param>
            <param name="args">The arguments of the redirection</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnNewObject(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Called when a new object is created.
            </summary>
            <param name="instance">Always null</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.OnException(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Called when an exception is explicitly thrown.  In other words, the following WILL
            generate this event:
            
            if(!NoInitialized)
              throw new Exception();
            
            But the following will NOT generate this event:
            
            object o = null;
            string s = o.ToString(); // null pointer won't be caught here!
            </summary>
            <param name="instance">Always null</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.MethodInTestStarted">
            <summary>
            This event is fired when the method-in-test starts.
            </summary>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.MethodInTestFinished">
            <summary>
            This event is fired when the method-in-test is finished.
            </summary>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.MethodStarted">
            <summary>
            This event is fired before a redirected method is invoked in the TestHarness.
            </summary>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.MethodFinished">
            <summary>
            This event is fired whenever a redirected method finishes executing in the TestHarness.
            </summary>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.RedirectionConsidered">
            <summary>
            This event is fired right before the framework decides whether to clone a method
            for redirection.  It allows users to fine-tune the scope of a test based on whatever
            rules they want by allowing them to override the default scoping of a test.  To 
            change the default decision making of a test, change the ShouldRedirect property 
            on the RedirectionArgs object to true or false.
            </summary>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.NewObject">
            <summary>
            This event is fired whenever an object is dynamically created within a redirected method.
            </summary>
        </member>
        <member name="E:Microsoft.MMF.TestHarness`1.Exception">
            <summary>
            This event is fired whenever an exception is thrown within a redirected method.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.Target">
            <summary>
            Gets or sets the object that the test harness should invoke test methods on.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.Scope">
            <summary>
            Defines the scope of what will be redirected during a test.  By default, Test will not 
            redirect into every method that is called.  To change the level of redirection during a test,
            add or remove flags from this enumeration.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedInstances">
            <summary>
            This dictionary maps the redirected object instances to the mock objects
            that will be called instead.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedTypes">
            <summary>
            This dictionary maps the redirected object types to the 
            mock objects that will be called instead.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedStaticTypes">
            <summary>
            This dictionary maps types that will redirect the static methods on those types..
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedNewTypes">
            <summary>
            This dictionary stores the types that should be returned when new instances 
            of that type are created inside the test.  These values can be null.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedNewTypesCallConstructors">
            <summary>
            This dictionary stores bools that determine whether the constructor for a given type
            should be called when it is being redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedNewTypesReturnUninitializedObjects">
            <summary>
            This dictionary stores bools that determine whether we should return an uninitialized
            object for a given type when it's being redirected.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.TestHarness`1.RedirectedAssemblies">
            <summary>
            This is a list of assemblies that we will redirect into.  We will automatically 
            redirect into the assembly that contains the method-in-test.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.TestHarness`1.NoHashCodeComparer`1">
            <summary>
            This helper class allows us to compare two objects in a dictionary without 
            using GetHashCode().  This helps us in cases where we are redirecting objects
            that are created through GetUninitializedInstance() which have overloaded 
            implementations of GetHashCode().
            </summary>
            <typeparam name="U">The type that we're comparing.</typeparam>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.NoHashCodeComparer`1.Equals(`1,`1)">
            <summary>
            Compares two objects and returns true if they are equal.
            </summary>
            <param name="x">The first type to compare</param>
            <param name="y">The second type to compare</param>
            <returns>True if x equals y</returns>
        </member>
        <member name="M:Microsoft.MMF.TestHarness`1.NoHashCodeComparer`1.GetHashCode(`1)">
            <summary>
            Returns the hashcode for a particular object.
            </summary>
            <param name="obj">The object to get a hashcode for</param>
            <returns>The hashcode of obj</returns>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.#ctor">
            <summary>
            Create a mimic test whose target is an uninitialized object of type T.  Uninitialized objects
            are dynamically created instances that have no had their constructor called.  You can use this constructor
            to test constructors on objects, or to simply create a harness on an object without having its constructor 
            invoked.  Note that not invoking the constructor can mean that the object is not set up properly, which means
            you may have to do some of this manually in your test.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.#ctor(`0)">
            <summary>
            Creates a test that can be used to unit test methods that invoke non-virtual, static,
            sealed types and dynamically created objects by cloning the IL of a target method but altering 
            it so that mock objects are invoked instead.
            </summary>
            <param name="testTarget">The instance of the object to test</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.Test(System.Action{`0})">
            <summary>
            This method is used to invoke statements by duplicating their IL, but replacing calls to the 
            methods that it was compiled against with calls to mock objects instead.  The method invoked in the 
            testStatement should be the method that you want to test using redirection.
            </summary>
            <param name="testStatement">The test statement, something like t => t.TheMethodIAmTesting()</param>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.Test``1(System.Func{`0,``0})">
            <summary>
            This method is used to invoke statements by duplicating their IL, but replacing calls to the 
            methods that it was compiled against with calls to mock objects instead.  The method invoked in the 
            testStatement should be the method that you want to test using redirection.
            </summary>
            <typeparam name="U">The return type of the method we are testing</typeparam>
            <param name="testStatement">The test statement, something like t => t.TheMethodIAmTesting()</param>
            <returns>A value of U returned by the method invoked in TestStatement</returns>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.Test(System.Reflection.MethodBase,System.Object[])">
            <summary>
            This method can be used to test private / protected methods and constructors.  The method passed into this 
            overload will be cloned for redirection and invoked with the supplied arguments.  Note that methods invoked
            this way can not be parameterized.
            </summary>
            <param name="methodInTest">The method to invoke can either be an instance method or a constructor</param>
            <param name="args">The arguments for method</param>
            <returns>The return value of the method, or null if there is no return value</returns>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.Test(System.Func{System.Object})">
            <summary>
            Deprecated.  Please use TestNew instead.
            </summary>
            <param name="testExpression">A delegate that creates an instance of T, like () => new MyObject()</param>
            <returns>A new instance of T after it has gone through the redirected constructor</returns>
        </member>
        <member name="M:Microsoft.MMF.MimicTest`1.TestNew(System.Func{`0})">
            <summary>
            Tests a constructor on type T.  The target that's passed into the constructor will the object contained in the Target
            property of this object.  You can use this overload to chain together a redirected constructor and method call, 
            in sequence, within one MimicTest.
            </summary>
            <param name="testExpression">A delegate that creates an instance of T, like () => new MyObject()</param>
            <returns>A new instance of T after it has gone through the redirected constructor</returns>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.MockRecordingException">
            <summary>
            This exception is thrown if the API can't create a mock method.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MockRecordingException.#ctor(System.String)">
            <summary>
            Creates the mock recording exception.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MockRecordingException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a mock recording exception with the specified inner exception.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MockRecordingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Templates.StubTemplate">
            <summary>
            This class contains the template methods that are used to create stub
            objects.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.IStub">
            <summary>
            All generated stub objects will implement this interface.  It allows us to set the state of a stub so
            that we can follow the arrange, act, assert pattern.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.IStub.ResetArrangements">
            <summary>
            This method will reset all of the arrange expectations that were set on a stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.IStub.ResetRecordedMethods">
            <summary>
            This method will reset all of the methods that were recorded on the stub during the act stage.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.IStub.ResetAll">
            <summary>
            This method will reset both the arranged and recorded lists.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.IsArranging">
            <summary>
            True when the stub is arranging.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.IsAsserting">
            <summary>
            True when the stub is asserting.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedMethod">
            <summary>
            When an arrangement is made, this property is set by the stub.  It is later used to make sure 
            that a method with a return value is set properly.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedReturnValue">
            <summary>
            During the arrange stage, this property is set on 
            a stub so that when a method is called, it can copy the value
            locally and return it when it is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedReturnValueHandler">
            <summary>
            Allows us to call a delegate that takes the arguments of the method and returns
            a specific value based on those arguments.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedCallbackHandler">
            <summary>
            Gets / sets the callback handler.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedExceptionToThrow">
            <summary>
            During the arrange stage, this property is set on a stub
            so that when a method is called, it can copy this exception reference locally
            and throw it when that method is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedIgnoresAllArguments">
            <summary>
            When arranging an expectation, this will make sure that the current expectation 
            ignores all arguments when acting.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedArgumentsToIgnore">
            <summary>
            When arranging an expectation, this will enable the current expectation to ignore certain
            arguments when acting.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.ArrangedOutParametersToAssign">
            <summary>
            When arranging an expectation, this will assign out parameters if applicable.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.AssertMethod">
            <summary>
            We need to store this method info for later during the assertion process.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.AssertExpectations">
            <summary>
            If we are arranging or asserting a particular method, the auto-generated
            code will set this expectation property so that we can access it and set 
            properties on it.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.IStub.AssertArguments">
            <summary>
            We also need to store the current arguments when we're in the validation phase so that 
            we can verify whether or not the stub was called with the arguments we were expecting.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Templates.StubTemplate.mStaticThis">
            <summary>
            Define a static reference to ourselves.  We use this to get the this pointer on static methods.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.ResetArrangements">
            <summary>
            This method resets all of the arrangements on the stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.ResetRecordedMethods">
            <summary>
            This method resets all of the recorded methods on the stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.ResetAll">
            <summary>
            This method resets the entire state of the stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.DefaultConstructor">
            <summary>
            This is the default template for constructors.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.DefaultNoReturn">
            <summary>
            This is the default stub method template for a method with no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.DefaultWithReturn``1">
            <summary>
            This is the default stub method template for a method with no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.MimicNoReturn">
            <summary>
            Stub mimics are different because we have no base class to call in case the call isn't stubbed.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.MimicWithReturn``1">
            <summary>
            Stub mimics should just return default values.
            </summary>
            <typeparam name="T">The type to return</typeparam>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.PartialMimicNoReturn">
            <summary>
            Stub mimics are different because we have no base class to call in case the call isn't stubbed.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.PartialMimicWithReturn``1">
            <summary>
            Stub mimics should just return default values.
            </summary>
            <typeparam name="T">The type to return</typeparam>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.StaticNoReturn">
            <summary>
            This is the template for static stub methods.  To get the instance of the 'this' pointer,
            we call into the StubTemplates' FindInstance method, using the declaring type as the key.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.StaticWithReturn``1">
            <summary>
            This is the static template with a return value.
            </summary>
            <typeparam name="T">The type that we return</typeparam>
            <returns>A value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.GetArrangementList(Microsoft.MMF.Generation.IStub,System.Reflection.FieldInfo)">
            <summary>
            This helper method is used to help compress the amount of code generated to create stub objects.  It 
            will check the value of a field on a stub to see if it's created.  If it's not, it will create it.  
            Otherwise it won't; instead it will just return it.
            </summary>
            <param name="stub">The stub to set the field on</param>
            <param name="field">The field that stores the list</param>
            <returns>The list on the field</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.GetAssertionList(Microsoft.MMF.Generation.IStub,System.Reflection.FieldInfo)">
            <summary>
            Another optimization method.  Reduces the amount of code we need to generate to create the arrangement
            list.  If it's not set, it will be set here.
            </summary>
            <param name="stub">The stub to get and set the field on</param>
            <param name="field">The field to store the list in</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.AddArrangement(Microsoft.MMF.Generation.IStub,System.Reflection.MethodBase,System.Object[],System.Collections.Generic.List{Microsoft.MMF.StateMachine.MethodExpectation})">
            <summary>
            This is another method to help optimize and speed up the creation of stub objects.  By placing this code in one 
            place, we don't need to generate it again and again every time we create a stub method from a template.
            </summary>
            <param name="stub">The stub</param>
            <param name="method">The method to record</param>
            <param name="arguments">An array of arguments to set an arrangement on</param>
            <param name="list">The list to add the expectation to</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.SetAssertionParameters(Microsoft.MMF.Generation.IStub,System.Reflection.MethodBase,System.Object[],System.Collections.Generic.List{Microsoft.MMF.StateMachine.MethodExpectation})">
            <summary>
            Sets the parameters of a stub so that it can be asserted.
            </summary>
            <param name="stub">The stub</param>
            <param name="method">The method to assert</param>
            <param name="arguments">An array of arguments</param>
            <param name="list">A list of assertion expectations</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubTemplate.RecordAndMatchExpectations(Microsoft.MMF.Generation.IStub,System.Reflection.MethodBase,System.Object[],System.Collections.Generic.List{Microsoft.MMF.StateMachine.MethodExpectation},System.Collections.Generic.List{Microsoft.MMF.StateMachine.MethodExpectation})">
            <summary>
            This is a huge perf optimization that dramatically reduces the time it takes to generate stubs.  By shoving this code
            into one method, we don't need to generate it again and again for each method.
            </summary>
            <param name="stub">The stub to record the expectation on</param>
            <param name="currentMethod">The current method</param>
            <param name="arguments">An array of arguments that were passed into the method</param>
            <param name="arrangedExpectations">A list of expectations that have been arranged</param>
            <param name="assertionExpectations">A list of expectations that have been recorded</param>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.AggregatedObject">
            <summary>
            This object is used when the stub is a partial mimic to call an aggregated object.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.IsDoneConstructing">
            <summary>
            This bool is set to true once the stub has been created and it's constructor has been called.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.WasCalled">
            <summary>
            This bool is set to true when the stub is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.IsArranging">
            <summary>
            This bool is set to true when the stub is arranging.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.IsAsserting">
            <summary>
            This bool is set to true when the stub is asserting.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedMethod">
            <summary>
            This is the method that the stub is arranging.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedReturnValue">
            <summary>
            This is the object that is being returned.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedReturnValueHandler">
            <summary>
            This is the callback that is invoked when the arranged method is called
            to set the return value.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedCallbackHandler">
            <summary>
            This is the callback that is invoked when the arranged method is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedExceptionToThrow">
            <summary>
            This is the exception to throw when the arranged method is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedIgnoresAllArguments">
            <summary>
            This is set to true when the arrangement should ignore all arguments.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedArgumentsToIgnore">
            <summary>
            These are the indexes of the arguments that the arrangement should ignore when matching.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.ArrangedOutParametersToAssign">
            <summary>
            These are the out parameters that the method should assign.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.AssertMethod">
            <summary>
            This is the method that we are asserting.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.AssertExpectations">
            <summary>
            These are the expectations that we are asserting against.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.StubTemplate.AssertArguments">
            <summary>
            These are the arguments that we are asserting against.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Templates.StubArrangingListAttribute">
            <summary>
            Indicates that the field is a list that has arranged expectations for a stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.StubArrangingListAttribute.#ctor">
            <summary>
            Creates the attribute.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.GetOriginalMethodPatch">
            <summary>
            This patch is used to emit the original method that a templated method was based on.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetOriginalMethodPatch.#ctor">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetOriginalMethodPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code so that the original method is left on the stack.
            </summary>
            <param name="tracker"></param>
        </member>
        <member name="T:Microsoft.MMF.StubObjectWrapper`2">
            <summary>
            This is the base class for all types of stub wrappers.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
        </member>
        <member name="M:Microsoft.MMF.StubObjectWrapper`2.#ctor(`1)">
            <summary>
            Creates the stub object wrapper.
            </summary>
            <param name="target">The target object</param>
        </member>
        <member name="T:Microsoft.MMF.StubObjectWrapper`1">
            <summary>
            The StubObjectWrapper aggregates the actual stub object.  It serves as a starting point 
            for the syntax chain that arranges or asserts methods that were invoked on it.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StubObjectWrapper`1.#ctor(`0)">
            <summary>
            Creates the stub wrapper
            </summary>
            <param name="stub">The stub to wrap</param>
        </member>
        <member name="T:Microsoft.MMF.StubMimicObjectWrapper`1">
            <summary>
            The StubMimicObjectWrapper aggregates the actual mimic object.  It serves as a starting point 
            for the syntax chain that arranges or asserts methods that were invoked on it.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
        </member>
        <member name="T:Microsoft.MMF.IMimicObjectWrapper`1">
            <summary>
            Defines an object wrapper for a mimic of type T.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.IMimicObjectWrapper`1.Target">
            <summary>
            Returns the target of the wrapper.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StubMimicObjectWrapper`1.#ctor(Microsoft.MMF.MMFMimic)">
            <summary>
            Creates the stub mimic object wrapper.
            </summary>
            <param name="target">The mimic object</param>
        </member>
        <member name="P:Microsoft.MMF.StubMimicObjectWrapper`1.Microsoft#MMF#IMimicObjectWrapper{T}#Target">
            <summary>
            Returns the mimic's target object.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.StubExtensionMethods">
            <summary>
            This class contains extension methods that are used on stub objects.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ResetArrangements``2(Microsoft.MMF.StubObjectWrapper{``0,``1})">
            <summary>
            Resets the arrangements on a stub.
            </summary>
            <typeparam name="T">The type of object that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper that wraps the stub object.</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ResetRecordedMethods``2(Microsoft.MMF.StubObjectWrapper{``0,``1})">
            <summary>
            Resets the methods that have been recorded on a stub.
            </summary>
            <typeparam name="T">The type of object that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper that wraps the stub object.</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ResetAll``2(Microsoft.MMF.StubObjectWrapper{``0,``1})">
            <summary>
            Resets all stubbed and recorded methods.
            </summary>
            <typeparam name="T">The type of object that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper that wraps the stub object.</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.Stubs``2(Microsoft.MMF.StubObjectWrapper{``0,``1})">
            <summary>
            Tells the stub to eat a method call instead of invoking the base or aggragated class.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <returns>An instance of VoidState2</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.StubsByCalling``2(Microsoft.MMF.StubObjectWrapper{``0,``1},Microsoft.MMF.CallbackHandler)">
            <summary>
            Tells the stub to eat a method call instead of invoking the base or aggragated class.  When a stubbed 
            method is invoked, the callback handler will be invoked with the arguments passed into that method.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="callback">The callback to invoke when the method is invoked</param>
            <returns>An instance of VoidState2</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.Throws``2(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Exception)">
            <summary>
            Tells the current arrangement to throw an exception when the arranged method is invoked.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="exception">The exception to throw</param>
            <returns>An instance of VoidState2</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.Returns``3(Microsoft.MMF.StubObjectWrapper{``0,``1},``2)">
            <summary>
            Sets the return value for this arrangement.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The type that the delegate handler returns</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="returnValue">The return value</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ReturnsByCalling``3(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Func{System.Object[],``2})">
            <summary>
            Sets a delegate that will be invoked to get the return value for this arrangement.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The type that the delegate handler returns</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="returnValueHandler">A delegate that is used to return a custom return value based on the arguments of the method</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.IgnoresAllArguments``2(Microsoft.MMF.StubObjectWrapper{``0,``1})">
            <summary>
            Tells the stub to ignore all arguments when either asserting or stubbing.
            </summary>
            <typeparam name="T">The object type that we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.IgnoresArgumentsAt``2(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Int32[])">
            <summary>
            Tells the stub to ignore arguments at specific indexes when either asserting or stubbing.  The 
            indexes are 0-based.
            </summary>
            <typeparam name="T">The object type that we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="indexes">The indexes to ignore arguments at</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThat``2(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Action{``0})">
            <summary>
            Asserts that the method invoked by the handler was called.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="handler">The handler to invoke</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThatNew``2(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Func{``0})">
            <summary>
            Asserts that the constructor invoked by the lambda was called.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="handler">>A lambda that invokes a constructor</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThat(Microsoft.MMF.StubObjectWrapper{Microsoft.MMF.MMFStatic},System.Action)">
            <summary>
            Asserts that the static method invoked by the handler was called.
            </summary>
            <param name="wrapper">The wrapper object</param>
            <param name="handler">The handler to invoke</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThat``2(Microsoft.MMF.StubObjectWrapper{``0,``1},System.String,System.Object[])">
            <summary>
            Asserts that the method invoked by the handler was called.  This overload searches for the method
            by it's name and the types of the arguments that were passed in.  If it can't a method by that name,
            a StubArrangingException is thrown.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="methodName">The name of the method to assert</param>
            <param name="args">The arguments for method</param>
            <returns>The next state</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.StubArrangingException">Thrown if no method by methodName, with these arguments, could be found</exception>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThat``2(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Asserts that the method invoked by the handler was called.  Use this method overload to assert 
            that a specific method was called, where the method is not public and can't be discovered just by
            it's name and argument types.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="method">The method to invoke</param>
            <param name="args">The arguments for method</param>
            <returns>The next state</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.StubArrangingException">Thrown if no method by methodName, with these arguments, could be found</exception>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThat``3(Microsoft.MMF.StubObjectWrapper{``0,``1},System.Func{``0,``2})">
            <summary>
            Asserts that the method invoked by the handler was called.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the method we are asserting</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="handler">The handler to invoke</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AssertsThat``1(Microsoft.MMF.StubObjectWrapper{Microsoft.MMF.MMFStatic},System.Func{``0})">
            <summary>
            Asserts that the static method invoked by the handler was called.
            </summary>
            <typeparam name="V">The return type of the method we are asserting</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="handler">The handler to invoke</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.Calls``2(Microsoft.MMF.StubObjectWrapper{``0,``1},Microsoft.MMF.CallbackHandler{System.Boolean})">
            <summary>
            Sets a callback to invoke which can validate that a particular method call qualifies as valid
            during the assertion phase.  This callback will be invoked for every method call that was recorded
            during the act phase of the test.  The callback should return true for every method call that it deems 
            as valid.  The various WasCalled methods will keep track of the number of times the delegate returns true
            and will fail if the handler didn't return true the requisite number of times.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="wrapper">The wrapper object</param>
            <param name="callback">The callback handler to invoke</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``2(Microsoft.MMF.States.StubVoidState2{``0,``1},System.Action{``0})">
            <summary>
            Sets an arrangement on the method invoked by handler.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
            <param name="handler">The handler that invokes a method on the stub</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.OnNew``2(Microsoft.MMF.States.StubVoidState2{``0,``1},System.Func{``0})">
            <summary>
            Sets an arrangement on a constructor.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
            <param name="handler">>A lambda that invokes a constructor</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On(Microsoft.MMF.States.StubVoidState2{Microsoft.MMF.MMFStatic,Microsoft.MMF.MMFStatic},System.Action)">
            <summary>
            Sets an arrangement on the static method invoked by handler.
            </summary>
            <param name="state2">The previous state</param>
            <param name="handler">The handler that invokes a method on the stub</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``2(Microsoft.MMF.States.StubVoidState2{``0,``1},System.String,System.Object[])">
            <summary>
            Sets an arrangement on a method by its name.  Use this overload to stub a method that is not
            public.  The framework will attempt to find the method by matching the name and the types of 
            the arguments passed into this method.  If no method by that name and arguments can be found,
            a StubRecordingException will be thrown.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
            <param name="methodName">The name of the method to invoke</param>
            <param name="args">The arguments for the method</param>
            <exception cref="T:Microsoft.MMF.Exceptions.StubArrangingException">Thrown if no method by methodName, with these argument types, can be found</exception>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``2(Microsoft.MMF.States.StubVoidState2{``0,``1},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Sets an arrangement on a method by its method info.  Use this overload to stub a method that is not
            public and is not easily discovered.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state2">The previous state</param>
            <param name="method">The method to invoke</param>
            <param name="args">The arguments for the method</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``3(Microsoft.MMF.States.StubVoidState2{``0,``1},System.Func{``0,``2})">
            <summary>
            Sets an arrangement on the method invoked by handler.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the delegate</typeparam>
            <param name="state2">The instance of state2</param>
            <param name="handler">The handler that invokes a method on the stub</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``3(Microsoft.MMF.States.StubReturnState2{``0,``1,``2},System.Func{``0,``2})">
            <summary>
            Sets an arrangement on the method invoked by handler.
            </summary>
            <typeparam name="T">The type of object that is wrapped</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The type that is returned from the method call</typeparam>
            <param name="state2">The return state 2 to build off of</param>
            <param name="handler">The handler that invokes a method on the stub</param>
            <returns>An instance of return state 3</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``1(Microsoft.MMF.States.StubReturnState2{Microsoft.MMF.MMFStatic,Microsoft.MMF.MMFStatic,``0},System.Func{``0})">
            <summary>
            Sets an arrangement on the static method invoked by handler.
            </summary>
            <typeparam name="V">The type that is returned from the method call</typeparam>
            <param name="state2">The return state 2 to build off of</param>
            <param name="handler">The handler that invokes a method on the stub</param>
            <returns>An instance of return state 3</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``3(Microsoft.MMF.States.StubReturnState2{``0,``1,``2},System.String,System.Object[])">
            <summary>
            Sets an arrangement on a method by its name.  Use this overload to stub a method that is not
            public.  The framework will attempt to find the method by matching the name and the types of 
            the arguments passed into this method.  If no method by that name and arguments can be found,
            a StubRecordingException will be thrown.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the method</typeparam>
            <param name="state2">The previous state</param>
            <param name="methodName">The name of the method to invoke</param>
            <param name="args">The arguments for the method</param>
            <exception cref="T:Microsoft.MMF.Exceptions.StubArrangingException">Thrown if no method by methodName, with these argument types, can be found</exception>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.On``3(Microsoft.MMF.States.StubReturnState2{``0,``1,``2},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Sets an arrangement on a method by its method info.  Use this overload to stub a method that is not
            public and can't easily be discovered.
            </summary>
            <typeparam name="T">The type that the object wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the method</typeparam>
            <param name="state2">The previous state</param>
            <param name="method">The method to invoke</param>
            <param name="args">The arguments for the method</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AndStubs``2(Microsoft.MMF.States.StubVoidState3{``0,``1})">
            <summary>
            Tells the stub to eat a method call instead of invoking the base or aggragated class.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">An instance of state3</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AndStubsByCalling``2(Microsoft.MMF.States.StubVoidState3{``0,``1},Microsoft.MMF.CallbackHandler)">
            <summary>
            Tells the stub to eat a method call instead of invoking the base or aggragated class.  When a stubbed 
            method is invoked, the callback handler will be invoked with the arguments passed into that method.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">An instance of state3</param>
            <param name="callback">A callback to invoke</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AndReturns``3(Microsoft.MMF.States.StubVoidState3{``0,``1},``2)">
            <summary>
            Sets the return value for this arrangement.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the method we're stubbing</typeparam>
            <param name="state3">An instance of state3</param>
            <param name="returnValue">The value to return on the method that's stubbed</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AndReturnsByCalling``3(Microsoft.MMF.States.StubVoidState3{``0,``1},System.Func{System.Object[],``2})">
            <summary>
            Sets a delegate that will be invoked to get the return value for this arrangement.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the method we're stubbing</typeparam>
            <param name="state3">An instance of state3</param>
            <param name="returnHandler">A method that will supply a specific return value based on the arguments of the method</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.AndThrows``2(Microsoft.MMF.States.StubVoidState3{``0,``1},System.Exception)">
            <summary>
            Tells the current arrangement to throw an exception when the arranged method is invoked.
            </summary>
            <typeparam name="T">The type that the wrapper wraps</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">An instance of state3</param>
            <param name="exception">The exception to throw when the expectation is met</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WhenAssertingThat``2(Microsoft.MMF.States.StubVoidState3{``0,``1},System.Action{``0})">
            <summary>
            Sets up the assertion routine for validating the method in handler was called properly.
            </summary>
            <typeparam name="T">The object type that wrapper is wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The instance of state3</param>
            <param name="handler">The handler to invoke</param>
            <returns>An instance of void state 4</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WhenAssertingThatNew``2(Microsoft.MMF.States.StubVoidState3{``0,``1},System.Func{``0})">
            <summary>
            Sets up the assertion routine for validating the constructor in handler was called properly.
            </summary>
            <typeparam name="T">The object type that wrapper is wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The instance of state3</param>
            <param name="handler">>A lambda that invokes a constructor</param>
            <returns>An instance of void state 4</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WhenAssertingThat(Microsoft.MMF.States.StubVoidState3{Microsoft.MMF.MMFStatic,Microsoft.MMF.MMFStatic},System.Action)">
            <summary>
            Sets up the assertion routine for validating the static method in handler was called properly.
            </summary>
            <param name="state3">The instance of state3</param>
            <param name="handler">The handler to invoke</param>
            <returns>An instance of void state 4</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WhenAssertingThat``2(Microsoft.MMF.States.StubVoidState3{``0,``1},System.String,System.Object[])">
            <summary>
            Sets up the assertion routine for validating that a method was called properly.  This method 
            overload allows the assertion to be setup by name and is useful for cases where the asserted method 
            is not public.  If the method cannot be found, or the parameter types do not match, then a a
            StubRecordingException is thrown.
            </summary>
            <typeparam name="T">The object type that wrapper is wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The previous state</param>
            <param name="methodName">The name of the method to invoke</param>
            <param name="args">The arguments of the method</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WhenAssertingThat``2(Microsoft.MMF.States.StubVoidState3{``0,``1},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Sets up the assertion routine for validating that a particular method was called properly.  This method 
            overload allows the assertion to be setup by a specific method info, and is useful in cases where the 
            method is not public and can't be discovered easily.
            </summary>
            <typeparam name="T">The object type that wrapper is wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state3">The previous state</param>
            <param name="method">The method to invoke</param>
            <param name="args">The arguments of the method</param>
            <returns>The next state</returns>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalled``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments a single time.  This is analogous to 
            calling WasCalledOneTime().
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledOneTime``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments a single time.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledTwoTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments two times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledThreeTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments three times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledFourTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments four times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledXTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1},System.Int32)">
            <summary>
            Validates that the given method was called with the arguments x times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
            <param name="x">The number of times that the asserted method should have been called</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledAtLeastOneTime``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments at least one time.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledAtLeastTwoTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments at least two times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledAtLeastThreeTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments at least three times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledAtLeastFourTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments at least four times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledAtLeastXTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1},System.Int32)">
            <summary>
            Validates that the given method was called with the arguments at least x times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
            <param name="x">The number of times to ensure that this method was called</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasNotCalled``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the method was not called - at all.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The fourth state in the call sequence</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledNoMoreThanOneTime``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments no more than one time.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledNoMoreThanTwoTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments no more than two times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledNoMoreThanThreeTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments no more than three times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledNoMoreThanFourTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1})">
            <summary>
            Validates that the given method was called with the arguments no more than four times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledNoMoreThanXTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1},System.Int32)">
            <summary>
            Validates that the given method was called with the arguments no more than x times.
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The previous state</param>
            <param name="x">The maximum number of times that we expect this method to be called</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.WasCalledBetweenXAndYTimes``2(Microsoft.MMF.States.StubVoidState4{``0,``1},System.Int32,System.Int32)">
            <summary>
            Validates that the given method was called with the arguments between min and max times
            (both arguments are inclusive).
            </summary>
            <typeparam name="T">The type of object that is being stubbed</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state4">The fourth state</param>
            <param name="minimum">The minimum number of times</param>
            <param name="maximum">The maximum number of times</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ValidateMethodExpectations``2(Microsoft.MMF.States.StubVoidState4{``0,``1},System.Int32,System.Int32)">
            <summary>
            This method holds the validation logic for all assertion methods.
            </summary>
            <typeparam name="T">The type of object that is being wrapped</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state">The base class for all states</param>
            <param name="minimum">The minimum number of times that the method can be called</param>
            <param name="maximum">The maximum number of times that the method can be called (or Int32.MaxValue for infinity)</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ToAssertThat``2(Microsoft.MMF.States.StubVoidState5{``0,``1},System.Action{``0})">
            <summary>
            Asserts that the method invoked by the handler was called.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state5">The instance of state 5</param>
            <param name="handler">The handler to invoke</param>        
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ToAssertThatNew``2(Microsoft.MMF.States.StubVoidState5{``0,``1},System.Func{``0})">
            <summary>
            Asserts that the constructor invoked by the handler was called.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state5">The instance of state 5</param>
            <param name="handler">>A lambda that invokes a constructor</param>        
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ToAssertThat(Microsoft.MMF.States.StubVoidState5{Microsoft.MMF.MMFStatic,Microsoft.MMF.MMFStatic},System.Action)">
            <summary>
            Asserts that the method invoked by the handler was called.
            </summary>
            <param name="state5">The instance of state 5</param>
            <param name="handler">The handler to invoke</param>        
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ToAssertThat``1(Microsoft.MMF.States.StubVoidState5{Microsoft.MMF.MMFStatic,Microsoft.MMF.MMFStatic},System.Func{``0})">
            <summary>
            Asserts that the method invoked by the handler was called.
            </summary>
            <typeparam name="V">The return type of the asserted method</typeparam>
            <param name="state5">The instance of state 5</param>
            <param name="handler">The handler to invoke</param>        
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ToAssertThat``2(Microsoft.MMF.States.StubVoidState5{``0,``1},System.String,System.Object[])">
            <summary>
            Asserts that the method with the name methodName was called.  This overload can be used to 
            find a method by its name, and is useful in cases where the method is not public or 
            otherwise accessible.  If the method cannot be found, then a StubArrangingException is thrown.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state5">The previous state</param>
            <param name="methodName">The name of the method to assert</param>
            <param name="args">The arguments for the method</param>
            <exception cref="T:Microsoft.MMF.Exceptions.StubArrangingException">Thrown if no method by this name, with these parameter types could be found</exception>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.ToAssertThat``2(Microsoft.MMF.States.StubVoidState5{``0,``1},System.Reflection.MethodBase,System.Object[])">
            <summary>
            Asserts that the method was called.  This overload can be used to assert method calls where the 
            method is not public and isn't easily discoverable.
            </summary>
            <typeparam name="T">The type of object we are wrapping</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <param name="state5">The previous state</param>
            <param name="method">The method to invoke</param>
            <param name="args">The arguments for the method</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.InvokeStubHandler``1(System.Delegate,Microsoft.MMF.Generation.IStub)">
            <summary>
            Invokes a delegate that calls a stubbed method.
            </summary>
            <typeparam name="T">The type that we refer to the stub by</typeparam>
            <param name="handler">A delegate to invoke</param>
            <param name="stub">The stub to invoke the handler on</param>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.FindNonPublicMethod(System.String,System.Object[],System.Object)">
            <summary>
            This method finds a private / non-public method on the stub type that has the specified name and arguments.
            </summary>
            <param name="methodName">The name of the method to search for</param>
            <param name="args">The arguments for the method</param>
            <param name="stub">The stub to find the method on</param>
            <returns>A MethodInfo that can be used to invoke the method via reflection</returns>
            <exception cref="T:Microsoft.MMF.Exceptions.StubArrangingException">Thrown if no method by this name, with these types, could be found</exception>
        </member>
        <member name="M:Microsoft.MMF.StubExtensionMethods.Reset(Microsoft.MMF.Generation.IStub)">
            <summary>
            Resets the state of a stub object.
            </summary>
            <param name="stub">The stub to reset</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.ILInstruction">
            <summary>
            This is a simple data structure that we use to represent an instruction in IL.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstruction.NO_ARGS">
            <summary>
            This static default value is used instead of newing new empty arrays 
            every time this object is created.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstruction.#ctor">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstruction.#ctor(System.Reflection.Emit.OpCode)">
            <summary>
            Creates an instruction out of the specified opcode.
            </summary>
            <param name="opCode">The opcode</param>
        </member>
        <member name="P:Microsoft.MMF.Generation.ILInstruction.Arguments">
            <summary>
            Returns the arguments of the instruction.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry">
            <summary>
            This object holds all of the special cases that we need to properly redirect methods.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry.mInstance">
            <summary>
            The one and only instance of this class.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry.mSpecialCases">
            <summary>
            This is a list of special cases.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry.#cctor">
            <summary>
            Creates the special case registry.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry.#ctor">
            <summary>
            Creates the special case registry.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry.IsSpecialCase(System.Reflection.MethodBase)">
            <summary>
            Tell the caller whether or not this method needs to be handled differently.
            </summary>
            <param name="method">The method to match</param>
            <returns>True if the method is a special case</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.SpecialCaseRegistry.HandleSpecialCase(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Handles a special case.
            </summary>
            <param name="method">The method that is a special case</param>
            <param name="tracker">The tracker to use to patch the special case</param>
        </member>
        <member name="T:Microsoft.MMF.Constraints.ContainsConstraint">
            <summary>
            Creates a constraint that checks the value of a string to see if it contains
            a certain string.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constraints.ContainsConstraint.mContainsString">
            <summary>
            The string to check with contains.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.ContainsConstraint.#ctor(System.Int32,System.String)">
            <summary>
            Creates the contains constraint out of the specified string.
            </summary>
            <param name="argIndex">The argument index to check</param>
            <param name="containsString">The string to check for contains</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.ContainsConstraint.Validate(System.Object)">
            <summary>
            validates that the string contains the specified text.
            </summary>
            <param name="argValue">The argument value to check</param>
            <returns>True if the string value of argValue contains the text</returns>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.StubExpectationViolationException">
            <summary>
            A stub expectation violation exception adds a replay log that allows users to debug 
            failed stub assertions.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.StubExpectationViolationException.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Boolean})">
            <summary>
            Creates the stub expectation violation expection.
            </summary>
            <param name="message">The message of the expection</param>
            <param name="validationMessages">A list of validation messages</param>
            <param name="results">A list of results from the expectations</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.StubExpectationViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="P:Microsoft.MMF.Exceptions.StubExpectationViolationException.ValidationMessages">
            <summary>
            Gets / sets the list of validation messages.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Exceptions.StubExpectationViolationException.Results">
            <summary>
            Gets / sets a list of results from the validation attempts.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Exceptions.StubExpectationViolationException.HTMLReport">
            <summary>
            Returns an html report of the stub assertion.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.ReturnState2`2">
            <summary>
            Represents the second state in the expectation building process, with a return value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.ReturnState3`2">
            <summary>
            Represents the third state in the expectation building process, with a return value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.ReturnState4`2">
            <summary>
            Represents the fourth state in the expectation building process, with a return value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.ReturnState5`2">
            <summary>
            Represents the fifth state in the expectation building process, with a return value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.ReturnState6`2">
            <summary>
            Represents the sixth state in the expectation building process, with a return value.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.States.StubReturnState2`3">
            <summary>
            Represents the second state in a stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return type of the method that we're stubbing</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubReturnState2`3.#ctor(`1)">
            <summary>
            Creates an instance of StubReturnState2.
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubReturnState3`3">
            <summary>
            Represents the third state in a stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return value of the method we are stubbing</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubReturnState3`3.#ctor(`1)">
            <summary>
            Creates the StubReturnState3.
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubReturnState4`3">
            <summary>
            Represents the fourth state in a stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return value of the method we are stubbing</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubReturnState4`3.#ctor(`1)">
            <summary>
            Creates the return state4.
            </summary>
            <param name="stubbedObject">The stubbed object wrapper</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubReturnState5`3">
            <summary>
            Represents the fifth state in a stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return value of the method we are stubbing</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubReturnState5`3.#ctor(`1)">
            <summary>
            Creates the return state5.
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.States.StubReturnState6`3">
            <summary>
            Represents the sixth state in a stub creation sequence.
            </summary>
            <typeparam name="T">The type that we are stubbing</typeparam>
            <typeparam name="U">The type that we refer to T by</typeparam>
            <typeparam name="V">The return value of the method we are stubbing</typeparam>
        </member>
        <member name="M:Microsoft.MMF.States.StubReturnState6`3.#ctor(`1)">
            <summary>
            Creates an instance of state6.
            </summary>
            <param name="stubbedObject">The object that we're stubbing</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.ShortInlineVarTranslator">
            <summary>
            Translates the short inline var.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineVarTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineVarTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the short inline var instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineVarTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a short inline var instruction.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.MockObjectWrapper`2">
            <summary>
            This is the base class for all mock object wrappers.
            </summary>
            <typeparam name="T">The type that we are mocking</typeparam>
            <typeparam name="U">The type that we refer to the generated type by</typeparam>
        </member>
        <member name="M:Microsoft.MMF.MockObjectWrapper`2.#ctor(`1)">
            <summary>
            Creates the mock object wrapper.
            </summary>
            <param name="target">The target object</param>
        </member>
        <member name="T:Microsoft.MMF.MockObjectWrapper`1">
            <summary>
            The MockObjectWrapper aggregates the actual mock object.  It serves as a starting point 
            for the syntax chain that allows method expectations to be set.
            </summary>
            <typeparam name="T">The type of object to mock.</typeparam>
        </member>
        <member name="M:Microsoft.MMF.MockObjectWrapper`1.#ctor(`0)">
            <summary>
            Creates the mock object wrapper.
            </summary>
            <param name="mockedObject">The mock object that we are wrapping</param>
        </member>
        <member name="T:Microsoft.MMF.MockMimicObjectWrapper`1">
            <summary>
            The MockMimicObjectWrapper aggregates the actual mimic object.  It serves as a starting point 
            for the syntax chain that allows method expectations to be set.
            </summary>
            <typeparam name="T">The type that we are mimicking</typeparam>
        </member>
        <member name="M:Microsoft.MMF.MockMimicObjectWrapper`1.#ctor(Microsoft.MMF.MMFMimic)">
            <summary>
            Creates the mock / mimic object wrapper.
            </summary>
            <param name="target">The generated object</param>
        </member>
        <member name="P:Microsoft.MMF.MockMimicObjectWrapper`1.Microsoft#MMF#IMimicObjectWrapper{T}#Target">
            <summary>
            Returns the mimic object.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Profiler">
            <summary>
            The profiler class serves as an entry point for a test harness to register itself to listen to events.
            When the Redirection API traps a method or a new, it forwards the call to the profiler which 
            then notifies any listeners of the event.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Profiler.mInstance">
            <summary>
            A singleton instance.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Profiler.mObservers">
            <summary>
            This is a list of observers that are paying attention to the events on the profiler.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Profiler.#cctor">
            <summary>
            The static constructor.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Profiler.#ctor">
            <summary>
            Creates the profiler object.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Profiler.AddObserver(Microsoft.MMF.IProfilerObserver)">
            <summary>
            Adds an observer to the list.
            </summary>
            <param name="observer">The observer to add</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.RemoveObserver(Microsoft.MMF.IProfilerObserver)">
            <summary>
            Removes an observer from the list.
            </summary>
            <param name="observer">The observer to remove</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireMethodInTestStartedEvent(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Fires a method-in-test started event.  This method should be called from the redirection API.
            </summary>
            <param name="instance">The object instance that the method was invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireMethodInTestFinishedEvent(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Fires a method-in-test finished event.  This method should be called from the redirection API.
            </summary>
            <param name="instance">The object instance that the method was invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireMethodStartedEvent(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Fires a method started event.  This method should be called from the redirection API.
            </summary>
            <param name="instance">The instance that the method is invoked on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireMethodFinishedEvent(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Fires a method finished event.  This method should be called from the redirection API.
            </summary>
            <param name="instance">The instance that the method finished on</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireRedirectionConsidered(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            This method is called when the framework is considering whether or not to redirect
            into a particular method.  The arguments contain all of the information neccessary
            for the tester to determine whether they should redirect into a method or not.  This 
            event gives the user the option to override the default scope of a test.
            </summary>
            <param name="instance">The instance that is being redirected into</param>
            <param name="args">The arguments of the redirection</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireNewObjectEvent(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Fires an event that tells all observers that a new object of a particular type was created.
            </summary>
            <param name="instance">Always null</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="M:Microsoft.MMF.Profiler.FireExceptionEvent(System.Object,Microsoft.MMF.RedirectionArgs)">
            <summary>
            Fires an event that tells all observers that an exception was thrown.
            </summary>
            <param name="instance">Always null</param>
            <param name="args">The arguments of the event</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.InterlockedClassSpecialCase">
            <summary>
            The system.threading.Interlocked class can't be intercepted, because doing so causes synchronization
            errors due to the nature of redirection.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.InterlockedClassSpecialCase.#ctor">
            <summary>
            Creates the special case.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.InterlockedClassSpecialCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Returns true if the method's declaring type is Interlocked and the method is public and static.
            </summary>
            <param name="method">The method to match</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.InterlockedClassSpecialCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches by simply calling the method.
            </summary>
            <param name="matchingMethod"></param>
            <param name="tracker"></param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.MakeLocalFieldPatch`1">
            <summary>
            This is a patch that creates a local field of type T on the class that this is patching.
            It leaves the FieldInfo of that field on the stack.
            </summary>
            <typeparam name="T">The type of field that the patch will create</typeparam>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.MakeLocalFieldPatch`1.#ctor">
            <summary>
            Creates the local field patch.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.MakeLocalFieldPatch`1.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the template by declaring a local field and putting it's FieldInfo on the top of the stack.
            </summary>
            <param name="tracker">The track to patch the template with</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.CallAggregatedClassPatch">
            <summary>
            This class is used to invoke an aggregated class, in cases where we have a partial mock / stub.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.CallAggregatedClassPatch.#ctor">
            <summary>
            Creates the patch class.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.CallAggregatedClassPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code to call the aggregated class.  This assumes that the aggregated class
            is on top of the stack when it's invoked.
            </summary>
            <param name="tracker">The tracker to use to patch</param>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.MimicTestException">
            <summary>
            This exception is thrown from inside the mimic test class to signify that something went wrong creating 
            tests and their redirections.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MimicTestException.#ctor(System.String)">
            <summary>
            Creates the mimic test exception.
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MimicTestException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="T:Microsoft.MMF.StaticMimicTest">
            <summary>
            This class can be used to redirect static methods so that they can be tested using the redirection API.
            Because static methods do not need an instance object to be invoked on, nothing needs to be 
            passed into this class when it is created.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StaticMimicTest.#ctor">
            <summary>
            Creates a test object that can be used to test static methods.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StaticMimicTest.Test(System.Action)">
            <summary>
            This method is used to test static methods using redirection.  It duplicates the methods IL, but 
            replaces calls to the methods that it was compiled against with calls to mock objects instead. 
            </summary>
            <param name="testStatement">The test statement for a static method, something like Environment.SetEnvironmentVariable(...)</param>
        </member>
        <member name="M:Microsoft.MMF.StaticMimicTest.Test``1(System.Func{``0})">
            <summary>
            This method is used to test static methods using redirection.  It duplicates the methods IL, but 
            replaces calls to the methods that it was compiled against with calls to mock objects instead. 
            </summary>
            <typeparam name="U">The type that the static method returns</typeparam>
            <param name="testStatement">The test statement, something like Environment.GetEnvironmentVariable(...)</param>
            <returns>A value of U returned by the method invoked in TestStatement</returns>
        </member>
        <member name="M:Microsoft.MMF.StaticMimicTest.Test(System.Reflection.MethodBase,System.Object[])">
            <summary>
            This method can be used to test a private or protected static method under redirection.
            </summary>
            <param name="methodInTest">The method to invoke</param>
            <param name="args">The arguments of the method</param>
            <returns>The result of the redirected method</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineSigTranslator">
            <summary>
            Translates an inline sig call.  The inline sig operand occurs for calli OpCode.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineSigTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineSigTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the inlinesig operand.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineSigTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Not currently supported.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.CalliParameters">
            <summary>
            Holds the parameters neccessary to generate a calli instruction.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Translators.CalliParameters.mCallingConvention">
            <summary>
            The calling convention of the call.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Translators.CalliParameters.mReturnType">
            <summary>
            The return type.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Translators.CalliParameters.mParameterTypes">
            <summary>
            The parameter type array.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Translators.CalliParameters.mReplacementMethod">
            <summary>
            This is the method that we will call instead of the original method.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.CalliParameters.#ctor(System.Reflection.MethodBase,System.Reflection.MethodInfo)">
            <summary>
            Creates a calli parameters object that can be used to emit the opcodes neccessary to call
            a method indirectly.
            </summary>
            <param name="originalMethod">The original method.  This is where we get the calling convention and parameters from</param>
            <param name="replacementMethod">The replacement method</param>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.CalliParameters.Method">
            <summary>
            Gets the function pointer that we should call indirectly.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.CalliParameters.CallingConvention">
            <summary>
            Returns the calling convention of the indirect call.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.CalliParameters.ReturnType">
            <summary>
            Gets the return type of the calli call.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Translators.CalliParameters.ParameterTypes">
            <summary>
            This is an array of parameter types.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.MakeLocalFieldWithAttributePatch`2">
            <summary>
            Makes a local field and adds a custom attribute to it so that it can be 
            found via reflection.
            </summary>
            <typeparam name="T">The field type</typeparam>
            <typeparam name="U">The attribute type</typeparam>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.MakeLocalFieldWithAttributePatch`2.#ctor">
            <summary>
            Creates the patch object.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.MakeLocalFieldWithAttributePatch`2.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code with a field that has a custom attribute of type U.
            </summary>
            <param name="tracker">The opcode tracker</param>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.StubArrangingException">
            <summary>
            This exception is thrown in cases where a unit test attempted to 
            arrange a stub in a way that was invalid.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.StubArrangingException.#ctor(System.String)">
            <summary>
            Creates the stub arranging exception.
            </summary>
            <param name="message">The message of the exception.</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.StubArrangingException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a stub arranging exception with the specified inner exception.
            </summary>
            <param name="message">The message of the exception</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.StubArrangingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineFieldTranslator">
            <summary>
            Translates an inline field.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineFieldTranslator.#ctor">
            <summary>
            Constructor does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineFieldTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inline field instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineFieldTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a field info object.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.MethodExpectation">
            <summary>
            This object represents the invocation of a method on a mock object.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.MethodExpectation.EMPTY_ARGUMENT_ARRAY">
            <summary>
            This is a static readonly array of empty objects.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.MethodExpectation.EMPTY_INDEX_ARRAY">
            <summary>
            This is a static readonly array of empty integers.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.MethodExpectation.mCount">
            <summary>
            This is the number of times that this method has been invoked.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.MethodExpectation.mMinimumHandler">
            <summary>
            This is the handler that handles minimum number of times.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.StateMachine.MethodExpectation.mMaximumHandler">
            <summary>
            This is the handler that handles maximum number of times.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.#ctor">
            <summary>
            Creates a method expectation.  This should never be created directly.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.Reset">
            <summary>
            Resets the state of the validator.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.PreValidate(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>
            Validates that this method call is acceptable.
            </summary>
            <param name="mockedObject">This is the object that is being mocked.</param>
            <param name="mockedMethod">This is the method that is being called on the mocked object.</param>
            <param name="args">The arguments of the method.</param>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.Validate">
            <summary>
            Validates that we can make this move one more time.  Basically, all we do is call
            the MaximumNumberOfTimes method to make sure that this method can be invoked once more.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.PostValidate">
            <summary>
            Validates that this method was invoked the minimum number of times.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.GetReturnValue(System.Object[])">
            <summary>
            Returns the return value for the method expectation either by returning the static value, or 
            by invoking the return value delegate.
            </summary>
            <param name="args">The arguments of the method</param>
            <returns>The return value.</returns>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.InvokeNonValidatingCallback(System.Object[])">
            <summary>
            If there is a non-validating callback set, this will invoke it.
            </summary>
            <param name="args">The arguments of the callback</param>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.CopyOutParametersIntoArgArray(System.Object[])">
            <summary>
            If the method expectation has out parameters and a callback was assigned, then we use the values 
            returned from the callback for out parameters.  Ref parameters get overwritten by default, but this 
            has no consequence usually because it's the same values that are passed in.  If a callback is used,
            we assume that it will assign the out parameter values - otherwise, we copy the default values that
            were set when the expectation was created.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.MethodExpectation.ToLogString">
            <summary>
            Returns a string that represents the method expectation
            </summary>
            <returns>A string that represents the expectation</returns>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.MockedObject">
            <summary>
            This is the object we are mocking.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.MockedMethod">
            <summary>
            This is the method that we are mocking.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.ReturnValue">
            <summary>
            This is the generic object that this method returns.  Can only be 
            set using the strongly typed TypedReturnValue property!
            </summary>        
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.ReturnValueHandler">
            <summary>
            Allows the user to set a return value method instead of a return value
            object.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.MinimumNumberOfTimes">
            <summary>
            This is the minimum number of times that the method is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.MaximumNumberOfTimes">
            <summary>
            This is the maximum number of times that the method is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.IsDefaultRangeHandler">
            <summary>
            This bool is true unless somebody explicitly sets 
            a min / max range.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.Arguments">
            <summary>
            These are the arguments into the method.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.OutParametersToAssign">
            <summary>
            These are the objects that should be assigned to any out parameters.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.ArgumentsToIgnore">
            <summary>
            These are the indexes of the arguments to ignore.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.IgnoresAllArguments">
            <summary>
            When true, the unit test should ignore every argument in the invoked method.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.DoDefault">
            <summary>
            When true, the expectation tells the mock to do the default the default
            action when the expectation is met.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.ExceptionToThrow">
            <summary>
            When this is not null, we are supposed to throw an exception
            when the method is called.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.Callback">
            <summary>
            When this is set, it will be invoked with the arguments 
            that were passed into the method expectation.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.NonValidatingCallback">
            <summary>
            This is a non-validating callback handler that is invoked in some cases.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.ValidationFailureReason">
            <summary>
            If any part of the validation process fails, this property should have a failure reason which
            can be logged for debugging purposes.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.MethodExpectation.Constraints">
            <summary>
            Gets / sets the constraints for this method expectation.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.ILInstructionReader">
            <summary>
            This class is used to read an array of IL and parse instructions from it.  Without
            this class, reading instructions from byte arrays is very difficult.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.ALL_OPCODES">
            <summary>
            Every opcode in the MSIL language 
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.PREFIX_OPCODES">
            <summary>
            For opcodes that are more than 1 byte long, we have an additional lookup.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.mBytes">
            <summary>
            This is the stream of bytes that we're iterating over.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.#cctor">
            <summary>
            The static constructor creates the OpCodes array.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.#ctor(System.Byte[])">
            <summary>
            Creates the instruction reader out of the specified array of bytes.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.GetEnumerator">
            <summary>
            Returns a new instance of the enumerator.
            </summary>
            <returns>An enumerator which iterates over the byte code</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns a new instance of the enumerator.
            </summary>
            <returns>An enumerator which iterates over the byte code</returns>
        </member>
        <member name="P:Microsoft.MMF.Generation.ILInstructionReader.IsLastInstruction">
            <summary>
            Returns true if this is the last instruction in the sequence.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator">
            <summary>
            This is the instance class that will actually iterate over the instruction
            byte array.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.mBytes">
            <summary>
            This is the stream of bytes that we're iterating over.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.mIndex">
            <summary>
            This is the current index in the list of bytes.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.mCurrentInstruction">
            <summary>
            This is the current instruction in the reader.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.mReader">
            <summary>
            This is the instance of the instruction reader.  
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.#ctor(Microsoft.MMF.Generation.ILInstructionReader)">
            <summary>
            Creates the enumerator.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.Dispose">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.MoveNext">
            <summary>
            Moves to the next instruction in the byte array.
            </summary>
            <returns>True if we can move next.  Otherwise false.</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.Reset">
            <summary>
            Resets the enumerator.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.Current">
            <summary>
            Returns the current ILInstruction
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.ILInstructionReader.ILInstructionReaderEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns the current instruction
            </summary>
        </member>
        <member name="T:Microsoft.MMF.TimesValidationHandler">
            <summary>
            This delegate is used by the mock method invocation object
            to dynamically validate the number of times that a method
            was called is acceptable.
            </summary>
            <param name="numberOfTimes">The number of times that a method was called.</param>
            <returns>True if the method was called an acceptable number of times.</returns>
        </member>
        <member name="T:Microsoft.MMF.RecorderOrderToggledHandler">
            <summary>
            This delegate represents a method that is called by an order toggler 
            to toggle the recording order of method calls.
            </summary>
            <param name="isOrdered">When true, the methods should be added in a ordered fashion.</param>
        </member>
        <member name="T:Microsoft.MMF.CallbackHandler">
            <summary>
            This delegate represents a method that is invoked when a method invocation
            expectation is reached.
            </summary>
            <param name="args">The arguments of the method</param>
        </member>
        <member name="T:Microsoft.MMF.CallbackHandler`1">
            <summary>
            This delegate represents a method that is invoked when a method invocation
            expectation is reached.
            </summary>
            <typeparam name="U">This is the return type of the method</typeparam>
            <param name="args">The arguments of the method</param>
            <returns>The return value of the handler</returns>
        </member>
        <member name="T:Microsoft.MMF.RedirectionHandler">
            <summary>
            This delegate represents a handler that can respond to the events on the profiler API.
            </summary>
            <param name="instance">The instance that was invoked</param>
            <param name="args">The arguments of the method</param>
        </member>
        <member name="T:Microsoft.MMF.RedirectionArgs">
            <summary>
            This class is as the argument for every redirection event fire by the profiler API.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.RedirectionArgs.#ctor">
            <summary>
            Creates the redirection args object.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.ShouldRedirect">
            <summary>
            This property gives users the ability to override the default scoping operator 
            by manually forcing redirection to redirect into a particular method.  If an 
            event handler for the RedirectionStarted event changes this value to true, then
            the method will be redirected even if it's outside the scope of the test.  Alternately,
            if it changes it to false, then it will not redirect the method even if it's within the 
            scope of the test.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.Type">
            <summary>
            This is the type that declares the method that was invoked.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.Exception">
            <summary>
            If the event generated an exception, it will be stored in this property.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.Method">
            <summary>
            This is the method that the redirection took place on.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.Arguments">
            <summary>
            These are the arguments of the method.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.ReturnValue">
            <summary>
            This is the return value from the method, if applicable.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.IsSameClass">
            <summary>
            This flag is true when the method is being invoked from the same 
            class as the method-in-test.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.IsBaseClass">
            <summary>
            This flag is true when the method is being invoked on the base 
            class of the method-in-test.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.IsOtherClass">
            <summary>
            This flag is true when the invoked method is on a different class from
            the type in test.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.IsSameAssembly">
            <summary>
            This flag is true when the invoked method is in an assembly that is part of the redirection.
            By default, this list only includes the assembly that defines the method-in-test, but it 
            can be expanded using the RedirectsInto method on the TestHarness class.  This flag is true
            so long as the invoked method is within the scope of those assemblies.  Otherwise, it is false.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.IsStatic">
            <summary>
            True when the method is static.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.RedirectionArgs.IsConstructor">
            <summary>
            True when the method is a constructor.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.Template">
            <summary>
            This class represents a class template that we use to generate code.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Template.mClassTemplateType">
            <summary>
            This is the type of the template.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Template.mModuleBuilder">
            <summary>
            This is the module builder that we are using to generate the current template.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Template.mTypeBuilder">
            <summary>
            This is the type builder that we use to create the type.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.#ctor(System.Type)">
            <summary>
            Creates a template out of a specific type.
            </summary>
            <param name="classTemplateType">The class template type</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.StartGeneratingType(System.Type,System.Type,System.Type[],Microsoft.MMF.Generation.EClassTemplateTypes,System.Reflection.Emit.ModuleBuilder)">
            <summary>
            Starts to generate a type based on the template.  This will automatically generated any members,
            properties and methods on the template class that are marked with the TemplateMember attribute.
            
            This method will also automatically generate constructors to to the base class.
            </summary>
            <param name="baseClassType">The base class of the generated type</param>
            <param name="mockedType">The type that we are mocking</param>
            <param name="interfaces">Additional interfaces to implement</param>
            <param name="classTemplate">The class template of the type to start generating</param>
            <param name="moduleBuilder">The module builder to create the type in</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.GenerateMockMethods(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},Microsoft.MMF.Generation.EMethodTemplateTypes)">
            <summary>
            Mocks every method in the list using a mock template that fits the passed in parameters.
            </summary>
            <param name="methods">An enumeration of methods to mock</param>
            <param name="methodTemplateType">The parameters of the template to use</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.FinishGeneratingType">
            <summary>
            Once we're done generating the type, this method will create it and return it to the caller.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.GetTemplateMethod(Microsoft.MMF.Generation.EMethodTemplateTypes,System.Type)">
            <summary>
            Searches the class template for a method template that matches the template types
            enumeration.
            </summary>
            <param name="methodTemplate">The method template</param>
            <param name="returnType">The return type of the method</param>
            <returns>A template method info</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.CloneMethod(System.Reflection.Emit.ModuleBuilder,System.Reflection.MethodBase)">
            <summary>
            Clones a method by the same name into the type builder that is part of the dynamic module. This method uses
            the translation API to clone the bits from one method into another.  It does not, however, instrument that 
            method unless there are calls to Patcher.Patch within it.
            </summary>
            <param name="moduleBuilder">The dynamic module builder</param>
            <param name="method">The method to clone</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Template.CloneMethod(System.Reflection.Emit.ModuleBuilder,System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <summary>
            Clones a method using a specific methodBuilder.  This allows us to define a method with a different
            signature than the method we are cloning.  Used when we are generating mock methods.
            </summary>
            <param name="moduleBuilder">The module builder</param>
            <param name="generator">The IL Generator used to build the method</param>
            <param name="templateMethod">The method to clone</param>
            <param name="mockedMethod">The method that we're mocking</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.GetCurrentMethodCase">
            <summary>
            This is the special case that handles calls to MethodBase.GetCurrentMethod().
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.GetCurrentMethodCase.#ctor">
            <summary>
            Creates the special case.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.GetCurrentMethodCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Returns true if a method matches this special case.
            </summary>
            <param name="method">The method to match</param>
            <returns>True if it matches; otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.GetCurrentMethodCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patch the redirected method.
            </summary>
            <param name="matchingMethod">The method that matched the special case</param>
            <param name="tracker">The tracker to use to patch</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Patches.GetCurrentMethodPatch">
            <summary>
            This patch is used to insert dynamic code into a template that returns the method 
            that is currently executing.  We need this because in order to handle generic methods,
            we need to explicitly create the method info out of the methods' generic arguments.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetCurrentMethodPatch.#ctor">
            <summary>
            Creates the patch.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Patches.GetCurrentMethodPatch.Patch(Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the template with code that puts the current method on the top of the stack.
            </summary>
            <param name="tracker">The tracker to use</param>
        </member>
        <member name="T:Microsoft.MMF.Constraints.SatisfiesConstraint`1">
            <summary>
            Creates a constraint that invokes a custom delegate to validate an argument value 
            at a specific index.
            </summary>
            <typeparam name="T">The type to validate</typeparam>
        </member>
        <member name="F:Microsoft.MMF.Constraints.SatisfiesConstraint`1.mCallback">
            <summary>
            This is the callback that we will invoke to test the parameter.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.SatisfiesConstraint`1.#ctor(System.Int32,System.Func{`0,System.Boolean})">
            <summary>
            Creates the satisfies constraint out of the specified index and callback.
            </summary>
            <param name="argIndex">The argument index</param>
            <param name="callback">The callback</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.SatisfiesConstraint`1.Validate(System.Object)">
            <summary>
            Invokes the callback to validate the argument value.
            </summary>
            <param name="argValue">The argument to validate</param>
            <returns>True if the callback validates, otherwise false</returns>
        </member>
        <member name="T:Microsoft.MMF.UninitializedObject">
            <summary>
            This is a utility class that makes the creation of uninitialized objects
            a little bit easier for consumers.  This class contains extension and static methods
            that make it easier to deal with sealed classes, etc.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.UninitializedObject.Create``1">
            <summary>
            Creates an uninitialized instance of type T.
            </summary>
            <typeparam name="T">The type to create</typeparam>
            <returns>An uninitialized instance of type T</returns>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.DynamicTypeCreationException">
            <summary>
            This exception is thrown if there is a problem creating a mock object.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.DynamicTypeCreationException.#ctor(System.String)">
            <summary>
            Creates the mock creation exception.
            </summary>
            <param name="message">The message of the error.</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.DynamicTypeCreationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="T:Microsoft.MMF.StateMachine.ExpectationLog">
            <summary>
            This class is used to log replay exceptions so that we can review them after a failure.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ExpectationLog.#ctor">
            <summary>
            Creates the expectation log.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ExpectationLog.Reset">
            <summary>
            Resets the log.  This should be called at the start of every new recording.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ExpectationLog.Log(Microsoft.MMF.StateMachine.AutomataState,Microsoft.MMF.StateMachine.MethodExpectation,Microsoft.MMF.StateMachine.AutomataState,System.Boolean)">
            <summary>
            Creates a new method expectation log entry.
            </summary>
            <param name="state1">The state that we were in when we ran this expectation</param>
            <param name="expectation">The method expectation object</param>
            <param name="state2">The state that we were evaluating whether we could go to</param>
            <param name="succeeded">True if the expectation was met or not</param>
        </member>
        <member name="M:Microsoft.MMF.StateMachine.ExpectationLog.PrintLogToDebug(System.Boolean)">
            <summary>
            Prints this log to the debug log.
            </summary>
            <param name="isFailure">This should be true when it was called after a failure</param>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLog.ExpectationEntries">
            <summary>
            This is a list of the methods that were executed in the state machine.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLog.LastEntry">
            <summary>
            Returns the last entry in the expectation log.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.StateMachine.ExpectationLog.IterationNumber">
            <summary>
            This is the iteration number.  This is a different value than the to and from
            state.  It's incremented every time an expectation is matched.  This allows us to 
            compare the most recent set of failures instead of all of them and makes erroring 
            a lot easier.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Exceptions.MMFException">
            <summary>
            This is a generic MMF Exception.  It can be thrown from many different places, from many different
            API's and is not specific to Mocks, Stubs, or Redirection.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MMFException.#ctor(System.String)">
            <summary>
            Creates the exception object.
            </summary>
            <param name="message">The message of the exception</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MMFException.#ctor(System.String,System.Exception)">
            <summary>
            Creates the exception out of the specified message and inner exception.
            </summary>
            <param name="message">The exception message</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="M:Microsoft.MMF.Exceptions.MMFException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A constructor that allows the exception to be serialized.
            </summary>
            <param name="info">The serialization info object</param>
            <param name="context">The streaming context object</param>
        </member>
        <member name="T:Microsoft.MMF.Constraints.AnyValueConstraint">
            <summary>
            Defines a constraint that will always validate the particular argument type.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.AnyValueConstraint.#ctor(System.Int32)">
            <summary>
            Creates the AnyValueConstraint object.
            </summary>
            <param name="argIndex">The argument index</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.AnyValueConstraint.Validate(System.Object)">
            <summary>
            This always returns true, regardless of what the value is.
            </summary>
            <param name="argValue">The argument to validate</param>
            <returns>True, regardless of the argument value</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineITranslator">
            <summary>
            Translates an inline I instruction
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineITranslator.#ctor">
            <summary>
            Default constructor does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineITranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates an inlineI instruction
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineITranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inline I opcode.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.ERedirectionScope">
            <summary>
            This enumeration defines the scope of a redirected method.  The scope indicates 
            how recursive redirection will be: whether it will redirect into other classes or 
            assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.MethodInTest">
            <summary>
            Indicates that only the method in test should be redirected.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.SameClass">
            <summary>
            Indicates that methods in the same class as the method in test should
            be redirected.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.BaseClass">
            <summary>
            Indicates that methods that are defined in the base class of the method
            in test should be redirected.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.AllClasses">
            <summary>
            Indicates that methods in all classes should be redirected, regardless of whether 
            they are the same class that is being tested.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.StaticMethods">
            <summary>
            Indicates that calls into static methods should be redirected.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.Constructors">
            <summary>
            Indicates that the test should redirect into constructors.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.ERedirectionScope.Everything">
            <summary>
            This flag will include everything.  Be careful when expanding the scope this large; it can have 
            unintended consequences.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Constants">
            <summary>
            This class holds constants used throughout the Mock API.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.REPORT_XSLT_FILE_NAME">
            <summary>
            This is the name of the mmf log html file.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.REPORT_XSLT_RESOURCE_PATH">
            <summary>
            This is the resource path to the embeded XSLT file.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.STRONG_NAME_KEY_PATH">
            <summary>
            This is the resource path to the snk file that is used to strong name the generated assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.MOCKS_ASSEMBLY_NAME">
            <summary>
            This is the name of the mock assembly
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.MIMIC_TESTS_ASSEMBLY_NAME">
            <summary>
            This is the name of the mimic test assembly
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.STUBS_ASSEMBLY_NAME">
            <summary>
            This is the name of the stubs assembly.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.INDIRECTION_ASSEMBLY_NAME">
            <summary>
            This is the name of the indirection assembly.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.REGISTRY_CLASS_NAME">
            <summary>
            This is the full name of the Registry class in the Indirection assembly.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.ADD_ONCALL_HANDLER_METHOD">
            <summary>
            This is the name of the add method for the OnCall event on the registry class.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.REMOVE_ONCALL_HANDLER_METHOD">
            <summary>
            This is the name of the remove method for the OnCall event on the registry class.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.ADD_ONSTATICCALL_HANDLER_METHOD">
            <summary>
            This is the name of the add method for the OnStaticCall event on the registry class.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constants.REMOVE_ONSTATICCALL_HANDLER_METHOD">
            <summary>
            This is the name of the remove method for the OnStaticCall event on the registry class.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constants.#ctor">
            <summary>
            Not to be created.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Parameterize">
            <summary>
            This class is used to parameterize the arguments of a redirected method.  The static methods within
            the parameterize class can be embedded in a Test statement.  The redirection API will automatically 
            iterate through all of the possible values and invoke a method-in-test with the specified argument values.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Parameterize.mCurrentIndexes">
            <summary>
            This list keeps track of the argument indexes that we are iterating through
            in the order that they come to us.  They will always come to us in the correct 
            order, where the earlier arguments will be added to the front of the list.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Parameterize.mCurrentValues">
            <summary>
            This list keeps track of the current value for a given iteration.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Parameterize.mMaxIndexList">
            <summary>
            This sorted list keeps track of the maximum number of items in each argument index.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Parameterize.mIsBeingParameterized">
            <summary>
            This bool gets set to true if the Parameterize class is being actively used
            in the current redirection.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Parameterize.mInstance">
            <summary>
            This is the one and only instance of the Parameterize class.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.#ctor">
            <summary>
            The private constructor creates the static data structures.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Reset">
            <summary>
            Resets the state of the Parameterize class.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.IsBeingParameterized">
            <summary>
            Returns true if the current method is being parameterized or not.  This 
            property gets consumed by redirected method roots.  When an exception gets caught, it 
            calls this method to see if it should rethrow the exception or not.  If the method's
            parameters are being parameterized, then the catch should NOT rethrow it.  Otherwise, it
            should.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Values``1(``0[])">
            <summary>
            Parameterizes the values in the array when invoking a redirected method.
            </summary>
            <typeparam name="T">The type of the argument to parameterize</typeparam>
            <param name="values">An array of values to iterate through</param>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Values``1(``0[],System.Int32)">
            <summary>
            This is the actual method that will iterate through a list of values.  Internally,
            it keeps track of where it is in the array using sorted lists and other data structures.  If 
            the values array is empty, the method will throw an exception.
            </summary>
            <typeparam name="T">The type of argument to iterate through</typeparam>
            <param name="values">An array of values to iterate</param>
            <param name="index">The index of the argument to iterate through</param>
            <returns>The next instance of values</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.List``1(System.Collections.Generic.List{``0})">
            <summary>
            Parameterizes the values in the specified list by iterating through each of them.
            </summary>
            <typeparam name="T">The object type to iterate through</typeparam>
            <param name="listOfValues">A list of values to iterate through</param>
            <returns>The default value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.List``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            This is the actual parameterize method that will be invoked.  It simply iterates 
            through a list of values one at a time.
            </summary>
            <typeparam name="T">The type to iterate through</typeparam>
            <param name="listOfValues">A list of values to iterate over</param>
            <param name="index">The argument index</param>
            <returns>The next value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Range(System.Int32,System.Int32)">
            <summary>
            Allows a test to be parameterized with a range of integer values.  The range generated is inclusive, meaning 
            Range(1, 3) will iterate over values 1, 2 and 3.
            </summary>
            <param name="start">The starting index</param>
            <param name="end">The ending index</param>
            <returns>The next integer in the range</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Range(System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the actual method that is called to iterate through a range.
            </summary>
            <param name="start">The starting index</param>
            <param name="end">The ending index</param>
            <param name="index">The argument index to parameterize</param>
            <returns>The next integer in the sequence</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Enumeration``1">
            <summary>
            Parameterizes an enumeration by iterating over all of its values.  The enumeration must have 
            at least 2 values in it.
            </summary>
            <typeparam name="T">The enumeration to parameterize</typeparam>
            <returns>The first value of the enumeration</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.Enumeration``1(System.Int32)">
            <summary>
            This is the actual method that will iterate through the enumeration values.
            </summary>
            <typeparam name="T">The type to enumerate through</typeparam>
            <param name="index">The index of the argument to iterate</param>
            <returns>The next value of the enumeration</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.GetNextIndex(System.Int32,System.Int32)">
            <summary>
            Figures out the next value in the x-nested loops.
            </summary>
            <param name="argIndex">The argument index to get the parameter number for</param>
            <param name="max">The maximum number of iterations at this index</param>
            <returns>The next index of the argument to return</returns>
        </member>
        <member name="M:Microsoft.MMF.Parameterize.IsDone">
            <summary>
            Returns true after we have iterated through all of the possible parameters.
            </summary>
            <returns>True if we have iterated through everything.  Otherwise, false.</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Templates.MockTemplate">
            <summary>
            This is the class template for all mock objects.  It contains template methods 
            for every type of mock we may ever want to generate.  The IL of this class and it's 
            methods are cloned for every mock object that the MMF generates.  
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.Templates.MockTemplate.MMFStatic">
            <summary>
            This is a static object that we use to mark the 'this' pointer on static method calls.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.#ctor">
            <summary>
            Creates the mock template.  Generated classes will have their own constructors.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.DefaultConstructor">
            <summary>
            This is the template for constructors.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.DefaultNoReturn">
            <summary>
            This is the default mock method template for a method that has no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.DefaultWithReturn``1">
            <summary>
            This is the default mock template method for a method that has a return value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.PartialNoReturn">
            <summary>
            This is the template for a partial mock method that has no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.PartialWithReturn``1">
            <summary>
            This is the method template for a partial mock method that has a return value.
            </summary>
            <typeparam name="T">The return type for the method</typeparam>
            <returns>The value of T</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.StaticNoReturn">
            <summary>
            This is the static mock method template for a method that has no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.StaticWithReturn``1">
            <summary>
            This is the static mock method template for a method that has no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.DefaultMimicNoReturn">
            <summary>
            This is the default mock / mimmic method template for a method that has no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.DefaultMimicWithReturn``1">
            <summary>
            This is the default mock / mimic template method for a method that has a return value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.PartialMimicNoReturn">
            <summary>
            This is the template for a partial mock method that has no return value.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Templates.MockTemplate.PartialMimicWithReturn``1">
            <summary>
            This is the method template for a partial mock method that has a return value.
            </summary>
            <typeparam name="T">The return type for the method</typeparam>
            <returns>The value of T</returns>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.MockTemplate.IsDoneConstructing">
            <summary>
            This property determines whether the mock's constructor has been called or not.
            If it hasn't, then the mock methods won't attempt to validate.  Instead, they'll pass 
            the call to the base class or eat the call completely.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Generation.Templates.MockTemplate.AggregatedObject">
            <summary>
            This property is used to invoke an aggregated object for partial mimics.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.TemplateRepository">
            <summary>
            This static class holds all of the class templates that reside inside this assembly.  It
            searches the assembly for all classes with the TemplateClass attribute and caches them locally
            so that they can be found easily and quickly.  TemplateClasses are searched for by their flags.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TemplateRepository.mInstance">
            <summary>
            This is the singleton instance of the template repository.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.TemplateRepository.mTemplateMap">
            <summary>
            Maps template types to the types that template them.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TemplateRepository.#cctor">
            <summary>
            The static constructor creates the singleton.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TemplateRepository.#ctor">
            <summary>
            One and only instance.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.TemplateRepository.GetTemplate(Microsoft.MMF.Generation.EClassTemplateTypes)">
            <summary>
            Returns the template that matches the template type.
            </summary>
            <param name="templateType">The type of template to return</param>
            <returns>A Template object that can be used to dynamically create a class and method</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.SpecialCases.GetExecutingAssemblyCase">
            <summary>
            Patches the code so that it returns the original assembly of the type-in-test, instead 
            of the dynamic assembly where the method is currently executing.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.SpecialCases.GetExecutingAssemblyCase.mGetExecutingAssemblyMethod">
            <summary>
            This is the special case method that we're patching.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.GetExecutingAssemblyCase.#ctor">
            <summary>
            Creates the special case.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.GetExecutingAssemblyCase.IsMatch(System.Reflection.MethodBase)">
            <summary>
            Returns true if a method matches this special case.
            </summary>
            <param name="method">The method to match</param>
            <returns>True if it matches; otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.SpecialCases.GetExecutingAssemblyCase.Patch(System.Reflection.MethodBase,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Patches the code so that we load the original assembly instead of calling 
            the method that it was compiled against.
            </summary>
            <param name="matchingMethod">The method that matched the special case</param>
            <param name="tracker">The tracker to use to patch</param>
        </member>
        <member name="T:Microsoft.MMF.Constraints.StartsWithConstraint">
            <summary>
            Defines a constraint that checks string values to check if they start with a specific string.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constraints.StartsWithConstraint.mStartsWithString">
            <summary>
            This is the string that we check against.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.StartsWithConstraint.#ctor(System.Int32,System.String)">
            <summary>
            Creates the starts with constraint out of the specified index and string.
            </summary>
            <param name="argIndex">The index</param>
            <param name="startsWithString">The string to check</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.StartsWithConstraint.Validate(System.Object)">
            <summary>
            Validates that the string value of the argument begins with the correct string.
            </summary>
            <param name="argValue">The string value to check</param>
            <returns>True if the string begins with the starts with value</returns>
        </member>
        <member name="T:Microsoft.MMF.Constraints.EndsWithConstraint">
            <summary>
            Defines a constraint that checks the end of a string.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Constraints.EndsWithConstraint.mEndsWithString">
            <summary>
            The string to check at the end.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Constraints.EndsWithConstraint.#ctor(System.Int32,System.String)">
            <summary>
            Creates an ends with constraint with the specified string.
            </summary>
            <param name="argIndex">The argument index to check</param>
            <param name="endsWithString">The string to check</param>
        </member>
        <member name="M:Microsoft.MMF.Constraints.EndsWithConstraint.Validate(System.Object)">
            <summary>
            Validates whether the string value of argValue ends with mEndswithString.
            </summary>
            <param name="argValue">The argument value</param>
            <returns>True if the argument value ends with the specified string</returns>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.ShortInlineRTranslator">
            <summary>
            Translates the short inline R instruction.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineRTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineRTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the ShortInlineR opperand.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.ShortInlineRTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits a float.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineSwitchTranslator">
            <summary>
            Translates the inline switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineSwitchTranslator.#ctor">
            <summary>
            Nothing to do.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineSwitchTranslator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the inline switch statement.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineSwitchTranslator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inline switch statement.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Generation.Translators.InlineI8Translator">
            <summary>
            Translates an inline I8 instruction
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineI8Translator.#ctor">
            <summary>
            Default constructor does nothing,
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineI8Translator.Translate(Microsoft.MMF.Generation.ILInstruction,Microsoft.MMF.Generation.OpCodeTracker)">
            <summary>
            Translates the inline I8 instruction.
            </summary>
            <param name="instruction">The instruction to translate</param>
            <param name="tracker">The opcode tracker used to set arguments</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.Translators.InlineI8Translator.Emit(Microsoft.MMF.Generation.TranslatedInstruction,System.Reflection.Emit.ILGenerator)">
            <summary>
            Emits an inlineI8 opcode.
            </summary>
            <param name="instruction">The translated instruction</param>
            <param name="generator">The ILGenerator</param>
        </member>
        <member name="T:Microsoft.MMF.Configuration.MMFOptions">
            <summary>
            This class reads the MMFConfigurationSection from the app.config (if it can) and returns the default options to
            any part of the code that wants to read these options.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Configuration.MMFOptions.mInstance">
            <summary>
            This is the one and only instance of the MMFOptions class.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Configuration.MMFOptions.mConfigSection">
            <summary>
            This is the configuration section that we use.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Configuration.MMFOptions.#cctor">
            <summary>
            The static constructor creates the instance variable.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Configuration.MMFOptions.#ctor">
            <summary>
            Creates the MMFOptions class.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFOptions.StrongNameGeneratedAssemblies">
            <summary>
            Returns true if the API should strong-name the generated assemblies.  Otherwise, false.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFOptions.CleanupExceptions">
            <summary>
            Returns true of redirected methods should clean up exceptions before they are
            rethrown.  For debug builds, the default is true.  For release builds, it is false.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFOptions.WriteRecordingLogByDefault">
            <summary>
            Returns true if the API should write recording logs on validation failures by default.  Otherewise, false.
            </summary>
        </member>
        <member name="P:Microsoft.MMF.Configuration.MMFOptions.WriteGeneratedAssembliesToDisk">
            <summary>
            Returns true if the generated assemblies should be written to disk or not.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Configuration.MMFConfigurationSectionConstants">
            <summary>
            Contains constants that are used in the MMF configuration section.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Configuration.MMFConfigurationSectionConstants.STRONG_NAME_GENERATED_ASSEMBLIES">
            <summary>
            This property is used to determine whether the generated assemblies should be strong-named or not.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Configuration.MMFConfigurationSectionConstants.CLEANUP_EXCEPTIONS">
            <summary>
            This property is used to determine whether exceptions thrown from redirected methods should 
            have their stack traces cleaned up so that they are more readable.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Configuration.MMFConfigurationSectionConstants.WRITE_RECORDING_LOG_BY_DEFAULT">
            <summary>
            This property is used to determine whether the recording logs are written by default or not.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Configuration.MMFConfigurationSectionConstants.SAVE_GENERATED_ASSEMBLIES_TO_DISK">
            <summary>
            This property is used to determine whether the generated assemblies should be saved to 
            the disk at the end of a test run.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Configuration.MMFConfigurationSectionConstants.#ctor">
            <summary>
            Cannot be instantiated.
            </summary>
        </member>
        <member name="T:Microsoft.MMF.Generation.ILHelper">
            <summary>
            This class has a number of utility methods that allow us to perform some common
            functionalities in one place.
            </summary>
        </member>
        <member name="F:Microsoft.MMF.Generation.ILHelper.mRedirectedMethodCache">
            <summary>
            This dictionary caches redirected methods so that we don't keep generating them.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.#cctor">
            <summary>
            Creates static members.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.#ctor">
            <summary>
            Can't be instantiated.
            </summary>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.GenerateUniqueName">
            <summary>
            Untility method to generate a unique name that can be used
            to name generated assemblies, modules, and types.
            </summary>
            <returns>The unique name to use.</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.CanSeeInternalsOf(System.Reflection.Assembly)">
            <summary>
            Checks to see if the generated assemblies will have access to internal methods
            and properties of the target assembly.  We can figure this out by looking for the
            InternalsVisibleTo attribute in the target assembly and seeing if it matches any of our
            generated assemblies.
            </summary>
            <param name="assembly">The assembly to check</param>
            <returns>True if the MMF has access; otherwise false</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.GenerateProperty(System.Reflection.Emit.TypeBuilder,System.String,System.Type)">
            <summary>
            Generates a default property with a randomly named member variable
            for a given type and returns the property builder for that property.
            </summary>
            <param name="typeBuilder">The type builder</param>
            <param name="propertyName">The name of the property to generate</param>
            <param name="propertyType">The type of the property</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.PrepForRethrow(System.Exception)">
            <summary>
            Preps an exception in a way that allows it to be rethrown.  The rethrown exception will preseve the original stack trace.  This allows 
            us to redirect methods and still have useful exceptions to look at.
            </summary>
            <param name="exception">The exception that is about to be rethrown</param>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.ExtractLastExecutedMethod(System.Delegate)">
            <summary>
            Reads the IL of the handler that is passed in and returns the last method that was executed
            in the method that the handler points to.
            </summary>
            <param name="handler">The handler to extract the method from</param>
            <returns>The last method that is invoked in the method that the handler points to</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.GenerateRedirectionMethod(System.Type,System.Reflection.MethodBase,System.Boolean)">
            <summary>
            Generates a method that redirects the method calls within methodInTest.
            </summary>
            <param name="typeInTest">The type in test</param>
            <param name="methodInTest">The method in test</param>
            <param name="isRootMethod">When true, the redirected method will be wrapped in code that passes the arg values to the profiler API</param>
            <returns>A static method that instruments the method in test</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.InvokeEquivalentMethodOnGeneratedObject(System.Delegate,System.Object)">
            <summary>
            This method invokes equivelent method that is invoked by the delegate passed into this method.  The generated object
            must define the same method that the handler invokes.  This method assumes that the generated object is also the target.
            See the override below for more information.
            </summary>
            <param name="handler">The delegate to invoke</param>
            <param name="generatedObject">The generated object</param>
            <returns>The return value from the delegate that was invoked</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.InvokeEquivalentMethodOnGeneratedObject(System.Delegate,System.Object,System.Reflection.MethodBase)">
            <summary>
            This method is used to generate a delegate that looks identicle to the one 
            that's passed into this method, but instead of invoking the method on whatever it was compiled against, it will
            find the same method that's defined on the generated object and invoke that method on the target object that's passed in.
            So, for instance:
            
            t => t.TestMe()
            
            Gets replaced with g => g.TestMe()
            
            Where g is the generated object that either subclasses or mimics t.  Alternately, this method makes it possible 
            for the target to be a different object that defines the method.  This works well in cases where the generated method
            is static, while the original method is not.  We do this to make MimicTests work: the generated method is static, but the 
            'target' is still the object that we're testing.
            </summary>
            <param name="handler">The handler we want to replace</param>
            <param name="target">The object to invoke the method on</param>
            <param name="replacementMethod">The method to invoke instead of the last method invoked by the delegate</param>
            <returns>A delegate that can be invoked in order to call the generatedObject when we are recording expecations</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.GetLocalSymbols(System.Diagnostics.SymbolStore.ISymbolScope)">
            <summary>
            Traverses the symbol scope tree hierarchy and returns a flat-list of all of the locals in the 
            method.
            </summary>
            <param name="symbolScope">The symbol store to return items for</param>
            <returns>A list of symbol stores</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.GetSymbolScopesAtOffset(System.Diagnostics.SymbolStore.ISymbolScope,System.Int32)">
            <summary>
            Recursively finds every symbol scope, and it's children, that start at a particular offset.  This method will
            return a list where the first element will be the parent, the second will be the child, and the third will be the 
            grand parent.
            </summary>
            <param name="symbolScope">The symbol scope to search from</param>
            <param name="offset">The offset to look for</param>
            <returns>A list of symbol scopes that start at this offset</returns>
        </member>
        <member name="M:Microsoft.MMF.Generation.ILHelper.FindReplacementMethodOnGeneratedType(System.Reflection.Me