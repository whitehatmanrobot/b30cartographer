.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndCreateTableIfNotExist(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create a table with the specified name if it does not already exist.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>true</c>, if table was created, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTableIfNotExist(System.String)">
            <summary>
            Creates the table if it does not exist.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns><c>true</c> if table was created, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginDoesTableExist(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to determine whether or not a table exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndDoesTableExist(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to verify if table exists.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>True</c>, if table exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DoesTableExist(System.String)">
            <summary>
            Checks whether the table exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>
            <c>True</c>, if table exists, <c>false</c> otherwise
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTablesFromModel(System.Type,System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Creates the tables needed for the specified custom TableServiceContext.
            </summary>
            <param name="serviceContextType">Type of the service context.</param>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTables">
            <summary>
            Lists the tables in the storage account.
            </summary>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTables(System.String)">
            <summary>
            Lists the tables which begin with particular prefix.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmented">
            <summary>
            Lists the tables as a set of pages.
            </summary>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmented(System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Lists the tables as a set of pages.
            </summary>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmented(System.String,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Lists the tables which begin with particular prefix as a set of pages.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginListTablesSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to list tables.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginListTablesSegmented(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous o
            peration to list tables.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginListTablesSegmented(System.String,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to list tables.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndListTablesSegmented(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to list tables.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>A segment containing current results and information to retrieve additional results.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginDeleteTable(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to delete a table.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndDeleteTable(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete a table.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTable(System.String)">
            <summary>
            Deletes the table.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginDeleteTableIfExist(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to delete the tables if it exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndDeleteTableIfExist(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to delete the tables if it exists.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>True</c>, if the table was deleted, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTableIfExist(System.String)">
            <summary>
            Deletes the table if it exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns><c>True</c>, if the table was deleted, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTableImpl(System.String)">
            <summary>
            Creates the table implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTableIfNotExistImpl(System.String,System.Action{System.Boolean})">
            <summary>
            Creates the table if not exist implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="setResult">The set result.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DoesTableExistImpl(System.String,System.Action{System.Boolean})">
            <summary>
            Verifies whether the table exist implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="setResult">The set result.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmentedImpl(System.String,System.Nullable{System.Int32},Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{System.String}})">
             <summary>
             Lists the tables segmented implementation.
             </summary>
             <param name="prefix">The prefix.</param>
            <param name="maxResults"></param>
            <param name="continuationToken"></param>
             <param name="setResult">The set result.</param>
             <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.GetResultOrDefault``1(Microsoft.WindowsAzure.StorageClient.Tasks.Task{``0},``0@)">
            <summary>
            Gets the result or default.
            </summary>
            <typeparam name="T">The type to resolve to result</typeparam>
            <param name="task">The task.</param>
            <param name="result">The result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTableImpl(System.String)">
            <summary>
            Delete table implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTableIfExistImpl(System.String,System.Action{System.Boolean})">
            <summary>
            Deletes table if exists implementation .
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="setResult">The set result.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BaseUri">
            <summary>
            Gets the base URI for the Table service
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.RetryPolicy">
            <summary>
            Gets or sets the retry policy for all of the requests by the service client
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.Timeout">
            <summary>
            Gets or sets the timeout for all of the requests by the service client
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.Credentials">
            <summary>
            Gets the credentials used by the client
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableServiceContext">
            <summary>
            A version of <see cref="T:System.Data.Services.Client.DataServiceContext"/> to work on Windows Azure Table service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.TableServiceContext"/> class.
            </summary>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.BeginSaveChangesWithRetries(System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to save changes while applying the retry policy.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.BeginSaveChangesWithRetries(System.Data.Services.Client.SaveChangesOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to save changes while applying the retry policy.
            </summary>
            <param name="options">The options for saving changes.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.EndSaveChangesWithRetries(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to save changes while applying the retry policy.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns> A <see cref="T:System.Data.Services.Client.DataServiceResponse"/> that represents the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.SaveChangesWithRetries">
            <summary>
            Saves changes while applying the retry policy.
            </summary>
            <returns> A <see cref="T:System.Data.Services.Client.DataServiceResponse"/> that represents the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.SaveChangesWithRetries(System.Data.Services.Client.SaveChangesOptions)">
            <summary>
            Saves changes while applying the retry policy.
            </summary>
            <param name="options">The options for saving changes.</param>
            <returns> A <see cref="T:System.Data.Services.Client.DataServiceResponse"/> that represents the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.SaveChangesWithRetriesImpl(System.Data.Services.Client.SaveChangesOptions,System.Action{System.Data.Services.Client.DataServiceResponse})">
            <summary>
            Saves the changes with retries implementation.
            </summary>
            <param name="options">The options for saving changes.</param>
            <param name="setResult">The action to set result.</param>
            <returns>A sequence of tasks to perform the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.DataContextSendingRequest(System.Object,System.Data.Services.Client.SendingRequestEventArgs)">
            <summary>
            Callback on DataContext object sending request.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:System.Data.Services.Client.SendingRequestEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceContext.RetryPolicy">
            <summary>
            Gets or sets the retry policy for all of the requests by the service client
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceContext.StorageCredentials">
            <summary>
            Gets the storage account credentials used by the client
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableServiceEntity">
            <summary>
            Represents an entity in a table.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.#ctor(System.String,System.String)">
            <summary>
            Creates a TableServiceEntity object.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.#ctor">
            <summary>
            Creates a TableServiceEntity object.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.Timestamp">
            <summary>
            Gets or sets the timestamp.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.PartitionKey">
            <summary>
            The partition key of a table entity.
            </summary>
            <remarks>
            The concatenation of the partition key 
            and row key must be unique within the table.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.RowKey">
            <summary>
            The row key of a table entity.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableServiceExtensionMethods">
            <summary>
            A class for adding useful methods for the Table service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceExtensionMethods.AsTableServiceQuery``1(System.Linq.IQueryable{``0})">
            <summary>
            Converts the query into a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/> object that supports 
            additional operations like retries.
            </summary>
            <typeparam name="TElement">The type of the element.</typeparam>
            <param name="query">The query.</param>
            <returns>
            <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/>
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1">
            <summary>
            Represents a single query request to the Windows Azure Table service.
            </summary>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.#ctor(System.Data.Services.Client.DataServiceQuery{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/> class with the specified <paramref name="query"/>.
            </summary>
            <param name="query">The <see cref="T:System.Data.Services.Client.DataServiceQuery`1"/> object to wrap.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.#ctor(System.Data.Services.Client.DataServiceQuery{`0},Microsoft.WindowsAzure.StorageClient.RetryPolicy)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/> class with the specified <paramref name="query"/> and <paramref name="retryPolicy"/>.
            </summary>
            <param name="query">The <see cref="T:System.Data.Services.Client.DataServiceQuery`1"/> object to wrap.</param>
            <param name="policy">The <see cref="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.RetryPolicy"/> to use when retrying requests.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute">
            <summary>
            Executes the query with retries and returns the results.
            </summary>
            <returns>The results of the query.</returns>
            <remarks>The <see cref="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute"/> method makes one request when it is called and further requests as elements are read from the returned result.</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute(Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Executes the query with retries and returns the results.
            </summary>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>The results of the query.</returns>
            <remarks>The <see cref="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute(Microsoft.WindowsAzure.StorageClient.ResultContinuation)"/> method makes one request when it is called and further requests as elements are read from the returned result.</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.BeginExecuteSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of results of a query.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.BeginExecuteSegmented(Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of results of a query.
            </summary>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.EndExecuteSegmented(System.IAsyncResult)">
            <summary>
            Returns the first segment of results of an asynchronous request to execute a query.
            </summary>
            <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of results.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Expand(System.String)">
            <summary>
            Expands the specified path.
            </summary>
            <param name="path">The path.</param>
            <returns>A new query with the expanded path</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.RetryPolicy">
            <summary>
            Gets or sets the <see cref="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.RetryPolicy"/> to use when retrying requests.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Provider">
            <summary>
            Gets the query provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceTable.#ctor(System.String)">
            <summary>
            Creates a table with the specified name.
            </summary>
            <param name="name">The name of the table.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceTable.TableName">
            <summary>
            The table name.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.SR">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentEmptyError">
            <summary>
              Looks up a localized string similar to The argument must not be empty string..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentOutOfRangeError">
            <summary>
              Looks up a localized string similar to The argument is out of range.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentTooLargeError">
            <summary>
              Looks up a localized string similar to The argument &apos;{0}&apos; is larger than maximum of &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentTooSmallError">
            <summary>
              Looks up a localized string similar to The argument &apos;{0}&apos; is smaller than minimum of &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.AttachToTableServiceContext">
            <summary>
              Looks up a localized string similar to Cannot attach to a TableStorageDataServiceContext object. These objects already contain the functionality for accessing the table storage service..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobQSharedKeyLiteUnsuppported">
            <summary>
              Looks up a localized string similar to &quot;Versions before 2009-09-19 do not support Shared Key Lite for Blob And Queue, current target version &apos;{0}&apos;&quot;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobSizeReductonError">
            <summary>
              Looks up a localized string similar to Cannot change size below currently written size.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobSizeTypeMismatch">
            <summary>
              Looks up a localized string similar to A stream blob must have a blob size of 0..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobTooLargeError">
            <summary>
              Looks up a localized string similar to The blob is larger than maximum supported size &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlocksExistError">
            <summary>
              Looks up a localized string similar to Data already uploaded.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlocksTooSmallError">
            <summary>
              Looks up a localized string similar to The block size must be positive value.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlockTooLargeError">
            <summary>
              Looks up a localized string similar to Block size can not be larger than &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotCreateSASForSnapshot">
            <summary>
              Looks up a localized string similar to Cannot create Shared Access Signature for snapshots. Perform the operation on the root blob instead..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotCreateSASSignatureForGivenCred">
            <summary>
              Looks up a localized string similar to Cannot create Shared Access Signature as the credentials does not have account name information. Please check that the credentials used support creating Shared Access Signature..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotCreateSASWithoutAccountKey">
            <summary>
              Looks up a localized string similar to Cannot create Shared Access Signature unless the Account Key credentials are used by the BlobServiceClient..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotModifySnapshot">
            <summary>
              Looks up a localized string similar to Cannot perform this operation on a blob representing a snapshot..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ClientSideTimeoutError">
            <summary>
              Looks up a localized string similar to Server operation did not finish within user specified timeout &apos;{0}&apos; seconds, check if operation is valid or try increasing the timeout..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConditionalRequiresDateTime">
            <summary>
              Looks up a localized string similar to If-Modified-Since and If-Unmodified-Since require a DateTime value..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConditionalRequiresETag">
            <summary>
              Looks up a localized string similar to If-Match and If-None-Match require an ETag value..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConditionNotMatchedError">
            <summary>
              Looks up a localized string similar to The conditionals specified for this operation did not match server..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConfigurationSettingPublisherError">
            <summary>
              Looks up a localized string similar to ConfigurationSettingSubscriber needs to be set before FromConfigurationSetting can be used.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CredentialsCantSignRequest">
            <summary>
              Looks up a localized string similar to The supplied credentials &apos;{0&apos;} cannot be used to sign request.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.DeleteSnapshotsNotValidError">
            <summary>
              Looks up a localized string similar to The option &apos;{0}&apos; must be &apos;None&apos; to delete a specific snapshot specified by &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.IncompatibleAddressesProvided">
            <summary>
              Looks up a localized string similar to Cannot combine incompatible absolute Uris base &apos;{0}&apos;  relative &apos;{1}&apos;.When trying to combine 2 absolute Uris, the base uri should be a valid base of the relative Uri..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.InvalidAclType">
            <summary>
              Looks up a localized string similar to Invalid acl public access type returned &apos;{0}&apos;. Expected blob or container..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.InvalidContinuationType">
            <summary>
              Looks up a localized string similar to The continuation type passed in is unexpected. Please verify that the correct continuation type is passed in. Expected {0}, found {1}.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.InvalidQueryParametersInsideBlobAddress">
            <summary>
              Looks up a localized string similar to Invalid query parameters inside Blob address &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ListSnapshotsWithDelimiterError">
            <summary>
              Looks up a localized string similar to Listing snapshots is only supported in flat mode (no delimiter). Consider setting BlobRequestOptions.UseFlatBlobListing property to true..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MD5MismatchError">
            <summary>
              Looks up a localized string similar to Calculated MD5 does not match existing property.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MessageTooLarge">
            <summary>
              Looks up a localized string similar to Messages cannot be larger than {0} bytes..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingAccountInformationInUri">
            <summary>
              Looks up a localized string similar to Cannot find account information inside Uri &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingContainerInformation">
            <summary>
              Looks up a localized string similar to Invalid blob address &apos;{0}&apos;, missing container information.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingMandatoryParamtersForSAS">
            <summary>
              Looks up a localized string similar to Missing mandatory parameters for valid Shared Access Signature.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingXmsDateInHeader">
            <summary>
              Looks up a localized string similar to Canonicalization did not find a non empty x-ms-date header in the WebRequest. Please use a WebRequest with a valid x-ms-date header in RFC 123 format (example request.Headers[&quot;x-ms-date&quot;] = DateTime.UtcNow.ToString(&quot;R&quot;, CultureInfo.InvariantCulture)).
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MultipleCredentialsProvided">
            <summary>
              Looks up a localized string similar to Cannot provide credentials as part of the address and as constructor parameter. Either pass in the address or use a different constructor..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MultipleSnapshotTimesProvided">
            <summary>
              Looks up a localized string similar to Multiple different snapshot times provided as part of query &apos;{0}&apos; and as constructor parameter &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MustCallEndMoveNextSegmentFirst">
            <summary>
              Looks up a localized string similar to EndMoveNextSegment must be called before the Current property can be accessed..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.NoMoreResultsForSegmentCursor">
            <summary>
              Looks up a localized string similar to The segment cursor has no more results..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.NotSupportedForPageBlob">
            <summary>
              Looks up a localized string similar to This operation is not supported for creating a PageBlob. Use other operations to create a PageBlob..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.PathStyleUriMissingAccountNameInformation">
            <summary>
              Looks up a localized string similar to Missing account name information inside path style uri. Path style uris should be of the form http://&lt;IPAddressPlusPort&gt;/&lt;accountName&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.RelativeAddressNotPermitted">
            <summary>
              Looks up a localized string similar to Address &apos;{0}&apos; is not an absolute address. Relative addresses are not permitted in here..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.SeekTooFarError">
            <summary>
              Looks up a localized string similar to Attempting to seek past the end of the stream.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.SeekTooLowError">
            <summary>
              Looks up a localized string similar to Attempting to seek before the start of the stream.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ServerReturnedMoreThanMaxResults">
            <summary>
              Looks up a localized string similar to Server returned more that MaxResults requested.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.TableNameInvalid">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid table name..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.TooManyBlocksError">
            <summary>
              Looks up a localized string similar to The number of blocks is larger than the maximum of &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.TooManyPolicyIdentifiers">
            <summary>
              Looks up a localized string similar to Too many &apos;{0}&apos; shared access policy identifiers provided. Server does not support setting more than &apos;{1}&apos; on a single container..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.UndefinedBlobType">
            <summary>
              Looks up a localized string similar to The blob type cannot be undefined..
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\Hive\Hive.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Hive</name>
    </assembly>
    <members>
        <member name="T:Hive.Functional.Doc">
            <HighLevel>
            The goal of this test plan is define the test coverage for the LIVE HIVE. Included you will find API descriptions, a test matrix, and signoff criteria.
            
            <b>What is LIVE HIVE?</b>
            Thought of as a LIVE Registry, the Xbox LIVE Hive stores client configuration settings that affect symbolic references to online resources, and various knobs that change a client's behavior towards Live. Clients call into a GetClientConfig API that returns relevant values based on the context in which they are requested. Currently this is targeted exclusively towards the Xbox 360. 
            
            <b>How it works?</b>
            The HIVE is a fairly simple concept. The HIVE contains a settings table exists in NPDB, the table name is t_live_registry_settings. 
            
             <center>
                <Table>
                    <tr align="center" bgcolor="#FFFFF0">
                        <td>guid_setting</td>
                        <td>vc_environment</td>
                        <td>vc_client_config</td>
                        <td>si_build</td>
                        <td>si_qfe</td>
                        <td>ti_beta_machine</td>
                        <td>vc_setting</td>
                        <td>vc_value</td>
                    </tr>
                    <tr>
                       <td>954ed4c9-9a5c-494d-b116-6fa72dd5ee81</td>	
                       <td>testnet</td>
                       <td>xenon</td>
                       <td>NULL</td>
                       <td>NULL</td>
                       <td>0	</td>
                       <td>AdCenterUri</td>	
                       <td>http://mfs.msn-int.com/mfs/mfs.aspx</td>
                    </tr>
                </Table>
            </center>
            
            GetLiveConfig only has one input value, and that is the config name. The config name is used to gather up all the settings that need to be sent back. The frontdoor code walks through all of the rows in the table and builds a cache for each config name it sees. When a client makes a request, a simple lookup and return is done on the passed in config name. 
            
            The plan is to put in place some code that picks up on changes and flushes the cache so that the new settings are always available.
            
            The returned item is a string of name=value pairs.
            
            Setting1=foo
            Setting2=bar
            </HighLevel>
            <Goals>
             •	Verify that requesting info for a specific config name returns only the info for that config name.
             •	Verify that sending invalid data will not cause and problems.
             •	Verify that database changes are picked up and cached automatically.
             •	Verify that performance meets minimum requirements.
            </Goals>
            <NonGoals>
             •	Test NPDB
            </NonGoals>
            <Implementation>
                <code>
                 // GetLiveConfigRequest
                 public class GetLiveConfigRequest : XRLObject2
                 {
                     [WireInfoAttribute(Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH*XOn.UTF8_MULT)]
                     public ushort confignameLen;
            
                     [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH)]
                     public string configname;
            
                     public override string Xrl
                     {
                         get { return "/stfd/getliveconfig.ashx"; }
                     }
                 }
            
                 // GetLiveConfigResponse
                 public class GetLiveConfigResponse: XRLObject2
                 {
                     public uint configLen;
            
                     [WireInfoAttribute(SizeParam="configLen")]
                     public string config;
                 }
                </code>
                <code>
                 public static GetLiveConfigResponse GetLiveConfig(IClient _client, 
                                                                     XblUser _user, 
                                                                     string _configType)
                 {
                     GetLiveConfigRequest request = new GetLiveConfigRequest();
                     GetLiveConfigResponse response = new GetLiveConfigResponse();
            
                     request.configname = _configType;
            
                     uint hr = SendRequest(_client, _user, request, response);
                     Throw.IfXErrFailed(hr);
            
                     return response;
                 }
                 </code>
            </Implementation>
            
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Xenon">
             <summary>
             BVT that verifies that a result is returned from GetLiveConfig. A normal console will
             call the GetLiveConfig with just the 'Xenon' parameter. That is exactly what this test
             does, the difference is that this will end up pulling up the results for the 'Xenon'
             config rather than the results for 'Xenon.Build.QFE' which is what the server actually
             requests using the console auth data. While this test case does not validate a real-world
             scenario, it provides functional validation that the service is responsive.
             <b>Sean is so fun.</b>
             </summary>
            
             <remarks>
                 <scenarios>
                 BVT: A request is made with no Build or QFE Number
                 </scenarios>
            
                 <section name="Notes">
                 This test does no validation, it only verifies that a response is returned.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_GetLiveConfigBvt">
             <summary>
             Deeper BVT that really verifies that all of the different configurations in 
             an envrionment are valid, rather than just verifying that a response is
             returned.
            
             This test goes through the database, and finds the config names for all
             of the current configs. It then calls GetLiveConfig with each of those
             configs and compares the result to what it expects. If a value is incorrect
             it will spit it out so the tester can investigate.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made to any of the currently loaded configs returns the
                 correct result.
                 </scenarios>
            
                 <section name="Notes">
                 This test does not follow the standard that the xenon console will use to
                 call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
                 the main roots are valid and the results are correct.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Xenon_Request_Case">
             <summary>
             Validates that configuration names are not case sensitive. Just in case in the
             future someone fat-fingers XenOn instead of xenon into the database we need
             to be 100% sure that it will make no difference in the result that is returned
             when the xenon configuration is requested.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made to any of to a loaded configuration with
                 incorrect case should result in the case-insensitive result to be returned.
                 </scenarios>
            
                 <section name="Notes">
                 This test does not follow the standard that the xenon console will use to
                 call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
                 the main roots are valid and the results are correct.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Request_Large_Num_Settings">
             <summary>
             Validates that a more realistic usage of the Hive works as expected. Normally
             there will be more than a handful of settings in the hive for any given configuration. 
             This test will setup 1000 individual settings of length 30 and then request them and 
             verify that the result matches what was inserted.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made using the configuration name that has ~1000 
                 settings returns a valid result that contains each of those settings.
                 </scenarios>
            
                 <section name="Notes">
                 This test does not follow the standard that the xenon console will use to
                 call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
                 the main roots are valid and the results are correct.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Escaped_Char_Request">
             <summary>
             Validates that a configuration that has settings that contains one of the escape
             characters is returned with the correct values escaped.
            
             For example:
                 If the setting were- Test=^awesome
                 The result that comes back should be- Test=^^awesome
                     Basically the escape character ^ is used to escape the
                     ^ that is in the orignal setting.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made using the configuration name that contains
                 a valid escape character is returned with the escape character escaped so that
                 the client can read it.
                 </scenarios>
            
                 <section name="Notes">
                 This test does not follow the standard that the xenon console will use to
                 call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
                 the main roots are valid and the results are correct.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Bad_Request">
             <summary>
             Validates that when calling GetLiveConfig with an invalid configuration name
             the correct error code is returned.
            
             The correct failure code is
             <code>8015C101: XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG</code>
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with an invalid (not setup) configuration
                 name fails with the correct/expected error code.
                 </scenarios>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Empty_Request">
             <summary>
             Validates that when calling GetLiveConfig with an empty configuration name
             the correct error code is returned.
            
             The correct failure code is
             <code>8015C101: XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG</code>
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with an empty configuration
                 name fails with the correct/expected error code.
                 </scenarios>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Long_Request_64">
             <summary>
             Validates that when calling GetLiveConfig with an configuration string that
             is exactly the maximum size (64), nothing breaks.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration string that is
                 the maximum length allowed still returns valid results that can be
                 verified.
                 </scenarios>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Long_Request_65">
             <summary>
             Validates that when calling GetLiveConfig with an configuration string that
             is exactly one over the maximum size (64), an exception is thrown.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration string that is
                 the maximum length allowed plus one fails with an exception being
                 thrown.
                 </scenarios>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_5000_Char_result">
             <summary>
             Validates that when calling GetLiveConfig with a congfiguration that has an
             expected result that is exactly 5000 characters a valid result is returned.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration whose expected
                 result is exactly 5000 characters gets back all 5000 characters and the
                 values retured match the ones in the database.
                 </scenarios>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_29999_Char_result">
             <summary>
             Validates that when calling GetLiveConfig with a congfiguration that has an
             expected result that is exactly 29,999 characters a valid result is returned.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration whose expected
                 result is exactly 29,999 characters gets back all 29,999 characters and the
                 values retured match the ones in the database.
                 </scenarios>
            
                 <section name="Notes">
                 The maximum value for the length of the return string is 30,000.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_30000_Char_result">
             <summary>
             Validates that when calling GetLiveConfig with a congfiguration that has an
             expected result that is exactly 30,000 characters a valid result is returned.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration whose expected
                 result is exactly 30,000 characters gets back all 30,000 characters and the
                 values retured match the ones in the database.
                 </scenarios>
            
                 <section name="Notes">
                 The maximum value for the length of the return string is 30,000.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_30001_Char_result">
             <summary>
             Validates that when calling GetLiveConfig with a congfiguration that has an
             expected result that is exactly 30,001 characters an exception is thrown.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration whose expected
                 result is exactly 30,001 fails due to an exception being thrown.
                 </scenarios>
             
                 <section name="Notes">
                 The maximum value for the length of the return string is 30,000.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_UTF8_Char">
             <summary>
             Validates that when calling GetLiveConfig with a configuration that has
             setting that contain UTF-8 characters, they are returned as UTF-8 characters.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration whose expected
                 result contains settings that contiant UTF-8 characters gets those
                 characters returned as UTF-8 and not as an ASCII string.
                 </scenarios>
            
                 <section name="Notes">
                 Last time we saw this fail, it was due to having the wrong convert
                 vall in our code that was sending the request.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_ExpectedConfigCount">
             <summary>
             Validates that when LiveInfo loads settings from the database, it only generates
             the expected set of configs.  This ensures that other combinations of build/qfe/
             beta group don't get unexpected settings because a non-required config was
             generated.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> When any individual setting is added to the database, it 
                 should not cause more than one new config to be created.  This test just adds
                 settings under a variety of build, qfe, betagroup combinations, and then 
                 retrieves the list of configs from the LiveHive front door.  It then checks
                 that there are no extraneous configurations generated.
                 </scenarios>
            
                 <section name="Notes">
                 This was created to verify a fix to a bug that was causing a config to be 
                 generated for every combination of build+qfe/betagroup.  This was causing
                 an explosion of configs on production, most of which would never be used.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Xenon_Build_QFE">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Build and QFE cannot be defined individually, if you define one you must define the other.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Xenon_Build_QFE_BetaOne">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             For this test we use the initial beta group.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Xenon_Build_QFE_BetaOnly">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             For this test we use the initial beta group.
             In this case there is no non-beta setting available.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_Xenon_Build_QFE_BetaMultipleHiveSettings">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             For this test we use the initial beta group.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Xenon_Build_QFE_Beta_NoBetaFlag">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             For this test we use the initial beta group.
             However the beta group flag is not set in the authdata, so it should short circuit and assume it's not in a group.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Xenon_Build_QFE_NotInBeta_BetaFlag">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             However the beta group flag is set in the authdata even though they're not in a beta group.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Xenon_Build_QFE_Beta_Not_Member">
             <summary>
             Validates that GetLiveConfig will not give us settings for a group that
             we don't belong to.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_Xenon_Build_QFE_Beta_MachineInMultipleGroups">
             <summary>
             Validates the real mainline scenario, calling GetLiveConfig with the same
             string that the console would normally call it with. That means that it is
             of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
             fakeSG auth data with build numbers that we expect in the database.
             For this test we use the initial beta group.
             Machine is in several unrelated non-conflicting beta groups.
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration which matches
                 what the Xbox360 console will send gets the correct result for that
                 config name.
                 </scenarios>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_NoBaseConfig">
             <summary>
             Validates that a call to GetLiveConfig without a Build and QFE is not
             allowed if the config name does not exists in NPDB.t_multisettings. The
             setting allows the call to be made without a Build and QFE specified.
             This should never be allowed in production.
            
             The expected failure code is
             <code>8015C101: XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG</code>
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made with a configuration that has not
                 been defined as a shared setting is denied when requested.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.N_NoBaseWithBuildQfe">
             <summary>
             Validates that a call to GetLiveConfig who's only settings have BUILD and
             QFE still returns a valid restult.
            
             Xenon           Setting1=1 Does not exist
             Xenon.6666.10   Setting1=1 Does exist
             </summary>
            
             <remarks>
                 <scenarios>
                 <b>Functional:</b> A request made to a configuration that doesn't have
                 a base value defined still returns valid settings.
                 </scenarios>
            
                 <section name="Notes">
                 Beta cannot be defined if Build and QFE are not both defined.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Functional.LiveHive.P_WiredataKeys">
             <summary>
             BVT that verifies that the Wiredata Public Key values we expect to exist in the hive for the xenon client do exist in the hive, 
             and that we can get the expected private key from the Crypto system.
             This should probably be moved into LiveBVT at some point, after the necessary steps have been taken to make it as robust as possible.
             </summary>
            
             <remarks>
                 <scenarios>
                 BVT: Clients can get the public key from the hive
                 BVT: Xuacs can get the private key from KEKCryptoMgr.GetKey
                 </scenarios>
            
                 <section name="Notes">
                 This test compares the key returned by a query of the hive against a hardcoded known value. If the public key ever changes, then this test will need to be updated with the new value.
                 The value for the private key is stored unencrypted in test-pci.xboxlive.com.cspblob, and will also need to be updated if the keys ever change.
                 The values used in this test are (for obvious reasons) only valid for use in test environments.
                 </section>
             </remarks>
        </member>
        <member name="T:Hive.Stress.LiveHiveStress.GetLiveConfigXRL">
             <summary>
             Stress test for GetLiveConfig. This test validates that the server can meet
             meet expected TPS (Transactions Per Second) by continually running the test
             based on the criteria set in the GUI. 
             </summary>
             
             <remarks>
                 <scenarios>
                 <b>Stress:</b> A request is made over and over and the results are validated
                 to ensure quality and efficiency of the GetLiveInfo API.
                 </scenarios>
            
                 <section name="Notes">
                 This test fills the database with over 1000 fake settings to make the
                 calls more realistic. Most of our testing is done with very few settings
                 in the database. This way we can tell how we will perform with less 
                 optimal database/setting configuration
                 </section>
            
                 <dependencies>
                 None.
                 </dependencies>
             </remarks>
        </member>
        <member name="M:Hive.Utils.ReloadLiveRegistry">
            <summary>
            Forces the LiveInfo service to reload the live hive settings
            </summary>
        </member>
        <member name="M:Hive.Utils.GetLiveConfigFromDatabase(System.String)">
            <summary>
            Looks into the config database in npdb and builds the expected
            GetLiveConfig result based on the database current state.
            </summary>
            <param name="_configName">The name that corresponds to the config name to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Hive.Utils.GetAllConfigNames">
            <summary>
            Looks into config database and builds a list of all the different
            config setting names.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hive.Utils.FillConfigDatabase(System.Int32,System.String)">
            <summary>
            Inserts entries into the HIVE config table. These settings are totally random string
            the entries are inserted as a random string for the setting name and then that same
            string in square brackets for the value. That way simple verification can be done if
            it is needed. The random string will be prefixed with XLH_, to make clean up much easier
            </summary>
            <param name="_numRows">Number of random rows to add</param>
            <param name="_configName">The config name to enter the rows under.</param>
        </member>
        <member name="M:Hive.Utils.FillConfigDatabase(System.Int32,System.String,System.Int32)">
            <summary>
            Inserts entries into the HIVE config table. These settings are totally random string
            the entries are inserted as a random string for the setting name and then that same
            string in square brackets for the value. That way simple verification can be done if
            it is needed. The random string will be prefixed with XLH_, to make clean up much easier
            </summary>
            <param name="_numRows">Number of random rows to add</param>
            <param name="_configName">The config name to enter the rows under.</param>
            <param name="_lengthOfEachSetting">Indicates the final length of the setting string returned in the response</param>
        </member>
        <member name="M:Hive.Utils.FillConfigDatabase(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Guid)">
            <summary>
            Inserts entries into the HIVE config table. These settings are totally random string
            the entries are inserted as a random string for the setting name and then that same
            string in square brackets for the value. That way simple verification can be done if
            it is needed. The random string will be prefixed with XLH_, to make clean up much easier
            </summary>
            <param name="_numRows">Number of random rows to add</param>
            <param name="_configName">The config name to enter the rows under.</param>
            <param name="_lengthOfEachSetting">Indicates the final length of the setting string returned in the response</param>
            <param name="_build">The build that the setting applies to</param>
            <param name="_qfe">The QFE number that the setting applies to</param>
            <param name="_betaGroupId">The beta group the setting applies to</param>
        </member>
        <member name="M:Hive.Utils.EmptyConfigDatabase">
            <summary>
            Goes through the config database and removes all settings that are prefixed with
            'XLH_' this way we don't leave the database full of random settings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Hive.Utils.EmptyConfigDatabase(System.String,System.String)">
            <summary>
            Goes through the config database and removes all settings that are LIKE the
            passed in setting name.
            </summary>
            <param name="_settingLike">The setting name to match with LIKE %[setting]%</param>
            <param name="_configName">The config name to remove those settings from. Pass null for all.</param>
            <returns></returns>
        </member>
        <member name="M:Hive.Utils.RemoveConfigDatabaseSetting(System.String,System.String)">
            <summary>
            Removes a single setting from the config database
            </summary>
            <param name="_settingName">Setting name to remove</param>
            <param name="_configName">Which configuration to remove the setting from. Pass null for all.</param>
            <returns></returns>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\LiveCacheXbosTest\LiveCacheXbosDoc.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LiveCacheXbos</name>
    </assembly>
    <members>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2">
            <summary>
                Functional tests for the XeContentEnumerate request.
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_WM7User_LIVEnClient_DASHTitle">
            <summary>
            	Create WM7 user 
            	Enumerate free gamertag with LiveEn,  Dash Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_Twice">
            <summary>
                Create WM7 user 
                Enumerate free gamertag with LiveEn,  Dash Title
                Enumerate free gamertag with LiveEn,  Dash Title one more time
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_WM7User_LIVEnClient_DASHTitle_SecondTime">
            <summary>
                Create WM7 user 
                Purchase free gamertag
                Enumerate charged gamertag with LiveEn, Dash Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_WM7User_LIVEnClient_CruxTitle_ZunePlatform">
            <summary>
            	Create WM7 user 
            	Enumerate free gamertag with Zune, Crux Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_ZuneUser_LIVEnClient_CruxTitle_ZunePlatform">
            <summary>
            	Create Zune user 
            	Enumerate free gamertag with Zune,  Crux Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_WM7User_ZuneClient_CruxTitle_ZunePlatform">
            <summary>
            	Create WM7 user 
            	Enumerate free gamertag with Zune, Crux Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_WM7User_ZuneClient_CruxTitle_ZunePlatform_SecondTime">
            <summary>
                Create WM7 user 
                Purchase free gamertag
                Enumerate charged gamertag with Zune, Crux Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeContentEnumerate2.P_GamertagChange_ZuneUser_ZuneClient_CruxTitle_ZunePlatform">
            <summary>
            	Create Zune user 
            	Enumerate free gamertag with Zune,  Crux Title
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag">
            <summary>
                Functional test cases for the XeOfferPurchaseGamertag API.
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_LIVEnClient_ZuneUser_ZuneGamerTag_ZunePlatform">
            <summary>
            	Create Zune user
                    Purchase 1600 pts
            	Purchase charged Zune gamertag change with Zune client Type
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform">
            <summary>
            	Create WM7 user
            	Purchase free gamertag change on web in WM7 with LIVEn client Type
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_LIVEnClient_WM7User_FreeGamerTag_MOBILEPlatform">
            <summary>
            	Create WM7 user
            	Purchase free gamertag change on web in WM7 with LIVEn client Type
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_Twice">
            <summary>
            	Create WM7 user
            	Purchase free gamertag change on web in WM7 with LIVEn client Type
            	Try one more time
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform_WithPoints">
            <summary>
            	Create WM7 user
                    Purchase 1600 pts
            	Purchase free gamertag change on web in WM7 with LIVEn client Type
                    Make sure no pts charged
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.N_LIVEnClient_WM7User_FreeGamerTag_XboxcomPlatform">
            <summary>
            	Create WM7 user
            	Purchase free gamertag change on web in WM7 with Xboxcom client Type - Should fail
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_XboxcomClient_WM7User_FreeGamerTag_XboxcomPlatform">
            <summary>
            	Create WM7 user
            	Purchase free gamertag change on web in WM7 with Xboxcom client Type - Should fail
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform_WEB_TITLE_ID">
            <summary>
                Create WM7 user
                Purchase free gamertag change on web in WM7 with WEB_TITLE_ID
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.N_LIVEnClient_WM7User_ChargedGamerTag_LIVEnPlatform">
            <summary>
                Create WM7 user
                Purchase charged gamertag change on web in WM7 with LIVEn client Type - should fail
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.N_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform_NonWMMachineID">
            <summary>
                Create WM7 user
                Purchase charged gamertag change on web in WM7 with LIVEn client Type but not WMMachineID - should fail
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_WM7User_FreeGamerTag_LIVEn_Reflection">
            <summary>
                Create WM7 user
                Purchase free gamertag change on web in WM7 with LIVEn client Type
                Enumerate gamertag change offer on Xbox - should return paid one
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_ZuneClient_ZuneUser_ZuneGamerTag_ZunePlatform">
            <summary>
                Create Zune user
                    Purchase 1600 pts
                Purchase charged Zune gamertag change with Zune client Type
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.XeOfferPurchaseGamertag.P_ZuneClient_WM7User_ZuneGamerTag_ZunePlatform">
            <summary>
                Create Zune user
                    Purchase 1600 pts
                Purchase charged Zune gamertag change with Zune client Type
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.MobilePurchase">
            <summary>
                Functional test cases for the LiveCache PurchaseMediaOffer API with Mobile products.
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.MobilePurchase.P_LIVEnClient_WM7User_PurchaseMobile_Point_LIVEnPlatform">
            <summary>
            	Create WM7 user
            	Purchase Mobile PDLC using points
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.MobilePurchase.P_LIVEnClient_WM7User_PurchaseMobile_Token_LIVEnPlatform">
            <summary>
            	Create WM7 user
            	Purchase Mobile PDLC using a token
            </summary>
        </member>
        <member name="T:PreviewProductpurchase.PreviewProductPurchaseGroup">
            <summary>
                Functional tests for the PreviewProductpurchase request.
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.PurchaseHistoryV2">
            <summary>
                Functional test cases for the LiveCache PurchaseMediaOffer API with Mobile products.
            </summary>
        </member>
        <member name="T:LiveCacheXbosTest.PurchaseHistoryV2.P_LIVEnClient_WM7User_Call_PurchaseHistory">
            <summary>
            	Create WM7 user
            	Do a sample PH call
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\MessagingTest\MessagingTest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MessagingTest</name>
    </assembly>
    <members>
        <member name="T:MessagingTest.FuncDeleteMsg_PositiveCases">
            <summary>
            Functional Tests for DeleteMessage
            </summary>
            Positive cases check for success hr, and that QVal is received.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="T:MessagingTest.FuncDeleteSystemMsg">
            <summary>
            Functional Tests for DeleteSystemMessage
            </summary>
            Positive cases check for success hr. Because this message is used to validate the
              exhaustive set of Send cases this list is short.  Summary contents will be checked
              against expected.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="T:MessagingTest.FuncEnumMsgs2">
             <summary>
             Functional Tests for EnumMessages2
             </summary>
             <remarks>
             <Description>
                 <p>
                 EnumMessages2 is a new XRL added for Xenon which supplies a new message summary
                 object which contains the subject property of the message which was previously
                 only available with a MessageDetails call.
                 </p>
            
                 <div class="test_data_label">
                 EnumMessages2 Request Format:
                 </div>
                 <table class="test_data">
                     <tr><td>ULONGLONG qwUserID</td><td>UserID for enumeration</td></tr>
                 </table>
            
                 <div class="test_data_label">
                 EnumMessages2 Reply Format:
                 </div>
                 <table class="test_data">
                     <tr><td>HRESULT hr                      </td><td>Result of the enumeration call</td></tr>
                     <tr><td>WORD cMessages                  </td><td>Count of message summaries in payload</td></tr>
                     <tr><td>Q_MESSAGE_SUMMARY_2 rgMessages[]</td><td>Message summary payload</td></tr>
                 </table>
            
                 <div class="test_data_label">
                 EnumMessages2 Reply Item Format:
                 </div>
                 <table class="test_data">
                     <tr><td>ULONGLONG qwSenderID                      </td><td>Unique user ID of the sender</td></tr>
                     <tr><td>ULONGLONG qwSenderContext                 </td><td>Configurable 64bit context of the sender</td></tr>
                     <tr><td>MSGTIME mtSentTime                        </td><td>Server message time message was sent</td></tr>
                     <tr><td>DWORD dwMessageID                         </td><td>Message ID in the user message folder</td></tr>
                     <tr><td>DWORD dwMessageFlags                      </td><td>See SendMessage for flag definitions</td></tr>
                     <tr><td>DWORD dwSenderTitleID                     </td><td>TitleID message was sent from</td></tr>
                     <tr><td>WORD wExpireMinutes                       </td><td>An offset in minutes from the sent time</td></tr>
                     <tr><td>WORD cbDetails                            </td><td>Number of bytes available</td></tr>
                     <tr><td>BYTE bMessageType                         </td><td>Message types, see SendMessage for definitions</td></tr>
                     <tr><td>CHAR szSenderName[XONLINE_GAMERTAG_SIZE-1]</td><td>Sender gamertag - ASCII</td></tr>
                     <tr><td>WCHAR szSubject[XONLINE_MAX_SUBJECT_SIZE] </td><td>Subject line - UTF-16</td></tr>
                 </table>
            
                 <div class="test_data_label">
                 EnumMessages2 Constants:
                 </div>
                 <table class="test_data">
                     <tr><td>XONLINE_GAMERTAG_SIZE</td><td>16</td></tr>
                     <tr><td>XONLINE_MAX_SUBJECT_SIZE</td><td>20</td></tr>
                 </table>
            
                 <div class="test_data_label">
                 EnumMessages2 HRESULTs:
                 </div>
                 <table class="test_data">
                     <tr><td>S_OK                                   </td><td>Operation successful</td></tr>
                     <tr><td>ERROR_NO_SUCH_USER                     </td><td>User ID was not found online</td></tr>
                     <tr><td>E_OUTOFMEMORY                          </td><td>Server ran out of memory buffering response</td></tr>
                     <tr><td>XONLINE_E_MESSAGE_INVALID_MESSAGE_ID   </td><td>The requested message ID was invalid</td></tr>
                 </table>
            
            
                 <p>
                 Positive cases check for success HRESULT. This message is used to validate the
                 send so the positive enumeration cases are actually pretty short..
                 Summary contents are checked against sent data stored locally per-field.
                 </p>
             </Description>
             </remarks>
        </member>
        <member name="T:MessagingTest.FuncEnumSystemMsgs">
            <summary>
            Functional Tests for EnumSystemMessages
            </summary>
            Positive cases check for success hr. Changes are verified with QMSG_ENUM_SYSTEM_MESSAGES.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="T:MessagingTest.FuncGetMsgDetails">
            <summary>
            Functional Tests for GetMessageDetails
            </summary>
            Positive cases check for success hr.  Because this message is used to validate the
              exhaustive set of Send cases this list is short.  Summary and details contents will
              be checked against expected, and then validated separately.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="M:MessagingTest.FuncGetMsgDetails.CreateTitleCustomMessage(System.UInt32,System.Collections.Generic.Dictionary{System.UInt16,System.UInt32})">
            <summary>
            Creates a Title Custom message with text, photo, voice, and typical
            custom title properties.  All of the data is random.
            </summary>
            <returns>Custom title message with details</returns>
        </member>
        <member name="T:MessagingTest.FuncGetMsgSummary2">
             <summary>
             Functional Tests for MessageSummary2
             </summary>
             <remarks>
             <Description>
            
                 <p>
                 MessageSummary2 is a new server API instroduced with Xenon to allow retrieving a single
                 message summary from the server for a given user and message ID.  It is different from
                 MessageSummary (v1) because it also has the message subject in the reply data.
                 </p>
            
                    <div class="test_data_label">
                    MessageSummary2 Request Format:
                    </div>
                    <table class="test_data">
                        <tr><td>ULONGLONG qwUserID</td><td>UserID to query</td></tr>
                        <tr><td>DWORD dwMessageID</td><td>MessageID to query</td></tr>
                    </table>
            
                    <div class="test_data_label">
                    MessageSummary2 Reply Format:
                    </div>
                    <table class="test_data">
                        <tr><td>HRESULT hr                      </td><td>Result of the summary call</td></tr>
                        <tr><td>Q_MESSAGE_SUMMARY_2 summary     </td><td>Message summary payload</td></tr>
                    </table>
            
                    <div class="test_data_label">
                    MessageSummary2 Reply Item Format:
                    </div>
                    <table class="test_data">
                     <tr><td>ULONGLONG qwSenderID                      </td><td>Unique user ID of the sender</td></tr>
                        <tr><td>ULONGLONG qwSenderContext                 </td><td>Configurable 64bit context of the sender</td></tr>
                        <tr><td>MSGTIME mtSentTime                        </td><td>Server message time message was sent</td></tr>
                        <tr><td>DWORD dwMessageID                         </td><td>Message ID in the user message folder</td></tr>
                        <tr><td>DWORD dwMessageFlags                      </td><td>See SendMessage for flag definitions</td></tr>
                        <tr><td>DWORD dwSenderTitleID                     </td><td>TitleID message was sent from</td></tr>
                        <tr><td>WORD wExpireMinutes                       </td><td>An offset in minutes from the sent time</td></tr>
                        <tr><td>WORD cbDetails                            </td><td>Number of bytes available</td></tr>
                        <tr><td>BYTE bMessageType                         </td><td>Message types, see SendMessage for definitions</td></tr>
                        <tr><td>CHAR szSenderName[XONLINE_GAMERTAG_SIZE-1]</td><td>Sender gamertag - ASCII</td></tr>
                        <tr><td>WCHAR szSubject[XONLINE_MAX_SUBJECT_SIZE] </td><td>Subject line - UTF-16</td></tr>
                    </table>
            
                    <div class="test_data_label">
                    MessageSummary2 Constants:
                    </div>
                    <table class="test_data">
                        <tr><td>XONLINE_GAMERTAG_SIZE</td><td>16</td></tr>
                        <tr><td>XONLINE_MAX_SUBJECT_SIZE</td><td>20</td></tr>
                    </table>
            
                    <div class="test_data_label">
                    MessageSummary2 HRESULTs:
                    </div>
                    <table class="test_data">
                        <tr><td>S_OK                                   </td><td>Operation successful</td></tr>
                        <tr><td>ERROR_NO_SUCH_USER                     </td><td>User ID was not found online</td></tr>
                        <tr><td>E_OUTOFMEMORY                          </td><td>Server ran out of memory buffering response</td></tr>
                        <tr><td>ERROR_INSUFFICIENT_BUFFER              </td><td>Server ran out of memory buffering response in Queue::ListItems()</td></tr>
                        <tr><td>E_INVALIDARG                           </td><td>Internal server error (queue type specified to Presence::ListItems() incorrect)</td></tr>
                    </table>
            
                 <p>
                 Positive cases check for success HRESULT. Because this message is used to validate the
                 exhaustive set of Send cases this list is short.  Summary contents will be checked
                 against data stored locally from a send.
                 </p>
            
                 <p>
                 Negative Casescheck for failure hr that makes sense and is consistent.
                 </p>
             </Description>
             </remarks>
            
        </member>
        <member name="M:MessagingTest.FuncGetMsgSummary2.GeneralMessageTypeTest(System.Byte,System.UInt32,System.UInt16)">
             <summary>
                    Summary2 single user xenon dash message types
             </summary>
             <remarks>
             <Description>
                 <p>
                 Send a single user message iterating new xenon message types.
                 Populate all of the fields and check them in the message summary.
                 </p>
            
                    <div class="test_data_label">
                 Message types test iterations:
                 </div>
                 <table class="test_data">
                        <tr><th>Message Type Define                 </th><th>Numeric</th><th>Context           </th><th>Requred properties</th></tr>
                        <tr><td>XONLINE_MSG_TYPE_TITLE_CUSTOM       </td><td>1      </td><td>Title defined     </td><td>Title defined</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_FRIEND_REQUEST     </td><td>2      </td><td>0                 </td><td>None</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_GAME_INVITE        </td><td>3      </td><td>See msg flags     </td><td>XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_TEAM_RECRUIT       </td><td>4      </td><td>Inviting team ID  </td><td>None</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_COMP_REMINDER      </td><td>5      </td><td>Comp event ID     </td><td>XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_EVENT_START</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_COMP_REQUEST       </td><td>6      </td><td>Comp entity ID    </td><td>XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_START, XONLINE_MSG_PROP_COMP_REG_CLOSE</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_LIVE_MESSAGE       </td><td>7      </td><td>0                 </td><td>XONLINE_MSG_PROP_SYSTEM_TEXT</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_PERSONAL_MESSAGE   </td><td>8      </td><td>0                 </td><td>XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_VIDEO_MESSAGE      </td><td>9      </td><td>0                 </td><td>XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA</td></tr>
                        <tr><td>XONLINE_MSG_TYPE_QUICK_CHAT_INVITE  </td><td>10     </td><td>0                 </td><td></td></tr>
                        <tr><td>XONLINE_MSG_TYPE_PUBLISHER_MESSAGE  </td><td>11     </td><td>0                 </td><td>XONLINE_MSG_PROP_TEXT</td></tr>
                 </table>
             </Description>
             <Verify>
                <ul>
                    <li>Validate field qwSenderID equal to sender</li>
                    <li>Validate field qwSenderContext equal to 0xabcdabcdabcdabcd (original value)</li>
                    <li>Validate field mtSentTime within 1 minute tolerance</li>
                    <li>Validate field dwMessageID equal to sent message ID</li>
                    <li>Validate field dwMessageFlags equal to required flags according to message type</li>
                    <li>Validate field dwSenderTitleID equal to sender xbox title ID</li>
                    <li>Validate field wExpireMinutes equal to default sent expire minutes</li>
                    <li>Validate field cbDetails 0</li>
                    <li>Validate field bMessageType equal to sent type</li>
                    <li>Validate field szSenderName equal to sender gamertag</li>
                    <li>Validate field szSubject equal to sent message subject data</li>
                </ul>
             </Verify>
             </remarks>
        </member>
        <member name="M:MessagingTest.FuncGetMsgSummary2.P_System_Message">
            <summary>
                   Summary2 system message after login
            </summary>
            <remarks>
            <Description>
                Send a system wide message. Login with user on title (message should be copied
                to the user message folder). Request the message with Summary2.
            </Description>
            <Verify>
               <ul>
                   <li>Validate field qwSenderID equal to 0</li>
                   <li>Validate field qwSenderContext equal to 0</li>
                   <li>Validate field mtSentTime within 1 minute tolerance</li>
                   <li>Validate field dwMessageID</li>
                   <li>Validate field dwMessageFlags</li>
                   <li>Validate field dwSenderTitleID equal to system message title ID</li>
                   <li>Validate field wExpireMinutes equal to original message</li>
                   <li>Validate field cbDetails equal to 0</li>
                   <li>Validate field bMessageType equal to XONLINE_MSG_TYPE_LIVE_MESSAGE</li>
                   <li>Validate field szSenderName equal to ""</li>
                   <li>Validate field szSubject equal to ""</li>
               </ul>
            </Verify>
            </remarks>
        </member>
        <member name="T:MessagingTest.FuncGetSystemMsgDetails">
            <summary>
            Functional Tests for GetSystemMessageDetails
            </summary>
            Positive cases check for success hr.  Because this Because this message is used to
              validate the exhaustive set of Send cases this list is short.  Contents will be checked
              against expected.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="T:MessagingTest.FuncPerfCounters_PositiveCases">
            <summary>
            Functional Tests for Messaging FD Performance Counters.
            </summary>
        </member>
        <member name="M:MessagingTest.FuncPerfCounters_PositiveCases.SendEachMessageTypeXRL">
            <summary>
            Sends 1 of each type of message and confirms that the totals are correct
            </summary>
        </member>
        <member name="M:MessagingTest.FuncPerfCounters_PositiveCases.SendSystemMessageXRL">
            <summary>
            Sends 1 system and confirms that the totals are correct
            </summary>
        </member>
        <member name="M:MessagingTest.FuncPerfCounters_PositiveCases.SendEachMessageTypeAPI">
            <summary>
            Sends 1 of each type of message and confirms that the totals are correct
            </summary>
        </member>
        <member name="M:MessagingTest.FuncPerfCounters_PositiveCases.SendSystemMessageAPI">
            <summary>
            Sends 1 system message and confirms that the totals are correct
            </summary>
        </member>
        <member name="T:MessagingTest.FuncRevokeExMsg_PositiveCases">
            <summary>
            Functional Tests for RevokeMessageEx
            </summary>
        </member>
        <member name="T:MessagingTest.FuncRevokeMsg">
            <summary>
            Functional Tests for Revoke Message
            </summary>
            Positive cases check for success hr, and that recipients get the QVAL and message is removed
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="T:MessagingTest.FuncSendMsg_GenericCases">
             <summary>
             Functional Tests for SendMessage
             </summary>
             <remarks>
             <Description>
                 <p>
                 SendMessage provides a flexible server API for sending message to one or many recipients. The message
                 is delivered by fanning out delivery from the sender's server to all recipient's servers. When the message
                 arrives on the recipient server it is stored immediately to SQL. If the user is online a QVal is is sent
                 to the user via the periodic heartbeat.
                 </p>
            
            
                    <div class="test_data_label">
                        Supported External Message Flags:
                    </div>
                    <table class="test_data">
                     <tr><td>XONLINE_MSG_FLAG_REQUIRED               </td><td>0x00000001  </td><td>The user is required to read this message</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_RECOMMENDED            </td><td>0x00000002  </td><td>The user has a system recommended message</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_HAS_VOICE              </td><td>0x00000004  </td><td>This message contains a voice attachment</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_HAS_TEXT               </td><td>0x00000008  </td><td>This message contains a text body</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_READ                   </td><td>0x00000010  </td><td>This message has been read</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_NON_EXPORTABLE         </td><td>0x00000020  </td><td>This message should only be displayed on Xbox consoles, not the web</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_TEAM_CONTEXT           </td><td>0x00000040  </td><td>This message's sender context refers to a team ID</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_COMP_CONTEXT           </td><td>0x00000080  </td><td>This message's sender context refers to a competition event or entity ID</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_ALTERNATE_TITLE        </td><td>0x00000100  </td><td>This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_MARKETING              </td><td>0x00000200  </td><td>Used on title-sent messages to indicate the message is marketing-related and opt-in settings should be checked</td></tr>
                        <tr><td>XONLINE_MSG_FLAGS_TITLE_RESERVED        </td><td>0xFF000000  </td><td>Flags reserved for title custom messages</td></tr>
                    </table>
            
                    <div class="test_data_label">
                        Supported Internal Message Flags:
                    </div>
                    <table class="test_data">
                        <tr><td>XONLINE_MSG_FLAG_SENDER_IS_FRIEND       </td><td>0x00800000  </td><td>Used by Notification to detect invites that should go to V1 clients, also used by clients to allow cross-title invites</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_RECV_DETAILS_NEEDED    </td><td>0x00200000  </td><td>Used by the client on received summaries to indicate that the title has requested downloading details</td></tr>
                        <tr><td>XONLINE_MSG_FLAG_SEND_MSG_OWNED         </td><td>0x00200000  </td><td>Used by the client on message sends to indicate that the message handle is owned by the Send operation</td></tr>
                        <tr><td>XONLINE_MSG_FLAGS_RESERVED              </td><td>0x005FFC00  </td><td>Flags reserved for future use</td></tr>
                    </table>
            
                    <div class="test_data_label">
                    XONLINE_MSG_FLAGS_VALID_SEND_MASK (Valid flags for Send) combines:
                    </div>
                    <ul>
                        <li>XONLINE_MSG_FLAGS_TITLE_RESERVED</li>
                        <li>XONLINE_MSG_FLAG_NON_EXPORTABL</li>
                        <li>XONLINE_MSG_FLAG_REQUIRED</li>
                        <li>XONLINE_MSG_FLAG_RECOMMENDED</li>
                        <li>XONLINE_MSG_FLAG_HAS_VOICE</li>
                        <li>XONLINE_MSG_FLAG_HAS_TEXT</li>
                        <li>XONLINE_MSG_FLAG_TEAM_CONTEXT</li>
                        <li>XONLINE_MSG_FLAG_COMP_CONTEXT</li>
                        <li>XONLINE_MSG_FLAG_MARKETING</li>
                    </ul>
            
                    <div class="test_data_label">
                        XONLINE_MSG_FLAGS_TITLE_SETABLE These flags are valid for a message that
                        has already been sent (valid flags for SetFlags)
                    </div>
                    <ul>
                        <li>XONLINE_MSG_FLAG_READ</li>
                        <li>XONLINE_MSG_FLAGS_TITLE_RESERVED</li>
                    </ul>
            
                    <div class="test_data_label">
                        XONLINE_MSG_FLAGS_TITLE_CLEARABLE: These flags are clearable for a message
                        that has already been sent (valid for Setflags)
                    </div>
                    <ul>
                        <li>XONLINE_MSG_FLAGS_TITLE_RESERVED</li>
                    </ul>
            
                    <div class="test_data_label">
                        Test Methods
                    </div>
            
                    <p>
                 Positive cases check for success HRESULT and valid message IDs in the recipient results
                   as well as proper QVals received by logged on users.
                   </p>
                   <p>
                   Message contents are verified with QMSG_MESSAGE_DETAILS, QMSG_MESSAGE_SUMMARY, and QMSG_ENUM_MESSAGES by all recipients.
                   </p>
                   <p>
                   Negative Cases check for failure HRESULT that makes sense and is consistent with previous releases of the service.
                   </p>
             </Description>
             </remarks>
        </member>
        <member name="M:MessagingTest.FuncSendMsg_Privacy.SetPrivileges(ServerTestFramework.LiveService.PresNotiCommon.PNUser,System.UInt32[],System.UInt32[])">
            <summary>
            Actually sets the privileges for the user
            </summary>
        </member>
        <member name="T:MessagingTest.FuncSendSystemMsg">
            <summary>
            Functional Tests for SendSystemMessage
            </summary>
            Positive cases check for success hr, and that the message ID has system message bit set.
              Also message contents are verified with QMSG_SYSTEM_MESSAGE_DETAILS and
              QMSG_ENUM_SYSTEM_MESSAGES. Delivery, or not, to expected recipients once they Alive is
              validated by QMSG_ENUM_MESSAGES with contents checked using QMSG_MESSAGE_DETAILS if needed.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="T:MessagingTest.FuncSetMsgFlags">
            <summary>
            Functional Tests for SetMessageFlags
            </summary>
            Positive casescheck for success hr.
            Negative Cases check for failure hr that makes sense and is consistent.
        </member>
        <member name="M:MessagingTest.FuncSetMsgFlags.CreateTitleCustomMessage(System.UInt32,System.Collections.Generic.Dictionary{System.UInt16,System.UInt32})">
            <summary>
            Creates a Title Custom message with text, photo, voice, and typical
            custom title properties.  All of the data is random.
            </summary>
            <returns>Custom title message with details</returns>
        </member>
        <member name="T:MessagingTest.DeleteMsg">
             <summary>
             Deletes a message from the user's inbox.
            
             Load2 is called at the end.
             </summary>
        </member>
        <member name="T:MessagingTest.DeleteMsgTransient">
             <summary>
             Rejects or Accepts a game invite.
            
             Load2 is called at the end.
             </summary>
        </member>
        <member name="T:MessagingTest.EnumMessages">
            <summary>
            Calls the EnumMessages API
            </summary>
        </member>
        <member name="T:MessagingTest.GetMsgDetails">
            <summary>
            Calls the GetDetails api
            </summary>
        </member>
        <member name="T:MessagingTest.GetMsgSummary2">
            <summary>
            Calls the GetSummary2 api
            </summary>
        </member>
        <member name="T:MessagingTest.SendMsg">
             <summary>
             Sends a random message type to another user.
            
             Calls Load2 on all recipients.
             </summary>
        </member>
        <member name="T:MessagingTest.SetMsgFlags">
            <summary>
            Calls the SetFlags api
            </summary>
        </member>
        <member name="T:MessagingTest.Dequeue">
            <summary>
            Calls Dequeue on the presence fd
            </summary>
        </member>
        <member name="T:MessagingTest.StressInfoDump">
            <summary>
            Random helpful stress queue information
            </summary>
        </member>
        <member name="T:MessagingTest.MessageTest">
             <summary>
             <TestSuite>Messaging Test Plan</TestSuite>
                <Tester>Jacob Repp</Tester>
                <Developer>Matt Childerston</Developer>
                <Developer>Peter Hansen</Developer>
                <PM>James Jen</PM>
                <Status>Draft</Status>
             </summary>
                <remarks>
                <Goal>Functional positive and negative test cases covering V1, V2 and V3 messaging features.</Goal>
                <Goal>Test code validation of Profile-UODB partitioning.</Goal>
                <Goal>Test code validation of Profile-UODB table data.</Goal>
                <NonGoal>Test of container environment (.NET, ASP.NET, IIS, Windows).</NonGoal>
                <NonGoal>Test of NT service startup/shutdown</NonGoal>
                <NonGoal>Test of internal INH only messages that are not exposed on the front-door</NonGoal>
                <Description>
                    <p>
                        Presence server previously was the one of two servers used for maintaining
                    user state in Xbox Live. The current service has been combined into
                    a single server which handles presence records, messaging, notification and
                    teams. The test suites for each portion of presence however will continue
                    be maintained as three seperate suites.
                    </p>
            
                    <p>
                        Messaging functional tests cover all of the 'Q' messages that are exposed
                    on the presence front door. These are as follows:
                    </p>
            
                    <p>
                    <table class="test_data">
                        <tr><td>EnumMessages           </td><td>V1,V2 enumerate user message folder</td></tr>
                        <tr><td>MessageSummary         </td><td>V1,V2 retrieve message summary</td></tr>
                        <tr><td>MessageDetails         </td><td>Retrieve the message details for a message</td></tr>
                        <tr><td>DeleteMessage          </td><td>Delete a message in a user message folder</td></tr>
                        <tr><td>SendMessage            </td><td>Send a user message</td></tr>
                        <tr><td>RevokeMessage          </td><td>Revoke a message from another user</td></tr>
                        <tr><td>DeleteTitle            </td><td>Delete a title from an internal title tracking</td></tr>
                        <tr><td>EnumTitles             </td><td>Enumerate all titles that a user has used</td></tr>
                        <tr><td>MessageFlags           </td><td>Modify flags on a message</td></tr>
                        <tr><td>EnumSystemMessages     </td><td>Enumerate all system message</td></tr>
                        <tr><td>SystemMessageDetails   </td><td>Retrieve message details for a system message</td></tr>
                        <tr><td>DeleteSystemMessage    </td><td>Delete a system message</td></tr>
                        <tr><td>SendSystemMessage      </td><td>Send a system message for all users</td></tr>
                        <tr><td>RevokeMessageEx        </td><td>Revoke messages matched by a set of properties</td></tr>
                        <tr><td>EnumMessages2          </td><td>V3 enumerate user message folder</td></tr>
                        <tr><td>MessageSummary2        </td><td>V3 retrieve message summary</td></tr>
                    </table>
                    </p>
             </Description>
             </remarks>
        </member>
        <member name="M:MessagingTest.MessageTest.Initialize">
            <summary>
            Setup for Functional Suite
               </summary>
        </member>
        <member name="M:MessagingTest.MessageTest.InitializeStress">
            <summary>
            Setup for Stress Suite
               </summary>
        </member>
        <member name="M:MessagingTest.StressUser.AliveMsg">
            <summary>
            Sends the alive message
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\iflictest\IFLICTest.xml ===
﻿<?xml version="1.0" encoding="utf-8" ?>
<IFLICTest>
  <UseExternalDNS>false</UseExternalDNS>
  <Address>http://piflc.int2.xbox.com/vortex</Address>
  <Port>13100</Port>
  <ValidCert>certificate.cer</ValidCert>
  <SpoofCert>certificate.cer</SpoofCert>
  <InvalidCert>certificate.cer</InvalidCert>
</IFLICTest>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\MixTestFramework\ProductManagementTest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MixTestFramework</name>
    </assembly>
    <members>
        <member name="T:MIXTesting.Config">
            <summary>
            Provides access to the configuration
            </summary>
        </member>
        <member name="F:MIXTesting.Config.catalogServicesUrl">
            <summary>
            catalogServicesUrl is the web service url
            </summary>
        </member>
        <member name="F:MIXTesting.Config.catalogDatabase">
            <summary>
            catalogDatabase is the name of the sql database hosting the catalog
            </summary>
        </member>
        <member name="F:MIXTesting.Config.catalogServer">
            <summary>
            catalogServer is the name of the sql server hosting the catalog
            </summary>
        </member>
        <member name="F:MIXTesting.Config.downloadServer">
            <summary>
            downloadServer is the name of the server hosting the download location
            </summary>
        </member>
        <member name="F:MIXTesting.Config.environment">
            <summary>
            environment is the name of the current xbox live environment
            </summary>
        </member>
        <member name="M:MIXTesting.Config.#ctor">
            <summary>
            Initializes a new instance of the Config class
            </summary>
        </member>
        <member name="M:MIXTesting.Config.EnableAPIs(System.String,System.String,System.String[])">
            <summary>
            Enable DebugPartner on WebSG to use a set of APIs.
            </summary>
            <param name="inter">Interface of your app</param>
            <param name="appname">Name of your app (Xonline.Mix.BetaManagement.Service, for example)</param>
            <param name="apis">The APIs you want to enable with DebugPartner</param>
        </member>
        <member name="P:MIXTesting.Config.CatalogDatabase">
            <summary>
            Gets the name of sql database hosting the catalog
            </summary>
        </member>
        <member name="P:MIXTesting.Config.CatalogServer">
            <summary>
            Gets the name of the sql server hosting the catalog
            </summary>
        </member>
        <member name="P:MIXTesting.Config.CatalogServicesUrl">
            <summary>
            Gets the url of the web service
            </summary>
        </member>
        <member name="P:MIXTesting.Config.DownloadServer">
            <summary>
            Gets the name of the download server
            </summary>
        </member>
        <member name="P:MIXTesting.Config.Environment">
            <summary>
            Gets the name of the current xbox live environment
            </summary>
        </member>
        <member name="T:MIXTesting.FindGameHelper">
            <summary>
            The purpose of the class to help to do end to end verification on ConfigureProduct API
            (for DataContract Game, Image, GameContent)based the returns from Catalog FindGames Query. 
            To use the class, first initiaze the class by passing mediaId, mediatype (mediatype must be 
            in game class), locale and usertype). The class will query FindGames using the parameters passed in. 
            If the Object being queried in database and FindGames will return one entry and the associated image will 
            also be returned. The three APIs GetGame(), GetGameContent(), GetImage() will return the corresponding
            data contract object extracted from the FindGames Query. The returned objects
            can be compared with the object that is passed to ConfigureProduct API through XML comparsion.
            </summary>
        </member>
        <member name="M:MIXTesting.FindGameHelper.GetGame">
            <summary>
            Return Game DataContract object if the mediatype of the entry returned from FindGames is Game or ArcadeGame
            Otherwise, return null
            </summary>
        </member>
        <member name="M:MIXTesting.FindGameHelper.GetGameContent">
            <summary>
            Return GameContent DataContract object if the mediatype of the entry returned from FindGames is GameContent
            Otherwise, return null
            </summary>
        </member>
        <member name="M:MIXTesting.FindGameHelper.GetImages(xonline.mix.productmanagement.contracts.V1.ProductBase)">
            <summary>
            Return Image DataContract objects if images are returned from FindGames
            Otherwise, return null
            </summary>
        </member>
        <member name="T:MIXTesting.Catalog">
            <summary>
            Provides access to get, set, and remove objects from the catalog
            </summary>
        </member>
        <member name="F:MIXTesting.Catalog.RawCatalogDbConnectionString">
            <summary>
            RawCatalogDb connection string 
            </summary>
        </member>
        <member name="F:MIXTesting.Catalog.sqlGameRemove">
            <summary>
            sqlGameRemove is the sql script to remove the game and its associated content from the catalog
            </summary>
        </member>
        <member name="F:MIXTesting.Catalog.sqlOfferRemove">
            <summary>
            sqlOfferRemove is the sql script to remove the offer from the catalog
            </summary>
        </member>
        <member name="F:MIXTesting.Catalog.xmlDiffReport">
            <summary>
            Diff report generator
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.#ctor">
            <summary>
            Initializes a new instance of the Catalog class
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.SqlQueryGetMediaModifiedDate(System.Guid)">
            <summary>
            Returns a query string for selecting the modifiedDate for a specific Media
            <param name="mediaId">The media id for the product</param>
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.Remove(System.Guid)">
            <summary>
            Remove the game and its associated content from the catalog
            </summary>
            <param name="value">The media id for the game</param>
        </member>
        <member name="M:MIXTesting.Catalog.ConfigureProduct(System.Exception@,System.Object,MIXTesting.CustomHttpHeader[])">
            <summary>
            Save the media to the catalog
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.GetProduct(System.Exception@,System.Guid,MIXTesting.CustomHttpHeader[])">
            <summary>
            Get the media and its associated content from the catalog
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.ConfigureOffer(System.Exception@,System.Object,MIXTesting.CustomHttpHeader[])">
            <summary>
            Save offer to catalog
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.GetOffer(System.Exception@,System.Guid,MIXTesting.CustomHttpHeader[])">
            <summary>
            Get offer from  catalog
            </summary>
        </member>
        <member name="M:MIXTesting.Catalog.RemoveOffer(System.Guid)">
            <summary>
            Remove the offer from the catalog
            </summary>
            <param name="offerId">The offer id to remove</param>
        </member>
        <member name="T:MIXTesting.DataContractSerialize">
            <summary>
            Class to handle Serializing and deserializes data contract objects
            </summary>
        </member>
        <member name="M:MIXTesting.DataContractSerialize.ObjectToXml(System.Object)">
            <summary>
            Serializes a datacontract object into a xml documents
            </summary>
        </member>
        <member name="M:MIXTesting.DataContractSerialize.DeserializeFromFile(System.String,System.Type)">
            <summary>
            Deserialize the xml file to a specified object type
            </summary>
            <param name="fileName">The xml file representing the specified object type</param>
            <param name="type">The specified object type</param>
            <returns>The object represented by the xml document</returns>
        </member>
        <member name="M:MIXTesting.DataContractSerialize.DeserializeFromXmlDoc(System.Xml.XmlDocument,System.Type)">
            <summary>
            Deserialize from xmldocment to a specified object type
            </summary>
            <param name="xmlDoc">Xmldocument object which is from the serilization of a data contract </param>
            <param name="type">The specified object type</param>
            <returns>The object represented by the xml document</returns>    
        </member>
        <member name="T:MIXTesting.Serializer">
            <summary>
            Serializes and deserializes objects into and from xml documents
            </summary>
        </member>
        <member name="M:MIXTesting.Serializer.DeserializeFromFile(System.String,System.Type)">
            <summary>
            Deserialize the xml file to a specified object type
            </summary>
            <param name="fileName">The xml file representing the specified object type</param>
            <param name="type">The specified object type</param>
            <returns>The object represented by the xml document</returns>
        </member>
        <member name="M:MIXTesting.Serializer.Serialize(System.Object)">
            <summary>
            Serialize the specified object to an xml document
            </summary>
            <param name="obj">The specified object</param>
            <returns>The xml document representing the object</returns>
        </member>
        <member name="M:MIXTesting.Serializer.SerializeToFile(System.Object,System.String)">
            <summary>
            Serialize the specified object to an xml file
            </summary>
            <param name="obj">The specified object</param>
            <param name="fileName">The xml file representing the specified object type</param>
        </member>
        <member name="T:MIXTesting.Serializer.StringWriterUTF8">
            <summary>
            Implements a StringWriter for writing an xml document to a UTF8 string
            </summary>
        </member>
        <member name="F:MIXTesting.Serializer.StringWriterUTF8.encoding">
            <summary>
            encoding is the encoding in which the output is written
            </summary>
        </member>
        <member name="M:MIXTesting.Serializer.StringWriterUTF8.#ctor(System.Text.StringBuilder)">
            <summary>
            Initializes a new instance of the StringWriterUTF8 class
            </summary>
            <param name="stringBuilder">The StringBuilder to write to</param>
        </member>
        <member name="M:MIXTesting.Serializer.StringWriterUTF8.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the StringWriterUTF8 and optionally releases the managed resources
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="P:MIXTesting.Serializer.StringWriterUTF8.Encoding">
            <summary>
            Gets the encoding in which the output is written
            </summary>
        </member>
        <member name="M:MIXTesting.Template.ProcessFileToApplyTemplate(System.String)">
            <summary>
            Process the input file, parse for the template to apply, generate template, and then save the proccessed file in the orignal location
            </summary>
            <param name="testCaseFilePath">path to file to be processed</param>
        </member>
        <member name="M:MIXTesting.Template.ProcessMediaTemplate(System.Xml.Linq.XElement)">
            <summary>
            Process Media template
            </summary>
            <param name="input">the xml to apply template to</param>
        </member>
        <member name="M:MIXTesting.Template.ProcessOfferTemplate(System.Xml.Linq.XElement)">
            <summary>
            Process Offer template
            </summary>
            <param name="input">the xml to apply template to</param>
        </member>
        <member name="M:MIXTesting.Template.ProcessTemplate(System.Xml.Linq.XElement,System.String,System.String)">
            <summary>
            Process the Media or Offer template, and send the list of media/ offer operation to ApplyTemplate
            </summary>
            <param name="input">the xml you wanted to process</param>
            <param name="operationKeyword">specifies which operation you want to process ("MediaOperation"/ "OfferOperation")</param>
            <param name="keyword">specifies which keyword to begin the replacement under ("Media"/ "ProcessedOffer")(</param>
        </member>
        <member name="M:MIXTesting.Template.RevertProcessedFile(System.String)">
            <summary>
            Reads the saves the input file as .templated, and then replace it with the original file
            </summary>
            <param name="testcaseFilePath">path to file to be reverted</param>
        </member>
        <member name="M:MIXTesting.Template.GetTemplate(System.String)">
            <summary>
            Gets the appropiate Template with provided templateTag
            </summary>
            <param name="templateTag">tag to indicate which template to use</param>
            <returns>an Xelement representing the template requested</returns>
        </member>
        <member name="M:MIXTesting.Template.ApplyTemplate(System.Xml.Linq.XElement,System.Xml.Linq.XElement,System.String)">
            <summary>
            Applies template to each individual operation for media/ offer operation
            </summary>
            <param name="template">the template to apply</param>
            <param name="operation">specifies which operation you want to process ("MediaOperation"/ "OfferOperation")</param>
            <param name="keyword">specifies which keyword to begin the replacement under ("Media"/ "ProcessedOffer")(</param>
        </member>
        <member name="T:MIXTesting.WCFTestBase">
            <summary>
            The test base for WCF test cases
            </summary>
        </member>
        <member name="M:MIXTesting.WCFTestBase.PrintObject(System.Object)">
            <summary>
            Print out the values of the Mix data member object
            It can handle an array of objects
            </summary>
            <param name="mixObj"></param>
        </member>
        <member name="T:MIXTesting.ConfigureDataProvider">
            <summary>
            Class to get the path info of testcase xml files
            </summary>
        </member>
        <member name="T:MIXTesting.TestCaseInfo">
            <summary>
            Class to generate stf test case
            </summary>
        </member>
        <member name="T:MIXTesting.TestGroupInfo">
            <summary>
            Class to generate stf test group
            </summary>
        </member>
        <member name="T:MIXTesting.TestData">
            <summary>
            Class to generate stf tests from a xml input file
            </summary>
        </member>
        <member name="M:MIXTesting.TestData.CreateTests(System.String,System.Collections.Generic.List{ServerTestFramework.TestNode})">
            <summary>
            Each individual test suite call this function to generate stf tests.
            "testcaseFilePath" is the path of test case xml file
            "groupList" is where the generated test cases are going to be added. 
            </summary>
        </member>
        <member name="T:MIXTesting.StringLengths">
            <summary>
            Static class which defines string lengths to be used in validators
            </summary>
        </member>
        <member name="T:MIXTesting.Tags">
            <summary>
            Static class which defines the Tags in the validators
            </summary>
        </member>
        <member name="T:MIXTesting.Input">
            <summary>
            Each Input object includes ValidationType, Value that can be used to set a Product 
            and the ErrorMessagor corresponding to that Value. Each Input object can be retrieved and used to create
            a test case to verfiy the corresponding validator. 
            </summary>
        </member>
        <member name="T:MIXTesting.ValidatorExceptionTable">
            <summary>
            A hash table is used to store info about individual validators. The key is the name of the validator and 
            the value of the  entry is an array of  objects that can be used to set the data member of a contract  
            and the error  message corresponding to the server returned when passing that value.
            </summary>
        </member>
        <member name="M:MIXTesting.ValidatorExceptionTable.AddStringLenthValidatorInput(System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Generate the Input object array used to veirfy the StringLength Validator
            1.Add  Input object to verify ValidationType.BiggerLenStrMax to the Input array
            2.if string length lowerBound >0, add Input object to verify ValidationType.LessStrLenMin to Input array
            3. If the datamember can not be null, add  Input object to veirfy ValidationType.NullException to the Input array
            </summary>
        </member>
        <member name="M:MIXTesting.ValidatorExceptionTable.GetInput(System.String,MIXTesting.ValidationType)">
            <summary>
             retrieve Input object for the specified validation type and key.
             </summary>
        </member>
        <member name="T:MIXTesting.SetValueHelper`1">
            <summary>
             Class to help retrieving certain value and crosponding error message from hash table 
             </summary>
        </member>
        <member name="T:MIXTesting.ValidateTestBase">
            <summary>
             Base class to generate tests from the hash table which stores the validator infomation. 
             </summary>
        </member>
        <member name="T:MixTest.TitleManagement.TitleManagementHelperV3">
            <summary>
            
            </summary>
        </member>
        <member name="M:MixTest.TitleManagement.TitleManagementHelperV3.GenerateEndpoint">
            <summary>
            Generate a random valid endpoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:MixTest.SettingsManagement.FullBusinessPartnerV3.#ctor(System.Guid)">
            <summary>
            Load business partner data from the database.
            </summary>
        </member>
        <member name="M:MixTest.SettingsManagement.MixSettingsHelperV3.LoadClaimTypes">
            <summary>
            Load all the available claim types from the database
            </summary>
        </member>
        <member name="M:MixTest.SettingsManagement.MixSettingsHelperV3.LoadTokenTypes">
            <summary>
            Load all the available token types from the database
            </summary>
        </member>
        <member name="M:MixTest.SettingsManagement.FullBusinessPartnerV4.#ctor(System.Guid)">
            <summary>
            Load business partner data from the database.
            </summary>
        </member>
        <member name="M:MixTest.SettingsManagement.MixSettingsHelperV4.LoadClaimTypes">
            <summary>
            Load all the available claim types from the database
            </summary>
        </member>
        <member name="M:MixTest.SettingsManagement.MixSettingsHelperV4.LoadTokenTypes">
            <summary>
            Load all the available token types from the database
            </summary>
        </member>
        <member name="T:LiveStatsTest.TitleStatsBase">
            <summary>
            Base class for storing leaderboard data from the Xbox Live service.
            This class should not be used directly.
            </summary>
        </member>
        <member name="T:LiveStatsTest.Xbox360Stats">
            <summary>
            Class used for retrieving leaderboard data from the Xbox Live service for Xbox 360 titles.
            </summary>
        </member>
        <member name="T:LiveStatsTest.Xbox1Stats">
            <summary>
            Class used for retrieving leaderboard data from the Xbox Live service for Xbox 1 titles.
            </summary>
        </member>
        <member name="T:LiveStatsTest.StatsVerifier">
            <summary>
            Base class for the leaderboard verification classes. This class should not be used directly.
            </summary>
        </member>
        <member name="T:LiveStatsTest.Xbox360StatsVerifier">
            <summary>
            Verification class for Xbox 360 leaderboards.
            </summary>
        </member>
        <member name="M:LiveStatsTest.Xbox360StatsVerifier.VerifyLeaderboards(ServerTestFramework.STFTools.ConfigFiles.XboxLiveSubmissionProject,LiveStatsTest.Xbox360Stats)">
            <summary>
            Verifies the User-Defined and TrueSkill leaderboards in a given XLAST file with what's in the service.
            </summary>
            <param name="xlast">The XLAST file containing the leaderboard definitions.</param>
            <param name="actData">The actual data from the Live Service.</param>
            <returns>
            If the verifications succeeded, TEST_RESULTS.PASSED is returned.
            If a verification fails, TEST_RESULTS.FAILED is returned.
            </returns>
        </member>
        <member name="T:LiveStatsTest.Xbox1StatsVerifier">
            <summary>
            Verifier class for Xbox 1 leaderboards.
            </summary>
        </member>
        <member name="T:LiveStatsTest.SVLeaderboard">
            <summary>
            This class represents a standard method of defining a leaderboard within
            the Stats Verification methods.
            </summary>
            <remarks>
            This class and it's supporting SV* classes are needed to normalize StatsView
            leaderboard definitions from an XLAST file with TrueSkill leaderboard definitions.
            </remarks>
        </member>
        <member name="M:LiveStatsTest.SVLeaderboard.GetLeaderboardsFromXlast(ServerTestFramework.STFTools.ConfigFiles.XboxLiveSubmissionProject)">
            <summary>
            Static method to extract user-defined and TrueSkill leaderboards from an XLAST file.
            </summary>
            <param name="xlast">An XboxLiveSubmissionProject object representing an XLAST file.</param>
            <returns>A hashtable containing all user-defined and TrueSkill leaderboards from the XLAST file.</returns>
        </member>
        <member name="T:LiveStatsTest.SVLeaderboardColumn">
            <summary>
            Leaderboard column definition class for both user-defined and TrueSkill leaderboards.
            </summary>
        </member>
        <member name="M:LiveStatsTest.SVLeaderboardColumn.#ctor(System.String,System.UInt32,System.String)">
            <summary>
            Creates an SVLeaderboardColumn object with the given name, attribute Id and formula
            </summary>
            <param name="name">The friendly name of the column</param>
            <param name="attributeId">The attribute ID of the column</param>
            <param name="formula">The column formula.</param>
        </member>
        <member name="T:LiveStatsTest.SVLocalizedDescription">
            <summary>
            This class represents a single string translation from an XLAST file.
            </summary>
        </member>
        <member name="T:LiveStatsTest.SVRawAttribute">
            <summary>
            This class represents the raw attributes for an Xbox 1 leaderboard.
            </summary>
        </member>
        <member name="T:MIXTesting.CustomHttpHeader">
            <summary>
            The custom http header for WebSG and Behaviour Injection
            </summary>
        </member>
        <member name="T:MIXTesting.WCFClientBase">
            <summary>
            Base WCF client for all Mix components
            </summary>
        </member>
        <member name="M:MIXTesting.WCFClientBase.GetRandomRequestId">
            <summary>
            Generates Random Request ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.WCFClientBase.Invoke``1(System.Object,System.UInt32@,System.Boolean@,System.Exception@,System.String,System.Object[])">
            <summary>
            Use reflection to call Mix APIs. All the exception handling is in this method.
            
            For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned and no exception is thrown.
            The FaultException is also returned as a out parameter. 
            For all other exceptions, a UnexpectedTestResultException is thrown.
            </summary>
            <typeparam name="ReturnObjectType">The return type for APIs with a return. Use NoReturn class if an API does not have a return.</typeparam>
            <param name="client">The clientbase from WCF proxy</param>
            <param name="hr">The HR from FaultException<MixClientFault/></param>
            <param name="retryable">The Retryable flag from FaultException<MixClientFault/></param>
            <param name="exception">The FaultException<MixClientFault/> exception</param>
            <param name="methodName">The API name</param>
            <param name="parameters">Input parameters for this API</param>
            <returns></returns>
        </member>
        <member name="T:MIXTesting.WCFClientBase.NoReturn">
            <summary>
            An empty class used to distinguish a method call without a return
            </summary>
        </member>
        <member name="T:MIXTesting.OfferManagementWCFClient">
            <summary>
            The OfferManagement WCF client. 
            This is the one location that contains all API calls for OfferManagement component.
            </summary>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.CreateNewClient">
            <summary>
            Create a new MixOfferManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.CreateNewClient(System.String)">
            <summary>
            Create a new MixOfferManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.ConfigureOffer(xonline.mix.offermanagement.contracts.V1.Offer)">
            <summary>
            API ConfigureOffer. This is for normal use or positive tests.
            </summary>
            <param name="offer"></param>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.ConfigureOffer(xonline.mix.offermanagement.contracts.V1.Offer,System.Exception@)">
            <summary>
            API ConfigureOffer. This is for negative tests.
            For FaultException<MixClientFault/> exception, a HR, a Retryable flag and the exception itself are returned as out parameters.
            No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
            
            For all other exceptions, an UnexpectedTestResultException is thrown.
            </summary>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.GetOffer(System.Guid)">
            <summary>
            API GetOffer. This is for normal use or positive tests.
            </summary>
            <param name="offerId"></param>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.GetOffer(System.Guid,System.Exception@)">
            <summary>
            API GetOffer. This is for negative tests.
            For FaultException<MixClientFault/> exception, a HR, a Retryable flag and the exception itself are returned as out parameters.
            No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
            
            For all other exceptions, an UnexpectedTestResultException is thrown.
            </summary>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.GetSignedHeader(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            API GetSignedHeader.
            </summary>
        </member>
        <member name="M:MIXTesting.OfferManagementWCFClient.GetSignedHeader(System.UInt32,System.UInt32,System.Byte[],System.UInt32@,System.Exception@)">
            <summary>
            API GetSignedHeader.
            </summary>
        </member>
        <member name="T:MIXTesting.ProductManagementWCFClient">
            <summary>
            The ProductManagement WCF client. 
            This is the one location that contains all API calls for ProductManagement component.
            </summary>
        </member>
        <member name="M:MIXTesting.ProductManagementWCFClient.CreateNewClient">
            <summary>
            Create a new MixProductManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.ProductManagementWCFClient.CreateNewClient(System.String)">
            <summary>
            Create a new MixProductManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.ProductManagementWCFClient.ConfigureProduct(xonline.mix.productmanagement.contracts.V1.Product)">
            <summary>
            API ConfigureProduct. This is for normal use or positive tests.
            </summary>
            <param name="product"></param>
        </member>
        <member name="M:MIXTesting.ProductManagementWCFClient.ConfigureProduct(xonline.mix.productmanagement.contracts.V1.Product,System.Exception@)">
            <summary>
            API ConfigureProduct. This is for negative tests.
            For FaultException<MixClientFault/> exception, the exception itself is returned as out parameter.
            No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
            
            For all other exceptions, an UnexpectedTestResultException is thrown.
            </summary>
        </member>
        <member name="M:MIXTesting.ProductManagementWCFClient.GetProduct(System.Guid)">
            <summary>
            API GetProduct. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.ProductManagementWCFClient.GetProduct(System.Guid,System.Exception@)">
            <summary>
            API GetProduct. This is for negative tests.
            For FaultException<MixClientFault/> exception, the exception itself is returned as out parameter.
            No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
            
            For all other exceptions, an UnexpectedTestResultException is thrown.
            </summary>
        </member>
        <member name="T:MIXTesting.MatchWCFClient">
            <summary>
            The Match WCF client. 
            This is the one location that contains all API calls for Match component.
            </summary>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.CreateNewClient">
            <summary>
            Create a new MixMatchClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.ConfigureMatchmaking(System.UInt32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            API ConfigureTitle
            </summary>
            <param name="titleId"></param>
            <param name="removeMode"></param>
            <param name="dropTable"></param>
            <param name="noReload"></param>
            <param name="overrideBuckets"></param>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.ConfigureMatchmaking(System.UInt32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,xonline.mix.match.contracts.V1.ConfigureMatchResult)">
            <summary>
            API Deploy. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
            <param name="removeMode"></param>
            <param name="dropTable"></param>
            <param name="noReload"></param>
            <param name="overrideBuckets"></param>
            <param name="expectedResult"></param>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.ClearDB(System.UInt32)">
            <summary>
            Clears all match tables, sprocs, and empties t_interface_buckets from the db
            </summary>
            <param name="titleId"></param>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.Verify(System.UInt32)">
            <summary>
            Verifies all tables and sprocs
            </summary>
            <param name="titleId"></param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.GetMatchServers(System.UInt32)">
            <summary>
            Gets the list of Match Servers for the titleid from the t_interface_buckets vc_server column.
            </summary>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.VerifyTables(System.String,System.UInt32)">
            <summary>
            Verifies the tables were created
            </summary>
            <returns>If the tables were created</returns>
        </member>
        <member name="M:MIXTesting.MatchWCFClient.VerifyProcs(System.String,System.UInt32)">
            <summary>
            Verifies that Match stored procs were created for Title
            </summary>
            <returns></returns>not
        </member>
        <member name="T:MIXTesting.StatsWCFClient">
            <summary>
            The Stats WCF client. 
            This is the one location that contains all API calls for the Stats component.
            </summary>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.CreateNewClient">
            <summary>
            Create a new MixStatsClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.ConfigureLeaderboards(System.UInt32)">
            <summary>
            API ConfigureLeaderboards. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.ConfigureLeaderboards(System.UInt32,System.Boolean)">
            <summary>
            API ConfigureLeaderboards. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
            <param name="force"></param>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.ResetLeaderboard(System.UInt32,System.UInt64)">
            <summary>
            API ResetLeaderboard. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
            <param name="leaderboardId"></param>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.DeleteLeaderboards(System.UInt32)">
            <summary>
            API DeleteLoeaderboards. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.VerifyXbox360StatsData(System.UInt32,System.Boolean)">
            <summary>
            Verifies all leaderboard configuration data in the service matches the XLAST and LTC files.
            </summary>
            <param name="titleId">Title ID</param>
            <param name="verifyLocation">Flag indicating whether or not the leaderboard locations should be verified.</param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.VerifyXbox360StatsData(System.UInt32,System.String,System.Boolean)">
            <summary>
            Verifies all leaderboard configuration data in the service matches the XLAST and LTC files.
            </summary>
            <param name="titleId">Title ID</param>
            <param name="path">Path to the xlast file to verify</param>
            <param name="verifyLocation">Flag indicating whether or not the leaderboard locations should be verified.</param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.StatsWCFClient.ClearDB(System.UInt32)">
            <summary>
            Clears all stats tables and sprocs from the db
            </summary>
            <param name="titleId"></param>
        </member>
        <member name="T:MIXTesting.StorageWCFClient">
            <summary>
            The Storage WCF client. 
            This is the one location that contains all API calls for Storage component.
            </summary>
        </member>
        <member name="M:MIXTesting.StorageWCFClient.CreateNewClient">
            <summary>
            Create a new MixStorageClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.StorageWCFClient.SubmitItemToStorage(System.UInt32,xonline.mix.storage.contracts.V1.MIXFileType,System.UInt64,System.Byte[])">
            <summary>
            API SubmitItemToStorage. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
            <param name="type"></param>
            <param name="imageID"></param>
            <param name="imageBlob"></param>
        </member>
        <member name="M:MIXTesting.StorageWCFClient.SubmitItemToStorage(System.UInt32,xonline.mix.storage.contracts.V1.MIXFileType,System.UInt64,System.Byte[],System.UInt32,System.Boolean)">
            <summary>
            API SubmitItemToStorage. This is for negative tests.
            For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
            Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
            For all other exceptions, an UnexpectedTestResultException is thrown.
            </summary>
        </member>
        <member name="M:MIXTesting.StorageWCFClient.SubmitAvatarImageToStorage(System.UInt32,xonline.mix.storage.contracts.V1.MIXFileType,System.Guid,System.Byte[])">
            <summary>
            API SubmitAvatarImageToStorage. This is for normal use or positive tests.
            </summary>
            <param name="titleId"></param>
            <param name="type"></param>
            <param name="avatarItemGuid"></param>
            <param name="imageBlob"></param>
        </member>
        <member name="M:MIXTesting.StorageWCFClient.SubmitAvatarImageToStorage(System.UInt32,xonline.mix.storage.contracts.V1.MIXFileType,System.Guid,System.Byte[],System.UInt32,System.Boolean)">
            <summary>
            API SubmitAvatarImageToStorage. This is for negative tests.
            For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
            Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
            For all other exceptions, an UnexpectedTestResultException is thrown.
            </summary>
        </member>
        <member name="T:MIXTesting.BetaManagementWCFClient">
            <summary>
            The Beta Management WCF client.
            This is the one location that contains all API calls for the Stats component.
            </summary>
        </member>
        <member name="F:MIXTesting.BetaManagementWCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.BetaManagementWCFClient.CreateNewClient">
            <summary>
            Create a new MixBetaManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.BetaManagementWCFClient.AssignReleaseToGroup(System.UInt32,System.UInt32,System.String,System.String,System.Guid,System.UInt32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="baseVersion"></param>
            <param name="currentFlashVersion"></param>
            <param name="systemOnlineManifest"></param>
            <param name="SystemManifest"></param>
            <param name="group"></param>
            <param name="titleID"></param>
            <param name="addUpgradePaths"></param>
        </member>
        <member name="M:MIXTesting.BetaManagementWCFClient.IsTitleVersionPropped(System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="titleID"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.BetaManagementWCFClient.GetGroups">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.BetaManagementWCFClient.GetGroupDetails(System.Guid)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MIXTesting.BetaManagementV2WCFClient">
            <summary>
            The Beta Management WCF client.
            This is the one location that contains all API calls for the Stats component.
            </summary>
        </member>
        <member name="F:MIXTesting.BetaManagementV2WCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.BetaManagementV2WCFClient.CreateNewClient">
            <summary>
            Create a new MixBetaManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.BetaManagementV2WCFClient.AssignReleaseToGroup(System.UInt32,System.UInt32,System.String,System.String,System.Guid,System.UInt32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="baseVersion"></param>
            <param name="currentFlashVersion"></param>
            <param name="systemOnlineManifest"></param>
            <param name="SystemManifest"></param>
            <param name="group"></param>
            <param name="titleID"></param>
            <param name="addUpgradePaths"></param>
        </member>
        <member name="M:MIXTesting.BetaManagementV2WCFClient.AssignTitleUpdateToGroup(System.UInt32,System.UInt32,System.UInt32,System.Guid)">
            <summary>
            
            </summary>
            <param name="titleID"></param>
            <param name="baseVersion"></param>
            <param name="currentVersion"></param>
            <param name="group"></param>
        </member>
        <member name="M:MIXTesting.BetaManagementV2WCFClient.IsTitleVersionPropped(System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="titleID"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.BetaManagementV2WCFClient.GetGroups">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.BetaManagementV2WCFClient.GetGroupDetails(System.Guid)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MIXTesting.BetaManagementV3WCFClient">
            <summary>
            The Beta Management WCF client.
            This is the one location that contains all API calls for the Stats component.
            </summary>
        </member>
        <member name="F:MIXTesting.BetaManagementV3WCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.BetaManagementV3WCFClient.CreateNewClient">
            <summary>
            Create a new MixBetaManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
        </member>
        <member name="M:MIXTesting.BetaManagementV3WCFClient.GetGroupDetails(System.Guid)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MIXTesting.BetaManagementV4WCFClient">
            <summary>
            The Beta Management WCF client.
            This is the one location that contains all API calls for the Stats component.
            </summary>
        </member>
        <member name="F:MIXTesting.BetaManagementV4WCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.BetaManagementV4WCFClient.CreateNewClient">
            <summary>
            Create a new MixBetaManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
        </member>
        <member name="M:MIXTesting.BetaManagementV4WCFClient.GetGroupDetails(System.Guid)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:MIXTesting.SettingsManagementWCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.SettingsManagementWCFClient.CreateNewClient">
            <summary>
            Create a new MixClientSettingsManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="F:MIXTesting.SettingsManagementV2WCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.SettingsManagementV2WCFClient.CreateNewClient">
            <summary>
            Create a new MixClientSettingsManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.SettingsManagementV3WCFClient.CreateNewClient">
            <summary>
            Create a new MixClientSettingsManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.SettingsManagementV4WCFClient.CreateNewClient">
            <summary>
            Create a new MixClientSettingsManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MIXTesting.TitleManagementWCFClient">
            <summary>
            The TitleManagement WCF client. 
            This is the one location that contains all API calls for TitleManagement component.
            </summary>
        </member>
        <member name="M:MIXTesting.TitleManagementWCFClient.CreateNewClient">
            <summary>
            Create a new MixTitleManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.TitleManagementWCFClient.ConfigureTitle(System.Byte[])">
            <summary>
            API ConfigureTitle. This is for normal use or positive tests.
            </summary>
            <param name="xlast"></param>
        </member>
        <member name="M:MIXTesting.TitleManagementWCFClient.ConfigureTitle(System.Byte[],System.Boolean,System.UInt32,System.Boolean)">
            <summary>
            API ConfigureTitle. This is for negative tests.
            </summary>
            <param name="xlast"></param>
            <param name="noReload"></param>
            <param name="expectedHR"></param>
            <param name="expectedRetryable"></param>
        </member>
        <member name="T:MIXTesting.TitleManagementV2WCFClient">
            <summary>
            The TitleManagement WCF client. 
            This is the one location that contains all API calls for TitleManagement component.
            </summary>
        </member>
        <member name="M:MIXTesting.TitleManagementV2WCFClient.CreateNewClient">
            <summary>
            Create a new MixTitleManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.TitleManagementV2WCFClient.ConfigureTitle(System.Byte[])">
            <summary>
            API ConfigureTitle. This is for normal use or positive tests.
            </summary>
            <param name="xlast"></param>
        </member>
        <member name="M:MIXTesting.TitleManagementV2WCFClient.ConfigureTitle(System.Byte[],System.Boolean,System.UInt32,System.Boolean)">
            <summary>
            API ConfigureTitle. This is for negative tests.
            </summary>
            <param name="xlast"></param>
            <param name="noReload"></param>
            <param name="expectedHR"></param>
            <param name="expectedRetryable"></param>
        </member>
        <member name="T:MIXTesting.TitleManagementV3WCFClient">
            <summary>
            The TitleManagement WCF client. 
            This is the one location that contains all API calls for TitleManagement component.
            </summary>
        </member>
        <member name="M:MIXTesting.TitleManagementV3WCFClient.CreateNewClient">
            <summary>
            Create a new MixTitleManagementClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.TitleManagementV3WCFClient.ConfigureTitle(System.Byte[])">
            <summary>
            API ConfigureTitle. This is for normal use or positive tests.
            </summary>
            <param name="xlast"></param>
        </member>
        <member name="M:MIXTesting.TitleManagementV3WCFClient.ConfigureTitle(System.Byte[],System.Boolean,System.UInt32,System.Boolean)">
            <summary>
            API ConfigureTitle. This is for negative tests.
            </summary>
            <param name="xlast"></param>
            <param name="noReload"></param>
            <param name="expectedHR"></param>
            <param name="expectedRetryable"></param>
        </member>
        <member name="T:MIXTesting.TokenManagementWCFClient">
            <summary>
            The TokenManagement WCF client.
            This is the one location that contains all API calls for TokenManagement component.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.CreateNewClient">
            <summary>
            Create a new MixTokenManagementClient for each API call.
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.ConfigureTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
            API ConfigureTokenCategory. This is for normal use or positive tests.
            </summary>
            <param name="tokenCategory"></param>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.ConfigureTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory,System.UInt32,System.Boolean)">
             <summary>
             API ConfigureTokenCategory. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenCategoryById(System.Guid)">
            <summary>
            API GetTokenCategoryById. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenCategoryById(System.Guid,System.UInt32,System.Boolean)">
             <summary>
             API GetTokenCategoryById. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenCategoryByName(System.String)">
            <summary>
            API GetTokenCategoryByName. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenCategoryByName(System.String,System.UInt32,System.Boolean)">
             <summary>
             API GetTokenCategoryByName. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenCategoryByOffer(System.Guid)">
            <summary>
            API GetTokenCategoryByOffer. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenCategoryByOffer(System.Guid,System.UInt32,System.Boolean)">
             <summary>
             API GetTokenCategoryByOffer. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenInfoByToken(System.String)">
            <summary>
            API GetTokenInfoByToken. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenInfoByToken(System.String,System.UInt32,System.Boolean)">
             <summary>
             API GetTokenInfoByToken. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenInfoByHash(System.Byte[])">
            <summary>
            API GetTokenInfoByHash. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenInfoByHash(System.Byte[],System.UInt32,System.Boolean)">
             <summary>
             API GetTokenInfoByHash. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GenerateTokens(System.Guid,System.UInt32,System.Byte[],System.Boolean)">
            <summary>
            API GenerateTokens. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GenerateTokens(System.Guid,System.UInt32,System.Byte[],System.UInt32,System.Boolean,System.Boolean)">
             <summary>
             API GenerateTokens. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenJobStatus(System.Guid)">
            <summary>
            API GetTokenJobStatus. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenJobStatus(System.Guid,System.UInt32,System.Boolean)">
             <summary>
             API GetTokenJobStatus. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenJobStatusByCategory(System.Guid)">
            <summary>
            API GetTokenJobStatusByCategory. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokenJobStatusByCategory(System.Guid,System.UInt32,System.Boolean)">
             <summary>
             API GetTokenJobStatusByCategory. This is for negative tests.
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokens(System.Guid,System.Byte[],System.Int32,System.Int32)">
            <summary>
            API GetTokens. This is for normal use or positive tests.
            </summary>
        </member>
        <member name="M:MIXTesting.TokenManagementWCFClient.GetTokens(System.Guid,System.Byte[],System.Int32,System.Int32,System.UInt32,System.Boolean)">
             <summary>
             API GetTokens 
             For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
             Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
            
             For all other exceptions, an UnexpectedTestResultException is thrown.
             </summary>
        </member>
        <member name="T:MIXTesting.SubscriptionFamilyWCFClient">
            <summary>
            The subscriptionfamily  WCF client.
            This is the one location that contains all API calls for the subscriptionfamily component.
            </summary>
        </member>
        <member name="F:MIXTesting.SubscriptionFamilyWCFClient.ExpectedHR">
            <summary> HR result expected by the call. </summary>
        </member>
        <member name="M:MIXTesting.SubscriptionFamilyWCFClient.CreateNewClient">
            <summary>
            Create a new MixsubscriptionfamilyClient for each API call. 
            When the API returns, the client is closed.
            We don't reuse client or proxy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.SubscriptionFamilyWCFClient.ServicePrivilegeSetEnumerate">
            <summary>
            
            </summary>       
        </member>
        <member name="M:MIXTesting.SubscriptionFamilyWCFClient.SubscriptionTypeEnumerate">
            <summary>
            
            </summary>       
        </member>
        <member name="M:MIXTesting.SubscriptionFamilyWCFClient.ServiceTypeEnumerate">
            <summary>
            
            </summary>        
        </member>
        <member name="M:MIXTesting.SubscriptionFamilyWCFClient.SubscriptionFamilyGet(System.Guid)">
            <summary>
            
            </summary>        
        </member>
        <member name="M:MIXTesting.SubscriptionFamilyWCFClient.SubscriptionFamilyConfigure(System.Guid,System.String,System.Int32,System.Int32,System.Int32,System.Int32[],System.Nullable{System.Int32})">
            <summary>
            
            </summary>        
        </member>
        <member name="T:MIXTesting.TokenGenerator">
            <summary>
            A simple class that creates some one use tokens and can be retrieved one by one. 
            </summary>
        </member>
        <member name="T:MIXTesting.MixTokenHelper">
            <summary>
            A helper class includes validation code, creating various objects
            and common data members
            </summary>
        </member>
        <member name="F:MIXTesting.MixTokenHelper._tc">
            <summary>
            Create a global token category shared by all the tests
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.CreateNewWebSGHeaders">
            <summary>
            Create new WebSG headers in the order
            0 - Subject Name
            1 - Client IP and Port
            2 - Request Id
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.NewChannelSKUObject(System.String)">
            <summary>
            create a new ChannelSKU object
            </summary>
            <param name="pkpn">the PKPN</param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.NewTokenCategory">
            <summary>
            Create a new token category object. It is for Xbox only game tokens.
            TokenCategoryId, TokenCategoryName, PromotionId and PKPN are different each time
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.NewTokenCategoryInCsatArcadeGame">
            <summary>
            Create a new token category object In Csat. It is for game tokens in Csat (CIS tokens).
            Set up the ChannelSKU which needs to be sent to CTP
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.NewTokenCategoryInCsatLiveSubscription">
            <summary>
            Create a new token category object In Csat. It is for Live Subscription in Csat.
            Set up the ChannelSKU which needs to be sent to CTP
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.NewTokenCategoryInCsatPointsBundle">
            <summary>
            Create a new token category object In Csat. It is for Points Bundle in Csat.
            Set up the ChannelSKU which needs to be sent to CTP
            </summary>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.CreateTokenCategoryFrom(xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
            Make a copy of the token category object
            </summary>
            <param name="tc"></param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyTokenCategoryNotExist(xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
            Verify the token category does not exist
            </summary>
            <param name="tc"></param>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
            Verify one single token category
            </summary>
            <param name="tc"></param>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory[])">
            <summary>
            Verify if the Token Categories are the same as expected. The order is not enforced.
            If there are more than 1 in the array, all the Token Categories must be from the same OfferId
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.CompareTwoTokenCategories(xonline.mix.tokenmanagement.contracts.V1.TokenCategory,xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
            Compare if two Token Categories are the same
            Two fields in TokenCategory are not saved in TokenDB, TokenType and ChannelSKUObject
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyTokenFormat(System.String)">
            <summary>
            Verify Token format
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyTokens(System.Int32,xonline.mix.tokenmanagement.contracts.V1.TokenEntry[],xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
             Verify an array of tokens
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyTokens(System.Int32,xonline.mix.tokenmanagement.contracts.V1.TokenEntry[],System.Int32,xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
             Verify only some of an array of tokens
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.VerifyToken(xonline.mix.tokenmanagement.contracts.V1.TokenEntry,xonline.mix.tokenmanagement.contracts.V1.TokenCategory)">
            <summary>
             Verify one Token
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.CompareTwoTokenInfo(xonline.mix.tokenmanagement.contracts.V1.TokenInfo,xonline.mix.tokenmanagement.contracts.V1.TokenInfo,xonline.mix.tokenmanagement.contracts.V1.TokenEntry)">
            <summary>
             Compare two TokenInfo objects
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.CompareTwoTokenRedemptions(xonline.mix.tokenmanagement.contracts.V1.TokenRedemption[],xonline.mix.tokenmanagement.contracts.V1.TokenRedemption[])">
            <summary>
            Compare two TokenRedemptions array
            </summary>
            <param name="redemptions1"></param>
            <param name="redemptions2"></param>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.GenerateTestTokens(System.Guid,System.UInt32,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Generate Tokens for the Test purposes
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.GenerateTestTokensWithNewTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory,System.UInt32,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Generate Tokens for the Test purposes, with the specified token category
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.GenerateTestTokens(System.Guid,System.UInt32,System.Byte[],System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Generate Tokens for more then one job for the Test purposes
            The fuction will wait until the Tokens are delivered
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.WaitOnTokenJobs(System.Guid[],System.Int32)">
            <summary>
            Wait all jobs become delivered. Return the token count List
            </summary>
            <param name="jobs">job id array</param>
            <param name="seconds">timeout value</param>
            <returns>List of token count</returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.WaitOnFailedTokenJob(System.Guid[],System.Int32)">
            <summary>
            This job will wait until all the token jobs are marked as Failed within the specified time
            </summary>
            <param name="jobs"></param>
            <param name="seconds"></param>
            <returns>Array containing number of failures for the Jobs</returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.WaitOnFailedTokenJob(System.Guid,System.Int32)">
            <summary>
            This job will wait until all the token jobs are marked as Failed within the specified time
            </summary>
            <param name="tokenCategoryId"></param>
            <param name="seconds"></param>
            <returns>Array containing number of failures for the Jobs</returns>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.GetTokenEntries(System.Guid,System.Byte[])">
            <summary>
            GetTokenEntries - This function will extract the list of tokens along with
            PKPN and sequence numbers associated with the jobId from the encrypted .xtx file
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.GetTokenEntries(System.Guid,System.Byte[],System.Int32)">
            <summary>
            GetTokenEntries - This function will extract the list of tokens along with
            PKPN and sequence numbers associated with the jobId from the encrypted .xtx file
            </summary>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.ThresholdValidation(System.UInt32[],System.UInt32,System.Guid[])">
            <summary>
            Validate Number of retires for the failure jobs is as expected
            </summary>
            <param name="numOfFailures">Number of failures returned by API GetTokenJobStatus</param>
            <param name="expectedFailureCount">Expected number of failures</param>
            <param name="jobs">Jobid's</param>
        </member>
        <member name="M:MIXTesting.MixTokenHelper.RunCronHealthCheck">
            <summary>
            Run Cron Health Check URI
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\LiveBVT\Microsoft.XboxLive.Auth.Internal.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.XboxLive.Auth.Internal</name>
    </assembly>
    <members>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Internal">
            <summary>the caller is internal.  the value of this
            claim is typically the component name of the caller</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Ip">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Port">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.PartnerId">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.ValueTypes">
            <summary>the claim value types for all AuthClaimTypes</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthExtensions">
            <summary> </summary>
            <summary>
            These are LINQ extensions to various web requests, such as WebClient,
            HttpWebRequest, and WCF (coming soon), to facilitate adding XAuthdata information
            to the outgoing request. These should be used by a service that is using an
            IClaimsPrincipal and that needs to call another service that is also using 
            XblAuthProtocolModule and has XAuthdataTokenHandler configured.
            </summary>
            <remarks>
            To use these extensions, you need to use the Microsoft.XboxLive.Auth namespace.
            It is helpful to also use Microsoft.IdentityModel.Claims to get the IClaimsPrincipal
            interface.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.IsInternal(Microsoft.XboxLive.Auth.AuthHelper,System.String[])">
            <summary>
            Check for existence of an internal claim (which is always issued
            by "System").  And if specified, check  the  claim  against  the 
            array of valid values.
            </summary>
            <param name="helper">The AuthHelper instance that servces as "this"</param>
            <param name="values">The values (if any) against which to check</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebClient)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebClient,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="client"></param>
            <param name="principal">Local instance or Thread.CurrentPrincipal</param>
            <example>
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest,Microsoft.XboxLive.Auth.AuthHelper)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
            <param name="auth">Local instance or AuthHelper.Current</param>
            <example>
            webReq.SetXAuthdata(AuthHelper.Current);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
            <param name="principal">Local instance or Thread.CurrentPrincipal</param>
            <example>
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection,Microsoft.XboxLive.Auth.AuthHelper)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
            <param name="auth"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
            <param name="principal"></param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions">
            <summary>
            These are LINQ extensions to various web requests, such as WebClient,
            HttpWebRequest, and WCF (coming soon), to facilitate adding XAuthdata information
            to the outgoing request. These should be used by a service that is using an
            IClaimsPrincipal and that needs to call another service that is also using 
            XblAuthProtocolModule and has XAuthdataTokenHandler configured.
            </summary>
            <remarks>
            To use these extensions, you need to use the Microsoft.XboxLive.Auth namespace.
            It is helpful to also use Microsoft.IdentityModel.Claims to get the IClaimsPrincipal
            interface.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.OperationContext)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.OperationContext,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="context"></param>
            <param name="principal"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.Channels.MessageProperties)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="properties"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.Channels.MessageProperties,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="properties"></param>
            <param name="principal"></param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataConstants">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken">
            <summary>
            XAuthdataToken is the internal representation of authorization
            internal to the Xbox LIVE data center.  XAuthdataToken objects
            must never leave the data center.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.#ctor(System.Collections.Generic.IEnumerable{Microsoft.IdentityModel.Claims.IClaimsIdentity})">
            <summary>
            Instantiate an XAuthdataToken object using the claims from
            the supplied identities.
            </summary>
            <param name="identityList">A list of identities continaing
            claims used to populate the XAuthdataToken</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.IdentityModel.Claims.IClaimsIdentity})">
            <summary>
            Instantiate an XAuthdataToken object using the claims from
            the supplied identities.
            </summary>
            <param name="id">Token id (statistically unique identifier)</param>
            <param name="identityList">A list of identities continaing
            claims used to populate the XAuthdataToken</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ToString">
            <summary>
            Returns a serialized XAuthData XML.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.Id">
            <summary>
            Gets the token id. The token id is initialized during
            construction
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.Identities">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.SecurityKeys">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ValidFrom">
            <summary>
            Gets the datetime from which this token is valid
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ValidTo">
            <summary>
            Gets the datetime until which this token is valid
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler.GetSigningKeys">
             <summary>
             Retrieve one or more signature keys from the configuration store. It currently
             uses the app settings in the web.config, but could be extended in the future 
             for registry, database, file, or external code support.
             </summary>
             <example>
               [appSettings]
                 [add key="XAuthdataSigningKeys" value="00112233445566778899AABBCCDDEEFF..."/]
                 [add key="XAuthdataMasterKeyVersions" value="1"/]
               [/appSettings]
            
               [appSettings]
                 [add key="XAuthdataSigningKeys" value="00112233445566778899AABBCCDDEEFF...,00102030405060708090A0B0C0D0E0F0..."/]
                 [add key="XAuthdataMasterKeyVersions" value="1,1"/]
               [/appSettings]
             </example>
             <returns>List of keys, ordered oldest to newest</returns>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\azure\Microsoft.WindowsAzure.StorageClient.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.WindowsAzure.StorageClient</name>
    </assembly>
    <members>
        <member name="T:Microsoft.WindowsAzure.StorageClient.PageRange">
            <summary>
            Represents a range of pages.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.PageRange.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.PageRange"/> class.
            </summary>
            <param name="start">The start offset.</param>
            <param name="end">The end offset.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.PageRange.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.PageRange.StartOffset">
            <summary>
            Gets the start offset of the page range
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.PageRange.EndOffset">
            <summary>
            Gets the end offset of the page range.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob">
            <summary>
            A class representing a page blob
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudBlob">
            <summary>
            Represents a Windows Azure blob.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.IListBlobItem">
            <summary>
            Interface for an item returned from a List Blobs operation.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.IListBlobItem.Uri">
            <summary>
            Gets the URI.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.IListBlobItem.Parent">
            <summary>
            Gets the parent.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.IListBlobItem.Container">
            <summary>
            Gets the container.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> class 
            to represent the blob at the specified URI. 
            </summary>
            <param name="blobAbsoluteUri">The absolute URI to the blob.</param>
            <remarks>
            Any authentication information inside the address will be used to set the blob's credentials.
            Otherwise a blob for anonymous access is created.
            Any snapshot information as part of the address will indicate that this blob is a snapshot.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(System.String,System.Boolean)">
            <summary>
            Create a blob info from a given address. 
            Any authentication information inside the address will be used.
            Otherwise a blob for anonymous access is created.
            Any snapshot information as part of the address will be recorded
            Explicity specify whether to use host style or path style uri        
            </summary>
            <param name="usePathStyleUris">True to use path style uri</param>
            <param name="blobAbsoluteUri">Absolute Uri</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> class 
            to represent the blob at the specified URI. 
            </summary>
            <param name="blobAbsoluteUri">The absolute URI to the blob.</param>
            <param name="credentials">Storage account credentials</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Create a CloudBlob and a new service client using the credentials and a complete blob Uri
            Explicity specify whether to use host style or path style uri        
            </summary>
            <param name="blobAbsoluteUri">Complete uri</param>
            <param name="credentials">Storage credentials</param>
            <param name="usePathStyleUris">True to use path style Uris</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(System.Nullable{System.Boolean},System.String)">
            <summary>
            Internal implementation of uri based constructors
            </summary>
            <param name="usePathStyleUris">True to use path style uris</param>
            <param name="blobAbsoluteUri"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> class 
            to represent the blob at the specified URI. 
            </summary>
            <param name="blobUri">A relative URI to the blob.</param>
            <param name="serviceClient">A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobClient"/> object that 
            specifies the endpoint for the Blob service.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(Microsoft.WindowsAzure.StorageClient.CloudBlob)">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> class
            from an existing instance.
            </summary>
            <param name="cloudBlob">A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.#ctor(Microsoft.WindowsAzure.StorageClient.BlobAttributes,Microsoft.WindowsAzure.StorageClient.CloudBlobClient,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> class with existing attributes
            </summary>
            <param name="attributes">The attributes (NOTE: Saved by reference, does not make a copy).</param>
            <param name="serviceClient">The service client.</param>
            <param name="snapshotTime">The snapshot time.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.ParseQueryAndVerify(System.Uri,Microsoft.WindowsAzure.StorageClient.CloudBlobClient,System.Nullable{System.Boolean})">
            <summary>
            Parse Uri for any snapshot and SAS (Shared access signature) information. Validate that no other query parameters are passed in.
            Any snapshot information will be saved.
            Any SAS information will be recorded as corresponding credentials instance.
            If existingClient is passed in, any SAS information found will not be supported
            Otherwise a new client is created based on SAS information or as anonymous credentials
            </summary>
            <param name="completeUri"></param>
            <param name="existingClient"></param>
            <param name="usePathStyleUris">True to use path style uris</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.FetchAttributes">
            <summary>
            Retrieves properties and metadata for this blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.FetchAttributes(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Retrieves properties and metadata for this blob.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginFetchAttributes(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to retrieve the blob's metadata and properties.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginFetchAttributes(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to retrieve the blob's metadata and properties.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndFetchAttributes(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to retrieve the blob's metadata and properties.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.SetMetadata">
            <summary>
            Updates the blob's metadata.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.SetMetadata(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Updates the blob's metadata.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginSetMetadata(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to update the blob's metadata.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginSetMetadata(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to update the blob's metadata.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndSetMetadata(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to update the blob's metadata.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.SetProperties">
            <summary>
            Updates the blob's properties.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.SetProperties(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Updates the blob's properties.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginSetProperties(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to update the blob's properties.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginSetProperties(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to update the blob's properties.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndSetProperties(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to update the blob's properties.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.CopyFromBlob(Microsoft.WindowsAzure.StorageClient.CloudBlob)">
            <summary>
            Copy blob contents and properties from another blob
            </summary>
            <param name="source">Source blob to copy from</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.CopyFromBlob(Microsoft.WindowsAzure.StorageClient.CloudBlob,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Copy blob contents and properties from another blob
            </summary>
            <param name="source">Source blob to copy from</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginCopyFromBlob(Microsoft.WindowsAzure.StorageClient.CloudBlob,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous Copy Blob operation.
            </summary>
            <param name="source">The source blob.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginCopyFromBlob(Microsoft.WindowsAzure.StorageClient.CloudBlob,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous Copy Blob operation.
            </summary>
            <param name="source">The source blob.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndCopyFromBlob(System.IAsyncResult)">
            <summary>
            Ends an asynchronous Copy Blob operation.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.Delete">
            <summary>
            Deletes the blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.Delete(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Deletes the blob.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginDelete(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the blob.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginDelete(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the blob.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndDelete(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete the blob.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DeleteIfExists">
            <summary>
            Deletes the blob if it exists.
            </summary>
            <returns>True if the blob was deleted</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DeleteIfExists(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Deletes the blob if it exists.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns>True if the blob was deleted</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginDeleteIfExists(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the blob if it exists.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginDeleteIfExists(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the blob if it exists.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndDeleteIfExists(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete the blob.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>true</c> if the blob was successfully deleted.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.OpenWrite">
            <summary>
            Creates a stream for writing to the blob.
            </summary>
            <returns>
            <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobStream"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.OpenWrite(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Creates a stream for writing to the blob.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns><see cref="T:Microsoft.WindowsAzure.StorageClient.BlobStream"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadFromStream(System.IO.Stream)">
            <summary>
            Uploads a blob from a stream. 
            </summary>
            <param name="source">The data stream to be uploaded</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadFromStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads a blob from a stream. 
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginUploadFromStream(System.IO.Stream,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to upload a blob from a stream.
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginUploadFromStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to upload a blob from a stream. 
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndUploadFromStream(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to upload a blob from a stream. 
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadText(System.String)">
            <summary>
            Uploads a string of text to a file. 
            </summary>
            <param name="content">The content to be upload</param>
            <remarks>This method assumes that the string is encoded as UTF-8.</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadText(System.String,System.Text.Encoding,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads a string of text to a file. 
            </summary>
            <param name="content">The content to be uploaded</param>
            <param name="encoding">The encoding to be used</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadFile(System.String)">
            <summary>
            Uploads a file from the file system to a blob.
            </summary>
            <param name="fileName">The file to be uploaded</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadFile(System.String,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads a file from the file system to a blob.
            </summary>
            <param name="fileName">The file to be uploaded</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadByteArray(System.Byte[])">
            <summary>
            Uploads an array of bytes to a blob.
            </summary>
            <param name="content">The array of bytes to be uploaded</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadByteArray(System.Byte[],Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads an array of bytes to a blob.
            </summary>
            <param name="content">The array of bytes to be uploaded</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.OpenRead">
            <summary>
            Gets a stream for reading the blob's contents.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.OpenRead(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Gets a stream for reading the blob's contents.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadToStream(System.IO.Stream)">
            <summary>
            Downloads the blob contents to a stream.
            </summary>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadToStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Downloads the blob contents to a stream.
            </summary>
            <param name="target">The target stream.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginDownloadToStream(System.IO.Stream,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to download the blob's contents to a stream.
            </summary>
            <param name="target">The target stream.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginDownloadToStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to download the blob's contents to a stream.
            </summary>
            <param name="target">The target stream.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndDownloadToStream(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to download the blob's contents to a stream.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadText">
            <summary>
            Downloads the blob contents as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadText(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Downloads the blob contents as a string.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.GetDefaultEncoding">
            <summary>
            Gets the default encoding for the blob, which is UTF-8.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadToFile(System.String)">
            <summary>
            Downloads the blob contents to a file.
            </summary>
            <param name="fileName">Name of the file.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadToFile(System.String,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Downloads the blob contents to a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadByteArray">
            <summary>
            Downloads the blob contents as an array of bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.DownloadByteArray(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Downloads the blob contents as an array of bytes. 
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.CreateSnapshot">
            <summary>
            Creates a snapshot of this blob.
            </summary>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object representing the snapshot.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.CreateSnapshot(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Creates a snapshot of this blob.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object representing the snapshot.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginCreateSnapshot(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a snapshot of this blob.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.BeginCreateSnapshot(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a snapshot of this blob.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>        
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.EndCreateSnapshot(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create a snapshot of this blob.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object representing the snapshot</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.GetSharedAccessSignature(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy)">
            <summary>
            Constructs the signature string for creating a Shared Access Signature for this blob.
            </summary>
            <param name="policy">Describe the shared access permission details</param>
            <returns>Query parameter string representing the signature</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.GetSharedAccessSignature(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy,System.String)">
            <summary>
            Constructs the signature string for creating a Shared Access Signature for this blob.
            </summary>
            <param name="policy">A policy describing container-level permissions.</param>
            <param name="groupPolicyIdentifier">The identifier for a container-level access policy associated with this signature.</param>
            <returns>Query parameter string representing the signature</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the current credentials don't support signing</exception>
            <exception cref="T:System.NotSupportedException">Thrown if blob is a snapshot</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.GetCanonicalName">
            <summary>
            Used by both Shared Access and Copy blob operation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadUnknownSizeStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.Int64)">
            <summary>
            Uploads a stream that doesn't have a known length. In this case we can't do any optimizations like creating a request before we read all of the data.
            </summary>
            <param name="source">The stream that is the source of data (unknown length)</param>
            <param name="options">The options to control the upload behavior</param>
            <param name="blockSize">The block size to be used (null - no blocks)</param>
            <returns>A sequence that represents uploading the blob</returns>
            <remarks>This is implemented by creating a BlobStream and using that to buffer data until we have sufficient amount to be sent</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.UploadData(System.Net.HttpWebRequest,System.IO.Stream,System.Action{System.Net.WebResponse})">
            <summary>
            Uploads the data into the web request.
            </summary>
            <param name="request">The request that is setup for a Put</param>
            <param name="source">The source of data</param>
            <param name="result">The response from the server</param>
            <returns>The sequence used for uploading data</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.ParseBlobAddressQuery(System.String,System.String@,Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature@)">
            <summary>
            Parses the BLOB address query and returns snapshot and SAS
            </summary>
            <param name="query">The query to parse</param>
            <param name="snapshot">The snapshot value, if any.</param>
            <param name="sasCreds">The SAS credentials</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.VerifyNoWriteOperationForSnapshot">
            <summary>
            Verifies that write operation is not done for snapshot.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlob.ParseSizeAndLastModified(System.Net.HttpWebResponse)">
            <summary>
            Retreive ETag and LastModified date time from response
            </summary>
            <param name="response"></param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.SnapshotTime">
            <summary>
            Gets the DateTime value that uniquely identifies the snapshot, if this blob is a snapshot.
            </summary>
            <remarks>
            If the blob is not a snapshot, this property returns null.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.ServiceClient">
            <summary>
            Gets the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobClient"/> object that represents the Blob service.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.Uri">
            <summary>
            Gets the URI for the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.Attributes">
            <summary>
            Gets the blob's attributes.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.Metadata">
            <summary>
            Gets the blob's user-defined metadata.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.Properties">
            <summary>
            Gets the blob's properties.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.TransformedAddress">
            <summary>
            Gets the Uri after applying authentication transformation
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.Container">
            <summary>
            Gets a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> object representing the blob's container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.Parent">
            <summary>
            Gets the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> object representing the 
            virtual parent directory for the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.ToPageBlob">
            <summary>
            Gets a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> object based on this blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlob.ToBlockBlob">
            <summary>
            Gets a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> object based on this blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(Microsoft.WindowsAzure.StorageClient.BlobAttributes,Microsoft.WindowsAzure.StorageClient.CloudBlobClient,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="attributes">The attributes.</param>
            <param name="serviceClient">The service client.</param>
            <param name="snapshotTime">The snapshot time.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="blobAddress">The blob address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="blobAddress">The blob address.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="blobAddress">The blob address.</param>
            <param name="serviceClient">The service client.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="blobAddress">The blob address.</param>
            <param name="credentials">The credentials.</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="blobAddress">The blob address.</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.#ctor(Microsoft.WindowsAzure.StorageClient.CloudBlob)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> class.
            </summary>
            <param name="cloudBlob">The cloud blob.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.Create(System.Int64)">
            <summary>
            Create a PageBlob
            </summary>
            <param name="size">In bytes</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.Create(System.Int64,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Create a PageBlob
            </summary>
            <param name="size">In bytes</param>
            <param name="options">Request option</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginCreate(System.Int64,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a page blob.
            </summary>
            <param name="size">The maximum size of the page blob, in bytes.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginCreate(System.Int64,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a page blob.
            </summary>
            <param name="size">In bytes</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.EndCreate(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create a page blob .
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.WritePages(System.IO.Stream,System.Int64)">
            <summary>
            Writes page data to a page blob.
            </summary>
            <param name="pageData">The page data.</param>
            <param name="startOffset">The start offset.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.WritePages(System.IO.Stream,System.Int64,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Writes page data to a page blob.
            </summary>
            <param name="pageData">The page data.</param>
            <param name="startOffset">The start offset.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginWritePages(System.IO.Stream,System.Int64,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to write pages to a page blob.
            </summary>
            <param name="pageData">The page data.</param>
            <param name="startOffset">The start offset.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginWritePages(System.IO.Stream,System.Int64,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to write pages to a page blob.
            </summary>
            <param name="pageData">The page data.</param>
            <param name="startOffset">The start offset.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.EndWritePages(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to write pages to a page blob.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.GetPageRanges">
            <summary>
            Gets a list of valid page ranges and their starting and ending bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.GetPageRanges(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Gets a list of valid page ranges and their starting and ending bytes.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginGetPageRanges(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to return the list of valid page ranges and their starting and ending bytes.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginGetPageRanges(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to return the list of valid page ranges and their starting and ending bytes.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.EndGetPageRanges(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to return page ranges and their starting and ending bytes.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.OpenWrite">
            <summary>
            Creates a stream for writing to the blob using Stream interface with automatic buffering.
            </summary>
            <returns>The stream to be used for writing</returns>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.OpenWrite(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Creates a stream for writing to the blob using Stream interface with automatic buffering.
            </summary>
            <param name="options">The options to control the upload behavior</param>
            <returns>The stream to be used for writing</returns>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadFromStream(System.IO.Stream)">
            <summary>
            Uploads a blob from a stream.
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <remarks>This uses the currently set Properties/Metadata for the blob, so they need to be set before calling this API.</remarks>
            <remarks>For optimum performance, the stream should support a length.</remarks>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadFromStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads a blob from a stream.
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <remarks>This uses the currently set Properties/Metadata for the blob, so they need to be set before calling this API.</remarks>
            <remarks>For optimum performance, the stream should support a length.</remarks>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginUploadFromStream(System.IO.Stream,System.AsyncCallback,System.Object)">
            <summary>
            Uploads a blob from a stream asynchronously.
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>
            An IAsyncResult that represents the asynchronous UploadFromStream, which could still be pending.
            </returns>
            <remarks>This uses the currently set Properties/Metadata for the blob, so they need to be set before calling this API.</remarks>
            <remarks>For optimum performance, the stream should support a length.</remarks>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.BeginUploadFromStream(System.IO.Stream,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Uploads a blob from a stream asynchronously.
            </summary>
            <param name="source">The data stream to be uploaded</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>
            An IAsyncResult that represents the asynchronous UploadFromStream, which could still be pending.
            </returns>
            <remarks>This uses the currently set Properties/Metadata for the blob, so they need to be set before calling this API.</remarks>
            <remarks>For optimum performance, the stream should support a length.</remarks>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.EndUploadFromStream(System.IAsyncResult)">
            <summary>
            Completes the asynchronous UploadFromStream request. Throws any exceptions provided by the server
            </summary>
            <param name="asyncResult">A reference to the outstanding asynchronous request.</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadText(System.String)">
            <summary>
            A convenience function to upload a string of text to a file.
            </summary>
            <param name="content">The content to be upload</param>
            <remarks>Assumes a UTF8 encoding</remarks>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadText(System.String,System.Text.Encoding,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            A convenience function to upload a string of text to a file.
            </summary>
            <param name="content">The content to be upload</param>
            <param name="encoding">The encoding to be used</param>
            <param name="options">The options to control the upload behavior</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadFile(System.String)">
            <summary>
            A convenience function to upload a file from a file system to a blob
            </summary>
            <param name="fileName">The file to be uploaded</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadFile(System.String,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            A convenience function to upload a file from a file system to a blob
            </summary>
            <param name="fileName">The file to be uploaded</param>
            <param name="options">The options to control the upload behavior</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadByteArray(System.Byte[])">
            <summary>
            A convenience function to upload a set of bytes
            </summary>
            <param name="content">The bytes to be uploaded</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.UploadByteArray(System.Byte[],Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            A convenience function to upload a set of bytes
            </summary>
            <param name="content">The bytes to be uploaded</param>
            <param name="options">The options to control the upload behavior</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on PageBlob</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.ThisCreationMethodNotSupportedException">
            <summary>
            Thises the creation method not supported exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.CreateImpl(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.Int64)">
            <summary>
            Creates the impl.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="sizeInBytes">The size in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.GetPageRangesImpl(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.Action{System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.PageRange}})">
            <summary>
            Gets the page ranges impl.
            </summary>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <param name="setResult">The set result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudPageBlob.WritePageImpl(System.IO.Stream,System.Int64,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Writes the page impl.
            </summary>
            <param name="pageData">The page data.</param>
            <param name="startOffset">The start offset.</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob">
            <summary>
            This class represents a blob that is made out of blocks and provides APIs to directly access it.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> class.
            </summary>
            <param name="blobAbsoluteUri">The absolute URI to the blob.</param>
            <param name="credentials">Storage credentials</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> class.
            </summary>
            <param name="blobUri">Relative URI to the blob.</param>
            <param name="client">Existing Blob service client which provides the base address</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> class.
            </summary>
            <param name="blobAbsoluteUri">Absolute URI to the blob.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> class.
            </summary>
            <param name="blobAbsoluteUri">Absolute URI to the blob.</param>
            <param name="credentials">Storage credentials</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> class.
            </summary>
            <param name="blobAbsoluteUri">The blob absolute URI.</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.DownloadBlockList">
            <summary>
            Retrieves the committed blocklist for the blob.
            </summary>
            <returns>The committed blocks</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.DownloadBlockList(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Retrieves the committed blocklist for the blob.
            </summary>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <returns>The committed blocks</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.DownloadBlockList(Microsoft.WindowsAzure.StorageClient.BlockListingFilter)">
            <summary>
            Retrieves the blocklist consisting of <paramref name="blockListingFilter"/> type of blocks.
            </summary>
            <param name="blockListingFilter">The type of blocks that should be retrieved</param>
            <returns>The list of blocks for this blob of <paramref name="blockListingFilter"/> type.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.DownloadBlockList(Microsoft.WindowsAzure.StorageClient.BlockListingFilter,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Retrieves the blocklist consisting of <paramref name="blockListingFilter"/> type of blocks.
            </summary>
            <param name="blockListingFilter">The type of blocks that should be retrieved</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <returns>The list of blocks for this blob of <paramref name="blockListingFilter"/> type.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.BeginDownloadBlockList(Microsoft.WindowsAzure.StorageClient.BlockListingFilter,System.AsyncCallback,System.Object)">
            <summary>
            Retrieves the blocklist consisting of <paramref name="blockListingFilter"/> type of blocks.
            </summary>
            <param name="blockListingFilter">The type of blocks that should be retrieved</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An IAsyncResult that represents the asynchronous DownloadBlockList, which could still be pending.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.BeginDownloadBlockList(Microsoft.WindowsAzure.StorageClient.BlockListingFilter,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Retrieves the blocklist consisting of <paramref name="blockListingFilter"/> type of blocks.
            </summary>
            <param name="blockListingFilter">The type of blocks that should be retrieved</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.EndDownloadBlockList(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to download the block list.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>
            The block list for this blob.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.PutBlock(System.String,System.IO.Stream,System.String)">
            <summary>
            Uploads a single block with a given <paramref name="blockId"/>.
            </summary>
            <param name="blockId">The base64 encoded block ID to be associated with the data.</param>
            <param name="blockData">The stream containing the data for the block. (Must support Size property)</param>
            <param name="contentMD5">Optional content-MD5 header value to be used with the request. 
            Null or empty value will be ignored and no Content-MD5 header will be set</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.PutBlock(System.String,System.IO.Stream,System.String,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads a single block with a given <paramref name="blockId"/>.
            </summary>
            <param name="blockId">The base64 encoded block ID to be associated with the data.</param>
            <param name="blockData">The stream containing the data for the block. (Must support Size property)</param>
            <param name="contentMD5">Optional content-MD5 header value to be used with the request. 
            Null or empty value will be ignored and no Content-MD5 header will be set</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.BeginPutBlock(System.String,System.IO.Stream,System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an operation to upload a single block with a given <paramref name="blockId"/>.
            </summary>
            <param name="blockId">The base64 encoded block ID to be associated with the data.</param>
            <param name="blockData">The stream containing the data for the block. (Must support Size property)</param>
            <param name="contentMD5">Optional content-MD5 header value to be used with the request. 
            Null or empty value will be ignored and no Content-MD5 header will be set</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.BeginPutBlock(System.String,System.IO.Stream,System.String,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an operation to upload a single block with a given <paramref name="blockId"/>.
            </summary>
            <param name="blockId">The base64 encoded block ID to be associated with the data.</param>
            <param name="blockData">The stream containing the data for the block. (Must support Size property)</param>
            <param name="contentMD5">Optional content-MD5 header value to be used with the request.
            Null or empty value will be ignored and no Content-MD5 header will be set</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.EndPutBlock(System.IAsyncResult)">
            <summary>
            Ends an operation to upload a single block with a given <paramref name="blockId"/>.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.PutBlockList(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Uploads the list of blocks to be committed as a blob. 
            </summary>
            <param name="blockList">The list of block IDs (base64 encoded)</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.PutBlockList(System.Collections.Generic.IEnumerable{System.String},Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Uploads the list of blocks to be committed as a blob.
            </summary>
            <param name="blockList">The list of block IDs (base64 encoded)</param>
            <param name="options">A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> object indicating any additional options to be specified on the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.BeginPutBlockList(System.Collections.Generic.IEnumerable{System.String},System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to upload a list of blocks. 
            </summary>
            <param name="blockList">The list of block IDs (base64-encoded)</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.BeginPutBlockList(System.Collections.Generic.IEnumerable{System.String},Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to upload a list of blocks.
            </summary>
            <param name="blockList">The list of block IDs (base64-encoded)</param>
            <param name="options">The options to be used for the current request to override the default behavior.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob.EndPutBlockList(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to upload a list of blocks.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ListBlockItem">
            <summary>
            Represents a block retrieved from the blob's block list.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ListBlockItem.Name">
            <summary>
            Gets the name of the block
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ListBlockItem.Size">
            <summary>
            Gets the size of block in bytes
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ListBlockItem.Committed">
            <summary>
            Type of BlockListItem returned is committed or uncommitted
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlockListingFilter">
            <summary>
            Indicates whether to list only committed blocks, only uncommitted blocks, or all blocks.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlockListingFilter.Committed">
            <summary>
            Include only the committed blocks
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlockListingFilter.Uncommitted">
            <summary>
            Include only the uncommitted blocks
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlockListingFilter.All">
            <summary>
            Include all blocks
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ParallelUpload">
            <summary>
            Class used to upload blocks for a blob in parallel
            
            The parallelism factor is configurable at the CloudBlobClient
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ParallelUpload.ParallelExecute(System.Func{Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream,System.String,System.String,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,Microsoft.WindowsAzure.StorageClient.Tasks.Task{Microsoft.WindowsAzure.StorageClient.Tasks.NullTaskReturn}})">
            <summary>
            Perform a parallel upload of blocks for a blob from a given stream
            
            The operation is done as a series of alternate producer and consumer tasks
            The producer tasks dispense out chunks of source stream as fixed size blocks
            This is done in serial order on a thread using InvokeTaskSequence's serial execution
            The consumer tasks upload each block in parallel on multiple thread
            The producer thread waits for atleast one consumer task to finish before adding more producer tasks
            
            The producer thread quits when no more data can be read from the stream and no other pending consumer
            tasks
            </summary>
            <param name="uploadFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ParallelUpload.DispenseBlockStream(System.Action{Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream,System.String})">
            <summary>
            Upload a single block. This can happen on parallel threads
            </summary>
            <param name="setResult"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ParallelUpload.CommitBlob">
            <summary>
            As a final step upload the block list to commit the blob 
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.ParallelUpload.blockList">
            <summary>
            The list of uploaded blocks
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes">
            <summary>
            Represents a set of attributes (properties and metadata) for a blob container.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes.Metadata">
            <summary>
            Gets the user-defined metadata for the container.
            </summary>
            <remarks>The value of this property is never null.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes.Properties">
            <summary>
            Gets the system properties for the container.  
            </summary>
            <remarks>The value of this property is never null.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes.Name">
            <summary>
            Gets the name of the container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes.Uri">
            <summary>
            Gets the URI of the container.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobContainerProperties">
            <summary>
            Represents the system properties for a container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerProperties.ETag">
            <summary>
            Gets the ETag of the container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerProperties.LastModifiedUtc">
            <summary>
            Gets the container's last-modified time, in UTC format.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs">
            <summary>
            The arguments for the ResponseReceived event.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.RequestId">
            <summary>
            Gets the request id.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.RequestHeaders">
            <summary>
            Gets the request headers.
            </summary>
            <remarks>Modifying the name-value collection may result in unexpected behavior.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.RequestUri">
            <summary>
            Gets the request URI.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.ResponseHeaders">
            <summary>
            Gets the response headers.
            </summary>
            <remarks>Modifying the name-value collection may result in unexpected behavior.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.StatusCode">
            <summary>
            Gets the status code.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.StatusDescription">
            <summary>
            Gets the status description.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs.Exception">
            <summary>
            Gets the exception.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.EventHelper.ProcessWebResponse(System.Net.WebRequest,System.IAsyncResult,System.EventHandler{Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs},System.Object)">
            <summary>
            This sets the event handler with request and response data
            Translate storage exceptions
            </summary>
            <param name="req"></param>
            <param name="asyncResult"></param>
            <param name="handler"></param>
            <param name="sender"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.EventHelper.OnResponseReceived(System.Net.WebRequest,System.Net.WebResponse,System.EventHandler{Microsoft.WindowsAzure.StorageClient.ResponseReceivedEventArgs},System.Object,System.Exception)">
            <summary>
            Set the event handler
            </summary>
            <param name="req"></param>
            <param name="webResponse"></param>
            <param name="eventHandler"></param>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.NavigationHelper.Slash">
            <summary>
            Used in address parsing
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.NavigationHelper.SlashAsSplitOptions">
            <summary>
            Used to split string on slash
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.NavigationHelper.DotAsSplitOptions">
            <summary>
            Used to split hostname
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetContainerName(System.Uri,System.Boolean)">
            <summary>
            Retrieves the container part of a storage Uri
            Any trailing slash is always removed
            
            Example GetContainerName(new Uri("http://test.blob.core.windows.net/mycontainer/myfolder/myblob"))
            will return mycontainer
            
            Example GetConatinerName(new Uri("http://test.blob.core.windows.net/mycontainer"))
            will return mycontainer
            
            Example GetConatinerName(new Uri("http://test.blob.core.windows.net/"))
            will throw ArgumentException
            </summary>
            <param name="blobAddress"></param>
            <param name="usePathStyleUris">True to use path style uris</param>
            <returns>Name of the container</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetContainerAddress(System.Uri,System.Boolean)">
            <summary>
            Retreives the complete container address from a storage Uri
            Example GetContainerAddress(new Uri("http://test.blob.core.windows.net/mycontainer/myfolder/myblob"))
            will return http://test.blob.core.windows.net/mycontainer
            </summary>
            <param name="blobAddress"></param>
            <param name="usePathStyleUris">True to use path style uris</param>
            <returns>Uri of the container</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetContainerNameAndAddress(System.Uri,System.Boolean,System.String@,System.Uri@)">
            <summary>
            Retrieve the container address and address
            </summary>
            <param name="blobAddress"></param>
            <param name="usePathStyleUris">True to use path style uris</param>
            <param name="containerName"></param>
            <param name="containerUri"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetParentName(System.Uri,System.String,System.Boolean)">
             <summary>
             Retreives the parent name from a storage Uri
             Adds the trailing delimiter as the prefix returned by the storage REST api always contains the delimiter
            
             Example GetParentName(new Uri("http://test.blob.core.windows.net/mycontainer/myfolder/myblob", "/"))
             will return /mycontainer/myfolder/
             
             Example GetParentName(new Uri("http://test.blob.core.windows.net/mycontainer/myfolder|myblob", "|")
             will return /mycontainer/myfolder|
             
             Example GetParentName(new Uri("http://test.blob.core.windows.net/mycontainer/myblob", "/")
             will return /mycontainer/
            
             Example GetParentName(new Uri("http://test.blob.core.windows.net/mycontainer", "/")
             will return /mycontainer/        
             </summary>
             <param name="blobAddress"></param>
             <param name="delimiter"></param>
             <param name="usePathStyleUris"></param>
             <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetParentAddress(System.Uri,System.String,System.Boolean)">
            <summary>
            Retrieves the parent address for a blob Uri
            
            Example GetParentName(new Uri("http://test.blob.core.windows.net/mycontainer/myfolder/myblob", null))
            will return http://test.blob.core.windows.net/mycontainer/myfolder/
            </summary>
            <param name="blobAddress"></param>
            <param name="delimiter"></param>
            <param name="usePathStyleUris"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetServiceClientBaseAddress(System.String,System.Nullable{System.Boolean})">
            <summary>
            Get service client address from a complete Uri
            
            Example GetServiceClientBaseAddress("http://testaccount.blob.core.windows.net/testconatiner/blob1") 
            returns "http://testaccount.blob.core.windows.net"
            </summary>
            <param name="address">Complete address of the resource</param>
            <param name="usePathStyleUris">True to use path style uris</param>
            <returns>Uri of the service client</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.AppendPathToUri(System.Uri,System.String)">
            <summary>
            Appends a path to a Uri correctly using "/" as separator
            
            AppendPathToUri(new Uri("http://test.blob.core.windows.net/test", "abc") 
            => new  Uri("http://test.blob.core.windows.net/test/abc")
            
            AppendPathToUri(new Uri("http://test.blob.core.windows.net/test"), "http://test.blob.core.windows.net/test/abc")
            => new Uri("http://test.blob.core.windows.net/test/abc")
            </summary>
            <param name="uri"></param>
            <param name="relativeOrAbslouteUri"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.AppendPathToUri(System.Uri,System.String,System.String)">
            <summary>
            Append a relative path to a URI, handling traling slashes appropiately.
            </summary>
            <param name="uri"></param>
            <param name="relativeOrAbslouteUri"></param>
            <param name="sep"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetContainerNameFromContainerAddress(System.Uri,System.Boolean)">
            <summary>
            Get container name from address for styles of paths
            Eg: http://test.blob.core.windows.net/container/blob => container
            http://127.0.0.1:10000/test/container/blob => container
            </summary>
            <param name="uri"></param>
            <param name="usePathStyleUris"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.NavigationHelper.GetQueueNameFromUri(System.Uri,System.Boolean)">
            <summary>
            Similar to getting container name from Uri
            </summary>
            <param name="uri"></param>
            <param name="usePathStyleUris"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions">
            <summary>
            The set of permissions for a container-level access policy.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions.None">
            <summary>
            No access
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions.Read">
            <summary>
            Read access
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions.Write">
            <summary>
            Write access
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions.Delete">
            <summary>
            Delete access
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions.List">
            <summary>
            List access
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy">
            <summary>
            Represents a container-level access policy which may govern one or more Shared Access Signatures.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy.PermissionsToString(Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions)">
            <summary>
            Converts the permissions specified as part of the access policy to a string.
            </summary>
            <param name="permissions">The permissions.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy.PermissionsFromString(System.String)">
            <summary>
            Constructs a <see cref="T:Microsoft.WindowsAzure.StorageClient.SharedAccessPermissions"/> object from a permissions string.
            </summary>
            <param name="value">The permissions string.</param>
            <returns>A set of permissions</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy.SharedAccessStartTime">
            <summary>
            Gets or sets the start time for a Shared Access Signature associated with this policy.
            </summary>
            <remarks>
            This value must be set either on the container-level access policy or on the Shared Access 
            Signature URL, but may not be set in both places.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy.SharedAccessExpiryTime">
            <summary>
            Gets or sets the expiry time for a Shared Access Signature associated with this policy.
            </summary>
            <remarks>
            This value must be set either on the container-level access policy or on the Shared Access 
            Signature URL, but may not be set in both places.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy.Permissions">
            <summary>
            Gets or sets the permissions for a Shared Access Signature associated with this policy.
            </summary>
            <remarks>
            This value must be set either on the container-level access policy or on the Shared Access 
            Signature URL, but may not be set in both places.
            </remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobReadStream">
            <summary>
            This class represents a seekable, read-only stream on a blob.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobStream">
            <summary>
            Represents a stream for reading and writing to a blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobStream.Abort">
            <summary>
            Aborts the operation to write to the blob. 
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobStream.BeginCommit(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to commit a blob.
            </summary>
            <param name="callback">An optional asynchronous callback, to be called when the commit is complete.</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous commit request from other requests.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that represents the asynchronous commit, which may still be pending.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobStream.EndCommit(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to commit the blob.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <exception cref="T:System.ArgumentNullException">asyncResult is null</exception>
            <remarks>Only supported if stream's property CanWrite is true</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobStream.Commit">
            <summary>
            Commits the blob.
            </summary>
            <remarks>Only supported if stream's property CanWrite is true</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobStream.Blob">
            <summary>
            Gets a reference to the blob on which the stream is opened.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobStream.IntegrityControlVerificationEnabled">
            <summary>
            Gets a value indicating whether the signature of each block should be verified. 
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobStream.ReadAheadSize">
            <summary>
            Gets or sets the number of bytes to read ahead. 
            </summary>
            <remarks>Only supported if stream's property CanRead is true</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobStream.BlockSize">
            <summary>
            Gets or sets the block size. (0 is no blocks)
            </summary>
            <remarks>Only supported if stream's property CanWrite is true</remarks>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadAheadThreshold">
            <summary>
            The threshold beyond which we start a new read-Ahead.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.position">
            <summary>
            The current position with the stream.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.readAheadSize">
            <summary>
            The number of bytes to read forward on every request.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.options">
            <summary>
            The options applied to the stream.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.setEtagCondition">
            <summary>
            True if the AccessCondition has been changed to match a single ETag. (Forces all download to single file.)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.blockList">
            <summary>
            The list of blocks for this blob.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.downloadedBlocksList">
            <summary>
            The already available blocks for reading. This member is the only possible point of thread contention between the user's requests and ReadAhead async work. 
            At any particular time, the ReadAhead thread may be adding more items into the list. The second thread will never remove/modify an existing item within the list.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.readAheadResult">
            <summary>
            A handle to the parallel download of data for ReadAhead.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.#ctor(Microsoft.WindowsAzure.StorageClient.CloudBlob,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.Int64,System.Boolean)">
            <summary>
            Initializes a new instance of the BlobReadStream class. 
            The constructor is internal to be created by BlobService only.
            </summary>
            <param name="blob">The blob used for downloads</param>
            <param name="options">Modifiers to be applied to the blob. After first request, the ETag is always applied</param>
            <param name="readAheadInBytes">The number of bytes to read ahead</param>
            <param name="verifyBlocks">Controls whether block's signatures are verified</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.SetLength(System.Int64)">
            <summary>
            Setting the length of the blob is not supported
            </summary>
            <param name="value">The desired length</param>
            <exception cref="T:System.NotSupportedException">Always thrown</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write is not supported
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.Flush">
            <summary>
            Flush is not supported on read-only stream
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeks to the desired position. Any seek outside of the buffered/read-ahead data will cancel read-ahead and clear the buffered data.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type System.IO.SeekOrigin indicating the reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
            <exception cref="T:System.ArgumentException">Thrown if offset is invalid for SeekOrigin</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies the specified amount of data from internal buffers to the buffer and advances the position
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values 
                                between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns> The total number of bytes read into the buffer. This can be less than the number of bytes requested 
            if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous read operation.
            </summary>
            <param name="buffer">The buffer to read the data into.</param>
            <param name="offset">The byte offset in <paramref name="buffer"/> at which to begin writing data read from the stream.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <param name="callback">An optional asynchronous callback, to be called when the read is complete.</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that represents the asynchronous read, which could still be pending.
            </returns>
            <exception cref="T:System.IO.IOException">
            Attempted an asynchronous read past the end of the stream, or a disk error occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            One or more of the arguments is invalid.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The current Stream implementation does not support the read operation.
            </exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.EndRead(System.IAsyncResult)">
            <summary>
            Ends an asynchronous read operation.
            </summary>
            <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
            <returns>
            The number of bytes read from the stream, between zero (0) and the number of bytes you requested. 
            Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="asyncResult"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="asyncResult"/> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/> method on the current stream.
            </exception>
            <exception cref="T:System.IO.IOException">
            The stream is closed or an internal error has occurred.
            </exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadImplWrapper(System.Byte[],System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Wraps the Read operation to remap any exceptions into IOException.
            </summary>
            <param name="buffer">The buffer to read the data into.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <param name="setResult">The action to be done upon completion to return the number of bytes read</param>
            <returns>A task sequence representing the operation</returns>
            <exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadImpl(System.Byte[],System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Performs the Read:
            * If verification is on, retrieve the blocklist
            * If there are downloaded blocks, read from there
            * Otherwise, if there's an outstanding request, wait for completion and read from there
            * Otherwise perform a new request
            </summary>
            <param name="buffer">The buffer to read the data into.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <param name="setResult">The action to be done upon completion to return the number of bytes read</param>
            <returns>A task sequence representing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.LockToEtag">
            <summary>
            Locks download to a specific ETag.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadAheadImpl(System.Int64,System.Int64)">
            <summary>
            Reads the data from the service starting at the specified location. Verifies the block's signature (if required) and adds it to the buffered data.
            </summary>
            <param name="startPosition">The starting position of the read-ahead</param>
            <param name="length">The number of bytes to read ahead</param>
            <returns> An TaskSequence that represents the asynchronous read action. </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.EndReadAhead(System.IAsyncResult)">
            <summary>
            Ends an asynchronous read-ahead operation.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <exception cref="T:System.ArgumentNullException">asyncResult is null</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.RetrieveSize">
            <summary>
            Retrieves the size of the blob.
            </summary>
            <remarks>If verification is on, it will retrieve the blocklist as well</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.VerifyBlocks">
            <summary>
            Verifies if the blocks are in expected format. Disables the integrity control if they are not appropriate for validation
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CalculateReadAheadBounds(System.Int64,System.Int64,System.Int32,System.Int64@,System.Int64@)">
            <summary>
            Calculates the ReadAhead bounds (start and count) as required by the existing data.
            </summary>
            <param name="gapStart">The desired start position.</param>
            <param name="gapEnd">The end of the existing gap</param>
            <param name="count">The desired number of bytes.</param>
            <param name="startReadAhead">The start position rounded down to the nearest block start.</param>
            <param name="readAheadCount">The number of bytes with readAheadSize included and rounded up to the end of the nearest block.</param>
            <remarks>This calculates the bounds based on the blocklist, not any existing data.</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadBufferedData(System.Byte[],System.Int32@,System.Int32@)">
            <summary>
            Reads from the verified blocks as much data as is available and needed.
            </summary>
            <param name="buffer">The buffer to read the data into.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>True if there was any data read</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CalculateIfBufferTooLow(System.Int64)">
            <summary>
            Calculates if the currently held data is less than <paramref name="ReadAheadThreshold"/> percentage depleted
            </summary>
            <param name="gapStart">The start position for any ReadAhead based on the last block</param>
            <returns>True if more data is needed</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CheckBounds(System.Int64)">
            <summary>
            Verifies if the given offset is within the bounds of the stream. 
            </summary>
            <param name="offset">The offset to be checked</param>
            <remarks>This may do a server round-trip if the length is not known</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CanRead">
            <summary>
            The stream is always readable
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CanSeek">
            <summary>
            The stream is seekable
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CanWrite">
            <summary>
            The seem is read-only
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.CanTimeout">
            <summary>
            The operations on the stream can timeout during network access
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadTimeout">
            <summary>
            Gets or sets a value, in miliseconds, that determines how long the stream will attempt to read before timing out.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.Length">
            <summary>
            Gets the length of the blob. 
            </summary>
            <remarks>May need to do a roundtrip to retrieve it.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.Position">
            <summary>
            Gets or sets the position within the stream.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.ReadAheadSize">
            <summary>
            Gets or sets the number of bytes to read ahead. 
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.IntegrityControlVerificationEnabled">
            <summary>
            Gets a value indicating whether the signature of each downloaded block should be verified. 
            </summary>
            <remarks>This requires having a blocklist, having blockIDs to be in the appropriate format. This causes all reads to be rounded to the nearest block.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.LengthAvailable">
            <summary>
            Gets a value indicating whether length is available.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlock">
            <summary>
            Represents a single block of data that was downloaded.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlock.#ctor(System.Int64,System.IO.Stream)">
            <summary>
            Initializes the instance of the DownloadedBlock.
            </summary>
            <param name="startOffset">The offset which marks the beginning of the block.</param>
            <param name="content">A stream containing the offset.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlock.StartOffset">
            <summary>
            Gets the starting location of the block.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlock.BlockContent">
            <summary>
            Gets the content of the block.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection">
            <summary>
            Encapsulates the collection of downloaded blocks and provides appropriate locking mechanism
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.downloadedBlocksList">
            <summary>
            Holds the downloaded blocks.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.GetBlockByPosition(System.Int64)">
            <summary>
            Finds the block that contains the data for the <paramref name="desiredPosition"/>.
            </summary>
            <param name="desiredPosition">The position which is requested</param>
            <returns>A block that contains the data for the <paramref name="desiredPosition"/> or null.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.RemoveExtraBlocks(System.Int64,System.Int64)">
            <summary>
            Removes any downloaded blocks that are outside the current bounds (position and readAheadSize).
            </summary>
            <param name="position">The position before which all blocks should be purged.</param>
            <param name="bufferedLength">Size of the read-ahead beyond position for blocks to be kept.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.CalculateGapLength(System.Int64,System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Calculates the length of the gap relative to <paramref name="position"/>.
            </summary>
            <param name="position">The position from which to find the gap.</param>
            <param name="desiredLength">Size of the desired.</param>
            <param name="gapStart">The gap start.</param>
            <param name="gapEnd">The gap end.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.Any">
            <summary>
            Tells if there are any blocks available
            </summary>
            <returns>true if there are any blocks</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.Add(Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlock)">
            <summary>
            Adds the specified downloaded block.
            </summary>
            <param name="downloadedBlock">The downloaded block.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobReadStream.DownloadedBlockCollection.Remove(System.Int64)">
            <summary>
            Removes the specified block based on the startOffset key.
            </summary>
            <param name="key">The key for the block (startOffset)</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobWriteStream">
            <summary>
            The class is an append-only stream for writing into storage.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.canWrite">
            <summary>
            The stream is writable until committed/close
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.position">
            <summary>
            The current position within the blob
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.blockSize">
            <summary>
            The size of the blocks to use. (null is non-block based upload)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.blockList">
            <summary>
            The list of uploaded blocks
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.blockBuffer">
            <summary>
            A memory stream holding the current block information.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.blockHash">
            <summary>
            The hash of the current block
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.blobHash">
            <summary>
            The ongoing blob hash
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.currentModifier">
            <summary>
            The set of options applying to the current blob
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.#ctor(Microsoft.WindowsAzure.StorageClient.CloudBlockBlob,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.Int64)">
            <summary>
            Initializes a new instance of the BlobWriteStream class. 
            The constructor is internal to be created by BlobService
            </summary>
            <param name="blob">The blob used for uploads</param>
            <param name="options">The options used for the stream</param>
            <param name="blockSize">The size of the blocks to use. null if no blocks should be used</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            The stream does not support reading
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values 
                                between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns> The total number of bytes read into the buffer. This can be less than the number of bytes requested 
            if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.NotSupportedException">Not supported operation as this is a write-only stream</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support seeking
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type System.IO.SeekOrigin indicating the reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
            <exception cref="T:System.NotSupportedException">Not supported operation as this is a write-only stream</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.SetLength(System.Int64)">
            <summary>
            The stream does not support setting of length. (No PageBlob support)
            </summary>
            <param name="value">The desired length of the current stream in bytes</param>
            <exception cref="T:System.NotSupportedException">Growing a stream is not possible without writing</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write the provided data into the underlying stream.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if blob is already committed/closed</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.WriteByte(System.Byte)">
            <summary>
            Copies a single byte into the stream
            </summary>
            <param name="value">The byte of data to be written</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous write operation.
            </summary>
            <param name="buffer">The buffer to write data from.</param>
            <param name="offset">The byte offset in buffer from which to begin writing.</param>
            <param name="count">The  number of bytes to write.</param>
            <param name="callback">An optional asynchronous callback, to be called when the write is complete.</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
            <returns>An IAsyncResult that represents the asynchronous write, which could still be pending.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if blob is already committed/closed</exception>
            <remarks>The operation will be completed synchronously if the buffer is not filled</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.EndWrite(System.IAsyncResult)">
            <summary>B
            Ends an asynchronous write operation.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <exception cref="T:System.ArgumentNullException">asyncResult is null</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Flush">
            <summary>
            Causes any buffered data to be written to the remote storage. If the blob is not using blocks, the blob is fully committed
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs while writing to storage</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Abort">
            <summary>
            Aborts the upload of the blob. 
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.BeginCommit(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to commit the blob.
            </summary>
            <param name="callback">An optional asynchronous callback, to be called when the commit is complete.</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous commit request from other requests.</param>
            <returns>An IAsyncResult that represents the asynchronous commit, which could still be pending.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.EndCommit(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to commit the blob.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <exception cref="T:System.ArgumentNullException">asyncResult is null</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Commit">
            <summary>
            Commits the blob on the server
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Dispose(System.Boolean)">
            <summary>
            Implements the disposing logic of committing the blob
            </summary>
            <param name="disposing">True to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.GetBlockID">
            <summary>
            Creates a blockID using the block's hash and a prefix
            </summary>
            <returns>The base64 encoded blockID</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.WriteBlockBlobImpl(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Implements the block writing task
            </summary>
            <param name="buffer">The buffer to write data from.</param>
            <param name="offset">The byte offset in buffer from which to begin writing.</param>
            <param name="count">The  number of bytes to write.</param>
            <returns>The sequence representing the uploading of the blocks</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.WriteNonBlockedBlobImpl(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a task that writes data for a full blob.
            </summary>
            <param name="buffer">The buffer to write data from.</param>
            <param name="offset">The byte offset in buffer from which to begin writing.</param>
            <param name="count">The  number of bytes to write.</param>
            <returns>The (synchronous) sequence that copies the data into a buffer</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the buffer is larger than maximum blob size</exception>
            <remarks>Since a non-block based blob is always fully buffered before upload, this task is a synchronous copy</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.FlushInternal">
            <summary>
            Implements the flushing sequence
            </summary>
            <returns>The sequence of events for a flush</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CommitImpl">
            <summary>
            Commits the blob by uploading any remaining data and the blocklist asynchronously. 
            </summary>
            <returns>A sequence of events required for commit (last block upload + commit)</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.UploadBlob">
            <summary>
            Implements a sequence of events to upload a full blob.
            </summary>
            <returns>The sequence of events required to upload the blob</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.SetBlobMD5">
            <summary>
            Sets the MD5 of the blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.UploadBlock">
            <summary>
            Implements a sequence to upload a block
            </summary>
            <returns>The sequence of events for upload</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CheckWriteState">
            <summary>
            Verifies that the blob is in writable state
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if stream is non-writable</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.ResetBlock">
            <summary>
            Resets the block and the block hash
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CreateNewBlock">
            <summary>
            Creates the new block and the block hash 
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CanRead">
            <summary>
            The stream is write-only
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CanSeek">
            <summary>
            The stream is write-only.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CanWrite">
            <summary>
            Gets the current state of the stream. True until the stream is committed or aborted.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.CanTimeout">
            <summary>
            The stream does underlying connections, so may timeout on some operations
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.WriteTimeout">
            <summary>
            Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Length">
            <summary>
            Gets the current length (equal to the position)
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.Position">
            <summary>
            Gets or sets the current position
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.BlockSize">
            <summary>
            Gets or sets the block size. (0 is no blocks)
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobWriteStream.UseBlocks">
            <summary>
            Gets a value indicating whether the upload is done in blocks
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.LeaseStatus">
            <summary>
            The lease status of the blob
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.LeaseStatus.Unspecified">
            <summary>
            The lease status is not specified.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.LeaseStatus.Locked">
            <summary>
            The blob is locked for exclusive-write access.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.LeaseStatus.Unlocked">
            <summary>
            The blob is not locked for exclusive-write access.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobType">
            <summary>
            The type of a blob
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobType.Unspecified">
            <summary>
            Not specified
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobType.PageBlob">
            <summary>
            A page blob
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobType.BlockBlob">
            <summary>
            A block blob
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobAttributes">
            <summary>
            Represents a set of attributes (properties and metadata) for a blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobAttributes.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobAttributes"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobAttributes.#ctor(Microsoft.WindowsAzure.StorageClient.BlobAttributes)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobAttributes"/> class.
            </summary>
            <param name="other">The blob attributes to clone</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobAttributes.Properties">
            <summary>
            Gets the system properties for the blob.
            </summary>
            <remarks>The value of this property is never null.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobAttributes.Metadata">
            <summary>
            Gets the user-defined metadata for the blob.
            </summary>
            <remarks>The value of this property is never null.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobAttributes.Uri">
            <summary>
            Gets the URI of the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobAttributes.Snapshot">
            <summary>
            Gets the date and time the snapshot was taken.
            </summary>
            <remarks>
            If the blob is not a snapshot, the value of this property is null.
            </remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobProperties">
            <summary>
            Represents the system properties for the blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobProperties"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobProperties.#ctor(Microsoft.WindowsAzure.StorageClient.BlobProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobProperties"/> class based on an existing instance.
            </summary>
            <param name="other">The instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobProperties"/> class to clone.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.CacheControl">
            <summary>
            Gets or sets the cache-control header for the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.ContentEncoding">
            <summary>
            Gets or sets the content-encoding header for the blob.
            </summary>
            <remarks>
            If this property has not been set for the blob, it returns null. 
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.ContentLanguage">
            <summary>
            Gets or sets the content-language header for the blob.
            </summary>
            <remarks>
            If this property has not been set for the blob, it returns null. 
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.Length">
            <summary>
            Gets the size of the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.ContentMD5">
            <summary>
            Gets or sets the content-MD5 header for the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.ContentType">
            <summary>
            Gets or sets the content-type header for the blob.
            </summary>
            <remarks>
            If this property has not been set for the blob, it returns null. 
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.ETag">
            <summary>
            Gets the blob's ETag. 
            </summary>
            <remarks>
            The ETag is an identifier assigned to the blob by the Blob service. It is updated
            on write operations to the blob. It may be used in conditional operations employing
            If-Match or If-None-Match conditions to determine whether the operation should be performed. 
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.LastModifiedUtc">
            <summary>
            Gets the the last-modified time for the blob, in UTC format.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.BlobType">
            <summary>
            Gets the type of the blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobProperties.LeaseStatus">
            <summary>
            Gets the blob's lease status.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory">
            <summary>
            Represents a virtual collection of blobs with a given prefix.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Create a CloudBlobDirectory at a give relative uri
            If the address does not end in a trailing delimiter, then we will add it always
            </summary>
            <param name="address"></param>
            <param name="service"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.GetBlobReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object representing a blob in this directory with the specified name.
            </summary>
            <param name="itemName">The name of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.GetPageBlobReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> representing a blob in this directory with the specified name.
            </summary>
            <param name="itemName">The name of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.GetBlockBlobReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> representing a blob in this directory with the specified name.
            </summary>
            <param name="itemName">The name of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.GetSubdirectory(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> representing a subdirectory with the specified name.
            </summary>
            <param name="itemName">The name of the subdirectory.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> object representing the subdirectory.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.ListBlobs(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Returns the list of blobs and subdirectories in this directory.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making requests.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all the blobs in the container.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.ListBlobs">
            <summary>
            Returns the list of blobs and subdirectories in this directory.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all the blobs in the container.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.ListBlobsSegmented(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Returns a list of all the blobs in the container in sets of pages.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making requests.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.ListBlobsSegmented(System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Returns a list of all the blobs in the container in sets of pages.
            </summary>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> HasNext and GetNext members to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making requests.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.BeginListBlobsSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of blobs and subdirectories contained in the directory.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.BeginListBlobsSegmented(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list the first segment of blobs in the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.BeginListBlobsSegmented(System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list the first segment of blobs in the container using paging.
            </summary>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.EndListBlobsSegmented(System.IAsyncResult)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> containing the first segment of blobs and directories in the directory.
            </summary>
            <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of blobs.</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.ServiceClient">
            <summary>
            Gets the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobClient"/> object for this directory.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.Uri">
            <summary>
            Gets the <see cref="P:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.Uri"/> of this directory.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.Prefix">
            <summary>
            Used when querying for blobs
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.Container">
            <summary>
            Gets the container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory.Parent">
            <summary>
            Gets the parent directory.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudBlobClient">
            <summary>
            Represents a client for accessing the Windows Azure blob service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.#ctor(System.String)">
            <summary>
            Creates a Blob service client for public access.
            </summary>
            <param name="baseAddress">Complete Uri</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Creates a Blob service client for the given credentials and URI string.
            </summary>
            <param name="baseAddress">The base Blob service address.</param>
            <param name="credentials">Access credentials</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.#ctor(System.Uri,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Creates a Blob service client for the given credentials and URI.
            </summary>
            <param name="baseUri">The base Blob service URI.</param>
            <param name="credentials">Access credentials</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.#ctor(System.Nullable{System.Boolean},System.Uri,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Internal constructor called by all public constructors
            </summary>
            <param name="usePathStyleUris">True to use path style uris</param>
            <param name="baseUri"></param>
            <param name="credentials"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetPageBlob(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> for a blob with the specified address.
            </summary>
            <param name="blobAddress">The address of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetPageBlobReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> for a blob with the specified address.
            </summary>
            <param name="blobAddress">The address of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudPageBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetBlockBlob(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> for a blob with the specified address.
            </summary>
            <param name="blobAddress">The address of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetBlockBlobReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> for a blob with the specified address.
            </summary>
            <param name="blobAddress">The address of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlockBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetBlobReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> for a blob with the specified address.
            </summary>
            <param name="blobAddress">The address of the blob.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> object representing the blob.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetContainerReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> for a container with the specified address.
            </summary>
            <param name="containerAddress">The address of the container.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> object representing the container.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.GetBlobDirectoryReference(System.String)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> for a directory with the specified address.
            </summary>
            <param name="blobDirectoryAddress">The address of the directory.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> object representing the directory.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListContainers">
            <summary>
            Lists all of the containers in the storage account.
            </summary>
            <returns>A list of containers</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListContainers(System.String)">
            <summary>
            Lists the containers whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match.</param>
            <returns>A list of containers.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListContainers(System.String,Microsoft.WindowsAzure.StorageClient.ContainerListingDetails)">
            <summary>
            Lists the containers whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <returns>A list of containers</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListContainersSegmented">
            <summary>
            Lists all of the containers in the storage account.
            </summary>
            <returns>A result segment of containers.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListContainersSegmented(System.String)">
            <summary>
            Lists the containers whose names begin with the specified prefix in sets of pages.
            </summary>
            <param name="prefix">The prefix to match.</param>
            <returns>A result segment of containers.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListContainersSegmented(System.String,Microsoft.WindowsAzure.StorageClient.ContainerListingDetails,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Lists the containers whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>A result segment of containers.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BeginListContainersSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list containers.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BeginListContainersSegmented(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list containers with a matching prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BeginListContainersSegmented(System.String,Microsoft.WindowsAzure.StorageClient.ContainerListingDetails,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list containers with a matching prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BeginListContainersSegmented(System.String,Microsoft.WindowsAzure.StorageClient.ContainerListingDetails,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list containers with a matching prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.EndListContainersSegmented(System.IAsyncResult)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> containing all or part of the list of containers.
            </summary>
            <param name="asyncResult">A reference to the pending asynchronous request.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListBlobsWithPrefix(System.String)">
            <summary>
            List the blobs whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match.</param>
            <returns>The list of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListBlobsWithPrefixSegmented(System.String)">
            <summary>
            Begins an asynchronous request to list blobs whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The blob prefix to list.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains all or part of the set of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ListBlobsWithPrefixSegmented(System.String,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Begins an asynchronous request to list blobs whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The blob prefix to list.</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>         
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param> 
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains all or part of the set of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BeginListBlobsWithPrefixSegmented(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list blobs whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The blob prefix to list.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BeginListBlobsWithPrefixSegmented(System.String,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list blobs whose names begin with the specified prefix.
            </summary>
            <param name="prefix">The blob prefix to list.</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>         
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param> 
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.EndListBlobsWithPrefixSegmented(System.IAsyncResult)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> containing all or part of the set of blobs whose names begin with the specified prefix.
            </summary>
            <param name="asyncResult">A reference to the pending asynchronous request.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains all or part of the set of blobs.</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.Credentials">
            <summary>
            Gets the credentials used by the Blob service client.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.BaseUri">
            <summary>
            Gets the base URI for the Blob service client.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.RetryPolicy">
            <summary>
            Gets or sets the retry policy for all requests by the Blob service client.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.Timeout">
            <summary>
            Gets or sets the timeout for all requests by the Blob service client.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.DefaultDelimiter">
            <summary>
            Gets or sets the default delimiter for blobs for the Blob service client.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.WriteBlockSizeInBytes">
            <summary>
            Gets or sets the size of the blocks to be written to a block blob.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ReadAheadInBytes">
            <summary>
            Gets or sets the amount of data to pre-fetch while reading a stream.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.UseIntegrityControlForStreamReading">
            <summary>
            Indicates whether the integrity of each block should be verified when reading from a stream. 
            </summary>
            <remarks>Setting this property causes all downloads to be rounded to the nearest block size.</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ParallelOperationThreadCount">
            <summary>
            Gets or sets a positive number representing the parallelism factor in certain 
            Blob service operations.
            </summary>
        </member>
        <member name="E:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.ResponseReceived">
            <summary>
            Occurs when a response is received from the server.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.UsePathStyleUris">
            <summary>
            Reflects whether the service client is used with Path style or Host style
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions">
            <summary>
            Represents a set of behavior options for a specific request
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.#ctor(Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> class from the blob service defaults.
            </summary>
            <param name="service">The Blob service client.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.#ctor">
            <summary>
            Initializes a default instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.#ctor(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> class based on the parameters of an 
            existing instance.
            </summary>
            <param name="other">The instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> class to clone.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.RetryPolicy">
            <summary>
            Gets or sets the retry policy.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.Timeout">
            <summary>
            Gets or sets the timeout for the request.
            </summary>
            <remarks>
            For more information about setting server timeouts, see 
            <a href="http://msdn.microsoft.com/en-us/library/dd179431.aspx">Setting Server Timeouts for Blob Service Operations</a>.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.AccessCondition">
            <summary>
            Gets or sets the access condition for the request.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.CopySourceAccessCondition">
            <summary>
            Gets or sets the access condition on the source blob, for the Copy Blob operation.
            </summary>
            <remarks>
            This property is applicable only for a Copy Blob operation.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.DeleteSnapshotsOption">
            <summary>
            Gets or sets options for deleting snapshots during the Delete Blob operation.
            </summary>
            <remarks>
            This property is applicable only for a Delete Blob operation.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.BlobListingDetails">
            <summary>
            Gets or sets a <see cref="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.BlobListingDetails"/> object that indicates which blob details are
            listed by a List Blobs operation.
            </summary>
            <remarks>
            This property is applicable only for a List Blobs operation.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions.UseFlatBlobListing">
            <summary>
            Gets or sets a value indicating whether to blob listing operation will list <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> and <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> 
            or expand all <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/> into the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlob"/> contained in them.
            </summary>
            <value><c>true</c> if only a flat listing is desired; <c>false</c> if listing should include <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobDirectory"/>.</value>
            <remarks>
            This property is applicable only for a List Blobs operation.
            </remarks>
            <remarks>if the containers contain the following blob items ("mycontainer/foo/a", "mycontainer/foo/b/c", "mycontainer/foo/b/d", "mycontainer/bar"), 
            then listing blobs under "mycontainer/foo/" will result in {blob "mycontainer/foo/a", blobdirectory "mycontainer/foo/b/"} if this flag is set to false and 
            <seealso cref="P:Microsoft.WindowsAzure.StorageClient.CloudBlobClient.DefaultDelimiter"/>
            and {"mycontainer/foo/a", "mycontainer/foo/b/c", "mycontainer/foo/b/d"} if the flag is set to true.</remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.DeleteSnapshotsOption">
            <summary>
            The set of options describing delete operation
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.DeleteSnapshotsOption.None">
            <summary>
            Don't delete snapshots
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.DeleteSnapshotsOption.IncludeSnapshots">
            <summary>
            Delete the blob and its snapshots
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.DeleteSnapshotsOption.DeleteSnapshotsOnly">
            <summary>
            Delete the blob's snapshots only
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobListingDetails">
            <summary>
            Specifies which details to include when listing the blobs in this container.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobListingDetails.None">
            <summary>
            No additional details
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobListingDetails.Snapshots">
            <summary>
            Include snapshots
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobListingDetails.Metadata">
            <summary>
            Include blob metadata
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobListingDetails.UncommittedBlobs">
            <summary>
            Include uncommitted blobs
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobListingDetails.All">
            <summary>
            Include all available details
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ContainerListingDetails">
            <summary>
            Specifies which details to include when listing the containers in this storage account.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.ContainerListingDetails.None">
            <summary>
            No additional details
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.ContainerListingDetails.Metadata">
            <summary>
            Include container metadata
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.ContainerListingDetails.All">
            <summary>
            Include all available details
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer">
            <summary>
            Represents a container in Windows Azure blob storage.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetBlobReference(System.String)">
            <summary>
            Gets the specified blob.
            </summary>
            <param name="blobAddressUri">URI of the blob relative to the container</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetPageBlobReference(System.String)">
            <summary>
            Gets the specified page blob.
            </summary>
            <param name="blobAddressUri">URI of the blob relative to the container</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetBlockBlobReference(System.String)">
            <summary>
            Gets the specified block blob.
            </summary>
            <param name="blobAddressUri">URI of the blob relative to the container</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetDirectoryReference(System.String)">
            <summary>
            Gets the specified virtual blob directory
            </summary>
            <param name="relativeAddress">Relative address of the blob virtual directory</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> class.
            </summary>
            <param name="containerAddress">The container address.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(System.String,System.Boolean)">
            <summary>
            Create a containerInfo from a given complete Uri
            Explicity specify whether to use host style or path style uri               
            </summary>
            <param name="containerAddress"></param>
            <param name="usePathStyleUris">True to use path style uris</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> class.
            </summary>
            <param name="containerAddress">The container address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Create a containerInfo from the given complete Uri and credentials
            </summary>
            <param name="containerAddress"></param>
            <param name="credentials"></param>
            <param name="usePathStyleUris"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> class.
            </summary>
            <param name="containerAddress">The container address as a relative URI.</param>
            <param name="service">The Blob service client.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(Microsoft.WindowsAzure.StorageClient.BlobContainerAttributes,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer"/> class.
            </summary>
            <param name="attrib">The attributes for the container (NOTE: Stored by reference).</param>
            <param name="client">The client to be used.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.#ctor(System.Nullable{System.Boolean},System.String)">
            <summary>
            Internal implementation of uri based constructors       
            </summary>
            <param name="usePathStyleUris">True to use path style uris</param>
            <param name="containerAddress"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.ParseQueryAndVerify(System.Uri,Microsoft.WindowsAzure.StorageClient.CloudBlobClient,System.Nullable{System.Boolean})">
            <summary>
            Parse Uri for SAS (Shared access signature) information. Validate that no other query parameters are passed in.
            Any SAS information will be recorded as corresponding credentials instance.
            If existingClient is passed in, any SAS information found will not be supported
            Otherwise a new client is created based on SAS information or as anonymous credentials
            </summary>
            <param name="completeUri"></param>
            <param name="existingClient"></param>
            <param name="usePathStyleUris"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.ListBlobs">
            <summary>
            Returns a list of all the blobs in the container.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all the blobs in the container.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.ListBlobs(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Returns a list of all the blobs in the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making requests.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all the blobs in the container.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.ListBlobsSegmented(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Returns a list of all the blobs in the container in sets of pages.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making requests.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.ListBlobsSegmented(System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Returns a list of all the blobs in the container in sets of pages.
            </summary>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making requests.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginListBlobsSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list the first segment of blobs in the container.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginListBlobsSegmented(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list the first segment of blobs in the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginListBlobsSegmented(System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to list the first segment of blobs in the container using paging.
            </summary>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndListBlobsSegmented(System.IAsyncResult)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> containing the first segment of blobs in the container.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of blobs.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Create">
            <summary>
            Creates the container.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Create(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Creates the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginCreate(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a container.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginCreate(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndCreate(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create a container.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.CreateIfNotExist">
            <summary>
            Creates the container if it does not already exist.
            </summary>
            <returns>true if the container did not already exist and was created; otherwise false</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.CreateIfNotExist(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Creates the container if it does not already exist.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <returns>true if the container did not already exist and was created; otherwise false</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginCreateIfNotExist(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to create the container if it does not already exist.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginCreateIfNotExist(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to create the container if it does not already exist.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndCreateIfNotExist(System.IAsyncResult)">
            <summary>
            Returns the result of the asynchronous request to create the container if it does not already exist.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>true if the container did not already exist and was created; otherwise false</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Delete">
            <summary>
            Deletes the container.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Delete(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Deletes the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginDelete(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete a container.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginDelete(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete a container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndDelete(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete a container.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.SetPermissions(Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions)">
            <summary>
            Sets the permissions for the container.
            </summary>
            <param name="permissions">The set of permissions to apply to the container</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.SetPermissions(Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Sets the permissions for the container.
            </summary>
            <param name="permissions">The set of permissions to apply to the container</param>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginSetPermissions(Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to set the permissions of the container.
            </summary>
            <param name="permissions">The set of permissions to apply to the container</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginSetPermissions(Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions,Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to set the permissions of the container.
            </summary>
            <param name="permissions">The set of permissions to apply to the container</param>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndSetPermissions(System.IAsyncResult)">
            <summary>
            Returns the result of the asynchronous request to set the permissions of the container.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetPermissions">
            <summary>
            Gets the permissions on the container.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetPermissions(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Gets the permissions on the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginGetPermissions(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to get the permissions on the container.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginGetPermissions(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request to get the permissions on the container.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndGetPermissions(System.IAsyncResult)">
            <summary>
            Returns the asynchronous result of the request to get the permissions on the container.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions"/> object containing the permissions on the container.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.FetchAttributes">
            <summary>
            Retrieves container metadata and properties.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.FetchAttributes(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Retrieves container metadata and properties.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginFetchAttributes(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation retrieve container metadata and properties.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginFetchAttributes(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation retrieve container metadata and properties.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndFetchAttributes(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation retrieve container metadata and properties.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.SetMetadata">
            <summary>
            Sets the container metadata.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.SetMetadata(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions)">
            <summary>
            Sets the container metadata.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginSetMetadata(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to set container metadata.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.BeginSetMetadata(Microsoft.WindowsAzure.StorageClient.BlobRequestOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to set container metadata.
            </summary>
            <param name="options">The <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobRequestOptions"/> to use when making the request.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.EndSetMetadata(System.IAsyncResult)">
            <summary>
            Ends an asynchronous request operation to set container metadata.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetSharedAccessSignature(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy)">
            <summary>
            Constructs the shared access signature.
            </summary>
            <param name="policy">The shared access policy.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetSharedAccessSignature(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy,System.String)">
            <summary>
            Constructs the shared access signature.
            </summary>
            <param name="policy">The shared access policy.</param>
            <param name="groupPolicyIdentifier">The group policy identifier.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.GetSharedAccessCanonicalName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.TransformedAddress">
            <summary>
            Uri after applying authentication transformation
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.ServiceClient">
            <summary>
            Gets the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobClient"/> for this container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Uri">
            <summary>
            Gets the <see cref="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Uri"/> of the container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Name">
            <summary>
            Gets the name of the container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Metadata">
            <summary>
            Gets a <see cref="T:System.Collections.Specialized.NameValueCollection"/> of metadata for the container.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Attributes">
            <summary>
            Gets the container's attributes.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudBlobContainer.Properties">
            <summary>
            Gets the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobContainerProperties"/> for the container.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobContainerPublicAccessType">
            <summary>
            The level of public access that is allowed on the container.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobContainerPublicAccessType.Off">
            <summary>
            No public access. Only the account owner can read resources in this container.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobContainerPublicAccessType.Container">
            <summary>
            Container-level public access. Anonymous clients can read container and blob data.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.BlobContainerPublicAccessType.Blob">
            <summary>
            Blob-level public access.  Anonymous clients can read blob data only within this container.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.SharedAccessPolicies">
            <summary>
            The set of container-level access policies for this container.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions">
            <summary>
            Represents the permissions on the container.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions.PublicAccess">
            <summary>
            Gets or sets the public access level.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.BlobContainerPermissions.SharedAccessPolicies">
            <summary>
            Gets the set of container-level access policies for the container.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream">
            <summary>
            This class provides MemoryStream-like behavior but uses a list of blocks rather than a single piece of bufferBlocks.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.DefaultBlockSize">
            <summary>
            The default block size
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.blockSize">
            <summary>
            The size of the block
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.bufferBlocks">
            <summary>
            The underlying bufferBlocks for the stream
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.length">
            <summary>
            The currently used length
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.capacity">
            <summary>
            The total capacity of the stream.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.position">
            <summary>
            The current position
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.#ctor">
            <summary>
            Initializes a new instance of the SmallBlockMemoryStream class with default 64KB block size and no reserved space
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the SmallBlockMemoryStream class with provided block size and no reserved space
            </summary>
            <param name="blockSize">The size of blocks to use</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the SmallBlockMemoryStream class
            </summary>
            <param name="blockSize">The size of blocks to use</param>
            <param name="reservedSize">The amount of memory to reserve</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="blockSize"/> is zero or negative</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies the specified amount of data from internal buffers to the buffer and advances the position
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values 
                                between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns> The total number of bytes read into the buffer. This can be less than the number of bytes requested 
            if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count</exception>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type System.IO.SeekOrigin indicating the reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="offset"/> is invalid for SeekOrigin</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the current stream. (preallocating the bufferBlocks)
            </summary>
            <param name="value">The desired length of the current stream in bytes</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="value"/> is negative</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentException">Offset subtracted from the buffer length is less than count. </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> or <paramref name="count"/> is negative</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Flush">
            <summary>
            Does not perform any operation as it's an in-memory stream.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Reserve(System.Int64)">
            <summary>
            Ensures that the amount of bufferBlocks is greater than or equal to the required size. 
            Does not trim the size.
            </summary>
            <param name="requiredSize">The size that </param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the <paramref name="requiredSize"/> is negative</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.AddBlock">
            <summary>
            Adds another block to the underlying bufferBlocks 
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies the specified amount of data from internal buffers to the buffer and advances the position
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values 
                                between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns> The total number of bytes read into the buffer. This can be less than the number of bytes requested 
            if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.WriteInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            (Requires the stream to be of sufficient size for writing)
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.AdvancePosition(System.Int32@,System.Int32@,System.Int32)">
            <summary>
            Advances the current position of the stream and adjust the offset and remainder based on the amount completed
            </summary>
            <param name="offset">The current offset in the external buffer</param>
            <param name="leftToProcess">The amount of data left to process</param>
            <param name="amountProcessed">The amount of data processed</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.GetCurrentBlock(System.Int32@,System.Byte[]@)">
            <summary>
            Calculate the block for the current position
            </summary>
            <param name="blockPosition">The position within a block</param>
            <param name="currentBlock">The block reference itself</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.CanRead">
            <summary>
            Always supports reading.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.CanSeek">
            <summary>
            Always supports seeking.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.CanWrite">
            <summary>
            Always allows writing.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Length">
            <summary>
            Returns the currently written length.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SmallBlockMemoryStream.Position">
            <summary>
            Represents the current position in the stream.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if position is outside the stream size</exception>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StreamUtilities">
            <summary>
            A class containing common functionality across the two blob streams
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StreamUtilities.CheckBufferArguments(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Verifies the parameters to a read/write operation.
            </summary>
            <param name="buffer">An array of bytes.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/>.</param>
            <param name="count">The maximum number of bytes to be access in <paramref name="buffer"/>.</param>        /// <exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StreamUtilities.ComputeHash(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Calculates an ongoing hash.
            </summary>
            <param name="input">The data to calculate the hash on</param>
            <param name="offset">The offset in the input buffer to calculate from</param>
            <param name="count">The number of bytes to use from input</param>
            <param name="hash">The hash algorithm to use</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StreamUtilities.GetHashValue(System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Retrieves the string representation of the hash. (Completes the creation of the hash)
            </summary>
            <param name="hash">The hashing object</param>
            <returns>A string that is the content of the hash</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CommonUtils">
            <summary>
            A set of common utilities for use in verfication
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.AssertNotNullOrEmpty(System.String,System.String)">
            <summary>
            Throws an exception if the string is empty or null
            </summary>
            <param name="paramName">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
            <exception cref="T:System.ArgumentException">Thrown if value is empty</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if value is null</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.AssertNotNull(System.String,System.Object)">
            <summary>
            Throw an exception if the value is null
            </summary>
            <param name="paramName">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
            <exception cref="T:System.ArgumentNullException">Thrown if value is null</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.ArgumentOutOfRange(System.String,System.Object)">
            <summary>
            Throw an exception indicating argument is out of range
            </summary>
            <param name="paramName">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.AssertInBounds``1(System.String,``0,``0,``0)">
            <summary>
            Throw an exception if the argument is out of bounds
            </summary>
            <typeparam name="T">The type of the value</typeparam>
            <param name="paramName">The name of the parameter</param>
            <param name="val">The value of the parameter</param>
            <param name="min">The minimum value for the parameter</param>
            <param name="max">The maximum value for the parameter</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.CheckStringParameter(System.String,System.Boolean,System.String,System.Int32)">
            <summary>
            Combines AssertNotNullOrEmpty and AssertInBounds for convenience
            </summary>
            <param name="paramName">The name of the parameter</param>
            <param name="canBeNullOrEmpty">Turns on or off null/empty checking</param>
            <param name="value">The value of the parameter</param>
            <param name="maxSize">The maximum size of value</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.AssertSegmentResultNotComplete``1(Microsoft.WindowsAzure.StorageClient.ResultSegment{``0})">
            <summary>
            Throws if the result segment does not have more results
            </summary>
            <typeparam name="T">The type of the batch context</typeparam>
            <param name="result">The result segment to check</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.UsePathStyleAddressing(System.Uri)">
            <summary>
            Determines if a URI requires path style addressing
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.LazyEnumerateSegmented``1(System.Func{System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{``0}},System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Tasks.ITask}},Microsoft.WindowsAzure.StorageClient.RetryPolicy)">
            <summary>
            Performs a 'magic enumerator' lazy segmented enumeration.
            </summary>
            <typeparam name="T">The type of the result</typeparam>
            <param name="impl">The task sequence generator that produces the first segment</param>
            <param name="retryPolicy">The retry policy to use</param>
            <returns>A 'magic enumerator' that makes requests when needed and chains segments accordingly</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.GetContentFromBase64String(System.String)">
            <summary>
            When calling the Get() operation on a queue, the content of messages 
            returned in the REST protocol are represented as Base64-encoded strings.
            This internal function transforms the Base64 representation into a byte array.
            </summary>
            <param name="str">The Base64-encoded string.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.ApplyRequestOptimizations(System.Net.HttpWebRequest,System.Int64)">
            <summary>
            Applies the request optimizations such as disabling buffering and 100 continue.
            </summary>
            <param name="request">The request to be modified</param>
            <param name="length">The length of the content, -1 if the content length is not setable</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CommonUtils.FindInnerDataServiceClientException(System.Exception)">
            <summary>
            Look for an inner exception of type DataServiceClientException. Different versions of Sytem.Data.Services.Client
            have different levels of wrapping of a DataServiceClientException.
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ResultContinuation">
            <summary>
            Manage continuation information for various listing operation.
            Can be serialized using XmlSerialization.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultContinuation.#ctor">
            <summary>
            Default constructor for ResultContinuation
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultContinuation.NextPartitionKey">
            <summary>
            Gets the NextPartitionKey for TableServiceEntity enumeration operations.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultContinuation.NextRowKey">
            <summary>
            Gets the NextRowKey for TableServiceEntity enumeration operations.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultContinuation.NextTableName">
            <summary>
            Gets the NextTableName for Table enumeration operations.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultContinuation.NextMarker">
            <summary>
            Gets the NextMarker for continuing results for CloudBlob and CloudBlobContainer and CloudQueue enumeration operations
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultContinuation.HasContinuation">
            <summary>
            Returns true there is continuation information present
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ResultPagination">
            <summary>
            Represents a class which manages pagination of results
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultPagination.#ctor(System.Int32)">
            <summary>
            Creates a new instance of ResultPagination instance to hold parameters for returning results as pages.
            Pass in zero if not using paging.
            </summary>
            <param name="maxResults">Number of results to be returned as a page. 
            maxResults of 0 or less means no paging.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultPagination.GetNextRequestPageSize">
            <summary>
            Gets the size for next request to pass in parameter like MaxResults.
            </summary>
            <returns>Postive value indicating size of a result page if using paging. 
            Else null is returned</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultPagination.UpdatePaginationForResult(System.Int32)">
            <summary>
            Update pagination paramters for new result set returned
            </summary>
            <param name="currentResultCount"></param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultPagination.EffectivePageSize">
            <summary>
            Gets the maxResults in use for the current Pagination instance
            Returns zero if paging is not in use
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultPagination.IsPagingEnabled">
            <summary>
            Returns true if paging is enabled with a valid postive page size. 
            An instance with a non positive page size will return false.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultPagination.IsPageCompleted">
            <summary>
            Returns true if there are no more remaining results in the current page
            Will return false if paging is not enabled
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StorageErrorCode">
            <summary>
            Error codes that can be returned by the storage service or the client library.
            These are divided into server errors and client errors depending on which side
            the error can be attributed to.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation">
            <summary>
            Represents extended error information returned by the storage service.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation.ErrorCode">
            <summary>
            Gets the error code.
            </summary>
            <value>The error code.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation.ErrorMessage">
            <summary>
            Gets the error message.
            </summary>
            <value>The error message.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation.AdditionalDetails">
            <summary>
            Gets additional error details.
            </summary>
            <value>The additional error details.</value>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StorageException">
            <summary>
            The base class for storage service exceptions
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StorageException.#ctor(Microsoft.WindowsAzure.StorageClient.StorageErrorCode,System.String,System.Net.HttpStatusCode,Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageException"/> class.
            </summary>
            <param name="errorCode">The error code.</param>
            <param name="message">The message.</param>
            <param name="statusCode">The status code.</param>
            <param name="extendedErrorInfo">The extended error info.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StorageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageException"/> class with
            serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> object that contains serialized object
            data about the exception being thrown</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> object that contains contextual information
            about the source or destionation. </param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StorageException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> object with additional exception information
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> object that holds the 
            serialized object data.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> object that contains contextual information
            about the source or destionation. </param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.StorageException.StatusCode">
            <summary>
            Gets the Http status code returned by the storage service
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.StorageException.ErrorCode">
            <summary>
            Gets the specific error code returned by the storage service
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.StorageException.ExtendedErrorInformation">
            <summary>
            Gets the extended error information returned by the storage service.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StorageServerException">
            <summary>
            Represents an exception due to a problem with a storage service server.
            </summary>
            <remarks>
            Server exceptions are those due to server-side problems.
            These may be transient and requests resulting in such exceptions
            can be retried with the same parameters.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StorageServerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageServerException"/> class with
            serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> object that contains serialized object
            data about the exception being thrown</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> object that contains contextual information
            about the source or destionation. </param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StorageClientException">
            <summary>
            Represents a storage client exception.
            </summary>
            <remarks>
            Client-side exceptions are due to incorrect parameters on the request.
            These requests should not be retried with the same parameters.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.StorageClientException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageClientException"/> class with
            serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> object that contains serialized object
            data about the exception being thrown</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> object that contains contextual information
            about the source or destionation. </param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.StorageErrorCodeStrings">
            <summary>
            Error code strings that are common to all storage services
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.BlobErrorCodeStrings">
            <summary>
            Error code strings that are specific to the Blob service
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.QueueErrorCodeStrings">
            <summary>
            Error code strings that are specific to the Queue service
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableErrorCodeStrings">
            <summary>
            Error code strings that are specific to the Table service
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.AccessCondition">
            <summary>
            Represents a set of access conditions to be used for operations against the storage services.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.AccessCondition.None">
            <summary>
            Indicates that no access condition is set.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.IfModifiedSince(System.DateTime)">
            <summary>
            Creates an access condition for the IfModifiedSince condition.
            </summary>
            <param name="lastModifiedUtc">The last-modified time, expressed as UTC time.</param>
            <returns>An <see cref="T:Microsoft.WindowsAzure.StorageClient.AccessCondition"/> object with the If-Modified-Since condition set.</returns>
            <remarks>
            Setting this access condition modifies the request to include the HTTP If-Modified-Since conditional header. 
            If this access condition is set, the operation is performed only if the resource has been modified since the specified time.
            See <a href="http://msdn.microsoft.com/en-us/library/dd179371.aspx">Specifying Conditional Headers for Blob Service Operations</a> 
            for more information.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.IfNotModifiedSince(System.DateTime)">
            <summary>
            Creates an access condition for the IfNotModifiedSince condition.
            </summary>
            <param name="lastModifiedUtc">The last-modified time, expressed as UTC time.</param>
            <returns>An <see cref="T:Microsoft.WindowsAzure.StorageClient.AccessCondition"/> object with the IfNotModifiedSince condition set.</returns>
            <remarks>
            Setting this access condition modifies the request to include the HTTP If-Unmodified-Since conditional header. 
            If this access condition is set, the operation is performed only if the resource has not been modified since the specified time.
            See <a href="http://msdn.microsoft.com/en-us/library/dd179371.aspx">Specifying Conditional Headers for Blob Service Operations</a> 
            for more information.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.IfMatch(System.String)">
            <summary>
            Creates an access condition for the IfMatch condition.
            </summary>
            <param name="etag">The ETag to match.</param>
            <returns>An <see cref="T:Microsoft.WindowsAzure.StorageClient.AccessCondition"/> object with the IfMatch condition set.</returns>
            <remarks>
            Setting this access condition modifies the request to include the HTTP If-Match conditional header. 
            If this access condition is set, the operation is performed only if the ETag of the resource 
            matches the specified ETag.
            See <a href="http://msdn.microsoft.com/en-us/library/dd179371.aspx">Specifying Conditional Headers for Blob Service Operations</a> 
            for more information.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.IfNoneMatch(System.String)">
            <summary>
            Creates an access condition for the IfNoneMatch condition.
            </summary>
            <param name="etag">The ETag to match.</param>
            <returns>An <see cref="T:Microsoft.WindowsAzure.StorageClient.AccessCondition"/> object with the IfNoneMatch condition set.</returns>
            <remarks>
            Setting this access condition modifies the request to include the HTTP If-None-Match conditional header. 
            If this access condition is set, the operation is performed only if the ETag of the resource 
            does not match the specified ETag.
            See <a href="http://msdn.microsoft.com/en-us/library/dd179371.aspx">Specifying Conditional Headers for Blob Service Operations</a> 
            for more information.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.ApplyCondition(System.Net.HttpWebRequest)">
            <summary>
            Applies the condition to the web request.
            </summary>
            <param name="request">The request to be modified.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.GetSourceConditions(Microsoft.WindowsAzure.StorageClient.AccessCondition,Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind@,System.String@)">
            <summary>
            Converts AccessCondition into a <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind"/> type for use as a source conditional to Copy.
            </summary>
            <param name="condition">The original condition.</param>
            <param name="header">The resulting header for the condition.</param>
            <param name="value">The value for the condition.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.AccessCondition.VerifyConditionHolds(System.String,System.DateTime)">
            <summary>
            Verifies the condition is true.
            </summary>
            <param name="etag">The ETag.</param>
            <param name="lastModifiedTimeUtc">The last modified time UTC.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.AccessCondition.AccessConditionHeader">
            <summary>
            The header of the request to be set
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.AccessCondition.AccessConditionValue">
            <summary>
            The value of the header
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.RetryPolicies">
            <summary>
            Provides definitions for some standard retry policies.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.RetryPolicies.DefaultMinBackoff">
            <summary>
            Default minimum backoff value for RetryExponential(int, TimeSpan)
            To use a specific maximum backoff value use RetryExponential(int, TimeSpan, TimeSpan, TimeSpan)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.RetryPolicies.DefaultMaxBackoff">
            <summary>
            Default maximum backoff value for RetryExponential(int, TimeSpan)
            To use a specific maximum backoff value use RetryExponential(int, TimeSpan, TimeSpan, TimeSpan)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.RetryPolicies.DefaultClientBackoff">
            <summary>
             Configurable defaults used by the service clients in creating the default retry policy as
             RetryExponential(DefaultClientRetryCount, DefaultClientBackoff)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.RetryPolicies.DefaultClientRetryCount">
            <summary>
            Configurable defaults used by the service clients in creating the default  retry policy as 
             RetryExponential(DefaultClientRetryCount, DefaultClientBackoff)
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.RetryPolicies.NoRetry">
            <summary>
            Policy that does no retries i.e., it just invokes <paramref name="action"/> exactly once
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.RetryPolicies.Retry(System.Int32,System.TimeSpan)">
            <summary>
            Policy that retries a specified number of times with a specified fixed time interval between retries
            </summary>
            <param name="retryCount">The number of times to retry. Should be a non-negative number</param>
            <param name="intervalBetweenRetries">The time interval between retries. Use TimeSpan.Zero to specify immediate
            retries</param>
            <returns></returns>
            <remarks>When <paramref name="retryCount"/> is 0 and <paramref name="intervalBetweenRetries"/> is
            TimeSpan.Zero this policy is equivalent to the NoRetry policy</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.RetryPolicies.RetryExponential(System.Int32,System.TimeSpan)">
            <summary>
            Policy that retries a specified number of times with a randomized exponential backoff scheme
            </summary>
            <param name="retryCount">The number of times to retry. Should be a non-negative number.</param>
            <param name="deltaBackoff">The multiplier in the exponential backoff scheme</param>
            <returns></returns>
            <remarks>For this retry policy, the minimum amount of milliseconds between retries is given by the 
            DefaultMinBackoff constant, and the maximum backoff is predefined by the DefaultMaxBackoff constant. 
            Otherwise, the backoff is calculated as 
            DefaultMinBackoff + (2^currentRetry - 1) * random (deltaBackoff *0.8, deltabackoff * 1.2).</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.RetryPolicies.RetryExponential(System.Int32,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Policy that retries a specified number of times with a randomized exponential backoff scheme
            </summary>
            <param name="retryCount">The number of times to retry. Should be a non-negative number</param>
            <param name="deltaBackoff">The multiplier in the exponential backoff scheme</param>
            <param name="minBackoff">The minimum backoff interval</param>
            <param name="maxBackoff">The maximum backoff interval</param>
            <returns></returns>
            <remarks>For this retry policy, the minimum amount of milliseconds between retries is given by the 
            minBackoff parameter, and the maximum backoff is predefined by the maxBackoff parameter. 
            Otherwise, the backoff is calculated as 
            minBackoff + (2^currentRetry - 1) * random (deltaBackoff *0.8, deltabackoff * 1.2)
            </remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ShouldRetry">
            <summary>
            Decides whether to retry a request, based on how many times the 
            request has been made and the reason for the last failure.
            </summary>
            <param name="retryCount">The number of times the request has been made</param>
            <param name="lastException">The exception raised by the most recent web request or parsing attempt</param>
            <param name="delay">An optional delay which specifies how long to wait before reissuing requests. 
            Returing less than or equal to TimeSpan.Zero means use no delay.
            </param>
            <returns>true if the request should be retried</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.RetryPolicy">
            <summary>
            Decides whether to retry a request, based on how many times the 
            request has been made and the reason for the last failure.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.RequestWithRetry">
            <summary>
            Utility functions that does the heavy lifting of carrying out retries on a IRetrayableRequest
            Both synchrous and asynchrous request styles are supported.
            They are used to implement the corresponding XXX, BeginXXX, EndXXX calls where XXX
            is something like GetBlobInfo.
            
            State passing for return value in the sync call (GetBlobInfo) and out parameters for the async calls
            (EndBlobInfo) is achieved by member variables in the implementation class of IRetryableRequest.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1">
            <summary>
            Represents a segment that was retrieved from the total set of possible results.
            </summary>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.BeginGetNext(System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to get the next set of results.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.EndGetNext(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to get the next set of results.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>
            The next segment.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.GetNext">
            <summary>
            Gets the next segment synchronously.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean,System.Func{System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{`0}},System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Tasks.ITask}},Microsoft.WindowsAzure.StorageClient.RetryPolicy)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> class.
            </summary>
            <param name="result">The result.</param>
            <param name="moreResults">if set to <c>true</c> [more results].</param>
            <param name="getNext">The next result segment</param>
            <param name="retryPolicy">The retry policy.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.GetNextImpl(System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{`0}})">
            <summary>
            Implementation of GetNext (For symmetry with normal tasks
            </summary>
            <param name="setResult">The action to set the results.</param>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerable`1"/> representing the operation to get the next set of results</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.Results">
            <summary>
            Gets the results.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.HasMoreResults">
            <summary>
            Gets a value indicating whether this instance has more results.
            When using pagination, this indicates if the current page has more results.
            </summary>
            <value>
            <c>true</c> if this instance has more results; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.ContinuationToken">
            <summary>
            Gets the continuation information for continuing the operation
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.ResultSegment`1.Pagination">
            <summary>
            Gets the pagination information for Results
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.ResultSegment">
            <summary>
            Represents a helper class to support additional operations on ResultSegments 
            such as grouping of results into pages.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment.HasContinuation(Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Checks if the result segment passed in has a valid continuation token
            </summary>
            <param name="continuation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment.HasMoreResultsInPage(Microsoft.WindowsAzure.StorageClient.ResultPagination,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Checks if the result segment has more results in the current page if pagination is used.
            If pagination is not used, it checks if a valid continuation is present
            </summary>
            <param name="pagination"></param>
            <param name="continuationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.ResultSegment.CreateResultSegment``1(System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{``0}},System.Collections.Generic.IEnumerable{``0},Microsoft.WindowsAzure.StorageClient.ResultContinuation,Microsoft.WindowsAzure.StorageClient.ResultPagination,Microsoft.WindowsAzure.StorageClient.RetryPolicy,System.Func{Microsoft.WindowsAzure.StorageClient.ResultPagination,Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{``0}},System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Tasks.ITask}})">
            <summary>
            Create a result segment from the result result
            </summary>
            <typeparam name="T"></typeparam>
            <param name="setResult"></param>
            <param name="resultList"></param>
            <param name="continuationToken"></param>
            <param name="pagination"></param>
            <param name="retryPolicy"></param>
            <param name="ContinuationFunction"></param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask">
            <summary>
            A task that implements the conventional BeginXX(), EndXX() pattern.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1">
            <summary>
            A task that implements the conventional BeginXX(), EndXX() pattern.
            </summary>
            <typeparam name="T">The return type of the task</typeparam>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1">
            <summary>
            Represents an asynchronous computation that yields a result of type T.
            </summary>
            <typeparam name="T">The type of the result of the operation</typeparam>
            <remarks>
            By this contract we:
             1) guarantee that the completion routine is performed, regardless of the outcome of ExecuteStep.
             2) insist that the completion routine does not throw an exception.
             3) insists that the abort routine does not throw an exception.
            </remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.ITask">
            <summary>
            An asynchronous computation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.ITask.ExecuteStep(System.Action)">
            <summary>
            Perform the next async step
            </summary>
            <param name="cont">The action to be performed on completion</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.ITask.Abort">
            <summary>
            Abort the task operation
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.ITask.CompletedSynchronously">
            <summary>
            Gets a value indicating whether the task has completed synchronously
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.ITask.Exception">
            <summary>
            Gets exception raised by this task (if any)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.result">
            <summary>
            The result of the operation
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.completed">
            <summary>
            Provides information if the task is compleated
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.completedSynchronously">
            <summary>
            Provides information if the task completed synchronously and therefore on the main thread
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.exception">
            <summary>
            Contains any exceptions raised by the task
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.completionFunction">
            <summary>
            The action to call once the operation is completed
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.ExecuteStep(System.Action)">
            <summary>
            Executes a single step of the task. (Delegates to the concrete implemetation for specific step.
            </summary>
            <param name="cont">The completion function to be called</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.ExecuteInternal">
            <summary>
            The specific implementation of the task's step
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.SetResult(System.Func{`0})">
            <summary>
            Implements a safe way to obtain the result.
            </summary>
            <param name="result">The function used to get the result value.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.Abort">
            <summary>
            Implements an abort routine that fulfills the contract.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.AbortInternal">
            <summary>
            The task-specific abort that should be called
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.Complete(System.Boolean)">
            <summary>
            The completion return that needs to be called whenever operation completes.
            </summary>
            <param name="completedSynchronously">Whether the underlying operation completed synchrnously</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.ExecuteAndWait">
            <summary>
            Executes the tasks and waits for the result.
            </summary>
            <returns>The result of the operation</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.Result">
            <summary>
            Gets the result of the operation and throws any exceptions raised by the operation
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.CompletedSynchronously">
            <summary>
            Gets a value indicating whether the operation was completed synchronously and therefore on main thread
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.Task`1.Exception">
            <summary>
            Gets any exceptions raised during execution
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.#ctor(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0})">
            <summary>
            Initializes a new instance of the APMTask class for use with normal APM
            </summary>
            <param name="begin">The APM function to begin operation</param>
            <param name="end">The APM functon to end the operation</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.#ctor(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Action)">
            <summary>
            Initializes a new instance of the APMTask class for use with normal APM
            </summary>
            <param name="begin">The APM function to begin operation</param>
            <param name="end">The APM functon to end the operation</param>
            <param name="abort">The function used for aborting an operation</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.ExecuteInternal">
            <summary>
            Implementation of the library execution. Performs the APM operation
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.AbortInternal">
            <summary>
            Implements the abort functionality
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.OnEnd(System.IAsyncResult)">
            <summary>
            Callback for the APM function
            </summary>
            <param name="ar">The async result for the APM model.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.BeginFunc">
            <summary>
            Gets or sets the begin function.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.EndFunc">
            <summary>
            Gets or sets the end function.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask`1.AbortFunc">
            <summary>
            Gets or sets the abort function.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.APMTask.#ctor(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>
            Initializes a new instance of the APMTask class for sequence without any return value
            </summary>
            <param name="begin">The APM function to begin operation</param>
            <param name="end">The APM functon to end the operation</param>
            [DebuggerNonUserCode]
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.DelayTask">
            <summary>
            A task class that implements a fixed delay
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.DelayTask.#ctor(System.TimeSpan)">
            <summary>
            Constructor
            </summary>
            <param name="delayInterval">delayInterval should  be between TimeSpan.Zero and TimeSpan.MaxValue</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask">
            <summary>
            Invokes a sequence with no return value.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1">
            <summary>
            Invokes a sequence of tasks
            </summary>
            <typeparam name="T">The type of the result of the operation</typeparam>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.sequenceGenerator">
            <summary>
            Contains the function that generates a squence of tasks to be invoked
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.currentTask">
            <summary>
            The current task that is being invoked
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.aborting">
            <summary>
            Controls whether the abort was called
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.#ctor(System.Func{System.Action{`0},System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Tasks.ITask}})">
            <summary>
            Initializes a new instance of the InvokeTaskSequenceTask class with a task sequence that returns a vlue
            </summary>
            <param name="sequenceFunction">The sequence of actions to be invoked</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.AbortInternal">
            <summary>
            Implements the abort logic by aborting the current task.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.ExecuteInternal">
            <summary>
            The starting point for executing a task sequence.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask`1.ExecuteTaskSequence(System.Collections.Generic.IEnumerator{Microsoft.WindowsAzure.StorageClient.Tasks.ITask},System.Boolean)">
            <summary>
            Executes a task sequence by iterating over all of the items and executing them
            </summary>
            <param name="taskList">The sequence of tasks to execute</param>
            <param name="completedSynchronously">Whether the sequence so far has completed synchronously</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.InvokeTaskSequenceTask.#ctor(System.Func{System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Tasks.ITask}})">
            <summary>
            Initializes a new instance of the InvokeTaskSequenceTask class for sequence without any return value
            </summary>
            <param name="sequenceFunction">The sequence of actions to be invoked</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.RaceTask`1">
            <summary>
            Facilitates a scenario where numerous simultaneous tasks are active, and only the first to complete should continue.
            </summary>
            <typeparam name="T">The type of the result of the operation</typeparam>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.StreamExtensions">
            <summary>
            Provides extensions for the stream object to support asynchronous operations
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.StreamExtensions.ReadAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Asynchronously reads data from a stream using BeginRead.
            </summary>
            <param name="stream">The stream on which the method is called</param>
            <param name="buffer">The buffer to read the data into</param>
            <param name="offset">Byte offset in the buffer</param>
            <param name="count">Maximum number of bytes to read</param>
            <returns>Returns non-zero if there are still some data to read</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.StreamExtensions.ReadToString(System.IO.Stream,System.Text.Encoding,System.Action{System.String})">
            <summary>
            Reads asynchronously the entire content of the stream and returns it 
            as a string using StreamReader.
            </summary>
            <param name="stream">The stream on which the method is called</param>
            <param name="encoding">The text encoding used for converting bytes read into string</param>
            <param name="result">The action to be performed with the resulting string</param>
            <returns>Returns a task sequence that must be performed to get result string using the 'Result' callback.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.StreamExtensions.WriteAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Asynchronously writes data from a stream using BeginWrite.
            </summary>
            <param name="stream">The stream on which the method is called</param>
            <param name="buffer">The buffer to write the data from</param>
            <param name="offset">Byte offset in the buffer</param>
            <param name="count">Maximum number of bytes to write</param>
            <returns>A task with no return value</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.StreamExtensions.WriteTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads asynchronously the entire content of the stream and writes it to the given output stream.
            </summary>
            <param name="stream">The origin stream</param>
            <param name="toStream">The destination stream</param>
            <returns>The sequence that when invoked results in an asynchronous copy</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.StreamExtensions.WriteToAndCloseOutput(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads asynchronously the entire content of the stream and writes it to the given output stream.
            Closes the output stream at the end
            </summary>
            <param name="stream">The origin stream</param>
            <param name="toStream">The destination stream</param>
            <returns>The sequence that when invoked results in an asynchronous copy</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask">
            <summary>
            A task that obtains a result synchronously.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask`1">
            <summary>
            A task that obtains a result synchronously.
            </summary>
            <typeparam name="T">The type of the result of the operation</typeparam>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask`1.func">
            <summary>
            The function to be executed
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the SynchronousTask class.
            </summary>
            <param name="operation">The function to execute</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask`1.ExecuteInternal">
            <summary>
            Performs the task and marks it as completed.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask`1.AbortInternal">
            <summary>
            Implements abort as NoOp
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.SynchronousTask.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the SynchronousTask class.
            </summary>
            <param name="operation">The function to execute</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.TableServiceExtensions">
            <summary>
            A set of extension methods for table service classes
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TableServiceExtensions.ExecuteAsync``1(System.Data.Services.Client.DataServiceQuery{``0})">
            <summary>
            Converts a DataServiceQuery execution into an APMTask
            </summary>
            <typeparam name="T">The result type of the query</typeparam>
            <param name="query">The query to convert</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TableServiceExtensions.SaveChangesAsync(Microsoft.WindowsAzure.StorageClient.TableServiceContext)">
            <summary>
            Converts the SaveChanges method into an APMTask
            </summary>
            <param name="context">The target context</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TableServiceExtensions.SaveChangesAsync(Microsoft.WindowsAzure.StorageClient.TableServiceContext,System.Data.Services.Client.SaveChangesOptions)">
            <summary>
            Converts the SaveChanges method to an APMTask
            </summary>
            <param name="context">The target context</param>
            <param name="options">The options to pass to SaveChanges</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.NullTaskReturn">
            <summary>
            A NullTaskReturn type.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.NullTaskReturn.Value">
            <summary>
            Represents a no-return from a task
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.NullTaskReturn.#ctor">
            <summary>
            Prevents public instantiation
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.AsyncResultExtensions">
            <summary>
            A class to extend a normal task 
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.AsyncResultExtensions.ToAsyncResult``1(Microsoft.WindowsAzure.StorageClient.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Converts a Task to an a TaskAsyncResult to allow for exposing Tasks as IAsyncResut.
            </summary>
            <typeparam name="T">The return type of the task</typeparam>
            <param name="async">The task to be converted</param>
            <param name="callback">The callback to be called at the end of the task</param>
            <param name="state">The callback's state</param>
            <returns>A TaskAsyncResult that implements IAsyncResult</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.AsyncResultExtensions.ToAsyncResult(Microsoft.WindowsAzure.StorageClient.Tasks.Task{Microsoft.WindowsAzure.StorageClient.Tasks.NullTaskReturn},System.AsyncCallback,System.Object)">
            <summary>
            Converts a Task to an a TaskAsyncResult to allow for exposing Tasks as IAsyncResut.
            </summary>
            <param name="async">The task to be converted</param>
            <param name="callback">The callback to be called at the end of the task</param>
            <param name="state">The callback's state</param>
            <returns>A TaskAsyncResult that implements IAsyncResult</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1">
            <summary>
            An implementation of IAsyncResult that encapsulates a task.
            </summary>
            <typeparam name="T">The type of the resulting value</typeparam>
            <remarks>Refer to http://csdweb/sites/oslo/engsys/DesignGuidelines/Wiki%20Pages/IAsyncResult.aspx and 
            http://www.bluebytesoftware.com/blog/2006/05/31/ImplementingAHighperfIAsyncResultLockfreeLazyAllocation.aspx for IAsyncResult details</remarks>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.realTask">
            <summary>
            The underlying task for the async operation
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.userCallback">
            <summary>
            The callback provided by the user
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.userState">
            <summary>
            The state for the callback
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.isCompleted">
            <summary>
            Indicates whether a task is completed
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.completedSynchronously">
            <summary>
            Indicates whether task completed synchronously
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.asyncWaitEvent">
            <summary>
            The event for blocking on this task's completion
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.#ctor(Microsoft.WindowsAzure.StorageClient.Tasks.Task{`0},System.AsyncCallback,System.Object)">
            <summary>
            Initializes a new instance of the TaskAsyncResult class.
            </summary>
            <param name="async">The task to be executed</param>
            <param name="callback">The callback method to be used on completion</param>
            <param name="state">The state for the callback</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.OnComplete">
            <summary>
            Called on completion of the async operation to notify the user
            (Based on Joe Duffy's lockless design)
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.LazyCreateWaitHandle">
            <summary>
            Provides the lazy initialization of the WaitHandle (based on Joe Duffy's blog)
            </summary>
            <returns>The WaitHandle to use for waiting on completion</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.EndInvoke">
            <summary>
            Provides a convenient function for waiting for completion and getting the result
            </summary>
            <returns>The result of the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.Dispose">
            <summary>
            We implement the dispose only to allow the explicit closing of the event.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.System#IAsyncResult#AsyncState">
            <summary>
            Gets A user-defined object that contains information about the asynchronous operation.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.System#IAsyncResult#AsyncWaitHandle">
            <summary>
             Gets a System.Threading.WaitHandle that is used to wait for an asynchronous operation to complete.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.System#IAsyncResult#CompletedSynchronously">
            <summary>
            Gets a value indicating whether the asynchronous operation completed synchronously
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Tasks.TaskAsyncResult`1.System#IAsyncResult#IsCompleted">
            <summary>
            Gets a value indicating whether the asynchronous operation has completed.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Tasks.WebRequestExtensions">
            <summary>
            A set of extension methods for a webrequest
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.WebRequestExtensions.GetRequestStreamAsync(System.Net.WebRequest)">
            <summary>
            Gets an asynchronous request stream for a given Web request.
            </summary>
            <param name="req">The requested that is used for operation</param>
            <returns>A task that yields a stream</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.WebRequestExtensions.GetResponseAsync(System.Net.WebRequest,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Gets an asynchronous response to a given Web request.
            </summary>
            <param name="req">The requested that is used for operation</param>
            <param name="service"></param>
            <returns>A task that yields the response</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.WebRequestExtensions.GetResponseAsync(System.Net.WebRequest,Microsoft.WindowsAzure.StorageClient.CloudQueueClient)">
            <summary>
            Gets an asynchronous response to a given Web request.
            </summary>
            <param name="req">The requested that is used for operation</param>
             <param name="service"></param>
            <returns>A task that yields the response</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.WebRequestExtensions.GetResponseAsyncWithTimeout(System.Net.WebRequest,Microsoft.WindowsAzure.StorageClient.CloudQueueClient,System.Nullable{System.TimeSpan})">
            <summary>
            Gets an asynchronous response to a given Web request.
            </summary>
            <param name="req">The requested that is used for operation</param>
            <param name="service"></param>
            <param name="timeout"></param>
            <returns>A task that yields the response</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Tasks.WebRequestExtensions.GetResponseAsyncWithTimeout(System.Net.WebRequest,Microsoft.WindowsAzure.StorageClient.CloudBlobClient,System.Nullable{System.TimeSpan})">
            <summary>
            Gets an asynchronous response to a given Web request.
            </summary>
            <param name="req">The requested that is used for operation</param>
            <param name="service"></param>
            <param name="timeout"></param>
            <returns>A task that yields the response</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.CloudStorageAccount">
            <summary>
            Class that provides methods for conveniently managing account information for storage services.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.#ctor(Microsoft.WindowsAzure.StorageCredentials,System.Uri,System.Uri,System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> class.
            </summary>
            <param name="storageCredentials">A <see cref="T:Microsoft.WindowsAzure.StorageCredentials"/> object.</param>
            <param name="blobEndpoint">The Blob service endpoint.</param>
            <param name="queueEndpoint">The Queue service endpoint.</param>
            <param name="tableEndpoint">The Table service endpoint.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.#ctor(Microsoft.WindowsAzure.StorageCredentialsAccountAndKey,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> class using the specified credentials.
            </summary>
            <param name="storageCredentialsAccountAndKey">The account name and account key for the storage account.</param>
            <param name="useHttps">if set to <c>true</c> [use HTTPS].</param>
            <remarks>
            This constructor returns a <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> object for which all service endpoints
            are configured as the default service endpoints.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.ToString">
            <summary>
            Returns a string representation of storage account information.
            </summary>
            <remarks>
            Returned string omits any sensitive information such as account key data.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.ToString(System.Boolean)">
            <summary>
            Returns a string representation of storage account information.
            </summary>
            <param name="exportSecrets">
            If set to <c>true</c>, the string will include private data such as account key or shared access tokens in the resulting value.
            The default value is <c>false</c>.
            </param>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.TryParse(System.String,Microsoft.WindowsAzure.CloudStorageAccount@)">
            <summary>
            Attempts to parse a configuration string into a <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> object.
            </summary>
            <param name="value">The string to parse.</param>
            <param name="account">A <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> object to construct from the parsed string.</param>
            <returns><c>true</c> if the string was successfully parsed; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.Parse(System.String)">
            <summary>
            Parses a connection string and returns a <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> object based on
            the connection string.
            </summary>
            <param name="value">The connection string to parse.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="setting"/> is null or empty</exception>
            <exception cref="T:System.FormatException">Thrown if <paramref name="setting"/> is not a valid connection string.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="setting"/> is not parseable.</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.FromConfigurationSetting(System.String)">
            <summary>
            Create a new instance of a <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> from a configuration setting.
            </summary>
            <param name="settingName">Name of the configuration setting.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the service configuration file
            is not available.</exception>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.ParseStringIntoSettings(System.String,System.Action{System.String})">
            <summary>
            Tokenizes input and stores name/value pairs in a NameValueCollection
            </summary>
            <param name="s">The string to parse</param>
            <param name="error">Error reporting delegate</param>
            <returns>Tokenized collection</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.Setting(System.String,System.String[])">
            <summary>
            Encapsulates a validation rule for an enumeration based account setting
            </summary>
            <param name="name">The name of the setting</param>
            <param name="validValues">A list of valid values for the setting</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.Setting(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Encapsulates a validation rule using a func
            </summary>
            <param name="name">The name of the setting</param>
            <param name="isValid">A func that determines if the value is valid</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.IsValidUri(System.String)">
            <summary>
            Validation function that validates Uris
            </summary>
            <param name="settingValue">Value to validate</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.AllRequired(System.Collections.Generic.KeyValuePair{System.String,System.Func{System.String,System.Boolean}}[])">
            <summary>
            Settings filter that requires all specified settings be present and valid
            </summary>
            <param name="requiredSettings">A list of settings that must be present</param>
            <returns>The remaining settings or null if the filter's requirement is not satisfied</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.Optional(System.Collections.Generic.KeyValuePair{System.String,System.Func{System.String,System.Boolean}}[])">
            <summary>
            Settings filter that removes optional values
            </summary>
            <param name="optionalSettings">A list of settings that are optional</param>
            <returns>The remaining settings or null if the filter's requirement is not satisfied</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.AtLeastOne(System.Collections.Generic.KeyValuePair{System.String,System.Func{System.String,System.Boolean}}[])">
            <summary>
            Settings filter that ensures that at least one setting is present
            </summary>
            <param name="atLeastOneSettings">A list of settings of which one must be present</param>
            <returns>The remaining settings or null if the filter's requirement is not satisfied</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.ValidCredentials">
            <summary>
            Settings filter that ensures that a valid combination of credentials is present
            </summary>
            <returns>The remaining settings or null if the filter's requirement is not satisfied</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.MatchesSpecification(System.Collections.Specialized.NameValueCollection,System.Func{System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection}[])">
            <summary>
            Tests to see if a given list of settings matches a set of filters exactly.
            </summary>
            <param name="settings">The settings to check</param>
            <param name="constraints">A list of filters to check</param>
            <returns>
            If any filter returns null, false.
            If there are any settings left over after all filters are processed, false.
            Otherwise true.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.GetCredentials(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Gets a StorageCredentials object corresponding to whatever credentials are supplied in the given settings.
            </summary>
            <param name="settings">The settings to check</param>
            <returns>The StorageCredentials object specified in the settings</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.CloudStorageAccount.SetConfigurationSettingPublisher(System.Action{System.String,System.Func{System.String,System.Boolean}})">
            <summary>
            Sets the global configuration setting publisher for the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> object.
            </summary>
            <param name="configurationSettingPublisher">The configuration setting publisher.</param>
            <remarks>
            <para>
            This method supports changing storage keys dynamically. For further details, 
            see the Thumbnails sample included with the Windows Azure SDK.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.CloudStorageAccount.BlobEndpoint">
            <summary>
            Gets the endpoint for the Blob service as configured for the storage account.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.CloudStorageAccount.QueueEndpoint">
            <summary>
            Gets the endpoint for the Queue service as configured for the storage account.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.CloudStorageAccount.TableEndpoint">
            <summary>
            Gets the endpoint for the Table service as configured for the storage account.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.CloudStorageAccount.Credentials">
            <summary>
            Gets the storage credentials to use to access the storage account.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.CloudStorageAccount.DevelopmentStorageAccount">
            <summary>
            Get the default configuration information for the development storage account.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.CloudStorageAccount.StorageAccountConfigurationSetting.ConfigurationSettingName">
            <summary>
            The name of the configuration setting from which we retrieve storage account information
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudStorageAccountStorageClientExtensions">
            <summary>
            A set of extensions to the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> to generate client objects for 
            the storage services.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudStorageAccountStorageClientExtensions.CreateCloudBlobClient(Microsoft.WindowsAzure.CloudStorageAccount)">
            <summary>
            Creates a new Blob service client.
            </summary>
            <param name="account">The storage account.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudBlobClient"/> based on the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudStorageAccountStorageClientExtensions.CreateCloudQueueClient(Microsoft.WindowsAzure.CloudStorageAccount)">
            <summary>
            Creates a new Queue service client.
            </summary>
            <param name="account">The storage account.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueueClient"/> based on the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudStorageAccountStorageClientExtensions.CreateCloudTableClient(Microsoft.WindowsAzure.CloudStorageAccount)">
            <summary>
            Creates the Table service client.
            </summary>
            <param name="account">The storage account.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableClient"/> based on the <see cref="T:Microsoft.WindowsAzure.CloudStorageAccount"/> </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageCredentials">
            <summary>
            Represents credentials to authenticate access to the Windows Azure storage services via a storage account.
            </summary>
            <remarks>
            <para>
            The Windows Azure storage services include the Blob, Queue, and Table services.
            </para>
            <para>
            For additional information about the Windows Azure storage services, see
            <a href="http://msdn.microsoft.com/en-us/library/dd179355.aspx">Windows Azure Storage Services API Reference</a>. 
            For detailed information on request authentication, see 
            <a href="http://msdn.microsoft.com/en-us/library/dd179428.aspx">Authentication Schemes</a>.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentials.TransformUri(System.String)">
            <summary>
            Transforms a resource URI for signing purposes. 
            The transformation may append to the string.
            </summary>
            <param name="resourceUri">The resource URI to be transformed</param>
            <returns>The new resource URI that includes any transformations required for signing</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentials.SignRequest(System.Net.HttpWebRequest)">
            <summary>
            Signs a request using the specified credentials under the Shared Key authentication scheme.
            </summary>
            <param name="request">The request to be signed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentials.SignRequestLite(System.Net.HttpWebRequest)">
            <summary>
            Signs a request using the specified credentials under the Shared Key Lite authentication scheme.
            </summary>
            <param name="request">The request to be signed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentials.ComputeHmac(System.String)">
            <summary>
            Encodes the signature string by using the HMAC-SHA256 algorithm over 
            the UTF-8-encoded string-to-sign.
            </summary>
            <param name="value">The UTF-8-encoded string-to-sign</param>
            <returns>The HMAC-encoded signature string</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentials.ComputeHmac512(System.String)">
            <summary>
            Performs the computation of the signature based on the private key.
            </summary>
            <param name="value">The string to be signed</param>
            <returns>The signature for the string</returns>
            <remarks> Need for D-SAS not public</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentials.AccountName">
            <summary>
            Gets the name of the storage account associated with the specified credentials.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentials.NeedsTransformUri">
            <summary>
            Indicates whether the <see cref="M:Microsoft.WindowsAzure.StorageCredentials.TransformUri(System.String)"/> method must be called
            before generating a signature string with the specified credentials.
            </summary>
            <value><c>true</c> if [needs transform URI]; otherwise, <c>false</c>. If <c>false</c>, 
            calling <see cref="M:Microsoft.WindowsAzure.StorageCredentials.TransformUri(System.String)"/> returns the original, unmodified URI.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentials.CanSignRequest">
            <summary>
            Indicates whether a request can be signed under the Shared Key authentication 
            scheme using the specified credentials.
            </summary>
            <value>
            <c>true</c> if a request can be signed with these credentials; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentials.CanSignRequestLite">
            <summary>
            Indicates whether a request can be signed under the Shared Key Lite authentication
            scheme using the specified credentials.
            </summary>
            <value>
            <c>true</c> if a request can be signed with these credentials; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentials.CanComputeHmac">
            <summary>
            Indicates whether the <see cref="M:Microsoft.WindowsAzure.StorageCredentials.ComputeHmac(System.String)"/> method will return a valid
            HMAC-encoded signature string when called with the specified credentials.
            </summary>
            <value>
            <c>true</c> if these credentials will yield a valid signature string; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Microsoft.WindowsAzure.SharedAccessSignatureHelper.GetSharedAccessSignatureHashImpl(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy,System.String,System.String,Microsoft.WindowsAzure.StorageClient.CloudBlobClient)">
            <summary>
            Get the signature hash embedded inside the Shared Access Signature
            </summary>
            <param name="policy"></param>
            <param name="groupPolicyIdentifier">Optional identifier</param>
            <param name="resourceName">(b) blob or (c) container</param>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.SharedAccessSignatureHelper.GetShareAccessSignatureImpl(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicy,System.String,System.String,System.String)">
            <summary>
            Get the complete query builder for creating the Shared Access Signature query
            </summary>
            <param name="policy"></param>
            <param name="groupPolicyIdentifier"></param>
            <param name="resourceType"></param>
            <param name="signature"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageCredentialsAnonymous">
            <summary>
            Class that represents credentials for anonymous access. Used by internal implementaion
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAnonymous.TransformUri(System.String)">
            <summary>
            A potential transformation to the URI for signing purposes. The transformation may append to the string.
            </summary>
            <param name="resourceUri">The resource URI to be transformed</param>
            <returns>The new resource URI that includes any transformations required for signing</returns>
            <remarks>Identity operation for anonymous access</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAnonymous.SignRequest(System.Net.HttpWebRequest)">
            <summary>
            An operation that may add any required authentication headers based for the credential type. (SharedKey algorithm)
            </summary>
            <param name="request">The request that needs to be signed.</param>
            <remarks>No op for anonymous access</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAnonymous.SignRequestLite(System.Net.HttpWebRequest)">
            <summary>
            An operation that may add any required authentication headers based for the credential type. (SharedKeyLite algorithm used for LINQ for Tables)
            </summary>
            <param name="request">The request that needs to be signed.</param>
            <remarks>No op for anonymous access</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAnonymous.ComputeHmac(System.String)">
            <summary>
            Performs the computation of the signature based on the private key.
            </summary>
            <param name="value">The string that should be signed</param>
            <returns>The signature for the string</returns>
            <remarks>Returns null representing no op</remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAnonymous.AccountName">
            <summary>
            Returns account name information if available. Else returns null
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAnonymous.NeedsTransformUri">
            <summary>
            Returns whether TransformUri should be called when using this credentials
            False means TransformUri will return the original Uri
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAnonymous.CanSignRequest">
            <summary>
            Returns whether SignRequest will perform signing when using this credentials. 
            False means SignRequest will not do anything.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAnonymous.CanSignRequestLite">
            <summary>
            Returns whether SignRequestLite will perform signing when using this credentials. 
            False means SignRequestLite will not do anything.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAnonymous.CanComputeHmac">
            <summary>
            Returns whether ComputeHMAC will return a valid HMAC when using this credentials. 
            False means ComputeHmac will return null
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey">
            <summary>
            Represents storage account credentials for accessing the Blob, Queue, and Table services
            using the Shared Key authentication scheme.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.#ctor(System.String,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey"/> class.
            </summary>
            <param name="accountName">Name of the account.</param>
            <param name="key">The account key, as an array of bytes.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey"/> class.
            </summary>
            <param name="accountName">Name of the account.</param>
            <param name="key">The account key, as a Base64-encoded string.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.TransformUri(System.String)">
            <summary>
            Transforms a resource URI for signing purposes.
            The transformation may append to the string.
            </summary>
            <param name="resourceUri">The resource URI to be transformed</param>
            <returns>
            The new resource URI that includes any transformations required for signing
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.SignRequest(System.Net.HttpWebRequest)">
            <summary>
            Signs a request using the specified credentials under the Shared Key authentication scheme.
            </summary>
            <param name="request">The request to be signed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.SignRequestLite(System.Net.HttpWebRequest)">
            <summary>
            Signs a request using the specified credentials under the Shared Key Lite authentication scheme.
            </summary>
            <param name="request">The request to be signed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.ComputeHmac(System.String)">
            <summary>
            Encodes the signature string by using the HMAC-SHA256 algorithm over
            the UTF-8-encoded string-to-sign.
            </summary>
            <param name="value">The UTF-8-encoded string-to-sign</param>
            <returns>The HMAC-encoded signature string</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.ComputeHmac512(System.String)">
            <summary>
            Performs the computation of the signature based on the private key.
            </summary>
            <param name="value">The string that should be signed</param>
            <returns>The signature for the string</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.Credentials">
            <summary>
            Gets a <see cref="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.Credentials"/> object that stores the protocol-level credentials.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.AccountName">
            <summary>
            Gets the name of the storage account associated with the specified credentials.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.NeedsTransformUri">
            <summary>
            Indicates whether the <see cref="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.TransformUri(System.String)"/> method must be called
            before generating a signature string with the specified credentials.
            </summary>
            <value>
            <c>true</c> if [needs transform URI]; otherwise, <c>false</c>. If <c>false</c>,
            calling <see cref="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.TransformUri(System.String)"/> returns the original, unmodified URI.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.CanSignRequest">
            <summary>
            Indicates whether a request can be signed under the Shared Key authentication
            scheme using the specified credentials.
            </summary>
            <value>
            <c>true</c> if a request can be signed with these credentials; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.CanSignRequestLite">
            <summary>
            Indicates whether a request can be signed under the Shared Key Lite authentication
            scheme using the specified credentials.
            </summary>
            <value>
            <c>true</c> if a request can be signed with these credentials; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.CanComputeHmac">
            <summary>
            Indicates whether the <see cref="M:Microsoft.WindowsAzure.StorageCredentialsAccountAndKey.ComputeHmac(System.String)"/> method will return a valid
            HMAC-encoded signature string when called with the specified credentials.
            </summary>
            <value>
            <c>true</c> if these credentials will yield a valid signature string; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature">
            <summary>
            Represents storage credentials for constructing a Shared Access Signature 
            for delegated access to Blob service resources.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.#ctor(System.String)">
            <summary>
            Constructs storage credentials based on a shared access signature token.
            </summary>
            <param name="token">A string token representing the shared access signature.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.TransformUri(System.String)">
            <summary>
            Transforms a resource URI for signing purposes.
            The transformation may append to the string.
            </summary>
            <param name="resourceUri">The resource URI to be transformed</param>
            <returns>
            The new resource URI that includes any transformations required for signing
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.SignRequest(System.Net.HttpWebRequest)">
            <summary>
            An operation that may add any required authentication headers based for the credential type. (SharedKey algorithm)
            </summary>
            <param name="request">The request to be signed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.SignRequestLite(System.Net.HttpWebRequest)">
            <summary>
            An operation that may add any required authentication headers based for the credential type. (SharedKeyLite algorithm used for LINQ for Tables)
            </summary>
            <param name="request">The request to be signed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.ComputeHmac(System.String)">
            <summary>
            Encodes the signature string by using the HMAC-SHA-256 algorithm over 
            the UTF-8-encoded string-to-sign.
            </summary>
            <param name="value">The UTF-8-encoded string-to-sign</param>
            <returns>The HMAC-encoded signature string</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.ComputeHmac512(System.String)">
            <summary>
            Encodes the signature string by using the HMAC-SHA-512 algorithm over 
            the UTF-8-encoded string-to-sign.
            </summary>
            <param name="value">The UTF-8-encoded string-to-sign</param>
            <returns>The HMAC-encoded signature string</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.AccountName">
            <summary>
            Gets the name of the storage account associated with the specified credentials.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.NeedsTransformUri">
            <summary>
            Indicates whether the <see cref="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.TransformUri(System.String)"/> method must be called
            before generating a signature string with the specified credentials.
            </summary>
            <value>
            <c>true</c> if [needs transform URI]; otherwise, <c>false</c>. If <c>false</c>,
            calling <see cref="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.TransformUri(System.String)"/> returns the original, unmodified URI.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.CanSignRequest">
            <summary>
            Indicates whether a request can be signed under the Shared Key authentication
            scheme using the specified credentials.
            </summary>
            <value>
            <c>true</c> if a request can be signed with these credentials; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.CanSignRequestLite">
            <summary>
            Indicates whether a request can be signed under the Shared Key Lite authentication
            scheme using the specified credentials.
            </summary>
            <value>
            <c>true</c> if a request can be signed with these credentials; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.CanComputeHmac">
            <summary>
            Indicates whether the <see cref="M:Microsoft.WindowsAzure.StorageCredentialsSharedAccessSignature.ComputeHmac(System.String)"/> method will return a valid
            HMAC-encoded signature string when called with the specified credentials.
            </summary>
            <value>
            <c>true</c> if these credentials will yield a valid signature string; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.AccessPolicyResponse">
            <summary>
            Parses the response XML from a Set Container ACL operation to retrieve container-level access policy data.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1">
            <summary>
            A base class to parse XML streams from the storage services.
            </summary>
            <typeparam name="T">The type to be parsed</typeparam>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.reader">
            <summary>
            The reader used for parsing
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.parser">
            <summary>
            The IEnumerator over the parsed content
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1"/> class.
            </summary>
            <param name="stream">The stream to be parsed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.ParseXml">
            <summary>
            Parses the XML by using an overriden parsing function that will perform the specific parsing and flag setting
            </summary>
            <returns>A list of enumerable objects in the XML</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.enumerableConsumed">
            <summary>
            Used to make sure that parsing is only done once, since a stream is not re-entrant
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.allObjectsParsed">
            <summary>
            Used to designate when all parsable objects are consumed
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.outstandingObjectsToParse">
            <summary>
            Stores any parsed objects that haven't been returned to the user due to specific requirement.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.Variable(System.Boolean@)">
            <summary>
            All other properties will be some variable type such as a string or int.  We don't really care about the resulting value in
            the base, but this logic will control how far we parse.  There can be an arbitrary number of these flags in the ParseXml() method,
            so we pass them in by reference here.
            </summary>
            <param name="consumable">when set to <c>true</c> the value is now consumable.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ResponseParsingBase`1.ObjectsToParse">
            <summary>
            Gets the parsable objects: For each class that inherits from this base, there is exactly one property the is an IEnumerable.  This is
            what should be returned in that case.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.AccessPolicyResponse.ParseXml">
            <summary>
            Parses the response XML from a Set Container ACL operation to retrieve container-level access policy data.
            </summary>
            <returns>A list of enumerable key-value pairs.</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.AccessPolicyResponse.AccessIdentifiers">
            <summary>
            Gets the container-level access policy identifiers.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.IListBlobEntry">
            <summary>
            Interface for items that appear in the Blobs section of the XML response for a List Blobs operation.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobPrefixEntry">
            <summary>
            The blob prefix, as returned in the Blobs section of the XML response for a List Blobs operation.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.BlobPrefixEntry.Name">
            <summary>
            The prefix string.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobEntry">
            <summary>
            Represents a blob item returned in the XML response for a List Blobs operation.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.BlobEntry.Attributes">
            <summary>
            Gets the attributes for this blob item.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.BlobEntry.Name">
            <summary>
            The name of the blob.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobContainerEntry">
            <summary>
            Represents a container item returned in the XML response for a List Containers operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobContainerEntry.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobContainerEntry"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.BlobContainerEntry.Attributes">
            <summary>
            Gets the attributes for this container item.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse">
            <summary>
            Provides a starting point for parsing any blob responses
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetError(System.Net.HttpWebResponse)">
            <summary>
            Parses the error response
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation"/> containing information about the response</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetMetadata(System.Net.HttpWebResponse)">
            <summary>
            Gets the metadata from the response.
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> containing all of the user-defined metadata</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetMetadata(System.Net.HttpWebResponse,System.String)">
            <summary>
            Gets the metadata for a specific name.
            </summary>
            <param name="response">The response received from server.</param>
            <param name="name">The name of the specific metadata header.</param>
            <returns>An array of metadata values</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetAttributes(System.Net.HttpWebResponse)">
            <summary>
            Gets the properties and metadata from server request.
            </summary>
            <param name="response">The response from the server.</param>
            <returns>The properties and metadata returned from the server</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetRequestId(System.Net.HttpWebResponse)">
            <summary>
            Gets the request id from response.
            </summary>
            <param name="response">The response from server.</param>
            <returns>The request ID from ther server</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetSnapshotTime(System.Net.HttpWebResponse)">
            <summary>
            Gets the snapshot time from the snapshot request.
            </summary>
            <param name="response">The response for a snapshot request.</param>
            <returns>A string representation of the DateTime of the snapshot</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.List(System.IO.Stream)">
            <summary>
            Parses the ListBlobs response
            </summary>
            <param name="stream">The stream for the response.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse"/> class used for parsing out details of the ListBlobs operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.List(System.Net.HttpWebResponse)">
            <summary>
            Parses the ListBlobs response
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse"/> class used for parsing out details of the ListBlobs operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetBlockList(System.IO.Stream)">
            <summary>
            Parses the GetBlockList response
            </summary>
            <param name="stream">The stream for the response.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetBlockListResponse"/> class used for parsing out details of the GetBlockList operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetBlockList(System.Net.HttpWebResponse)">
            <summary>
            Parses the GetBlockList response
            </summary>
            <param name="response">The response of the operation.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetBlockListResponse"/> class used for parsing out details of the GetBlockList operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetPageRanges(System.IO.Stream)">
            <summary>
            Parses the GetPageRanges response
            </summary>
            <param name="stream">The stream for the response.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse"/> class used for parsing out details of the GetPageRanges operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobResponse.GetPageRanges(System.Net.HttpWebResponse)">
            <summary>
            Parses the GetPageRanges response
            </summary>
            <param name="response">The response of the request.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse"/> class used for parsing out details of the GetPageRanges operation</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategyFactory">
            <summary>
            Retrieve appropriate version of CanonicalizationStrategy based on the webrequest
            for Blob Queue and Table
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategyFactory.GetBlobQueueFullCanonicalizationStrategy(System.Net.HttpWebRequest)">
            <summary>
            Gets canonicalization strategy for Blob and Queue SharedKey Authentication
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategyFactory.GetTableLiteCanonicalizationStrategy(System.Net.HttpWebRequest)">
            <summary>
            Get canonicalization strategy for Tables for SharedKeyLite Authentication
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy">
            <summary>
            Describes the base canonicalization used for a request.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.CanonicalizeHttpRequest(System.Net.HttpWebRequest,System.String)">
            <summary>
            Canonicalizes the HTTP request based on the specified strategy.
            </summary>
            <param name="request">The request to canonicalize.</param>
            <param name="accountName">Name of the account.</param>
            <returns>Canonicalization of the request fields</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.CanonicalizeHttpRequest(System.Uri,System.String,System.String,System.String,System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Create a canonicalized string out of HTTP request header contents for signing
            Blob or Queue servoce requests under the Shared Key Lite authentication scheme.
            </summary>
            <param name="address">The URI address of the HTTP request.</param>
            <param name="accountName">The storage account name.</param>
            <param name="method">The method of the HTTP request (GET/PUT, etc.).</param>
            <param name="contentType">The content type of the HTTP request.</param>
            <param name="date">The date/time specification for the HTTP request.</param>
            <param name="headers">Additional headers specified on the HTTP request.</param>
            <returns>A canonicalized string.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.CanonicalizeHttpRequestVersion2(System.Uri,System.String,System.String,System.String,System.Int64,System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Create a canonicalized string out of HTTP request header contents for signing
            Blob or Queue service requests under the Shared Authentication scheme.
            </summary>
            <param name="address">The URI address of the HTTP request.</param>
            <param name="accountName">The storage account name.</param>
            <param name="method">The method of the HTTP request (GET/PUT, etc.).</param>
            <param name="contentType">The content type of the HTTP request.</param>
            <param name="contentLength">The length of the HTTP request in bytes.</param>
            <param name="date">The date/time specification for the HTTP request.</param>
            <param name="headers">Additional headers specified on the HTTP request.</param>
            <returns><see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.AddCanonicalizedResourceVer2(System.Uri,System.String,Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString)">
            <summary>
            Adds the canonicalized resource for version 2.
            </summary>
            <param name="address">The address.</param>
            <param name="accountName">Name of the account.</param>
            <param name="canonicalizedString">The canonicalized string.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.GetStandardHeaderValue(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Gets the standard HTTP header value.
            </summary>
            <param name="headers">The collection of headers.</param>
            <param name="headerName">The name of the header.</param>
            <returns><see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.GetHeaderValues(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            A helper function for extracting HTTP header values from a NameValueCollection object.
            </summary>
            <param name="headers">A NameValueCollection object that should contain HTTP header name-values pairs.</param>
            <param name="headerName">Name of the header.</param>
            <returns>A array list of values for the header. The values are in the same order as they are stored in the NameValueCollection object.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.AddCanonicalizedResource(System.Uri,System.String,Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString)">
            <summary>
            Add the resource name
            </summary>
            <param name="address"></param>
            <param name="accountName"></param>
            <param name="canonicalizedString"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.AppendStringToCanonicalizedString(System.Text.StringBuilder,System.String)">
            <summary>
            Appends a string to the canonicalized resource string.
            </summary>
            <param name="canonicalizedString">The canonicalized string.</param>
            <param name="stringToAppend">The string to append.</param>
            <returns>The modified canonicalized resource string.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.GetCanonicalizedResource(System.Uri,System.String)">
            <summary>
            Gets the canonicalized resource for the Shared Key Lite authentication scheme.
            </summary>
            <param name="address">The resource address.</param>
            <param name="accountName">The name of the storage account.</param>
            <returns>The canonicalized resource string</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.GetCanonicalizedResourceVersion2(System.Uri,System.String)">
            <summary>
            Gets the canonicalized resource for the Shared Key authentication scheme.
            </summary>
            <param name="address">The resource address.</param>
            <param name="accountName">The name of the storage account.</param>
            <returns>The canonicalized resource string</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy.AddCanonicalizedHeaders(System.Collections.Specialized.NameValueCollection,Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString)">
            <summary>
            Add x-ms- prefixed headers in a fixed order
            </summary>
            <param name="headers"></param>
            <param name="canonicalizedString"></param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobQueueLite">
            <summary>
            Provides an implementation of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy"/> class for blobs and queues
            for the Shared Key Lite authentication scheme.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobQueueLite.CanonicalizeHttpRequest(System.Net.HttpWebRequest,System.String)">
            <summary>
            Canonicalizes the HTTP request.
            </summary>
            <param name="request">An HttpWebRequest object.</param>
            <param name="accountName">Name of the storage account.</param>
            <returns>
            The canonicalized string for the request.
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobQueueFull">
            <summary>
            Provides an implementation of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy"/> class for blobs and queues
            for the Shared Key authentication scheme.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobQueueFull.CanonicalizeHttpRequest(System.Net.HttpWebRequest,System.String)">
            <summary>
            Canonicalizes the HTTP request.
            </summary>
            <param name="request">An HttpWebRequest object.</param>
            <param name="accountName">Name of the storage account.</param>
            <returns>
            The canonicalized string for the request.
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.TableLite">
            <summary>
            Provides an implementation of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy"/> class for tables
            for the Shared Key Lite authentication scheme.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.TableLite.CanonicalizeHttpRequest(System.Net.HttpWebRequest,System.String)">
            <summary>
            Canonicalizes the HTTP request.
            </summary>
            <param name="request">An HttpWebRequest object.</param>
            <param name="accountName">Name of the storage account.</param>
            <returns>
            The canonicalized string for the request.
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.TableFull">
            <summary>
            Provides an implementation of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizationStrategy"/> class for tables
            for the Shared Key authentication scheme.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.TableFull.CanonicalizeHttpRequest(System.Net.HttpWebRequest,System.String)">
            <summary>
            Canonicalizes the HTTP request.
            </summary>
            <param name="request">An HttpWebRequest object.</param>
            <param name="accountName">Name of the storage account.</param>
            <returns>
            The canonicalized string for the request.
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString">
            <summary>
            An internal class that stores the canonicalized string version of an HTTP request.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString.#ctor(System.String)">
            <summary>
            Constructor for the class.
            </summary>
            <param name="initialElement">The first canonicalized element to start the string with.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString.AppendCanonicalizedElement(System.String)">
            <summary>
            Append additional canonicalized element to the string.
            </summary>
            <param name="element">An additional canonicalized element to append to the string.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.CanonicalizedString.Value">
            <summary>
            Property for the canonicalized string.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse">
            <summary>
            Used to parse the HttpWebResponse of a ContainerRequest.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.GetError(System.Net.HttpWebResponse)">
            <summary>
            Parses the error response
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation"/> containing information about the response</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.GetMetadata(System.Net.HttpWebResponse)">
            <summary>
            Gets the metadata from the response.
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> containing all of the user-defined metadata</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.GetMetadata(System.Net.HttpWebResponse,System.String)">
            <summary>
            Gets the metadata for a specific name.
            </summary>
            <param name="response">The response received from server.</param>
            <param name="name">The name of the specific metadata header.</param>
            <returns>An array of metadata values</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.GetAttributes(System.Net.HttpWebResponse)">
            <summary>
            Gets the properties and metadata from server request.
            </summary>
            <param name="response">The response from the server.</param>
            <returns>The properties and metadata returned from the server</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.GetRequestId(System.Net.HttpWebResponse)">
            <summary>
            Gets the request id from response.
            </summary>
            <param name="response">The response from server.</param>
            <returns>The request ID from ther server</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.GetAcl(System.Net.HttpWebResponse)">
            <summary>
            Gets the acl for the container.
            </summary>
            <param name="response">The response for the GetAcl request.</param>
            <returns>A string representing the level of ACL</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerResponse.List(System.Net.HttpWebResponse)">
            <summary>
            Parses a List containers request's response
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse"/> for parsing ListContainers request</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetBlockListResponse">
            <summary>
            Parses the XML response for a Get Block List operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.GetBlockListResponse.ParseXml">
            <summary>
            Parses the XML response returned by a Get Block List operation.
            </summary>
            <returns>A list of blocks </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.GetBlockListResponse.Blocks">
            <summary>
            Gets a list of blocks from the response.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse">
            <summary>
            Parses the XML response for a Get Messages operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse"/> class.
            </summary>
            <param name="stream">The stream of messages to parse.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse.ParseXml">
            <summary>
            Parses the response XML for a Get Messages operation.
            </summary>
            <returns>A list of <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage"/> objects in the response XML.</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse.Messages">
            <summary>
            Gets a list of messages from the response.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse">
            <summary>
            Parse the XML response for a Get Page Ranges operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse"/> class.
            </summary>
            <param name="stream">The stream of page ranges to be parsed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse.ParseXml">
            <summary>
            Parses the XML response for a Get Page Ranges operation.
            </summary>
            <returns>A list of enumerable objects in the XML</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.GetPageRangesResponse.PageRanges">
            <summary>
            Gets a list of page ranges.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse">
            <summary>
            Parses the response XML for a List Blobs operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse"/> class.
            </summary>
            <param name="stream">The stream to be parsed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.ParseXml">
            <summary>
            Parses the response XML for a List Blobs operation.
            </summary>
            <returns>A list of enumerable objects in the XML</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.ListingContext">
            <summary>
            Gets the listing context from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.Blobs">
            <summary>
            Gets a list of blobs from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.Prefix">
            <summary>
            Gets the prefix from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.Marker">
            <summary>
            Gets the marker from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.Delimiter">
            <summary>
            Gets the delimiter from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.MaxResults">
            <summary>
            Gets the maximum results value from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListBlobsResponse.NextMarker">
            <summary>
            Gets the next marker value from the XML response.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse">
            <summary>
            Parses the response XML for a List Containers operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse"/> class.
            </summary>
            <param name="stream">The stream to be parsed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.ParseXml">
            <summary>
            Parses the XML response for a List Containers operation.
            </summary>
            <remarks>This may return a null for an object if it parses non-BlobContainer item (such a property)</remarks>
            <returns>A list of enumerable objects in the XML</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.ListingContext">
            <summary>
            Gets the listing context from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.Containers">
            <summary>
            Gets the list of containers from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.Prefix">
            <summary>
            Gets the prefix from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.Marker">
            <summary>
            Gets the marker from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.MaxResults">
            <summary>
            Gets the maximum results value from the XML response.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListContainersResponse.NextMarker">
            <summary>
            Gets the next marker value from the XML response.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse">
            <summary>
            Parses the XML response for a List Queues operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.ParseXml">
            <summary>
            Parses the XML response for a List Queues operation.
            </summary>
            <returns>A list of enumerable objects in the XML</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.ListingContext">
            <summary>
            Gets the listing context.
            </summary>
            <value>The listing context.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.Queues">
            <summary>
            Gets a list of queues.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.Prefix">
            <summary>
            Gets the prefix used for enumeration.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.Marker">
            <summary>
            Gets the marker used for continuations.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.MaxResults">
            <summary>
            Gets the max results setting.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse.NextMarker">
            <summary>
            Gets the next marker for use in continuations.
            </summary>
            <value>The next marker.</value>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse">
            <summary>
            Parses the response XML for a Peek Messages operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse"/> class.
            </summary>
            <param name="stream">The stream to be parsed.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse.ParseXml">
            <summary>
            Parses the response XML for a Peek Messages operation.
            </summary>
            <returns>A list of enumerable objects in the XML</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse.Messages">
            <summary>
            Gets a list of the message.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage">
            <summary>
            Represents a message retrieved from a queue.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.ExpirationTime">
            <summary>
            Gets the message expiration time.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.Id">
            <summary>
            Gets the message ID.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.InsertionTime">
            <summary>
            Gets the time the message was added to the queue.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.TimeNextVisible">
            <summary>
            Gets the time the message is next visible.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.PopReceipt">
            <summary>
            Gets the pop receipt for the message.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.Text">
            <summary>
            Gets the text of the message.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage.DequeueCount">
            <summary>
            Gets the number of times this message has been dequeued.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueEntry">
            <summary>
            Represents a queue item returned in the XML response for a List Queues operation.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueEntry.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.QueueAttributes)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueEntry"/> class.
            </summary>
            <param name="name">The name of the queue.</param>
            <param name="attributes">The queue's attributes.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueEntry.Name">
            <summary>
            Gets the name of the queue.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.QueueEntry.Attributes">
            <summary>
            Gets the queue's attributes.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse">
            <summary>
            Provides parsing for Queue responses
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetError(System.Net.HttpWebResponse)">
            <summary>
            Parses the error response
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.StorageExtendedErrorInformation"/> containing information about the response</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetMetadata(System.Net.HttpWebResponse)">
            <summary>
            Gets the metadata from the response.
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> containing all of the user-defined metadata</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetMetadata(System.Net.HttpWebResponse,System.String)">
            <summary>
            Gets the metadata for a specific name.
            </summary>
            <param name="response">The response received from server.</param>
            <param name="name">The name of the specific metadata header.</param>
            <returns>An array of metadata values</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetRequestId(System.Net.HttpWebResponse)">
            <summary>
            Gets the request id from response.
            </summary>
            <param name="response">The response from server.</param>
            <returns>The request ID from ther server</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetApproximateMessageCount(System.Net.HttpWebResponse)">
            <summary>
            Gets the approximate message count.
            </summary>
            <param name="response">The response from server.</param>
            <returns>The approximate count returned from server</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetMessages(System.IO.Stream)">
            <summary>
            Parses the GetMessages request.
            </summary>
            <param name="stream">The stream to parse.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse"/> class to parse the response </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.GetMessages(System.Net.HttpWebResponse)">
            <summary>
            Parses the GetMessages request.
            </summary>
            <param name="response">The response from the server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.GetMessagesResponse"/> class to parse the response </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.List(System.IO.Stream)">
            <summary>
            Parses the List Queues request.
            </summary>
            <param name="stream">The response stream from the server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse"/> class to parse the response </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.List(System.Net.HttpWebResponse)">
            <summary>
            Parses the List Queues request.
            </summary>
            <param name="response">The response from the server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListQueuesResponse"/> class to parse the response </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.PeekMessages(System.IO.Stream)">
            <summary>
            Parses the PeekMessages request.
            </summary>
            <param name="stream">The response stream from the server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse"/> class to parse the response </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueResponse.PeekMessages(System.Net.HttpWebResponse)">
            <summary>
            Parses the PeekMessages request.
            </summary>
            <param name="response">The response from the server.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.PeekMessagesResponse"/> class to parse the response </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException">
            <summary>
            The exception thrown if the client attempts to parse the response a second time.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException"/> class.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException"/> class.
            </summary>
            <param name="message">The message for the exception.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ResourceConsumedException"/> class.
            </summary>
            <param name="info">The serialization info.</param>
            <param name="context">The context for serialization.</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials">
            <summary>
            Credentials used to sign a request against the storage services.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials.#ctor(System.String,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials"/> class.
            </summary>
            <param name="accountName">The storage account name</param>
            <param name="key">The storage account key</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials"/> class.
            </summary>
            <param name="accountName">The storage account name</param>
            <param name="base64EncodedKey">The account key as a Base64-encoded string</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials.ExportKey">
            <summary>
            Retrieve the account key.
            </summary>
            <returns>A copy of the account key</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials.ExportBase64EncodedKey">
            <summary>
            Retrieve the key in base64 encoded form.
            </summary>
            <returns>The account key as a base64 encoded string</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials.AccountName">
            <summary>
            Account name used in signing request.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.Credentials.Key">
            <summary>
            Key used in signing request.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.StorageKey">
            <summary>
            Container for storage key.
            </summary>
            <remarks>
            May eventually use native APIs to keep key pinned and not memory.
            </remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudQueue">
            <summary>
            Represents a Windows Azure queue.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.CloudQueue.messageRequestAddress">
            <summary>
            URI for the messages
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.CloudQueue.lastRetrievedTime">
            <summary>
            The last time count was retrieved
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Creates a queue using a relative address.
            </summary>
            <param name="address">The relative address.</param>
            <param name="credentials">The storage account credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Creates a queue using a relative address.
            </summary>
            <param name="address">The relative address.</param>
            <param name="credentials">The storage account credentials.</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.#ctor(System.Nullable{System.Boolean},System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Internal implementaion of the public constructors
            </summary>
            <param name="usePathStyleUris">True to use path style uris</param>
            <param name="address">The address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.#ctor(System.Uri,Microsoft.WindowsAzure.StorageClient.CloudQueueClient)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueue"/> class.
            </summary>
            <param name="queueAddress">The queue address.</param>
            <param name="client">The client.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.#ctor(Microsoft.WindowsAzure.StorageClient.QueueAttributes,Microsoft.WindowsAzure.StorageClient.CloudQueueClient)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueue"/> class.
            </summary>
            <param name="attributes">The attributes of the queue</param>
            <param name="client">The client.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetIndividualMessageAddress(System.String)">
            <summary>
            Gets the individual message address.
            </summary>
            <param name="messageId">The message id.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.Create">
            <summary>
            Creates a queue.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginCreate(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a queue.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndCreate(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create a queue.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.CreateIfNotExist">
            <summary>
            Creates the queue if it does not exist.
            </summary>
            <returns><c>true</c> if the container did not exist and was created; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginCreateIfNotExist(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create the queue if it does not exist.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndCreateIfNotExist(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create the queue if it does not exist.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.Delete">
            <summary>
            Deletes the queue.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginDelete(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the queue. 
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndDelete(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete the queue.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.Exists">
            <summary>
            Existses this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginExists(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to determine whether the queue exists.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndExists(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to determine whether the queue exists.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.FetchAttributes">
            <summary>
            Fetches queue attributes
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginFetchAttributes(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to fetch queue attributes.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndFetchAttributes(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to fetch queue attributes.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.SetMetadata">
            <summary>
            Sets queue metadata.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginSetMetadata(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to set queue metadata.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndSetMetadata(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to set queue metadata.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.RetrieveApproximateMessageCount">
            <summary>
            Retrieves the approximate message count.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.AddMessage(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage)">
            <summary>
            Adds a message to the queue.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.AddMessage(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage,System.TimeSpan)">
            <summary>
            Adds a message to the queue.
            </summary>
            <param name="message">The message.</param>
            <param name="timeToLive">The message time-to-live.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginAddMessage(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to add a message to the queue.
            </summary>
            <param name="message">The message.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginAddMessage(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage,System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to add a message to the queue.
            </summary>
            <param name="message">The message.</param>
            <param name="timeToLive">The message time-to-live.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndAddMessage(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to add a message to the queue.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessages(System.Int32)">
            <summary>
            Gets a list of messages from the queue.
            </summary>
            <param name="messageCount">The number of messages to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessages(System.Int32,System.TimeSpan)">
            <summary>
            Gets a list of messages from the queue.
            </summary>
            <param name="messageCount">The number of messages to retrieve.</param>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginGetMessages(System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to get messages from the queue.
            </summary>
            <param name="messageCount">The number of messages to retrieve.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginGetMessages(System.Int32,System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to get messages from the queue.
            </summary>
            <param name="messageCount">The number of messages to retrieve.</param>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndGetMessages(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to get messages from the queue.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessage">
            <summary>
            Gets a single message from the queue.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessage(System.TimeSpan)">
            <summary>
            Gets a single message from the queue.
            </summary>
            <param name="visibilityTimeout">The visibility time out.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginGetMessage(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to get a single message from the queue.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginGetMessage(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to get a single message from the queue.
            </summary>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndGetMessage(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to get a single message from the queue.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessageInternal(System.Nullable{System.TimeSpan})">
            <summary>
            Gets the message internal.
            </summary>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessagesInternal(System.Nullable{System.Int32},System.Nullable{System.TimeSpan})">
            <summary>
            Gets the messages internal.
            </summary>
            <param name="numberOfMessages">The number of messages.</param>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginGetMessagesInternal(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.AsyncCallback,System.Object)">
            <summary>
            Begins the get messages internal.
            </summary>
            <param name="numberOfMesages">The number of mesages.</param>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.PeekMessage">
            <summary>
            Gets a message from the queue, but does not alter the visibility of the message.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginPeekMessage(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to peek a message.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndPeekMessage(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to peek a message.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.PeekMessages(System.Int32)">
            <summary>
            Gets a list of messages from the queue, but does not alter the visibility of the messages.
            </summary>
            <param name="messageCount">The number of messages to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginPeekMessages(System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to peek messages.
            </summary>
            <param name="messageCount">The number of messages to retrieve.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndPeekMessages(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to peek messages.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.DeleteMessage(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage)">
            <summary>
            Deletes the message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.DeleteMessage(System.String,System.String)">
            <summary>
            Deletes the message.
            </summary>
            <param name="messageId">The message id.</param>
            <param name="popReceipt">The pop receipt.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginDeleteMessage(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the message.
            </summary>
            <param name="message">The message.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginDeleteMessage(System.String,System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to delete the message.
            </summary>
            <param name="messageId">The message id.</param>
            <param name="popReceipt">The pop receipt.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndDeleteMessage(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete the message.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.Clear">
            <summary>
            Clears all messages from the queue.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.BeginClear(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to clear messages from the queue.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.EndClear(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to clear messages from the queue.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.ExistsImpl(System.Action{System.Boolean})">
            <summary>
            Existses the impl.
            </summary>
            <param name="setResult">The set result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.SetMetadataImpl">
            <summary>
            Sets the metadata impl.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.FetchAttributesImpl">
            <summary>
            Fetches the metadata and properties impl.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.CreateImpl">
            <summary>
            Creates the impl.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.CreateIfNotExistImpl(System.Action{System.Boolean})">
            <summary>
            Creates if not exist impl.
            </summary>
            <param name="setResult">The set result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.DeleteImpl">
            <summary>
            Deletes the impl.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.ClearMessagesImpl">
            <summary>
            Clears the messages impl.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.AddMessageImpl(Microsoft.WindowsAzure.StorageClient.CloudQueueMessage,System.Nullable{System.TimeSpan})">
            <summary>
            Adds the message impl.
            </summary>
            <param name="message">The message.</param>
            <param name="timeToLive">The time to live.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.PeekMessagesImpl(System.Nullable{System.Int32},System.Action{System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.CloudQueueMessage}})">
            <summary>
            Peeks the messages impl.
            </summary>
            <param name="numberOfMessages">The number of messages.</param>
            <param name="setResult">The set result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.DeleteMessageImpl(System.String,System.String)">
            <summary>
            Deletes the message impl.
            </summary>
            <param name="messageId">The message id.</param>
            <param name="popReceipt">The pop receipt.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetMessagesImpl(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Action{System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.CloudQueueMessage}})">
            <summary>
            Gets the messages impl.
            </summary>
            <param name="numberOfMessages">The number of messages.</param>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <param name="setResult">The set result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.MaterializeAndParseResponse(System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage},System.Func{Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage,Microsoft.WindowsAzure.StorageClient.CloudQueueMessage})">
            <summary>
            // Materialize results so that we can close the response object
            </summary>
            <param name="protocolList">List of response objects from the Protocol layer</param>
            <param name="responseProjector">Projection function</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.SelectGetMessageResponse(Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage)">
            <summary>
            Selects the get message response.
            </summary>
            <param name="protocolMessage">The protocol message.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.SelectPeekMessageResponse(Microsoft.WindowsAzure.StorageClient.Protocol.QueueMessage)">
            <summary>
            Selects the peek message response.
            </summary>
            <param name="protocolMessage">The protocol message.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueue.GetPropertiesAndMetadataFromResponse(System.Net.HttpWebResponse)">
            <summary>
            Gets the properties and metadata from response.
            </summary>
            <param name="webResponse">The web response.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.ServiceClient">
            <summary>
            Gets the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueueClient"/> object that represents the Queue service.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.Name">
            <summary>
            Gets the queue name.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.Uri">
            <summary>
            Gets the URI for the queue.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.Attributes">
            <summary>
            Gets the attributes of the queue.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.Metadata">
            <summary>
            Gets user-defined metadata for the queue.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.ApproximateMessageCount">
            <summary>
            Gets the approximate message count.
            </summary>
            <value>The approximate message count.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueue.MessageRequestAddress">
            <summary>
            Uri for general message operations
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.QueueAttributes">
            <summary>
            Represents a set of attributes for a queue.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.QueueAttributes.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.QueueAttributes"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.QueueAttributes.#ctor(Microsoft.WindowsAzure.StorageClient.QueueAttributes)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.QueueAttributes"/> class.
            </summary>
            <param name="other">The attributes to clone</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.QueueAttributes.Metadata">
            <summary>
            Gets user-defined metadata for the queue.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.QueueAttributes.Uri">
            <summary>
            Gets the URI for the queue
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage">
            <summary>
            Represents a message in a queue
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.content">
            <summary>
            The message content
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.MaxMessageSize">
            <summary>
            The maximum message size in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.MaxTimeToLive">
            <summary>
            The maximum amount of time a message is kept in the queue.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.MaxNumberOfMessagesToPeek">
            <summary>
            Maximum number of messages that can be peeked at a time.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.#ctor(System.Byte[])">
            <summary>
            Creates a message from the given message content.
            </summary>
            <param name="content">Message content</param>
            <remarks>
            Regardless of whether the message content is XML or binary data, message contents are 
            converted to Base64 before adding the message to the queue.
            Keep in mind that the size of the Base64-encoded message must be less than or equal to
            the value of <see cref="F:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.MaxMessageSize"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.#ctor(System.String)">
            <summary>
            Creates a message from UTF-8-encoded message content.
            </summary>
            <param name="content">UTF-8 encoded message content</param>
            <remarks>
            In this implementation, regardless of whether an XML or binary data is passed into this
            function, message contents are converted to base64 before passing the data to the queue service.
            When calculating the size of the message, the size of the base64 encoding is thus the important
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.AsBytes">
            <summary>
            Gets content as bytes.
            </summary>
            <value>As bytes.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.Id">
            <summary>
            Gets the id.
            </summary>
            <value>The id.</value>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.PopReceipt">
            <summary>
            Gets the pop receipt.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.InsertionTime">
            <summary>
            Gets the insertion time.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.ExpirationTime">
            <summary>
            Gets the expiration time.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.NextVisibleTime">
            <summary>
            Gets the next visible time.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.AsString">
            <summary>
            Gets the content as string.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage.DequeueCount">
            <summary>
            Gets the number of times this message has been dequeued.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudQueueClient">
            <summary>
            A client for accessing Windows Azure queue service
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Create a queue service client for a given base address.
            </summary>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Create a queue service client for a given base address.
            </summary>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.#ctor(System.Uri,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Create a queue service client for a given base address
            </summary>
            <param name="baseAddressUri">The base address URI.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.#ctor(System.Uri,Microsoft.WindowsAzure.StorageCredentials,System.Boolean)">
            <summary>
            Create a queue service client for a given base address
            </summary>
            <param name="baseAddressUri">The base address URI.</param>
            <param name="credentials">The credentials.</param>
            <param name="usePathStyleUris">if set to <c>true</c> [use path style uris].</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.#ctor(System.Nullable{System.Boolean},System.Uri,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Internal implementation of uri based constructors
            </summary>
            <param name="usePathStyleUris">True to use path style uris</param>
            <param name="baseAddressUri"></param>
            <param name="credentials"></param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.GetQueueReference(System.String)">
            <summary>
            Gets a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueue"/> object representing the queue.
            </summary>
            <param name="queueAddress">The relative URI to the queue</param>
            <returns>
            A <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueue"/> object representing the queue.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ListQueues">
            <summary>
            Lists all of the queues in the storage account.
            </summary>
            <returns>A list of queues</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ListQueues(System.String)">
            <summary>
            Lists the queues whose name begin with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <returns>A list of containers</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ListQueues(System.String,Microsoft.WindowsAzure.StorageClient.QueueListingDetails)">
            <summary>
            Lists the queues whose name begin with the specified prefix. 
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <returns>A list of queues</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ListQueuesSegmented">
            <summary>
            Lists all of the queues in the storage account. 
            </summary>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of queues.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ListQueuesSegmented(System.String,Microsoft.WindowsAzure.StorageClient.QueueListingDetails)">
            <summary>
            Lists the queues whose name begin with the specified prefix as a set of pages. 
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of queues.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ListQueuesSegmented(System.String,Microsoft.WindowsAzure.StorageClient.QueueListingDetails,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Lists the queues whose name begin with the specified prefix as a set of pages. 
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of queues.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.BeginListQueuesSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of the list of all queues in the storage account.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.BeginListQueuesSegmented(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of the list of queues whose names begins with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.BeginListQueuesSegmented(System.String,Microsoft.WindowsAzure.StorageClient.QueueListingDetails,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of the list of queues whose names begins with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.BeginListQueuesSegmented(System.String,Microsoft.WindowsAzure.StorageClient.QueueListingDetails,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of the list of queues whose names begins with the specified prefix.
            </summary>
            <param name="prefix">The prefix to match</param>
            <param name="detailsIncluded">The details to include in the listing</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.EndListQueuesSegmented(System.IAsyncResult)">
            <summary>
            Returns a <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> containing the first segment of the list of queues.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>
            <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/>
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.RetryPolicy">
            <summary>
            Default retry policy for queue operations
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.Timeout">
            <summary>
            Default timeout for queue operations
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ApproximateMessageCountCacheLength">
            <summary>
            Determines how long is the data cached for returning approximate message count
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.UsePathStyleUris">
            <summary>
            Reflects whether the service client is used with path-style or host-style URIs
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.Credentials">
            <summary>
            Gets the storage account credentials to use for the queue.
            </summary>
        </member>
        <member name="E:Microsoft.WindowsAzure.StorageClient.CloudQueueClient.ResponseReceived">
            <summary>
            Occurs when a response is received from the server.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.QueueListingDetails">
            <summary>
            Specifies which details to include when listing queues
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.QueueListingDetails.None">
            <summary>
            No extra details
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.QueueListingDetails.Metadata">
            <summary>
            Include metadata
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.QueueListingDetails.All">
            <summary>
            Include all available details
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobListingContext">
            <summary>
            Provides context for the List Blobs operation.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext">
            <summary>
            Represents the listing context for enumeration operations.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext.#ctor(System.String,System.Nullable{System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext"/> class.
            </summary>
            <param name="prefix">Optional. Filters the results to return only blobs whose names
            begin with the specified prefix.</param>
            <param name="maxResults">Optional. Specifies the maximum number of blobs to return,
            including all BlobPrefix elements.</param>
            <remarks>
            If maxresults is not specified, the server will
            return up to 5,000 items. Setting maxresults to a value greater than 5,000 results
            in error response code 400 (Bad Request).
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext.Prefix">
            <summary>
            Gets or sets the prefix string.
            </summary>
            <value>The prefix.</value>
            <remarks>
            Including a prefix string on the request filters the results to return only blobs whose names
            begin with the specified prefix.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext.MaxResults">
            <summary>
            Gets or sets the max results.
            </summary>
            <value>The max results.</value>
            <remarks>
            Specifies the maximum number of blobs to return, including all BlobPrefix elements.
            If maxresults is not specified, the server will return up to 5,000 items. Setting
            maxresults to a value greater than 5,000 results in error response code 400 (Bad Request).
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext.Marker">
            <summary>
            Gets or sets the marker.
            </summary>
            <remarks>
            A string value that identifies the portion of the 
            list to be returned with the next list operation. The operation returns a marker 
            value within the response body if the list returned was not complete. The marker 
            value may then be used in a subsequent call to request the next set of list items.
            </remarks>
            <value>The marker.</value>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobListingContext.#ctor(System.String,System.Nullable{System.Int32},System.String,Microsoft.WindowsAzure.StorageClient.BlobListingDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobListingContext"/> class.
            </summary>
            <param name="prefix">The blob prefix.</param>
            <param name="maxResults">The maximum number of results to return.</param>
            <param name="delimiter">The blob delimiter.</param>
            <param name="include">The include parameter.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.BlobListingContext.Delimiter">
            <summary>
            Gets or sets the delimiter for a List Blobs operation.
            </summary>
            <value>The delimiter.</value>
            <remarks>
            The delimiter parameter enables the caller to traverse the blob namespace by using a user-configured delimiter. 
            Using this parameter, it is possible to traverse a virtual hierarchy of blobs as though it were a file system. 
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.BlobListingContext.Include">
            <summary>
            Gets or sets the value of the include parameter.
            </summary>
            <value>The include parameter.</value>
            <remarks>
            The include parameter specifies that the response should include one or more of the following subsets: snapshots,
            metadata, uncommitted blobs.
            </remarks>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.PageWrite">
            <summary>
            Actions used for writing a page
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.PageWrite.Update">
            <summary>
            Update the page with new data
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.PageWrite.Clear">
            <summary>
            Clear the page
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.LeaseAction">
            <summary>
            Actions that can be performed on a lease
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.LeaseAction.Acquire">
            <summary>
            Acquire the lease
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.LeaseAction.Renew">
            <summary>
            Renew the lease
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.LeaseAction.Release">
            <summary>
            Release the lease
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.LeaseAction.Break">
            <summary>
            Break the lease
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlockSearchMode">
            <summary>
            The block lists to search for blocks specified by a Put Block List operation. 
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.BlockSearchMode.Committed">
            <summary>
            Committed blocks only
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.BlockSearchMode.Uncommitted">
            <summary>
            Uncommitted blocks only
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.BlockSearchMode.Latest">
            <summary>
            Latest available
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.PutBlockListItem">
            <summary>
            Represents a block in a block list.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.PutBlockListItem.#ctor(System.String,Microsoft.WindowsAzure.StorageClient.Protocol.BlockSearchMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.PutBlockListItem"/> class.
            </summary>
            <param name="id">The block ID.</param>
            <param name="searchMode">The block lists to search.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.PutBlockListItem.Id">
            <summary>
            Gets the id.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.PutBlockListItem.SearchMode">
            <summary>
            Gets the search mode.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.PutPageProperties">
            <summary>
            Represents properties for writing to a page blob.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.PutPageProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.Protocol.PutPageProperties"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.PutPageProperties.Range">
            <summary>
            The range of bytes to write to.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.Protocol.PutPageProperties.PageWrite">
            <summary>
            The type of write operation.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest">
            <summary>
            A factory class for constructing blob requests.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.Put(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.BlobProperties,Microsoft.WindowsAzure.StorageClient.BlobType,System.String,System.Int64)">
            <summary>
            Creates a new block blob or page blob, or updates the content of an existing block blob. 
            </summary>
            <param name="uri">The URI for the blob.</param>
            <param name="timeout">The timeout for operation.</param>
            <param name="properties">The properties for blob.</param>
            <param name="blobType">Type of the blob.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <param name="pageBlobSize">Size of the blob for page blobs; for block blobs this parameter is ignored</param>
            <returns>A web request for performing the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.Delete(System.Uri,System.Int32,System.Nullable{System.DateTime},Microsoft.WindowsAzure.StorageClient.DeleteSnapshotsOption,System.String)">
            <summary>
            Returns an <see cref="T:System.Net.HttpWebRequest"/> object to delete the specified blob.
            </summary>
            <param name="uri">The resource URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot version, if the blob is a snapshot.</param>
            <param name="deleteSnapshotsOption">A <see cref="T:Microsoft.WindowsAzure.StorageClient.DeleteSnapshotsOption"/> object indicating whether to delete snapshots.</param>
            <param name="leaseId">The lease ID. Required if the blob has an active lease.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.GetMetadata(System.Uri,System.Int32,System.Nullable{System.DateTime},System.String)">
            <summary>
            Returns the user-defined metadata for this blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <returns>A web request for performing the operiaton</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.SetMetadata(System.Uri,System.Int32,System.String)">
            <summary>
            Sets user-defined metadata for the blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.SignRequest(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request.
            </summary>
            <param name="request">The request.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.AddMetadata(System.Net.HttpWebRequest,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Adds user-defined metadata to the blob.
            </summary>
            <param name="request">The request.</param>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.AddMetadata(System.Net.HttpWebRequest,System.String,System.String)">
            <summary>
            Adds user-defined metadata to the blob.
            </summary>
            <param name="request">The request.</param>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.GetProperties(System.Uri,System.Int32,System.Nullable{System.DateTime},System.String)">
            <summary>
            Returns user-defined metadata for this blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot.</param>
            <param name="leaseId">The lease ID.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.SignRequestForSharedKeyLite(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request for shared key lite.
            </summary>
            <param name="request">The request.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.AddConditional(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind,System.String)">
            <summary>
            Adds a conditional header.
            </summary>
            <param name="request">The request.</param>
            <param name="header">The conditional header.</param>
            <param name="etag">The blob's ETag.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.AddConditional(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind,System.DateTime)">
            <summary>
            Adds a conditional header.
            </summary>
            <param name="request">The request.</param>
            <param name="header">The conditional header.</param>
            <param name="dateTime">The date and time specification for the request.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.List(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.BlobListingContext)">
            <summary>
            Returns the list of all blobs under this container.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="listingContext">The listing context.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.CopyFrom(System.Uri,System.Int32,System.String,System.Nullable{System.DateTime},Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind,System.String,System.String)">
            <summary>
            Returns an <see cref="T:System.Net.HttpWebRequest"/> object to copy a blob.
            </summary>
            <param name="uri">The resource URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="source">The source blob.</param>
            <param name="sourceSnapshot">The snapshot version, if the source blob is a snapshot.</param>
            <param name="sourceConditions">A condition on the source blob.</param>
            <param name="sourceConditionsValue">The value of the condition.</param>
            <param name="leaseId">The lease ID for the source blob.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.Get(System.Uri,System.Int32,System.Nullable{System.DateTime},System.String)">
            <summary>
            Returns an <see cref="T:System.Net.HttpWebRequest"/> object to get the blob's content, properties, and metadata.
            </summary>
            <param name="uri">The resource URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot version, if the blob is a snapshot.</param>
            <param name="leaseId">The lease ID. Optionall</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.Get(System.Uri,System.Int32,System.Nullable{System.DateTime},System.Int64,System.Int64,System.String)">
            <summary>
            Returns a portion (range) of the blob's content with properties and metadata.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot.</param>
            <param name="offset">The offset at which request starts</param>
            <param name="count">The number of bytes to download</param>
            <param name="leaseId">Optional lease id</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.GetBlockList(System.Uri,System.Int32,System.Nullable{System.DateTime},Microsoft.WindowsAzure.StorageClient.BlockListingFilter,System.String)">
            <summary>
            Returns the list of blocks for the List blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot.</param>
            <param name="typesOfBlocks">Type of the blocks included in the list.</param>
            <param name="leaseId">Optional</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.GetPageRanges(System.Uri,System.Int32,System.Nullable{System.DateTime},System.String)">
            <summary>
            Return a list of active page ranges for the Index Blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="snapshot">The snapshot.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.Lease(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.LeaseAction,System.String)">
            <summary>
            Acquires, renews, releases or breaks  the lease for the blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="action">The action.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.PutBlock(System.Uri,System.Int32,System.String,System.String)">
            <summary>
            Writes a block that will be part of a blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="blockId">The block id.</param>
            <param name="leaseId">Optional</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.PutBlockList(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.BlobProperties,System.String)">
            <summary>
            Commits a blob by specifying the list of block IDs that make up the blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="properties">The properties.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.WriteBlockListBody(System.Collections.Generic.IEnumerable{Microsoft.WindowsAzure.StorageClient.Protocol.PutBlockListItem},System.IO.Stream)">
            <summary>
            Writes the block list body.
            </summary>
            <param name="blocks">The blocks.</param>
            <param name="outputStream">The output stream.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.PutPage(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.PutPageProperties,System.String)">
            <summary>
            Writes or Clear range of pages into Blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="properties">The properties.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.SetProperties(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.BlobProperties,System.String,System.Nullable{System.Int64})">
            <summary>
            Set the user-defined properties for a blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="properties">The properties.</param>
            <param name="leaseId">The lease ID, if the blob has an active lease.</param>
            <param name="newBlobSize">new blob size if non-null; only applicable to page blob usder the current protocol</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.Snapshot(System.Uri,System.Int32)">
            <summary>
            Create a snapshot for the blob.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.BlobRequest.AddSnapshot(Microsoft.WindowsAzure.StorageClient.Protocol.UriQueryBuilder,System.Nullable{System.DateTime})">
            <summary>
            Adds the snapshot.
            </summary>
            <param name="builder">The builder.</param>
            <param name="snapshot">The snapshot.</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest">
            <summary>
            Factory class for generating blob container requests
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.CreateWebRequest(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.UriQueryBuilder)">
            <summary>
            Creates the web request.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="query">The query.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.GetContainerUriQueryBuilder">
            <summary>
            Gets the container URI query builder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.Create(System.Uri,System.Int32)">
            <summary>
            Creates a new container.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.Delete(System.Uri,System.Int32)">
            <summary>
            Deletes the container and all of its blobs.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.GetMetadata(System.Uri,System.Int32)">
            <summary>
            Retrieves metadata headers on the container.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.GetProperties(System.Uri,System.Int32)">
            <summary>
            Returns the user-defined metadata for this container.
            </summary>
            <param name="uri"></param>
            <param name="timeout"></param>
            <returns>A web request for performing the operation</returns>     
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.SetMetadata(System.Uri,System.Int32)">
            <summary>
            Sets user-defined metadata for the container.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>
            A web request for performing the operation
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.SignRequest(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request.
            </summary>
            <param name="request">The request.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.AddMetadata(System.Net.HttpWebRequest,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Adds the metadata.
            </summary>
            <param name="request">The request.</param>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.AddMetadata(System.Net.HttpWebRequest,System.String,System.String)">
            <summary>
            Adds the metadata.
            </summary>
            <param name="request">The request.</param>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.SignRequestForSharedKeyLite(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request for shared key lite.
            </summary>
            <param name="request">The request.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.AddConditional(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind,System.String)">
            <summary>
            Adds the conditional.
            </summary>
            <param name="request">The request.</param>
            <param name="header">The header.</param>
            <param name="etag">The ETag.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.AddConditional(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind,System.DateTime)">
            <summary>
            Adds the conditional.
            </summary>
            <param name="request">The request.</param>
            <param name="header">The header.</param>
            <param name="dateTime">The date time.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.List(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext,Microsoft.WindowsAzure.StorageClient.ContainerListingDetails)">
            <summary>
            Returns the list of all containers under this storage account.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="listingContext">The listing context.</param>
            <param name="detailsIncluded">Extra details to include in the listing</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.GetAcl(System.Uri,System.Int32)">
            <summary>
            Returns the ACL for this container.
            </summary>
            <param name="uri"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.SetAcl(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.BlobContainerPublicAccessType)">
            <summary>
            Sets the ACL for the container.
            </summary>
            <param name="uri"></param>
            <param name="timeout"></param>
            <param name="publicAccess">Set to "container" or "blob" to set or use empty to clear it</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ContainerRequest.WriteSharedAccessIdentifiers(Microsoft.WindowsAzure.StorageClient.SharedAccessPolicies,System.IO.Stream)">
            <summary>
            Writes the shared access identifiers.
            </summary>
            <param name="sharedAccessPolicies">The shared access policy set.</param>
            <param name="outputStream">The output stream.</param>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest">
            <summary>
            Represents a factory for the requests against Queue.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.CreateWebRequest(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.UriQueryBuilder)">
            <summary>
            Creates the web request.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="query">The query.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.Create(System.Uri,System.Int32)">
            <summary>
            Creates the specified URI.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.Delete(System.Uri,System.Int32)">
            <summary>
            Creates a request to delete the specified queue.
            </summary>
            <param name="uri">The URI for queue.</param>
            <param name="timeout">The timeout for operation.</param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.GetMetadata(System.Uri,System.Int32)">
            <summary>
            Returns the user-defined metadata for this queue.
            </summary>
            <param name="uri"></param>
            <param name="timeout"></param>
            <returns>A web request for performing the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.SetMetadata(System.Uri,System.Int32)">
            <summary>
            Sets user-defined metadata for the queue.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns>A web request for performing the operation</returns>        
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.SignRequest(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request.
            </summary>
            <param name="request">The request.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.AddMetadata(System.Net.HttpWebRequest,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Adds the metadata.
            </summary>
            <param name="request">The request.</param>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.AddMetadata(System.Net.HttpWebRequest,System.String,System.String)">
            <summary>
            Adds the metadata.
            </summary>
            <param name="request">The request.</param>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.SignRequestForSharedKeyLite(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request for shared key lite.
            </summary>
            <param name="request">The request.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.List(System.Uri,System.Int32,Microsoft.WindowsAzure.StorageClient.Protocol.ListingContext,Microsoft.WindowsAzure.StorageClient.QueueListingDetails)">
            <summary>
            Returns the list of all queues under this storage account.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="listingContext">The listing context.</param>
            <param name="detailsIncluded">Queue details to include in the listing</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.ClearMessages(System.Uri,System.Int32)">
            <summary>
            Clears all messages in the queue.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <returns><see cref="T:System.Net.HttpWebRequest"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.DeleteMessage(System.Uri,System.Int32,System.String)">
            <summary>
            Deletes the specified message.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="popReceipt">The pop receipt.</param>
            <returns><see cref="T:System.Net.HttpWebRequest"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.GetMessages(System.Uri,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Gets a specified number of messages.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="numberOfMessages">The number of messages.</param>
            <param name="visibilityTimeout">The visibility timeout.</param>
            <returns><see cref="T:System.Net.HttpWebRequest"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.PeekMessages(System.Uri,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Gets a specified number of messages without changing their visibility.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="numberOfMessages">The number of messages.</param>
            <returns><see cref="T:System.Net.HttpWebRequest"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.PutMessage(System.Uri,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Adds the message to the queue.
            </summary>
            <param name="uri">The URI.</param>
            <param name="timeout">The operation timeout.</param>
            <param name="messageTimeToLive">The message time-to-live.</param>
            <returns><see cref="T:System.Net.HttpWebRequest"/>
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.QueueRequest.GenerateMessageRequestBody(System.String)">
            <summary>
            Generates the message request body from a string containing the message.
            </summary>
            <param name="message">The message.</param>
            <returns>An array of bytes
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind">
            <summary>
            Conditional headers.
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind.None">
            <summary>
            No conditions
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind.IfUnmodifiedSince">
            <summary>
            If the resource has not been modified since the specified time
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind.IfMatch">
            <summary>
            If the specified ETag matches the value stored by the service
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind.IfModifiedSince">
            <summary>
            If the resource has been modified since the specified time
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.ConditionHeaderKind.IfNoneMatch">
            <summary>
            If the specified ETag does not match the value stored by the service
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.UriQueryBuilder.AddToUri(System.Uri)">
            <summary>
            Add query parameter to an existing Uri. This takes care of any existing query parameters in the Uri
            </summary>
            <param name="uri">Original uri which may contain query parameters already</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Request.SignRequestForBlobAndQueue(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs the request appropriately to make it an authenticated request for Blob and Queue
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Request.SignRequestForTablesSharedKey(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs requests using the SharedKey authentication scheme for the table storage service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Request.SignRequestForTablesSharedKeyLite(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs requests using the SharedKeyLite authentication scheme with is used for the table storage service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Request.SignRequestForBlobAndQueuesSharedKeyLite(System.Net.HttpWebRequest,Microsoft.WindowsAzure.StorageClient.Protocol.Credentials)">
            <summary>
            Signs requests using the SharedKeyLite authentication scheme with is used for the table storage service.
            Currently we only support for table
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Request.ConvertDateTimeToHttpString(System.DateTime)">
            <summary>
            Creates a standard datetime string for the shared key lite authentication scheme.
            </summary>
            <param name="dateTime">DateTime value to convert to a string in the expected format.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.ParseExtensions">
            <summary>
            A class to help with parsing
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.ParseExtensions.ToUTCTime(System.String)">
            <summary>
            Converts a string to UTC time.
            </summary>
            <param name="str">The string to convert.</param>
            <returns>A UTC representation of the string</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.Response">
            <summary>
            Implements the common parsing between all the responses
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetError(System.Net.HttpWebResponse)">
            <summary>
            Gets the error details from the response object.
            </summary>
            <param name="response">The response from server.</param>
            <returns>An extended error information parsed from the input</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetHeaders(System.Net.HttpWebResponse)">
            <summary>
            Gets the headers (metadata or properties).
            </summary>
            <param name="response">The response from sever.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> of all the headers</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetMetadata(System.Net.HttpWebResponse)">
            <summary>
            Gets the user-defined metadata.
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> of the metadata</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetMetadata(System.Net.HttpWebResponse,System.String)">
            <summary>
            Gets a specific user-defined metadata.
            </summary>
            <param name="response">The response from server.</param>
            <param name="name">The metadata header requested</param>
            <returns>An array of the values for the metadata</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetProperties(System.Net.HttpWebResponse)">
            <summary>
            Gets the storage properties.
            </summary>
            <param name="response">The response from server.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> of the properties</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetProperties(System.Net.HttpWebResponse,System.String)">
            <summary>
            Gets a specific storage property.
            </summary>
            <param name="response">The response from server.</param>
            <param name="name">The property requested</param>
            <returns>An array of the values for the property</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetRequestId(System.Net.HttpWebResponse)">
            <summary>
            Gets the request id.
            </summary>
            <param name="response">The response from server.</param>
            <returns>the request ID</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.Protocol.Response.GetMetadataOrProperties(System.Net.HttpWebResponse,System.String)">
            <summary>
            Gets the metadata or properties.
            </summary>
            <param name="response">The response from server.</param>
            <param name="prefix">The prefix for all the headers.</param>
            <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection"/> of the headers with the prefix</returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.Protocol.Constants">
            <summary>
            Contains storage constants
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.DefaultWriteBlockSizeBytes">
            <summary>
            Default Write Block Size used by Blob stream
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.DefaultReadAheadSizeBytes">
            <summary>
            Default Read Ahead Size used by Blob stream      
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.DefaultBufferSize">
            <summary>
            Default size of buffer for unknown sized requests 
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.MaxSingleUploadBlobSize">
            <summary>
            The maximum size of a blob before it must be separated into blocks
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.MaxBlobSize">
            <summary>
            The maximum size of a blob with blocks
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.MaxBlockSize">
            <summary>
            The maximum size of a single block
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.MaxBlockNumber">
            <summary>
            The maximum number of blocks
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.PageSize">
            <summary>
            The size of a page in a PageBlob
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.MaxSharedAccessPolicyIdentifiers">
            <summary>
            Maximum number of shared access policy identifiers supported by server
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.KB">
            <summary>
            A constant representing a kilo-byte (Non-SI version)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.MB">
            <summary>
            A constant representing a megabyte (Non-SI version)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.GB">
            <summary>
            A constant representing a megabyte (Non-SI version)
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.DefaultClientSideTimeout">
            <summary>
            Default client side timeout for all service clients
            </summary>
        </member>
        <member name="F:Microsoft.WindowsAzure.StorageClient.Protocol.Constants.BlockPrefix">
            <summary>
            This is used to create BlockIDs. The prefix must be Base64 compatible
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudTableClient">
            <summary>
            A client for accessing the Windows Azure Table service
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableClient"/> class.
            </summary>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.GetDataServiceContext">
            <summary>
            Creates a new <see cref="T:Microsoft.WindowsAzure.StorageClient.TableServiceContext"/> for performing operations against table storage.
            </summary>
            <returns>
            A new <see cref="T:Microsoft.WindowsAzure.StorageClient.TableServiceContext"/> for performing operations against table storage.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.Attach(System.Data.Services.Client.DataServiceContext)">
            <summary>
            Attaches to the specified service context.
            </summary>
            <param name="serviceContext">The service context.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginCreateTable(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asychronous operation to create a table.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndCreateTable(System.IAsyncResult)">
            <summary>
            Ends an asychronous operation to create a table.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTable(System.String)">
            <summary>
            Creates the table with specified name.
            </summary>
            <param name="tableName">Name of the table to create.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginCreateTableIfNotExist(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to create a table with the specified name if it does not already exist.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndCreateTableIfNotExist(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to create a table with the specified name if it does not already exist.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>true</c>, if table was created, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTableIfNotExist(System.String)">
            <summary>
            Creates the table if it does not exist.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns><c>true</c> if table was created, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginDoesTableExist(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous operation to determine whether or not a table exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndDoesTableExist(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to verify if table exists.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>True</c>, if table exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DoesTableExist(System.String)">
            <summary>
            Checks whether the table exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>
            <c>True</c>, if table exists, <c>false</c> otherwise
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTablesFromModel(System.Type,System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Creates the tables needed for the specified custom TableServiceContext.
            </summary>
            <param name="serviceContextType">Type of the service context.</param>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTables">
            <summary>
            Lists the tables in the storage account.
            </summary>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTables(System.String)">
            <summary>
            Lists the tables which begin with particular prefix.
            </summary>
            <param name="prefix">The prefix.</param>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmented">
            <summary>
            Lists the tables as a set of pages.
            </summary>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmented(System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Lists the tables as a set of pages.
            </summary>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmented(System.String,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Lists the tables which begin with particular prefix as a set of pages.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>A list of table names</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginListTablesSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to list tables.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginListTablesSegmented(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous o
            peration to list tables.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginListTablesSegmented(System.String,System.Int32,Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to list tables.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="maxResults">Non negative value which indicates the maximum number of results that should be returned at a time. Zero means no limit.
            Note the returned ResultSegment.Results may still have less than the maxResults number of results. 
            Use <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> to return the remaining results.</param>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">The user-provided state.</param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndListTablesSegmented(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to list tables.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns>A segment containing current results and information to retrieve additional results.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginDeleteTable(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to delete a table.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndDeleteTable(System.IAsyncResult)">
            <summary>
            Ends an asynchronous operation to delete a table.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTable(System.String)">
            <summary>
            Deletes the table.
            </summary>
            <param name="tableName">Name of the table.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BeginDeleteTableIfExist(System.String,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to delete the tables if it exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.EndDeleteTableIfExist(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to delete the tables if it exists.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns><c>True</c>, if the table was deleted, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTableIfExist(System.String)">
            <summary>
            Deletes the table if it exists.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns><c>True</c>, if the table was deleted, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTableImpl(System.String)">
            <summary>
            Creates the table implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.CreateTableIfNotExistImpl(System.String,System.Action{System.Boolean})">
            <summary>
            Creates the table if not exist implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="setResult">The set result.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DoesTableExistImpl(System.String,System.Action{System.Boolean})">
            <summary>
            Verifies whether the table exist implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="setResult">The set result.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.ListTablesSegmentedImpl(System.String,System.Nullable{System.Int32},Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.Action{Microsoft.WindowsAzure.StorageClient.ResultSegment{System.String}})">
             <summary>
             Lists the tables segmented implementation.
             </summary>
             <param name="prefix">The prefix.</param>
            <param name="maxResults"></param>
            <param name="continuationToken"></param>
             <param name="setResult">The set result.</param>
             <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.GetResultOrDefault``1(Microsoft.WindowsAzure.StorageClient.Tasks.Task{``0},``0@)">
            <summary>
            Gets the result or default.
            </summary>
            <typeparam name="T">The type to resolve to result</typeparam>
            <param name="task">The task.</param>
            <param name="result">The result.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTableImpl(System.String)">
            <summary>
            Delete table implementation.
            </summary>
            <param name="tableName">Name of the table.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableClient.DeleteTableIfExistImpl(System.String,System.Action{System.Boolean})">
            <summary>
            Deletes table if exists implementation .
            </summary>
            <param name="tableName">Name of the table.</param>
            <param name="setResult">The set result.</param>
            <returns>A sequence of tasks to do the operation</returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.BaseUri">
            <summary>
            Gets the base URI for the Table service
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.RetryPolicy">
            <summary>
            Gets or sets the retry policy for all of the requests by the service client
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.Timeout">
            <summary>
            Gets or sets the timeout for all of the requests by the service client
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableClient.Credentials">
            <summary>
            Gets the credentials used by the client
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableServiceContext">
            <summary>
            A version of <see cref="T:System.Data.Services.Client.DataServiceContext"/> to work on Windows Azure Table service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.#ctor(System.String,Microsoft.WindowsAzure.StorageCredentials)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.TableServiceContext"/> class.
            </summary>
            <param name="baseAddress">The base address.</param>
            <param name="credentials">The credentials.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.BeginSaveChangesWithRetries(System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to save changes while applying the retry policy.
            </summary>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.BeginSaveChangesWithRetries(System.Data.Services.Client.SaveChangesOptions,System.AsyncCallback,System.Object)">
            <summary>
            Begins the asynchronous operation to save changes while applying the retry policy.
            </summary>
            <param name="options">The options for saving changes.</param>
            <param name="callback">A callback method that is called when the asynchronous operation completes.</param>
            <param name="state">A user-defined object that contains information about the asynchronous operation. </param>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.EndSaveChangesWithRetries(System.IAsyncResult)">
            <summary>
            Ends the asynchronous operation to save changes while applying the retry policy.
            </summary>
            <param name="asyncResult">An object of type <see cref="T:System.IAsyncResult"/> that references the asynchronous operation.</param>
            <returns> A <see cref="T:System.Data.Services.Client.DataServiceResponse"/> that represents the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.SaveChangesWithRetries">
            <summary>
            Saves changes while applying the retry policy.
            </summary>
            <returns> A <see cref="T:System.Data.Services.Client.DataServiceResponse"/> that represents the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.SaveChangesWithRetries(System.Data.Services.Client.SaveChangesOptions)">
            <summary>
            Saves changes while applying the retry policy.
            </summary>
            <param name="options">The options for saving changes.</param>
            <returns> A <see cref="T:System.Data.Services.Client.DataServiceResponse"/> that represents the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.SaveChangesWithRetriesImpl(System.Data.Services.Client.SaveChangesOptions,System.Action{System.Data.Services.Client.DataServiceResponse})">
            <summary>
            Saves the changes with retries implementation.
            </summary>
            <param name="options">The options for saving changes.</param>
            <param name="setResult">The action to set result.</param>
            <returns>A sequence of tasks to perform the operation</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceContext.DataContextSendingRequest(System.Object,System.Data.Services.Client.SendingRequestEventArgs)">
            <summary>
            Callback on DataContext object sending request.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:System.Data.Services.Client.SendingRequestEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceContext.RetryPolicy">
            <summary>
            Gets or sets the retry policy for all of the requests by the service client
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceContext.StorageCredentials">
            <summary>
            Gets the storage account credentials used by the client
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableServiceEntity">
            <summary>
            Represents an entity in a table.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.#ctor(System.String,System.String)">
            <summary>
            Creates a TableServiceEntity object.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.#ctor">
            <summary>
            Creates a TableServiceEntity object.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.Timestamp">
            <summary>
            Gets or sets the timestamp.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.PartitionKey">
            <summary>
            The partition key of a table entity.
            </summary>
            <remarks>
            The concatenation of the partition key 
            and row key must be unique within the table.
            </remarks>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceEntity.RowKey">
            <summary>
            The row key of a table entity.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.TableServiceExtensionMethods">
            <summary>
            A class for adding useful methods for the Table service.
            </summary>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceExtensionMethods.AsTableServiceQuery``1(System.Linq.IQueryable{``0})">
            <summary>
            Converts the query into a <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/> object that supports 
            additional operations like retries.
            </summary>
            <typeparam name="TElement">The type of the element.</typeparam>
            <param name="query">The query.</param>
            <returns>
            <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/>
            </returns>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1">
            <summary>
            Represents a single query request to the Windows Azure Table service.
            </summary>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.#ctor(System.Data.Services.Client.DataServiceQuery{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/> class with the specified <paramref name="query"/>.
            </summary>
            <param name="query">The <see cref="T:System.Data.Services.Client.DataServiceQuery`1"/> object to wrap.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.#ctor(System.Data.Services.Client.DataServiceQuery{`0},Microsoft.WindowsAzure.StorageClient.RetryPolicy)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1"/> class with the specified <paramref name="query"/> and <paramref name="retryPolicy"/>.
            </summary>
            <param name="query">The <see cref="T:System.Data.Services.Client.DataServiceQuery`1"/> object to wrap.</param>
            <param name="policy">The <see cref="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.RetryPolicy"/> to use when retrying requests.</param>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute">
            <summary>
            Executes the query with retries and returns the results.
            </summary>
            <returns>The results of the query.</returns>
            <remarks>The <see cref="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute"/> method makes one request when it is called and further requests as elements are read from the returned result.</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute(Microsoft.WindowsAzure.StorageClient.ResultContinuation)">
            <summary>
            Executes the query with retries and returns the results.
            </summary>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <returns>The results of the query.</returns>
            <remarks>The <see cref="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Execute(Microsoft.WindowsAzure.StorageClient.ResultContinuation)"/> method makes one request when it is called and further requests as elements are read from the returned result.</remarks>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.BeginExecuteSegmented(System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of results of a query.
            </summary>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.BeginExecuteSegmented(Microsoft.WindowsAzure.StorageClient.ResultContinuation,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous request for the first segment of results of a query.
            </summary>
            <param name="continuationToken">Optional continuationToken from previous ResultSegment for continuing listing operation</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> delegate.</param>
            <param name="state">An object containing state information for this asynchronous request.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that references the asynchronous request.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.EndExecuteSegmented(System.IAsyncResult)">
            <summary>
            Returns the first segment of results of an asynchronous request to execute a query.
            </summary>
            <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
            <returns>A <see cref="T:Microsoft.WindowsAzure.StorageClient.ResultSegment`1"/> that contains the first segment of results.</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Expand(System.String)">
            <summary>
            Expands the specified path.
            </summary>
            <param name="path">The path.</param>
            <returns>A new query with the expanded path</returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.RetryPolicy">
            <summary>
            Gets or sets the <see cref="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.RetryPolicy"/> to use when retrying requests.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.CloudTableQuery`1.Provider">
            <summary>
            Gets the query provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="M:Microsoft.WindowsAzure.StorageClient.TableServiceTable.#ctor(System.String)">
            <summary>
            Creates a table with the specified name.
            </summary>
            <param name="name">The name of the table.</param>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.TableServiceTable.TableName">
            <summary>
            The table name.
            </summary>
        </member>
        <member name="T:Microsoft.WindowsAzure.StorageClient.SR">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentEmptyError">
            <summary>
              Looks up a localized string similar to The argument must not be empty string..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentOutOfRangeError">
            <summary>
              Looks up a localized string similar to The argument is out of range.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentTooLargeError">
            <summary>
              Looks up a localized string similar to The argument &apos;{0}&apos; is larger than maximum of &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ArgumentTooSmallError">
            <summary>
              Looks up a localized string similar to The argument &apos;{0}&apos; is smaller than minimum of &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.AttachToTableServiceContext">
            <summary>
              Looks up a localized string similar to Cannot attach to a TableStorageDataServiceContext object. These objects already contain the functionality for accessing the table storage service..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobQSharedKeyLiteUnsuppported">
            <summary>
              Looks up a localized string similar to &quot;Versions before 2009-09-19 do not support Shared Key Lite for Blob And Queue, current target version &apos;{0}&apos;&quot;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobSizeReductonError">
            <summary>
              Looks up a localized string similar to Cannot change size below currently written size.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobSizeTypeMismatch">
            <summary>
              Looks up a localized string similar to A stream blob must have a blob size of 0..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlobTooLargeError">
            <summary>
              Looks up a localized string similar to The blob is larger than maximum supported size &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlocksExistError">
            <summary>
              Looks up a localized string similar to Data already uploaded.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlocksTooSmallError">
            <summary>
              Looks up a localized string similar to The block size must be positive value.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.BlockTooLargeError">
            <summary>
              Looks up a localized string similar to Block size can not be larger than &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotCreateSASForSnapshot">
            <summary>
              Looks up a localized string similar to Cannot create Shared Access Signature for snapshots. Perform the operation on the root blob instead..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotCreateSASSignatureForGivenCred">
            <summary>
              Looks up a localized string similar to Cannot create Shared Access Signature as the credentials does not have account name information. Please check that the credentials used support creating Shared Access Signature..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotCreateSASWithoutAccountKey">
            <summary>
              Looks up a localized string similar to Cannot create Shared Access Signature unless the Account Key credentials are used by the BlobServiceClient..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CannotModifySnapshot">
            <summary>
              Looks up a localized string similar to Cannot perform this operation on a blob representing a snapshot..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ClientSideTimeoutError">
            <summary>
              Looks up a localized string similar to Server operation did not finish within user specified timeout &apos;{0}&apos; seconds, check if operation is valid or try increasing the timeout..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConditionalRequiresDateTime">
            <summary>
              Looks up a localized string similar to If-Modified-Since and If-Unmodified-Since require a DateTime value..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConditionalRequiresETag">
            <summary>
              Looks up a localized string similar to If-Match and If-None-Match require an ETag value..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConditionNotMatchedError">
            <summary>
              Looks up a localized string similar to The conditionals specified for this operation did not match server..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ConfigurationSettingPublisherError">
            <summary>
              Looks up a localized string similar to ConfigurationSettingSubscriber needs to be set before FromConfigurationSetting can be used.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.CredentialsCantSignRequest">
            <summary>
              Looks up a localized string similar to The supplied credentials &apos;{0&apos;} cannot be used to sign request.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.DeleteSnapshotsNotValidError">
            <summary>
              Looks up a localized string similar to The option &apos;{0}&apos; must be &apos;None&apos; to delete a specific snapshot specified by &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.IncompatibleAddressesProvided">
            <summary>
              Looks up a localized string similar to Cannot combine incompatible absolute Uris base &apos;{0}&apos;  relative &apos;{1}&apos;.When trying to combine 2 absolute Uris, the base uri should be a valid base of the relative Uri..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.InvalidAclType">
            <summary>
              Looks up a localized string similar to Invalid acl public access type returned &apos;{0}&apos;. Expected blob or container..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.InvalidContinuationType">
            <summary>
              Looks up a localized string similar to The continuation type passed in is unexpected. Please verify that the correct continuation type is passed in. Expected {0}, found {1}.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.InvalidQueryParametersInsideBlobAddress">
            <summary>
              Looks up a localized string similar to Invalid query parameters inside Blob address &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ListSnapshotsWithDelimiterError">
            <summary>
              Looks up a localized string similar to Listing snapshots is only supported in flat mode (no delimiter). Consider setting BlobRequestOptions.UseFlatBlobListing property to true..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MD5MismatchError">
            <summary>
              Looks up a localized string similar to Calculated MD5 does not match existing property.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MessageTooLarge">
            <summary>
              Looks up a localized string similar to Messages cannot be larger than {0} bytes..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingAccountInformationInUri">
            <summary>
              Looks up a localized string similar to Cannot find account information inside Uri &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingContainerInformation">
            <summary>
              Looks up a localized string similar to Invalid blob address &apos;{0}&apos;, missing container information.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingMandatoryParamtersForSAS">
            <summary>
              Looks up a localized string similar to Missing mandatory parameters for valid Shared Access Signature.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MissingXmsDateInHeader">
            <summary>
              Looks up a localized string similar to Canonicalization did not find a non empty x-ms-date header in the WebRequest. Please use a WebRequest with a valid x-ms-date header in RFC 123 format (example request.Headers[&quot;x-ms-date&quot;] = DateTime.UtcNow.ToString(&quot;R&quot;, CultureInfo.InvariantCulture)).
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MultipleCredentialsProvided">
            <summary>
              Looks up a localized string similar to Cannot provide credentials as part of the address and as constructor parameter. Either pass in the address or use a different constructor..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MultipleSnapshotTimesProvided">
            <summary>
              Looks up a localized string similar to Multiple different snapshot times provided as part of query &apos;{0}&apos; and as constructor parameter &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.MustCallEndMoveNextSegmentFirst">
            <summary>
              Looks up a localized string similar to EndMoveNextSegment must be called before the Current property can be accessed..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.NoMoreResultsForSegmentCursor">
            <summary>
              Looks up a localized string similar to The segment cursor has no more results..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.NotSupportedForPageBlob">
            <summary>
              Looks up a localized string similar to This operation is not supported for creating a PageBlob. Use other operations to create a PageBlob..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.PathStyleUriMissingAccountNameInformation">
            <summary>
              Looks up a localized string similar to Missing account name information inside path style uri. Path style uris should be of the form http://&lt;IPAddressPlusPort&gt;/&lt;accountName&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.RelativeAddressNotPermitted">
            <summary>
              Looks up a localized string similar to Address &apos;{0}&apos; is not an absolute address. Relative addresses are not permitted in here..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.SeekTooFarError">
            <summary>
              Looks up a localized string similar to Attempting to seek past the end of the stream.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.SeekTooLowError">
            <summary>
              Looks up a localized string similar to Attempting to seek before the start of the stream.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.ServerReturnedMoreThanMaxResults">
            <summary>
              Looks up a localized string similar to Server returned more that MaxResults requested.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.TableNameInvalid">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid table name..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.TooManyBlocksError">
            <summary>
              Looks up a localized string similar to The number of blocks is larger than the maximum of &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.TooManyPolicyIdentifiers">
            <summary>
              Looks up a localized string similar to Too many &apos;{0}&apos; shared access policy identifiers provided. Server does not support setting more than &apos;{1}&apos; on a single container..
            </summary>
        </member>
        <member name="P:Microsoft.WindowsAzure.StorageClient.SR.UndefinedBlobType">
            <summary>
              Looks up a localized string similar to The blob type cannot be undefined..
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\SubscriptionFamilyServiceTest\SubscriptionFamilyServiceTest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SubscriptionFamilyServiceTest</name>
    </assembly>
    <members>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\StorageTest\MixStorage.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MixStorage</name>
    </assembly>
    <members>
        <member name="T:MixTest.StorageTests">
            <summary>
            This test group covers the storage submission APIs.
            </summary>
            
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\SettingsManagementTest\MixSettingsManagementTest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MixSettingsManagementTest</name>
    </assembly>
    <members>
        <member name="T:MixTest.SettingsGroupListTestNode`1">
            <summary>
            A test group for a list of SettingsGroup objects.
            </summary>
        </member>
        <member name="T:MixTest.SettingsManagement.V3.STSConfigurationV3">
            <summary>
            BVTs are sufficient for the zero parameter APIs:
            GetClaimTypes
            GetTokenTypes
            
            GetAppliesToInfo is tested by every positive SetAppliesToInfo and RemoveAppliesToInfo test.
            </summary>
        </member>
        <member name="T:MixTest.SettingsManagement.V4.STSConfigurationV4">
            <summary>
            BVTs are sufficient for the zero parameter APIs:
            GetClaimTypes
            GetTokenTypes
            
            GetAppliesToInfo is tested by every positive SetAppliesToInfo and RemoveAppliesToInfo test.
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\TokenManagementManualTest\TokenManagementManualTest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TokenManagementManualTest</name>
    </assembly>
    <members>
        <member name="T:MixTest.GenerateTokensLargeTests">
            <summary>
            Call Mix GenerateTakens API with large number of tokens.
            The tests will run for a long time and should be run only manually.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensLargeTests.P_GetTokenJobStatus_Exponential_Delay">
            <summary>
            For a Failed Job verify between each reprocessing there is an exponential delay which is done by comparing the next Processing date returned by
            GetTokenJobStatus API with the expected value for each retry.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensLargeTests.P_GetTokenJobStatus_Max_Threshold_Validation">
            <summary>
            For a Failed job verify its abandon from future processing and moved to failed state within a defined threshold.
            Verify Number of failures returned by GetTokenJobStatus API is equal number of failures in t_token_job_history which is then equal to tokenService_maxFailureThreshold value
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensLargeTests.P_GetTokenJobStatus_MultiJob_Threshold_Validation">
            <summary>
            Submits 3 Failed job and 1 Passing Job
            Verify all the Failed Jobs are abandon from future processing and moved to failed state within a defined threshold.
            For all failed job verify Number of failures returned by GetTokenJobStatus API is equal number of failures in t_token_job_history which is then equal to tokenService_maxFailureThreshold value
            Passing job is delivered properly
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\TokenManagementTest\TokenManagementTest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TokenManagementTest</name>
    </assembly>
    <members>
        <member name="T:MixTest.GenerateTokensTests">
            <summary>
            This test group covers 2 TokenManagement APIs.
            GenerateTokens
            GetTokenJobStatus
            </summary>
        </member>
        <member name="T:MixTest.GetTokensTests">
            <summary>
            This test group covers GetTokens tests
            </summary>
        </member>
        <member name="T:MixTest.TokenCategoryCTPTests">
            <summary>
            This test group covers 4 TokenManagement APIs:
            ConfigureTokenCategory
            GetTokenCategoryById
            GetTokenCategoryByName
            GetTokenCategoryByOffer
            </summary>
        </member>
        <member name="T:MixTest.TokenCategoryTests">
            <summary>
            This test group covers 4 TokenManagement APIs:
            ConfigureTokenCategory
            GetTokenCategoryById
            GetTokenCategoryByName
            GetTokenCategoryByOffer
            </summary>
        </member>
        <member name="T:MixTest.TokenInfoTests">
             <summary>
             This test group covers 2 TokenManagement APIs.
             GetTokenInfoByToken
             GetTokenInfoByHash
             </summary>
            
        </member>
        <member name="M:MixTest.TokenIntegrationTests.CreateArcadeTokenCategory">
            <summary>
            Create a new token category object
            TokenCategoryId, TokenCategoryName, OfferId, PromotionId and PKPN are different each time
            </summary>
            <returns></returns>
        </member>
        <member name="M:MixTest.TokenIntegrationTests.CreateSubscriptionTokenCategory">
            <summary>
            Create a new token category object
            TokenCategoryId, TokenCategoryName, OfferId, PromotionId and PKPN are different each time
            </summary>
            <returns></returns>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.OneTimeSetup">
            <summary>
            One time setup prior to stress suite execution
            </summary>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.PostRun">
            <summary>
            Wrap up the stress test execution
            </summary>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.JobMonitorWorker">
            <summary>
            Monitor the token generation jobs to completion
            </summary>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.GenerateTokens(System.UInt32,System.Boolean)">
            <summary>
            Generate a specified number of tokens
            </summary>
            <param name="tokenCount">The number of tokens to generate</param>
            <param name="inCTP">Whether or not to invoke the CTP LoadTokenInstance APIs</param>
            <returns>Whether or not the generation job could be successfully started or not</returns>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.ConfigureTokenCategory(System.Boolean)">
            <summary>
            Configure a new token token category
            </summary>
            <returns>The new token category.</returns>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.CreateNewTokenCategory">
            <summary>
            Create a new token category object
            TokenCategoryId, TokenCategoryName, OfferId, PromotionId and PKPN are different each time
            </summary>
            <returns></returns>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.GetTokens(System.Guid,System.Int32)">
            <summary>
            Get the tokens for the job specified.
            </summary>
            <param name="jobId">The ID of the job to retrieve the tokens for.</param>
            <param name="tokenCount">The total number of tokens generated for the job specified.</param>
            <returns>Whether or not the retrieval was a success.</returns>
        </member>
        <member name="M:MixTest.TokenManagementStressTestBase.ThrowResultException(ServerTestFramework.TEST_RESULTS)">
            <summary> This is a temporary workaround for fixing this test suite to compile now that TestNode no longer has a return value.  Ideally the way these stress tests would be changed to directly throw as appropriate, but that is a larger work item that I'll leave up to the owner of this test suite.  Unfortunately in this context we have no better information to use for the exception strings.  </summary>
        </member>
        <member name="T:MixTest.GenerateTokensThousands">
            <summary>
            The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
            the value specified indicates the total number of jobs of that size that are running at any given time.
            This test group covers 2 TokenManagement APIs:
                GenerateTokens is used to actually generate the tokens requests.
                GetTokenJobStatus is used to monitor the status of the token job.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensHundredThousands">
            <summary>
            The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
            the value specified indicates the total number of jobs of that size that are running at any given time.
            This test group covers 2 TokenManagement APIs:
                GenerateTokens is used to actually generate the tokens requests.
                GetTokenJobStatus is used to monitor the status of the token job.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensMillions">
            <summary>
            The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
            the value specified indicates the total number of jobs of that size that are running at any given time.
            This test group covers 2 TokenManagement APIs:
                GenerateTokens is used to actually generate the tokens requests.
                GetTokenJobStatus is used to monitor the status of the token job.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensThousandsInCTP">
            <summary>
            The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
            the value specified indicates the total number of jobs of that size that are running at any given time.
            This test group covers 2 TokenManagement APIs:
                GenerateTokens is used to actually generate the tokens requests.
                GetTokenJobStatus is used to monitor the status of the token job.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensHundredThousandsInCTP">
            <summary>
            The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
            the value specified indicates the total number of jobs of that size that are running at any given time.
            This test group covers 2 TokenManagement APIs:
                GenerateTokens is used to actually generate the tokens requests.
                GetTokenJobStatus is used to monitor the status of the token job.
            </summary>
        </member>
        <member name="T:MixTest.GenerateTokensMillionsInCTP">
            <summary>
            The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
            the value specified indicates the total number of jobs of that size that are running at any given time.
            This test group covers 2 TokenManagement APIs:
                GenerateTokens is used to actually generate the tokens requests.
                GetTokenJobStatus is used to monitor the status of the token job.
            </summary>
        </member>
        <member name="T:MixTest.ConfigureTokenCategory">
            <summary>
            Configures a new token category.
            </summary>
        </member>
        <member name="T:MixTest.ConfigureTokenCategoryInCTP">
            <summary>
            Configures a new token category.
            </summary>
        </member>
        <member name="T:MixTest.GetTokenCategory">
            <summary>
            Calls GetTokenCategory for a TokenCategory that has previously been configured.
            If no TokenCategory is known for this stress instance, ConfigureToken is called
            to prime the system and unblock GetTokenCategory.  If other stress cases are 
            running that are creating TokenCategories, those will be available to this test
            case as well.
            </summary>
        </member>
        <member name="T:MixTest.GetTokenJobStatus">
            <summary>
            Calls GetTokenJobStatus for a token job that has previously been kicked off.
            If no current job is known for this stress instance, a new token generation job is
            kicked off to prime the system and unblock GetTokenJobStatus.  If other stress cases are 
            running that are creating token jobs, those will be available to this test case as well.
            </summary>
        </member>
        <member name="T:MixTest.GetTokens">
            <summary>
            Calls GetTokens for a token job that has previously been delivered.
            If no completed job is known for this stress instance, GenerateTokens is called
            to prime the system and unblock GetTokens.  If other stress cases are 
            running that are creating tokens, those will be available to this test
            case as well.
            </summary>
        </member>
        <member name="T:MixTest.GetTokenInfo">
            <summary>
            Calls GetTokenInfo for a token that has previously been retrieved via GetTokens.
            If no tokens are known for this stress instance, GetTokens is called to prime the 
            system and unblock GetTokenInfo.  If other stress cases are running that are creating 
            tokens, those will be available to this test case as well.
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\TitleManagementTest\MixTitleManagement.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MixTitleManagementTest</name>
    </assembly>
    <members>
        <member name="M:MixTest.TestMobileTitle.#ctor(System.String,System.String)">
            <summary>
            Constructor for TestMobileTitle for testing a mobile title
            </summary>
            <param name="TitlePath">Input Mobile XLAST file</param>
            <param name="LocXMLPath">MobileStatsColumnsLocalized.xml file path</param>
        </member>
        <member name="M:MixTest.TestMobileTitle.ConvertFromMobileToGeneralFormat">
            <summary>
            Convert FriendsStatsView to StatsViewCount.
            _afterConversionXLSP and _afterConversionXML are populated with converted data.
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.VerifyStatsViewCount">
            <summary>
            Verify StatsViewCount after conversion       
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.VerifyLocalizedStrings">
            <summary>
            Verify LocalizedStrings data after conversion       
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.IfLocExists(xonline.common.xlastutil.LocalizedString)">
            <summary>
            Help function to check if the given LocalizedString item is present in the _afterConversionXLSP object under LocalizedStrings node
            It compares each member in LocalizedString object and returns true if they match
            </summary>
            <param name="locStr">input LocalizedString object to find</param>
            <returns>true if input LocalizedString object is found in the XLSP after conversion</returns>
        </member>
        <member name="M:MixTest.TestMobileTitle.InitializeVerification">
            <summary>
            Verifies if the _beforeConversionXLSP and _afterConversionXLSP objects are available and not null
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.VerifyProperties">
            <summary>
            Verify Properties data after conversion       
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.IfPropertyExist(xonline.common.xlastutil.XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty)">
            <summary>
            Help function to see if a given Property is present in the Propery list in XLSP after conversion
            </summary>
            <param name="expectedProp"></param>
            <returns>If the input property is found returns true else retrun false</returns>
        </member>
        <member name="M:MixTest.TestMobileTitle.VerifyStatsView">
            <summary>
            Verify StatsView data after conversion       
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.GetStatsView(xonline.common.xlastutil.FriendStatsView)">
            <summary>
            Help functions for VerifyStatsView 
            </summary>
        </member>
        <member name="M:MixTest.TestMobileTitle.VerifyStatsViewData(xonline.common.xlastutil.FriendStatsView,System.Collections.Generic.List{xonline.common.xlastutil.StatsView})">
            <summary>
            Verifies if each FriendsStatsView is properly converted to a pair of StatsView data
            </summary>
            <param name="friendStats">FriendsStatView data from original Mobile XLAST before conversion</param>
            <param name="statsView">StatsView data from converted General format XLAST</param>
        </member>
        <member name="M:MixTest.TestMobileTitle.IfFieldExists(xonline.common.xlastutil.StatsView,xonline.common.xlastutil.ViewFieldType)">
            <summary>
            Verifies if the given ViewFieldType is present in given StatsView columns        
            </summary>
            <param name="_stat">StatsView column</param>
            <param name="_ExpectedField">Input Fiels to find in StatsView columns</param>
            <returns>return true if found else false</returns>
        </member>
        <member name="M:MixTest.TestMobileTitle.BuildField(System.UInt16,System.String,System.Boolean,System.UInt16,System.UInt16,xonline.common.xlastutil.PropertyFieldTypeAggregationType,System.String)">
            <summary>
            Help function to construct ViewFieldType object for verification.
            </summary>
            <param name="_attributeID">attributeID</param>
            <param name="_friendlyName">friendlyName</param>
            <param name="_hidden">hidden</param>
            <param name="_stringId">stringId</param>
            <param name="_ordinal">ordinal</param>
            <param name="_aggegrationType">aggegrationType</param>
            <param name="_propertyID">propertyID</param>
            <returns></returns>
        </member>
        <member name="T:MixTest.TitleManagementTests_MobileWeb_Titles">
            <summary>
            Tests for MobileWeb gameconfig/XLAST title ingestion
            Tests are divided into three categories
            1. Verification for Mobile format to General format, basically checking each FriendsStatsView is converted to a pair of StatsView data.
            2. Verification of MixTitleManagement API and making sure the converted XLAST file can be successfully ingested. This includes both V1 and V2 version.
            3. Verification of MixStats API to make sure a Mobile ingested title ( basically after above 2 steps) can be successfully configured for leaderboard data.
            </summary>
            
        </member>
        <member name="T:MixTest.TitleManagementTests_Positive">
            <summary>
            This test group covers the title management submission API.
            </summary>
            
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\TitleManagement\MobileStatsColumnsLocalized.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<MobileStatsColumnsLocalized>
    <Entry Column="BestScore"   Locale="en-US" Value="Score" />
    <Entry Column="BestTime"    Locale="en-US" Value="Time" />
    <Entry Column="Wins"        Locale="en-US" Value="Wins" />

    <Entry Column="BestScore"   Locale="de-DE" Value="Punkte" />
    <Entry Column="BestTime"    Locale="de-DE" Value="Zeit" />
    <Entry Column="Wins"        Locale="de-DE" Value="Gewinne" />

    <Entry Column="BestScore"   Locale="fr-FR" Value="Score" />
    <Entry Column="BestTime"    Locale="fr-FR" Value="Heure" />
    <Entry Column="Wins"        Locale="fr-FR" Value="Victoires" />

    <Entry Column="BestScore"   Locale="it-IT" Value="Punteggio" />
    <Entry Column="BestTime"    Locale="it-IT" Value="Tempo" />
    <Entry Column="Wins"        Locale="it-IT" Value="Vittorie" />

    <Entry Column="BestScore"   Locale="es-ES" Value="Puntuación" />
    <Entry Column="BestTime"    Locale="es-ES" Value="Tiempo" />
    <Entry Column="Wins"        Locale="es-ES" Value="Juegos ganados" />

    <Entry Column="BestScore"   Locale="ja-JP" Value="スコア" />
    <Entry Column="BestTime"    Locale="ja-JP" Value="タイム" />
    <Entry Column="Wins"        Locale="ja-JP" Value="勝ち" />

    <Entry Column="BestScore"   Locale="ko-KR" Value="점수" />
    <Entry Column="BestTime"    Locale="ko-KR" Value="시간" />
    <Entry Column="Wins"        Locale="ko-KR" Value="승수" />

    <Entry Column="BestScore"   Locale="pt-PT" Value="Pontuação" />
    <Entry Column="BestTime"    Locale="pt-PT" Value="Tempo" />
    <Entry Column="Wins"        Locale="pt-PT" Value="Vitórias" />

    <Entry Column="BestScore"   Locale="pl-PL" Value="Wynik" />
    <Entry Column="BestTime"    Locale="pl-PL" Value="Czas" />
    <Entry Column="Wins"        Locale="pl-PL" Value="Zwycięstwa" />

    <Entry Column="BestScore"   Locale="ru-RU" Value="Счет" />
    <Entry Column="BestTime"    Locale="ru-RU" Value="Время" />
    <Entry Column="Wins"        Locale="ru-RU" Value="Победы" />

    <Entry Column="BestScore"   Locale="zh-CN" Value="分数" />
    <Entry Column="BestTime"    Locale="zh-CN" Value="时间" />
    <Entry Column="Wins"        Locale="zh-CN" Value="获胜次数" />

    <Entry Column="BestScore"   Locale="zh-CHT" Value="分數" />
    <Entry Column="BestTime"    Locale="zh-CHT" Value="時間" />
    <Entry Column="Wins"        Locale="zh-CHT" Value="獲勝次數" />
</MobileStatsColumnsLocalized>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\xCryptoTest\XCryptoDoc.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XCryptoTest</name>
    </assembly>
    <members>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\XConnSrvTest\XConnSrvTestDoc.XML ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XConnSrvTest</name>
    </assembly>
    <members>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases">
            <summary>
            Functional Tests for Connect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.BVT_SingleUser">
            <summary>
            Basic BVT Test which connects a single user on a single connection then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_SameUserDifferentIndicesWithNewConnection">
            <summary>
            Connect a single user on each of 4 indices, one at a time, on a different connection, then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_SameUserDifferentIndicesReuseConnection">
            <summary>
            Connect a single user on each of 4 indices, one at a time, on the same connection, then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_RotateDifferentUserOnSameIndexWithNewConnection">
            <summary>
            Connect 4 different users on the same index on on different connections then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_RotateDifferentUserOnSameIndexReuseConnection">
            <summary>
            Connect 4 different users on the same index on the same connection then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_RotateDifferentUserOnDifferentIndicesWithNewConnection">
            <summary>
            Connect 4 different users on different indices on different connections then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_RotateDifferentUserOnDifferentIndicesReuseConnection">
            <summary>
            Connect 4 different users on different indices (disconnecting the previous) on the same connection then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_UserPairConnecting">
            <summary>
            Connect 2 users at a time (0+2 then 1+3) to the same connection then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_FourUsersConnecting">
            <summary>
            Connect all 4 users at the same time to the same connection then disconnect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_UseNewConnectionEachTimeFromOneConsole">
            <summary>
            Connects 4 different times on different indicies with different connections, but using the same
            xbox console, then disconnects
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_FourUsersConnectingOneByOne">
            <summary>
            Connects 4 users, one at a time, adding a new user each time, on the same connection
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_FourUsersConnectingAndDisconnectingOneByOne">
            <summary>
            Connects 4 users, one at a time, adding a new user each time, and then disconnects one user at a
            time by calling connect with 1 user less each time
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.Basic_Create32Connection">
            <summary>
            Creates 32 connects and connects 1 unique user on each, then disconnects
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.ReconnectSingleUser">
            <summary>
            Basic reconnect test. Connects a single user, disconnects, reconnects, then disconnects again
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.ReconnectBeforeConnect">
            <summary>
            Sends reconnect call before normal connect call
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.ReconnectWithDifferentUsersSameIndicesThanConnect">
            <summary>
            Connects with 2 users on indices 0+1, disconnects, reconnects with 2 new users on indicies 0+1
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.ReconnectWithDifferentUsersAndIndicesThanConnect">
            <summary>
            Connects with users 0+1, disconnects, reconnects with users 2+3
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.ReconnectWithSameAndDifferentUsersThanConnect">
            <summary>
            Connects with users 0+1, disconnects, reconnects with users 0+1+2+3
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_PostiveCases.ReconnectWhileConnected">
            <summary>
            Connects a single user, reconnects with the same user without disconnecting
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases">
            <summary>
            Functional Negative tests for Connect
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.MultipleUsersSameIndex">
            <summary>
            Connect multiple users to the same index. The connection is expected to be dropped
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.MultipleIndicesSameUser">
            <summary>
            Connects the same user to multiple indices. Expected to work
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.MismatchedIndicesIdsSizesMoreIds">
            <summary>
            Sends the connect message with mismatched lengths of indices and userIds, having more Ids
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.MismatchedIndicesIdsSizesMoreIndices">
            <summary>
            Sends the connect message with mismatched lengths of indices and userIds, having more indices
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.DisconnectBeforeConnect">
            <summary>
            Sends the disconnect message before sending the connect message
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.Add5thUserToConnection">
            <summary>
            Attemps to connect a 5th user after 4 are already connected
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.ConnectNoUsers">
            <summary>
            Attempts to connect with no users or indices
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncConnect_NegativeCases.ConnectOneValidOneInvalidUser">
            <summary>
            Attempts to connect one valid (connected to SG) and one invalid user at the same time
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncMemCacheFriendsListTests">
            <summary>
            Functional Tests for Singleton Connection
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncMemCacheFriendsListTests.BVT_MemCacheFriendsListNotifications">
            <summary>
            
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncXConnSrvFriendsListTests.BVT_XConnSrvFriendsList">
            <summary>
            
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases">
             <summary>
             Functional Tests for Language Specific blobs in Velocity.
             
             Random Rich Presence for your clairification pleasure:
             
             console language = 1
             user language = 2
            
             Order of precedence:
             1) Language 1, Country Code
             2) Language 1, Default Country for Language 1
             3) Language 2, Country Code (if L2 != L1)
             4) Language 2, Default County for Language 2 (if L2 != L1)
             5) Default Language for Country Code, Country Code
            
             "de-DE" = GERMAN
             "en-US" = ENGLISH
             "es-ES" = SPANISH
             "fr-FR" = FRENCH
             "it-IT" = ITALIAN
             "ja-JP" = JAPANESE
             "ko-KR" = KOREAN
             "pl-PL" = POLISH
             "pt-PT" = PORTUGUESE
             "ru-RU" = RUSSIAN
             "zh-TW" = TRADITIONAL CHINESE
             "zh-CHT" = TRADITIONAL CHINESE (Testing only?)
             "zh-CN" = SIMPLIFIED CHINESE
             "zh-CHS" = SIMPLIFIED CHINESE (Testing only?)
             </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.BVT_UseLanguage1AndCountryCode">
            <summary>
            BVT Test Case for Rich Presence blob, uses step #1
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.DefaultToLanguage1sCountryCode">
            <summary>
            The pair of Language 1 + Country Code does not give a valid locale, so it goes to step #2 and gets the default
            country code for Language 1, which is ES, thus getting es-ES
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.DefaultToLanguage2AndCountryCode">
            <summary>
            Steps #1 and #2 are not valid, so it goes to step #3 and uses Language 2 and Country code, this getting fr-FR
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.DefaultToLanguage2sCountryCode">
            <summary>
            Steps #1, #2, and #3 are not valid, so it goes to step #4 and uses the default country for Language 2, which is
            PL, thus getting pl-PL
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.DefaultToCountryCodesLanguageAndCountryCode">
            <summary>
            Steps #1, #2, #3, and #4 fail, so it goes to step #5 and uses the default language for the country code, which is
            fr, thus getting fr-FR
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.DefaultToDefault">
            <summary>
            All steps fail so it must default to the default rich presence string, which is the first in the list,
            which in our case is de-DE
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.AllLocalesPointingToSameString">
            <summary>
            All locales in the header are pointing to the same single Rich Presence string in the blob
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.UseLastLanguage">
            <summary>
            Uses the last locale in the TOC
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.TwoUsersSameConsoleDifferentLanguages">
            <summary>
            Two users are logged onto a single xbox and they each have different language settings. One user has
            unsupported languages and country and would default to the default string, and the other has an unsupported language 1
            but a supported language 2. They both subscribe to the same user and the expectation is to get the 2nd
            user's string.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.TwoUsersSameConsoleMixedSettings">
            <summary>
            Two users are logged onto a single xbox and they each have different language settings. User1 has de-DE (default)
            available as a step #3, and user0 has en-CA, which should default to en-US in step #2. We expect en-US since even
            though user1 has an earlier locale, the server loops through the user's locale's first, and user0 is at the top so
            it will use en-US.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.OffsetOutOfRange">
            <summary>
            This will manually change one offset to be out of range of the blob
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncLanguageSpecific_PositiveCases.RichPresenceBySetTitleData">
            <summary>
            This test inserts real Rich Presence data through the Presence FD using SetTitleData with a GIBlob for Pong
            and checks the returned string for accuracy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases">
            <summary>
            Functional Tests for Notifications.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.BVT_Notification">
            <summary>
            BVT Test Case that subscribes a single user to a single friend and triggers a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationFromUserTypes">
            <summary>
            Creates one subscription to each type of user (offline friend remote, offline friend same console,
            online friend remote, online friend same console, etc) and creates a notification for each
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationFromDataTypes">
            <summary>
            Creates one subscription to each data type (Basic Presence, Rich Presence, etc) and
            creates a notification for each
            </summary>
        </member>
        <member name="M:XConnSrvTest.FuncNotification_PositiveCases.NotificationFromDataTypes.pnub_PNUserCreationEvent(System.Object,ServerTestFramework.LiveService.XConnSrv.PNUserCreationEventArgs)">
            <summary>
            This will be used to insert data for all data types besides friends list and basic presence since that will already be done for us.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.MassNotifications">
            <summary>
            Creates 32 users on different consoles who all subscribe to the same subscription. A notification
            is triggered and we verify all 32 users receive it.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationFromUpdatingData">
            <summary>
            Create 1 user subscribed to 1 piece of data, update that data in the cache, and verify that a notification
            is sent to the subscribed user
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationFromDataSizeIncrease">
            <summary>
            A single user subscribes to data, which is then updated to be a larger size, and verifies that the
            user gets a notification of the correct size
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.MultipleUsersSameSubscriptionsSameBox">
            <summary>
            Connect 4 users on the same box, subscribe 3 of them to the same data, issue a notification and confirm
            that only those 3 users received the notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationPartialUsersMultipleConsoles">
            <summary>
            Creates 2 xboxs with 2 users on each, the first user on each is subscribed to the same data. A notification
            is sent and is verified that only the first user on both consoles receives it.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NoNotificationForDisconnectedUser">
            <summary>
            A single user creates a subscription, disconnects, and then when a notification is sent, verifies it isn't
            to the disconnected user.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationDataUpdatedToSame">
            <summary>
            A single user subscribes to data, which is then Set to the same thing, verifies the user
            gets a notification still
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationUnexistantDataExists">
            <summary>
            This verifies that if we subscribe to something which does not yet exist in the cache, that once
            it is added, a notification is sent to the subscribee
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationReceivedWhenDataRemoved">
            <summary>
            This verifies that if we subscribe to something which exists, that when it is removed from the cache
            we get a notification with a sizeof(BASE_DATA_HEADER)
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.DuplicateSubscribeSingleNotification">
            <summary>
            This subscribes a user absolutely then normally to the same object, triggers a notification, and
            verify only 1 notification is received
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NotificationFromSubscriptionOnSameConsole">
            <summary>
            Make subscriptions to users on the same console and get notifications
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.NoNotificationWhenNoOneSignedIn">
            <summary>
            Creates 2 users on a connection and subscribes them to each other, disconnect them, and
            make sure no notifications are received
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.OwnerNotifyBasic">
            <summary>
            Simple case for owner notify functionality
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncNotification_PositiveCases.OwnerNotifyLanguageSpecific">
            <summary>
            Language specific case for owner notify functionality
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPerfCounters_PositiveCases">
            <summary>
            Functional Tests for XConnSrv Performance Counters.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPerfCounters_PositiveCases.ClientConnections">
            <summary>
            Creates 50 connections with a single user on a each connection, verifies the connection count, disconnects
            every connection, verifies the counter is at 0
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPerfCounters_PositiveCases.ConnectedUsers">
            <summary>
            Creates 40 users, 4 users per connection, verifies the user count, disconnects every connection + user, verifies
            the counter is at 0
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPerfCounters_PositiveCases.TotalSubscriptions">
            <summary>
            Creates a single user on a single connection and subscribes to 50 friends' basic presence and 50 friends' rich
            presence, verifies the subscription count, unsubscribes from rich, then unsubscribes from basic, verifies the 
            counter is at 0
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPerfCounters_PositiveCases.ReconnectRate">
            <summary>
            Creates a single user on a single connection, connects normally, then reconnects several times in a row and verifies
            that the counter is not 0, then pauses and confirms it is 0, then repeats with more reconnects. At the end a total
            number of reconnects is verified.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases">
            <summary>
            Functional Tests for Privacy.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BVT_Privacy">
            <summary>
            BVT Test for Privacy 
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicNotificationFriendOpen">
            <summary>
            User subscribes to Friend with open privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicNotificationFriendFriendsOnly">
            <summary>
            User subscribes to Friend with friends-only privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicNotificationFriendBlocked">
            <summary>
            User subscribes to Friend with blocked privacy and doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicNotificationPeerOpen">
            <summary>
            User subscribes to Peer with open privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicNotificationPeerFriendsOnly">
            <summary>
            User subscribes to Peer with friends-only privacy and doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicNotificationPeerBlocked">
            <summary>
            User subscribes to Peer with blocked privacy and doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.PendingFriendNotificationOpen">
            <summary>
            User requests friendship to User with open privacy and then subscribes and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.PendingFriendNotificationFriendsOnly">
            <summary>
            User requests friendship to User with friends-only privacy and then subscribes and does not expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.PendingFriendNotificationBlocked">
            <summary>
            User requests friendship to User with blocked privacy and then subscribes and does not expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationFriendOpenToFriendsOnly">
            <summary>
            User subscribes to Friend with open privacy, Friend changes privacy to friends-only, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationFriendOpenToBlocked">
            <summary>
            User subscribes to Friend with open privacy, Friend changes privacy to blocked, doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationFriendFriendsOnlyToOpen">
            <summary>
            User subscribes to Friend with friends-only privacy, Friend changes privacy to open, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationFriendFriendsOnlyToBlocked">
            <summary>
            User subscribes to Friend with friends-only privacy, Friend changes privacy to blocked, doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationFriendBlockedToOpen">
            <summary>
            User subscribes to Friend with blocked privacy, Friend changes privacy to open, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationFriendBlockedToFriendsOnly">
            <summary>
            User subscribes to Friend with blocked privacy, Friend changes privacy to friends-only, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationPeerOpenToFriendsOnly">
            <summary>
            User subscribes to Peer with open privacy, Peer changes privacy to friends-only, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationPeerOpenToBlocked">
            <summary>
            User subscribes to Peer with open privacy, Peer changes privacy to blocked, doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationPeerFriendsOnlyToOpen">
            <summary>
            User subscribes to Peer with friends-only privacy, Peer changes privacy to open, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationPeerFriendsOnlyToBlocked">
            <summary>
            User subscribes to Peer with friends-only privacy, Peer changes privacy to blocked, doesn't expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationPeerBlockedToOpen">
            <summary>
            User subscribes to Peer with blocked privacy, Peer changes privacy to open, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangePrivacyNotificationPeerBlockedToFriendsOnly">
            <summary>
            User subscribes to Peer with blocked privacy, Peer changes privacy to friends-only, expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangeFriendStatusNotificationOpenFriendToPeer">
            <summary>
            User subscribes to Friend with open privacy, friendship is ended and Friend becomes Peer
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangeFriendStatusNotificationFriendsOnlyFriendToPeer">
            <summary>
            User subscribes to Friend with friends-only privacy, friendship is ended and Friend becomes Peer
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangeFriendStatusNotificationBlockedFriendToPeer">
            <summary>
            User subscribes to Friend with blocked privacy, friendship is ended and Friend becomes Peer
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangeFriendStatusNotificationOpenPeerToFriend">
            <summary>
            User subscribes to Peer with open privacy, friendship is made and Peer becomes Friend
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangeFriendStatusNotificationFriendsOnlyPeerToFriend">
            <summary>
            User subscribes to Peer with friends-only privacy, friendship is made and Peer becomes Friend
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.ChangeFriendStatusNotificationBlockedPeerToFriend">
            <summary>
            User subscribes to Peer with blocked privacy, friendship is made and Peer becomes Friend
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleNotificationFriendOpen">
            <summary>
            User subscribes to friend on same console with open privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleNotificationFriendFriendsOnly">
            <summary>
            User subscribes to friend on same console with friends-only privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleNotificationFriendBlocked">
            <summary>
            User subscribes to friend on same console with blocked privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleNotificationPeerOpen">
            <summary>
            User subscribes to peer on same console with open privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleNotificationPeerFriendsOnly">
            <summary>
            User subscribes to peer on same console with friends-only privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleNotificationPeerBlocked">
            <summary>
            User subscribes to peer on same console with blocked privacy and expects a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationFriendFriendOpen">
            <summary>
            Two users on the same console subscribe to a shared friend with open privacy and expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationFriendFriendFriendsOnly">
            <summary>
            Two users on the same console subscribe to a shared friend with friends-only privacy and expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationFriendFriendBlocked">
            <summary>
            Two users on the same console subscribe to a shared friend with blocked privacy and do not expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationPeerPeerOpen">
            <summary>
            Two users on the same console subscribe to a shared peer with open privacy and expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationPeerPeerFriendsOnly">
            <summary>
            Two users on the same console subscribe to a shared peer with friends-only privacy and do not expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationPeerPeerBlocked">
            <summary>
            Two users on the same console subscribe to a shared peer with blocked privacy and do not expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationFriendPeerOpen">
            <summary>
            Two users (one a friend, one a peer) on the same console subscribe to a user with open privacy and expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationFriendPeerFriendsOnly">
            <summary>
            Two users (one a friend, one a peer) on the same console subscribe to a user with friends-only privacy and expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedNotificationFriendPeerBlocked">
            <summary>
            Two users (one a friend, one a peer) on the same console subscribe to a user with blocked privacy and do not expect a notification
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyFriendOpen">
            <summary>
            User subscribes to Friend with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyFriendFriendsOnly">
            <summary>
            User subscribes to Friend with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyFriendBlocked">
            <summary>
            User subscribes to Friend with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyPeerOpen">
            <summary>
            User subscribes to Peer with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyPeerFriendsOnly">
            <summary>
            User subscribes to Peer with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyPeerBlocked">
            <summary>
            User subscribes to Peer with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyPendingFriendOpen">
            <summary>
            User requests friendship to User with open privacy and then subscribes
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyPendingFriendFriendsOnly">
            <summary>
            User requests friendship to User with friends-only privacy and then subscribes
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.BasicSubscriptionReplyPendingFriendBlocked">
            <summary>
            User requests friendship to User with blocked privacy and then subscribes
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleSubscriptionReplyFriendOpen">
            <summary>
            User subscribes to Friend on the same console with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleSubscriptionReplyFriendFriendsOnly">
            <summary>
            User subscribes to Friend on the same console with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleSubscriptionReplyFriendBlocked">
            <summary>
            User subscribes to Friend on the same console with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleSubscriptionReplyPeerOpen">
            <summary>
            User subscribes to Peer on the same console with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleSubscriptionReplyPeerFriendsOnly">
            <summary>
            User subscribes to Peer on the same console with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleSubscriptionReplyPeerBlocked">
            <summary>
            User subscribes to Peer on the same console with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyFriendFriendOpen">
            <summary>
            Two users on the same console subscribe to a shared friend with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyFriendFriendFriendsOnly">
            <summary>
            Two users on the same console subscribe to a shared friend with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyFriendFriendBlocked">
            <summary>
            Two users on the same console subscribe to a shared friend with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyPeerPeerOpen">
            <summary>
            Two users on the same console subscribe to a shared peer with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyPeerPeerFriendsOnly">
            <summary>
            Two users on the same console subscribe to a shared peer with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyPeerPeerBlocked">
            <summary>
            Two users on the same console subscribe to a shared peer with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyFriendPeerOpen">
            <summary>
            Two users (one a friend, one a peer) on the same console subscribe to a user with open privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyFriendPeerFriendsOnly">
            <summary>
            Two users (one a friend, one a peer) on the same console subscribe to a user with friends-only privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.SameConsoleMixedSubscriptionReplyFriendPeerBlocked">
            <summary>
            Two users (one a friend, one a peer) on the same console subscribe to a user with blocked privacy
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.MultipleMixedSubscriptionReply">
            <summary>
            One user subscribes to 2 users who have different relationships (1 friend, 1 peer) with the subscriber and
            verifies that the privacy for each entry in the reply is valid
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.FriendsManuallyGetNotification">
            <summary>
            A single user subscribes to a peer, manually make friends (request + accept), then confirm
            notifications are sent without logging off/on
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPrivacy_PositiveCases.PSBugNum37361">
            <summary>
            This was the issue where XConnSrv would get into a deadlock when the following happens:
                User A is subscribed to User B
                User B has privacy set to friends only
                User B has a notification to send
                XConnSrv iterates through User A's (as well as all other User B subscribers) friend list to see if they are friends and a notification should be sent
                User A disconnects while their friend list is being traversed
                Bam, there it is -> deadlock
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncPublish_PostiveCases">
            <summary>
            Functional Tests for Publish
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSingleConnectionTests">
            <summary>
            Functional Tests for Singleton Connection
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSingleConnectionTests.BVTSingleUser">
            <summary>
            
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSingleConnectionTests.BVTMultiUser">
            <summary>
            
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSingleConnectionTests.MultiUserVerifySubscriptions1">
            <summary>
            
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases">
            <summary>
            Functional Tests for Subscribe
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.BVT_Subscribe">
            <summary>
            Basic BVT test which subscribes and unsubscribes a single user from basic and rich presence
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeUnsubscribeIndividually">
            <summary>
            Connects 4 users, one at a time, and makes the same subscriptions for all of them,
            then unsubscribes 1 user at a time
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.UnsubscribeAllUsersLoggedOn">
            <summary>
            Adds one user at a time to the existing connection, creating the same subscriptions
            for everyone connected, then unsubscribes all 4 users with a single call
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeUnsubscribeUserPairsAtATime">
            <summary>
            Connects 4 users and subscriptions in pairs (0+2, 1+3), then unsubscribes 2 users at a time (1+3, 0+2)
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.UnsubscribePartial">
            <summary>
            Gives 1 user multiple subscriptions, but only unsubscribes from a partial set of the subscriptions
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.Subscribe2UsersUnsubscribe1">
            <summary>
            Connects 2 users and makes the same subscriptions for both of them, then unsubscribes only 1 user
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeUnsubscribeSameFromDifferentConsoles">
            <summary>
            2 users make the same subscriptions/unsubscriptions from different consoles
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeUnsubscribeOverlappedFromDifferentConsoles">
            <summary>
            2 users make overlapping (some same, some different) subscriptions/unsubscriptions from different consoles
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeUnsubscribeOverlappedFromSameConsoles">
            <summary>
            2 users make overlapping (some same, some different) subscriptions/unsubscriptions from same console
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.UnsubscribeWhenDisconnect">
            <summary>
            Connects 2 users and makes the same subscriptions for both of them, then disconnects 1 user at a time
            and confirms the subscriptions are torn down
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeAbsoluteOneAtATimeDiffSub">
            <summary>
            Connects 4 users at then subscribes one user at a time absolutely to a different subscription, then
            confirms that user is subscribed
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeAbsoluteOneAtATimeSameSub">
            <summary>
            Connects 4 users and then subscribes one user at a time absolutely to the same subscription, then
            confirms that all users have their correct subscriptions
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.Subscribe3Same1SameAbsoluteLast">
            <summary>
            Connects 4 users and then subscribes the first 3 one user at a time to the same subscription, then
            subscribes the 4th user absolutely to the same thing and verifies everyone has the correct subscriptions
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.Subscribe3Same1DiffAbsoluteLast">
            <summary>
            Connects 4 users and then subscribes the first 3 one user at a time to the same subscription, then
            subscribes the 4th user absolutely to something else and verifies everyone has a subscription
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeAbsoluteFirst">
            <summary>
            Connects 4 users and then subscribes the first 2 users absolutely, then 2 normally and confirms all
            4 still have valid subscriptions
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeNormalAllAbsolutePartial">
            <summary>
            Connects 4 users and subscribes all 4 to the same 2 subscriptions, then subscribes only 2 users
            absolutely to 1 of the 2 previous subscriptions
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeMixedSquence">
            <summary>
            This test tries to simulate a real set of subscription calls by doing the following:
             - Connect user0
             - user0 subscribes to 4 friends
             - user0 subscribes to 2 more items
             - user0 subscribes to 7 total items absolutely (6 old, 1 new)
             - user0 subscribes to 2 more items
             - user0 unsubscribes from all
             - user0 disconnects
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.Subscribe0UsersAbsolute">
            <summary>
            A single user connects and subscribes to one item, then subscribes absolutely to an empty list
            and verifies all previous subscriptions were removed
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeSmallerObjSize">
            <summary>
            Subscribe to a subset of the data (smaller wObjectSize)
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeMultipleSame">
            <summary>
            Creates a single user and sends 2 identical subscriptions after each other
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeToUsersOnSameConsole">
            <summary>
            Creates and connects 4 users and then subscribes each user to the other 3 users on the xbox
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeAbsolutelyToSubsetOfUser">
            <summary>
            Creates a single user and subscribes to both Basic and Rich Presence of several users, then subscribes
            absolutely to only Basic presence and verifies the Rich Presence subscriptions were torn down
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeToSelf">
            <summary>
            Connects a single user and subscribes to himself
            
            Note: This is currently not possible on the client since it checks for a self subscription
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscriptionsRemovedWhenUserChanges">
            <summary>
            Connects a single user on a connection and makes subscriptions. Then a different user logs onto
            the same index, booting off the previous user, and confirms the previous user's subscriptions
            were tore down as well
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.MaximumSubscriptions">
            <summary>
            Creates the maximum number of subscriptions possible for a single connection.
            100 friends * 4 users + 800 other peers (basic + rich each)
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SubscribeMaxObjectsPerMessage">
            <summary>
            
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.SendConnectPairAfterSubscribe">
            <summary>
            Connects 2 users, makes subscriptions for each user, then sends the connect message again, and verifies that
            the subscriptions still remain
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_PostiveCases.Unsubscribe2InMiddleInvalidatesSubscriptionList">
            <summary>
            This test is meant to reproduce a bug. If users 0-3 subscribe to user 4, in order, then if user 2 unsubscribes,
            followed by user 1, and then a notification is triggered, only user 3 will get a notification, not user 0.
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases">
            <summary>
            Functional Negative Tests for Subscribe
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.SubscribeInvalidXUID">
            <summary>
            Creates a subscription for a single user to an invalid XUID
            
            NOTE: It is currently valid to make a subscription to an invalid XUID
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.SubscribeInvalidDataType">
            <summary>
            Creates a subscription for a single user to an invalid Data Type
            
            NOTE: It is currently valid to make a subscription to an invalid Data Type
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.SubscribeTo0DataObjects">
            <summary>
            Creates a subscription for a single user, although the subscription length is 0 and contains nothing
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.SubscribeMultipleSame">
            <summary>
            Creates a single user and sends 2 identical subscriptions at the same time
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeFromNotSubscribed">
            <summary>
            Creates a user with a single subscription, but tries to unsubscribe from something not subscribed to
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeInvalidXUID">
            <summary>
            Creates a user with a single subscription and tries to unsubscribe from it with an invalid XUID
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeInvalidDataType">
            <summary>
            Creates a user with a single subscription and tries to unsubscribe from it with an invalid Data Type
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeFrom0DataObjects">
            <summary>
            Creates a user with a single subscription and attempts to unsubscribe from 0 items
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeMultipleSame">
            <summary>
            Creates a single user with a single subscription and then sends 2 indentical unsubscriptions at the same time
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeIncorrectUserId">
            <summary>
            Creates 2 users with different subscriptions on the same xbox and user 1 attempts to unsubscribe from
            subscriptions only user 0 is subscribed to
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.PartialSubscriptionFullUnsubscription">
            <summary>
            Creates 3 users, 2 of which are subscribed to the same thing, and attempts to unsubscribe all 3 from it
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.SubscribeUnsubscribeMultipleTimes">
            <summary>
            Creates a user and subscribes to the same thing 3 times, then attempts to unsubscribe from it 3 times
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.SubscribeBeforeConnect">
            <summary>
            Sends the subscribe message before sending the connect message
            </summary>
        </member>
        <member name="T:XConnSrvTest.FuncSubscribe_NegativeCases.UnsubscribeBeforeConnect">
            <summary>
            Sends the unsubscribe message before sending the connect message
            </summary>
        </member>
        <member name="T:XConnSrvTest.XConnSrvTestHelpers">
            <summary>
            Helper functions for all XConnSrv tests
            </summary>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.VerifySubscription(System.UInt64,xonline.common.community.DATA_OBJECT_SPECIFIER[],ServerTestFramework.LiveService.XConnSrv.SUBSCRIBE_REPLY,System.Boolean)">
            <summary>
            Verifies the overall subscription length match for the subscription request and reply, as well as
            object size, data type, and owner XUID for each subscription
            </summary>
            <returns></returns>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.VerifyUnsubscription(System.UInt64,xonline.common.community.DATA_OBJECT_SPECIFIER[],ServerTestFramework.LiveService.XConnSrv.UNSUBSCRIBE_REPLY)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.IsUserConnected(System.UInt64,System.Int32)">
            <summary>
            
            </summary>
            <param name="userId"></param>
            <param name="userIndex"></param>
            <returns></returns>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.VerifyRichPresString(System.Byte[],System.String)">
            <summary>
            Used to extract the rich presence string from the SUBSCRIPTION_DATA we received from the notification and then
            compare it to the desired string for verification.
            </summary>
            <param name="subData">data portion of SUBSCRIPTION_NOTIFICATION containing rich presence blob</param>
            <param name="expectedResult">expected string result</param>
            <returns></returns>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(System.UInt64,System.UInt64[]@)">
            <summary>
            Returns a friendslist for a user
            </summary>
            <param name="userId"></param>
            <param name="friendsUserIds"></param>
            <remarks >
            2 friends found for user: 9000002445813
                   0: 9000002445815, status = 0
                   1: 9000002445816, status = 0
            </remarks>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.GetUserCacheServerLocation(System.UInt64)">
            <summary>
            Return the string server name where this user was last located to.
            </summary>
            <param name="userId"></param>
            <returns>
            Output format as below:
            User 9000002445813 was last connected to server MATTCHIL-LKG1(10.121.148.121) from client address 10.121.152.246:27099.
            </returns>
        </member>
        <member name="M:XConnSrvTest.XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(xonline.common.community.DATA_OBJECT_SPECIFIER,System.String)">
            <summary>
            Takes the original DATA_OBJECT_SPECIFIER and the expected string, and creates a new DATA_OBJECT_SPECIFIER to represent
            the new size we expect based on the string.
            </summary>
            <param name="originalDOS">Original DATA_OBJECT_SPECIFIER that represents the Rich Presence blob in the cache</param>
            <param name="expectedString">The expected Rich Presence string</param>
            <returns></returns>
        </member>
        <member name="T:XConnSrvTest.XConnSrvSuite">
             <summary>
             <TestSuite>Connection Server Test Plan</TestSuite>
            	<Tester>Paul Lyttle</Tester>
            	<Tester>Cody Luitjens</Tester>
            	<Tester>Shailesh Shah</Tester>
            	<Developer>Matt Childerston</Developer>
            	<PM>TBD</PM>
            	<Status>Draft</Status>
             </summary>
            	<remarks>
            	<Goal>Functional positive and negative test cases covering connection server features.</Goal>
            	<NonGoal>nongoal</NonGoal>
            	<Description>
            		<p>
            			Presence server previously was the one of two servers used for maintaining
            		user state in Xbox Live. The current service has been combined into 
            		a single server which handles presence records, messaging, notification and
            		teams. The test suites for each portion of presence however will continue 
            		be maintained as three seperate suites.
            		</p>
            
            		<p>
            			Presence functional tests cover all of the 'P' messages that are exposed 
            		on the presence front door sans teams messages. These are as follows:
            		</p>
            
            		<p>
            		<table class="test_data">
            			<tr><td>Connect           </td><td>Accept a new socket connection to a connection server using connection protocol</td></tr>
            			<tr><td>Disconnect        </td><td>Disconnect via connection protocol and closes socket</td></tr>
            		</table>
            		</p>
             </Description>
             </remarks>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\XSecsupTests\Microsoft.XboxLive.Auth.Internal.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.XboxLive.Auth.Internal</name>
    </assembly>
    <members>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Internal">
            <summary>the caller is internal.  the value of this
            claim is typically the component name of the caller</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Ip">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Port">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.PartnerId">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.ValueTypes">
            <summary>the claim value types for all AuthClaimTypes</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthExtensions">
            <summary> </summary>
            <summary>
            These are LINQ extensions to various web requests, such as WebClient,
            HttpWebRequest, and WCF (coming soon), to facilitate adding XAuthdata information
            to the outgoing request. These should be used by a service that is using an
            IClaimsPrincipal and that needs to call another service that is also using 
            XblAuthProtocolModule and has XAuthdataTokenHandler configured.
            </summary>
            <remarks>
            To use these extensions, you need to use the Microsoft.XboxLive.Auth namespace.
            It is helpful to also use Microsoft.IdentityModel.Claims to get the IClaimsPrincipal
            interface.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.IsInternal(Microsoft.XboxLive.Auth.AuthHelper,System.String[])">
            <summary>
            Check for existence of an internal claim (which is always issued
            by "System").  And if specified, check  the  claim  against  the 
            array of valid values.
            </summary>
            <param name="helper">The AuthHelper instance that servces as "this"</param>
            <param name="values">The values (if any) against which to check</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebClient)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebClient,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="client"></param>
            <param name="principal">Local instance or Thread.CurrentPrincipal</param>
            <example>
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest,Microsoft.XboxLive.Auth.AuthHelper)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
            <param name="auth">Local instance or AuthHelper.Current</param>
            <example>
            webReq.SetXAuthdata(AuthHelper.Current);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
            <param name="principal">Local instance or Thread.CurrentPrincipal</param>
            <example>
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection,Microsoft.XboxLive.Auth.AuthHelper)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
            <param name="auth"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
            <param name="principal"></param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions">
            <summary>
            These are LINQ extensions to various web requests, such as WebClient,
            HttpWebRequest, and WCF (coming soon), to facilitate adding XAuthdata information
            to the outgoing request. These should be used by a service that is using an
            IClaimsPrincipal and that needs to call another service that is also using 
            XblAuthProtocolModule and has XAuthdataTokenHandler configured.
            </summary>
            <remarks>
            To use these extensions, you need to use the Microsoft.XboxLive.Auth namespace.
            It is helpful to also use Microsoft.IdentityModel.Claims to get the IClaimsPrincipal
            interface.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.OperationContext)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.OperationContext,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="context"></param>
            <param name="principal"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.Channels.MessageProperties)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="properties"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.Channels.MessageProperties,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="properties"></param>
            <param name="principal"></param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataConstants">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken">
            <summary>
            XAuthdataToken is the internal representation of authorization
            internal to the Xbox LIVE data center.  XAuthdataToken objects
            must never leave the data center.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.#ctor(System.Collections.Generic.IEnumerable{Microsoft.IdentityModel.Claims.IClaimsIdentity})">
            <summary>
            Instantiate an XAuthdataToken object using the claims from
            the supplied identities.
            </summary>
            <param name="identityList">A list of identities continaing
            claims used to populate the XAuthdataToken</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.IdentityModel.Claims.IClaimsIdentity})">
            <summary>
            Instantiate an XAuthdataToken object using the claims from
            the supplied identities.
            </summary>
            <param name="id">Token id (statistically unique identifier)</param>
            <param name="identityList">A list of identities continaing
            claims used to populate the XAuthdataToken</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ToString">
            <summary>
            Returns a serialized XAuthData XML.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.Id">
            <summary>
            Gets the token id. The token id is initialized during
            construction
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.Identities">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.SecurityKeys">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ValidFrom">
            <summary>
            Gets the datetime from which this token is valid
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ValidTo">
            <summary>
            Gets the datetime until which this token is valid
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler.GetSigningKeys">
             <summary>
             Retrieve one or more signature keys from the configuration store. It currently
             uses the app settings in the web.config, but could be extended in the future 
             for registry, database, file, or external code support.
             </summary>
             <example>
               [appSettings]
                 [add key="XAuthdataSigningKeys" value="00112233445566778899AABBCCDDEEFF..."/]
                 [add key="XAuthdataMasterKeyVersions" value="1"/]
               [/appSettings]
            
               [appSettings]
                 [add key="XAuthdataSigningKeys" value="00112233445566778899AABBCCDDEEFF...,00102030405060708090A0B0C0D0E0F0..."/]
                 [add key="XAuthdataMasterKeyVersions" value="1,1"/]
               [/appSettings]
             </example>
             <returns>List of keys, ordered oldest to newest</returns>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\XboxDotComFeedTest\Resources\config.xml ===
﻿<DBSchemaConfig xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:dbschema-config">
  <SuppressTypes>
    <Regex>^wsp_MS.*$</Regex>
    <Name>WspAddAccountToRole</Name>
    <Regex>^.*FSSLatency$</Regex>
    <Regex>^Merge_.*$</Regex>
    <Regex>^Merged_.*$</Regex>
    <Name>CatalogWatcherUpdateProductMedia</Name>
    <Name>GetProductDocuments</Name>
    <Name>GetSpeechDocuments</Name>
  </SuppressTypes>

  <SuppressElements>
    <Name>modifiedDate</Name> <!-- set by triggers -->
  </SuppressElements>

  
  <SuppressElementsByType>
    <Type>
      <Name>MediaUserRatingAggregate</Name>
      <SuppressElements>
        <Name>roundedAggregate</Name>
        <Name>modifiedDate2</Name>
        <Name>sku</Name>
      </SuppressElements>
    </Type>
  </SuppressElementsByType>
  

  <!-- Optional elements at a global level -->
  <OptionalElements>
        <Name>categoryId</Name>
        <Name>categoryIds</Name>
        <Name>categorySystemId</Name>
        <Name>contributorLimit</Name>
        <Name>detailView</Name>
	<Name>imageTypeIds</Name>
        <Name>legalLocale</Name>
        <Name>locale</Name>
        <Name>mediaIds</Name>
        <Name>mediaRelationshipTypes</Name>
        <Name>now</Name>
        <Name>offerIds</Name>
        <Name>offerFilterLevel</Name>
        <Name>pageNum</Name>
        <Name>pageSize</Name>
        <Name>ratingIds</Name>
	<Name>relations</Name>
        <Name>store</Name>
	<Name>titleFilters</Name>
	<Name>userTypes</Name>
	<Name>userTypes</Name>
	<Name>videoFilter</Name>
  </OptionalElements>

  <OptionalElementsByType>
    <Type>
      <Name>CategoryCorporationUpsert</Name>
      <OptionalElements>
        <Name>htmlDescription</Name>
        <Name>website</Name>
        <Name>rssFeatures</Name>
        <Name>rssAnnouncements</Name>
        <Name>rssNews</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>CategoryUpsert</Name>
      <OptionalElements>
        <Name>parentCategoryId</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>MediaContributor</Name>
      <OptionalElements>
        <Name>contributorAliasId</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>Provider</Name>
      <OptionalElements>
        <Name>accountNumber</Name>
        <Name>contactInfo</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>VideoInstance</Name>
      <OptionalElements>
        <Name>audioChannel</Name>
        <Name>audioSamplingRate</Name>
        <Name>audioCC</Name>
        <Name>audioSubtitle</Name>
        <Name>audioBitRate</Name>
        <Name>videoFrame</Name>
      </OptionalElements>
    </Type>    
  </OptionalElementsByType>

  <TypeDependencies>
    <Type>
      <Name>CategoryCorporationUpsert</Name>
      <DependsOn>
        <Name>ImageSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>LicenseType</Name>
      <DependsOn>
        <Name>LegalText</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>MediaSet</Name>
      <DependsOn>
        <Name>ContributorSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>OfferSave</Name>
      <DependsOn>
        <Name>VideoSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSave</Name>
      <DependsOn>
        <Name>VideoSeasonSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSeasonSave</Name>
      <DependsOn>
        <Name>VideoSeriesSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSeriesSave</Name>
      <DependsOn>
        <Name>CategoryCorporationUpsert</Name>
      </DependsOn>
    </Type>
  </TypeDependencies>

  <ExternalSchemaReferencesByType>
    <Type>
      <Name>ContributorSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Contributor.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>GameContentSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>GameContent.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>GameSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Game.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>ImageSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Image.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>OfferSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Offer.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Video.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSeasonSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>VideoSeason.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSeriesSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>VideoSeries.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
  </ExternalSchemaReferencesByType>

  <PublishSchemas>
    <Schema>
      <Name>Game</Name>
      <Elements>
        <Name>GameContentSave</Name>
        <Name>GameSave</Name>
        <Name>OfferSave</Name>
      </Elements>
    </Schema>
    <Schema>
      <Name>Video</Name>
      <Elements>
        <Name>CategoryCorporationUpsert</Name>
        <Name>CategoryUpsert</Name>
        <Name>ContributorSave</Name>
        <Name>ImageSave</Name>
        <Name>OfferSave</Name>
        <Name>VideoSave</Name>
        <Name>VideoSeasonSave</Name>
        <Name>VideoSeriesSave</Name>
      </Elements>
    </Schema>
  </PublishSchemas>

  <LogicalObjects>
    <Elements>
      <Type>xmlData</Type>
      <Type>Offer.xsd.Data.Custom</Type>
      <Type>TestData</Type>
      <Type>ArcadeGame</Type>
      <Type>Xbox360Game</Type>
      <Type>XboxOriginal</Type>
      <Type>XNAGame</Type>
      <Type>GamerTagChangeProduct</Type>
      <Type>PointsBundleProduct</Type>
      <Type>Bundle</Type>
      <Type>OfferSaveLegacy</Type>
      <Type>OfferSaveCurrent</Type>
      <Type>OfferSaveBundle</Type>
      <Type>GameTrailer</Type>
      <Type>GameVideo</Type>
    </Elements>
    <Types>

      <Type>
        <Name>TestData</Name>
        <Includes>
          <Type minOccurs="0" maxOccurs="unbounded">ArcadeGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">Xbox360Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">XboxOriginal</Type>
          <Type minOccurs="0" maxOccurs="unbounded">XNAGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">Bundle</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveLegacy</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveCurrent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveBundle</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>ArcadeGame/ArcadeGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ArcadeGame/ArcadeGameFullVersion/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>Xbox360Game/GameTitle/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>XboxOriginal/XboxGame/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>XNAGame/XNAGameFullVersion/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>Bundle/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveCurrent/xmlData/Offer.xsd.Data.Custom/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
	      <KeyRef>
                <Selector>OfferSaveBundle/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstance</Selector>
            <Fields>
              <Field>offerInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstance</Selector>
                <Fields>
                  <Field>offerInstanceId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstanceProviderTerm</Selector>
                <Fields>
                  <Field>offerInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTerm</Selector>
            <Fields>
              <Field>providerTermId</Field>
            </Fields>
            <KeyRefs>              
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTermGameContentInstance</Selector>
                <Fields>
                  <Field>providerTermId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTermMediaInstanceClientType</Selector>
                <Fields>
                  <Field>providerTermId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>          
        </Keys>
      </Type>
      <Type>
        <Name>ArcadeGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">ArcadeGameFullVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ArcadeGameTrialVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrial</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>ArcadeGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ArcadeGameTrialVersion/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrial/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>ArcadeGameFullVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">23</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>ArcadeGameTrialVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameTrial</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>AvatarContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentAvatarItem</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">18</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameDemo</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">19</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameTitle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>          
          <Type minOccurs="1" maxOccurs="unbounded">GameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaContributor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="1">ThisToThis</Type>
        </Includes>       
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">1</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GenericConsumableContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameConsumable</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">24</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GenericGameContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">18</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>OwnerToThis</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">MediaRelationship</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PicturePack</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">22</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>      
      <Type>
        <Name>ThemePack</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">20</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>ThisToThis</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">MediaRelationship</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Xbox360Game</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">GameTitle</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameDemo</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameTitle/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>GameDemo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XboxGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
	  <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
	  <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">21</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>XboxOriginal</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">XboxGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>XboxGame/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XNAGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">XNAGameFullVersion</Type>
          <Type minOccurs="0" maxOccurs="1">XNAGameTrialVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrial</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>XNAGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>XNAGameTrialVersion/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
	      <KeyRef>
                <Selector>GameTrial/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XNAGameFullVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">23</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>XNAGameTrialVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GamerTagChangeProduct</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaRevenueSku</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">GamerTagChange</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GamerTagChangeProductOffers</Type>
        </Includes>
      </Type>
      <Type>
        <Name>GamerTagChangeProductOffers</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceUserType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceMedia</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PointsBundleProduct</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaRevenueSku</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">PointsBundle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">PointsBundleProductOffers</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PointsBundleProductOffers</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceUserType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceMedia</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Bundle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstanceClientType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">36</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>OfferSaveBundle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="1">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceUserType</Type>
        </Includes>
      </Type>
      <Type>
        <Name>OfferSaveCurrent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">xmlData</Type>
        </Includes>
      </Type>
      <Type>
        <Name>OfferSaveLegacy</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">xmlData</Type>          
        </Includes>
      </Type>
      <Type>
        <Name>xmlData</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer.xsd.Data.Custom</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Offer.xsd.Data.Custom</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="1">OfferStore</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstance</Type>          
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTerm</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermGameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermMediaInstanceClientType</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceProviderTerm</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceUserType</Type>
        </Includes>
      </Type>
      <Type>
        <Name>GameTrailer</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PreviewMediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoSubtitle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">Video</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>Video</Selector>
                <Fields>
                  <Field>videoMediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">34</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameVideo</Name>
        <Includes>
          <Type minOccurs="0" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PreviewMediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoSubtitle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">Video</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>Video</Selector>
                <Fields>
                  <Field>videoMediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">30</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
    </Types>    
  </LogicalObjects>

</DBSchemaConfig>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\PropManagerRequest.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PropManagerRequest</name>
    </assembly>
    <members>
        <member name="T:PropManagerRequest.RequestInfo">
            <summary>
            Request info for prop manager
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestVersion">
            <summary>
            Request version
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.testState">
            <summary>
            Test state
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestGUID">
            <summary>
            Request guid
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestName">
            <summary>
            Request name
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestTitleID">
            <summary>
            Request title
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestEnvironmentName">
            <summary>
            Request environment name
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestSubmitter">
            <summary>
            Request submitter
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.requestData">
            <summary>
            Request data
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psTitle">
            <summary>
            PS title
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psPriority">
            <summary>
            PS Priority
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psIssueType">
            <summary>
            PS issue type
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psPropDateTime">
            <summary>
            PS prop datetime
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psDescription">
            <summary>
            PS description
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psReproSteps">
            <summary>
            PS repro steps
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psLinkedBug">
            <summary>
            PS linked bug
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psLinkedBugType">
            <summary>
            PS linked bug type
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psAttachFiles">
            <summary>
            PS attached files
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.psSetAutoPropState">
            <summary>
            PS auto prop state
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.emailTitle">
            <summary>
            Email title
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.emailHTMLBody">
            <summary>
            Email HTML body
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.emailCCList">
            <summary>
            Email CC list
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.filePaths">
            <summary>
            File paths
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.fileDropPointPath">
            <summary>
            File drop point path
            </summary>
        </member>
        <member name="F:PropManagerRequest.RequestInfo.serializedTempPath">
            <summary>
            Serialized temp path
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\VelocityInterop\CacheBaseLibrary.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
	<assembly>
		<name>CacheBaseLibrary</name>
	</assembly>
	<members>
		<member name="T:Microsoft.Data.Caching.DataCacheErrorCode">
			<summary>A static class used to store global error codes.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.CacheItemVersionMismatch">
			<summary>The object in the cache does not match with the specified version; integer value equals 1.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.CacheServerUnavailable">
			<summary>One or more specified cache servers are unavailable; integer value equals 19.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ClientServerVersionMismatch">
			<summary>The cache client assemblies are a different version than the cache host assemblies; integer value equals 24.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.InvalidArgument">
			<summary>The argument is not valid; integer value equals 5.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.InvalidCacheLockHandle">
			<summary>The specified lock handle is not valid; integer value equals 15.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.InvalidEnumerator">
			<summary>An invalid enumerator is specified; integer value equals 16.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.KeyAlreadyExists">
			<summary>The key is already present in the cache or region; integer value equals 10.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.KeyDoesNotExist">
			<summary>An object cached with the specified key does not exist in the cache or region; integer value equals 8.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.MaxNamedCacheCountExceeded">
			<summary>The named cache count exceeded the maximum value; integer value equals 12.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NamedCacheDoesNotExist">
			<summary>The named cache does not exist; integer value equals 11.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NotificationNotSupported">
			<summary>Cache notifications are not supported because the cache client is a simple client or the named cache has been created without notifications enabled; integer value equals 20.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NotPermittedForDefaultRegions">
			<summary>The operation is only supported in regions that you explicitly create with the <see cref="M:Microsoft.Data.Caching.DataCache.CreateRegion(System.String,System.Boolean)" /> method; integer value equals 18.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NullArgument">
			<summary>A null has been specified as an argument; integer value equals 3.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ObjectLocked">
			<summary>The cached object has already been locked; integer value equals 13.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ObjectNotLocked">
			<summary>The object is not locked; integer value equals 14.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.RegionAlreadyExists">
			<summary>The region already exists; integer value equals 9.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.RegionDoesNotExist">
			<summary>The region does not exist; integer value equals 7.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.RetryLater">
			<summary>Temporary failure, retry the operation later; integer value equals 22.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.SerializationException">
			<summary>An exception was encountered during object serialization; integer value equals 25.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ServerNull">
			<summary>The servers parameter of the <see cref="Overload:Microsoft.Data.Caching.DataCacheFactory.#ctor" /> constructor or one of the items in the array is null; integer value equals 26.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.Timeout">
			<summary>Communications with the cache cluster have experienced a delay past the timeout value; integer value equals 23.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.UndefinedError">
			<summary>Unknown error; integer value equals 6. </summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheException">
			<summary>Used for cache-related exceptions.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor(System.String)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class; allows you to provide a message with the exception.</summary>
			<param name="message">The message describing the exception.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class; allows you to provide serialization information with the exception.</summary>
			<param name="info">Stores serialization information about an object.</param>
			<param name="context">Describes the source, destination, and context of a serialized stream.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor(System.String,System.Exception)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class; allows you to provide a message and another exception with the exception.</summary>
			<param name="message">The message describing the exception.</param>
			<param name="innerException">Another exception related to this exception.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
			<summary>The interface that is used for serialization.</summary>
			<param name="info">The SerializationInfo class used to store all the data that you need to serialize the exception.</param>
			<param name="context">The StreamingContext class used to describe the source and destination of the exception.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheException.ErrorCode">
			<summary>The integer used to identify the type of exception encountered.</summary>
			<returns>An integer specifying the type of exception encountered.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheException.Message">
			<summary>The description of the exception encountered.</summary>
			<returns>A string that describes the type of exception encountered.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheItem">
			<summary>Used to retrieve all information associated with the cached object in the cluster.</summary>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.CacheName">
			<summary>The name of the cache where the object is stored.</summary>
			<returns>A string value that represents the name of the cache where the object is stored.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Key">
			<summary>The identifier that is used to distinguish the cached object in the cache or region.</summary>
			<returns>A string value that represents the identifier that is used to distinguish the cached object in the cache or region.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.RegionName">
			<summary>If applicable, the name of the region where the object is stored.</summary>
			<returns>A string value that represents, if applicable, the name of the region where the object is stored.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Tags">
			<summary>A generic list of tags associated with the cached object.</summary>
			<returns>An generic list of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects associated with the cached object.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Value">
			<summary>The object stored in cache.</summary>
			<returns>An object representing the deserialized form of the cached object.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Version">
			<summary>The version of the cached object.</summary>
			<returns>The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> is updated every time the object is updated. Only the latest version of the object is stored on the cache cluster. Due to the distributed nature of the cluster, the cache client may not have the latest copy of the object. For this reason, the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> class is essential for concurrency operations. For more information, see Concurrency Models (Velocity) and Concurrency Methods (Velocity).When using cache notifications, the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object corresponding to an item-related cache operation can be returned to your application with the version parameter of the <see cref="T:Microsoft.Data.Caching.DataCacheNotificationCallback" /> delegate method. For more information, see <see cref="Cache Notifications (Velocity)" />.Version comparisons are only meaningful when comparing versions of the same item specified with the same key. Comparison methods may return a result, but the result is only valid for versions of the same key. </returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheItemVersion">
			<summary>Used to represent the version of a cached object.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheItemVersion.CompareTo(Microsoft.Data.Caching.DataCacheItemVersion)">
			<summary>Used to compare two versions of the same item, specified with the same key.</summary>
			<returns>An integer value: 0 if the versions are equal, greater than zero if the instance is greater than the version parameter value, or less than zero if the instance is less than the version parameter value.</returns>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> to be compared.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheItemVersion.Equals(System.Object)">
			<summary>Used to determine whether another object is the same.</summary>
			<returns>A Boolean value: true, if the objects are the same; false, if they are different.</returns>
			<param name="obj">Another object for comparison.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheItemVersion.GetHashCode">
			<summary>Returns the hash code of the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object.</summary>
			<returns>An integer value that represents the hash code of the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object. </returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheLockHandle">
			<summary>The structure used as a key to lock and unlock cached objects in a pessimistic concurency scenario.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLockHandle.ToString">
			<summary>Returns the string representation of the lock handle.</summary>
			<returns>A string representing the lock handle.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheLogSink">
			<summary>Used to specify an individual log sink.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLogSink.#ctor(Microsoft.Data.Caching.DataCacheSinkType)">
			<summary>Defines the type of log sink and assigns a TraceLevel of Warning.</summary>
			<param name="sinkType">The type of log sink, represented by the <see cref="T:Microsoft.Data.Caching.DataCacheSinkType" /> enumeration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLogSink.#ctor(Microsoft.Data.Caching.DataCacheSinkType,System.Diagnostics.TraceLevel)">
			<summary>Defines the type of log sink and assigns the specified TraceLevel.</summary>
			<param name="sinkType">The type of log sink, represented by the <see cref="T:Microsoft.Data.Caching.DataCacheSinkType" /> enumeration.</param>
			<param name="logLevel">The TraceLevel of the log sink, represented by the <see cref="T:System.Diagnostics.TraceLevel" /> enumeration. Available options include: No tracing, Error, Warning, Information, and Verbose.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLogSink.#ctor(Microsoft.Data.Caching.DataCacheSinkType,System.Diagnostics.TraceLevel,System.String)">
			<summary>Defines the type of log sink and assigns the specified TraceLevel. This overload also enables setting additional log sink parameters.</summary>
			<param name="sinkType">The type of log sink, represented by the <see cref="T:Microsoft.Data.Caching.DataCacheSinkType" /> enumeration.</param>
			<param name="logLevel">The TraceLevel of the log sink, represented by the <see cref="T:System.Diagnostics.TraceLevel" /> enumeration. Available options include: No tracing, Error, Warning, Information, and Verbose.</param>
			<param name="sinkParam">Only used for file-based logging to specify the file naming convention of the log file.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheSinkType">
			<summary>Used to specify the type of log sink used to trace events on the cache client.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheSinkType.CONSOLE">
			<summary>Used to specify console-based log sinks. </summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheSinkType.ETW">
			<summary>Used to specify Event Tracing for Windows (ETW)-based log sinks.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheSinkType.FILE">
			<summary>Used to specify file-based log sinks.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheTag">
			<summary>Represents an optional string-based identifier that you can associate with a cached object.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.#ctor(System.String)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> class.</summary>
			<param name="tag">The string-based identifier to associate with a cached object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.Equals(System.Object)">
			<summary>Compares the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object for equality with the specified <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</summary>
			<returns>True if the object implements the ToString method and its value is the same as the string representation of the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" />; otherwise, false.</returns>
			<param name="obj">The object whose string representation is compared for equality to the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.GetHashCode">
			<summary>Returns the hash code for the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</summary>
			<returns>An integer representing the hash code for the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</returns>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.ToString">
			<summary>Returns the string representation of the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</summary>
			<returns>A string representing the current value of the <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object. </returns>
		</member>
	</members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\XUserTests\Microsoft.XboxLive.Auth.Internal.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.XboxLive.Auth.Internal</name>
    </assembly>
    <members>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Internal">
            <summary>the caller is internal.  the value of this
            claim is typically the component name of the caller</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Ip">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.Port">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.PartnerId">
            <summary>connection claim typically added by a gateway.
            claim should never appear in a user/machine/title token</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthInternalClaimTypes.ValueTypes">
            <summary>the claim value types for all AuthClaimTypes</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthExtensions">
            <summary> </summary>
            <summary>
            These are LINQ extensions to various web requests, such as WebClient,
            HttpWebRequest, and WCF (coming soon), to facilitate adding XAuthdata information
            to the outgoing request. These should be used by a service that is using an
            IClaimsPrincipal and that needs to call another service that is also using 
            XblAuthProtocolModule and has XAuthdataTokenHandler configured.
            </summary>
            <remarks>
            To use these extensions, you need to use the Microsoft.XboxLive.Auth namespace.
            It is helpful to also use Microsoft.IdentityModel.Claims to get the IClaimsPrincipal
            interface.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.IsInternal(Microsoft.XboxLive.Auth.AuthHelper,System.String[])">
            <summary>
            Check for existence of an internal claim (which is always issued
            by "System").  And if specified, check  the  claim  against  the 
            array of valid values.
            </summary>
            <param name="helper">The AuthHelper instance that servces as "this"</param>
            <param name="values">The values (if any) against which to check</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebClient)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebClient,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="client"></param>
            <param name="principal">Local instance or Thread.CurrentPrincipal</param>
            <example>
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest,Microsoft.XboxLive.Auth.AuthHelper)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
            <param name="auth">Local instance or AuthHelper.Current</param>
            <example>
            webReq.SetXAuthdata(AuthHelper.Current);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.HttpWebRequest,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="request"></param>
            <param name="principal">Local instance or Thread.CurrentPrincipal</param>
            <example>
            webReq.SetXAuthdata(Thread.CurrentPrincipal as IClaimsPrincipal);
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection,Microsoft.XboxLive.Auth.AuthHelper)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
            <param name="auth"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.SetXAuthdata(System.Net.WebHeaderCollection,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="headers"></param>
            <param name="principal"></param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions">
            <summary>
            These are LINQ extensions to various web requests, such as WebClient,
            HttpWebRequest, and WCF (coming soon), to facilitate adding XAuthdata information
            to the outgoing request. These should be used by a service that is using an
            IClaimsPrincipal and that needs to call another service that is also using 
            XblAuthProtocolModule and has XAuthdataTokenHandler configured.
            </summary>
            <remarks>
            To use these extensions, you need to use the Microsoft.XboxLive.Auth namespace.
            It is helpful to also use Microsoft.IdentityModel.Claims to get the IClaimsPrincipal
            interface.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.OperationContext)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.OperationContext,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="context"></param>
            <param name="principal"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.Channels.MessageProperties)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="properties"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Extensions.ServiceModel.AuthExtensions.SetXAuthdata(System.ServiceModel.Channels.MessageProperties,Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Sets an XAuthdataToken in the Authorization HTTP header
            </summary>
            <param name="properties"></param>
            <param name="principal"></param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataConstants">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken">
            <summary>
            XAuthdataToken is the internal representation of authorization
            internal to the Xbox LIVE data center.  XAuthdataToken objects
            must never leave the data center.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.#ctor(System.Collections.Generic.IEnumerable{Microsoft.IdentityModel.Claims.IClaimsIdentity})">
            <summary>
            Instantiate an XAuthdataToken object using the claims from
            the supplied identities.
            </summary>
            <param name="identityList">A list of identities continaing
            claims used to populate the XAuthdataToken</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.IdentityModel.Claims.IClaimsIdentity})">
            <summary>
            Instantiate an XAuthdataToken object using the claims from
            the supplied identities.
            </summary>
            <param name="id">Token id (statistically unique identifier)</param>
            <param name="identityList">A list of identities continaing
            claims used to populate the XAuthdataToken</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ToString">
            <summary>
            Returns a serialized XAuthData XML.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.Id">
            <summary>
            Gets the token id. The token id is initialized during
            construction
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.Identities">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.SecurityKeys">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ValidFrom">
            <summary>
            Gets the datetime from which this token is valid
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Tokens.XAuthdataToken.ValidTo">
            <summary>
            Gets the datetime until which this token is valid
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler.GetSigningKeys">
             <summary>
             Retrieve one or more signature keys from the configuration store. It currently
             uses the app settings in the web.config, but could be extended in the future 
             for registry, database, file, or external code support.
             </summary>
             <example>
               [appSettings]
                 [add key="XAuthdataSigningKeys" value="00112233445566778899AABBCCDDEEFF..."/]
                 [add key="XAuthdataMasterKeyVersions" value="1"/]
               [/appSettings]
            
               [appSettings]
                 [add key="XAuthdataSigningKeys" value="00112233445566778899AABBCCDDEEFF...,00102030405060708090A0B0C0D0E0F0..."/]
                 [add key="XAuthdataMasterKeyVersions" value="1,1"/]
               [/appSettings]
             </example>
             <returns>List of keys, ordered oldest to newest</returns>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\VelocityInterop\ClientLibrary.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
	<assembly>
		<name>ClientLibrary</name>
	</assembly>
	<members>
		<member name="N:Microsoft.Data.Caching">
			<summary>The <see cref="N:MIcrosoft.Data.Caching" /> namespace provides access to an in-memory application cache application for developing scalable, high-performance applications. This namespace can be used to cache any common language runtime (CLR) object and provides access through simple APIs.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCache">
			<summary>The object that is used by cache-enabled applications for storing and retrieving objects from the cache cluster. An instance of this object is referred to as the cache client. </summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object)">
			<summary>Adds an object to the cache.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds an object to the cache. This method enables associating tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.String)">
			<summary>Adds an object to a region in the cache.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="region">The name of the region to save the object in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan)">
			<summary>Adds an object to the cache. This method provides the ability to specify when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds an object to a region in the cache. This method enables associating tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
			<param name="region">The name of the region to save the object in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds an object to the cache. This method enables associating tags with the cached object and specifying when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan,System.String)">
			<summary>Adds an object to a region in the cache. This method provides the ability to specify when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region to save the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds an object to a region in the cache. This method enables associating tags with the cached object and specifying when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
			<param name="region">The name of the region to save the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddCacheLevelCallback(Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback)">
			<summary>Adds a cache notification callback for cache operations occurring on all regions and items.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback. </returns>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddFailureNotificationCallback(Microsoft.Data.Caching.DataCacheFailureNotificationCallback)">
			<summary>Adds a failure notification callback, for notifications indicating that a client has missed one or more cache notifications.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="failureCallback">The name of the method that you want to invoke when the failure notification occurs.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddItemLevelCallback(System.String,Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback)">
			<summary>Adds a cache notification callback for cache operations occurring on one specific item that is not stored in a region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="key">The key used to store the object in the cache.</param>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddItemLevelCallback(System.String,Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback,System.String)">
			<summary>Adds a cache notification callback for cache operations occurring on one specific item that is stored in region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="key">The key used to store the object in the cache.</param>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
			<param name="regionName">The name of the region where the object is stored.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddRegionLevelCallback(System.String,Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback)">
			<summary>Adds a cache notification callback for cache operations occurring on one specific region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="regionName">The name of the region for which the specified item or region operations can trigger cache notifications.</param>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.ClearRegion(System.String)">
			<summary>Deletes all objects in the specified region.</summary>
			<param name="region">The name of the region whose objects are removed.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.CreateRegion(System.String,System.Boolean)">
			<summary>Creates a region and specifies if resident objects may be evicted.</summary>
			<param name="region">The name of the region that is created.</param>
			<param name="evictionOn">True if objects in the region can be evicted.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String)">
			<summary>Gets an object from the cache using the specified key.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String,Microsoft.Data.Caching.DataCacheItemVersion@)">
			<summary>Gets an object from the cache using the specified key. You may also provide the version to obtain the specific version of a key, if that version is still the most current in the cache.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist. Even if the key does exist, null may also be returned because the object has been updated to a new version.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="version">The version of the desired object. If this parameter is null, the version of the current object is retrieved.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String,System.String)">
			<summary>Gets an object from the specified region by using the specified key.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String,Microsoft.Data.Caching.DataCacheItemVersion@,System.String)">
			<summary>Gets an object from the specified region by using the specified key. You may also provide the version to obtain the specific version of a key, if that version is still the most current in the region.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist. Even if the key does exist, null may also be returned because the object has been updated to a new version.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="version">The version of the desired object. If this parameter is null, the version of the current object is retrieved.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetAndLock(System.String,System.TimeSpan,Microsoft.Data.Caching.DataCacheLockHandle@)">
			<summary>Returns and locks the cached object (if present).</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the object has already been locked or the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="timeout">A non-zero value indicating how many minutes the object remains locked.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object required to unlock the object. The lockHandle output parameter is passed by reference.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetAndLock(System.String,System.TimeSpan,Microsoft.Data.Caching.DataCacheLockHandle@,System.String)">
			<summary>Returns and locks the cached object (if present). For objects stored in regions.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the object has already been locked or the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="timeout">A non-zero value indicating how many minutes the object remains locked.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object required to unlock the object. The lockHandle output parameter is passed by reference.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetCacheItem(System.String)">
			<summary>Gets a <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object to retrieve all information associated with your cached object in the cluster.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object that contains all information associated with your cached object. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetCacheItem(System.String,System.String)">
			<summary>Gets a <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object to retrieve all information associated with your cached object in the cluster. For objects stored in regions.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object that contains all information associated with your cached object. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetIfNewer(System.String,Microsoft.Data.Caching.DataCacheItemVersion@)">
			<summary>Gets an object from the cache, but only if a newer version of the object resides in the cache.</summary>
			<returns>If the version in the cache differs from the version parameter, the corresponding cached object is returned. If the version in the cache is the same as the version parameter, null is returned.</returns>
			<param name="key">The unique value that is used to identify the object in the cache. If this parameter is null, an exception is thrown.</param>
			<param name="version">The version of the desired object, passed by reference. If this parameter is null, an exception is thrown.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetIfNewer(System.String,Microsoft.Data.Caching.DataCacheItemVersion@,System.String)">
			<summary>Gets an object from the specified region, but only if a newer version of the object resides in the region. </summary>
			<returns>If the version in the region differs from the version parameter, the corresponding cached object is returned. If the version in the region is the same as the version parameter, null is returned.</returns>
			<param name="key">The unique value that is used to identify the object in the cache. If this parameter is null, an exception is thrown.</param>
			<param name="version">The version of the desired object, passed by reference. If this parameter is null, an exception is thrown.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsByAllTags(System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region that have all the same tags in common.</summary>
			<returns>An enumerable list of all cached objects in the specified region that have all the same tags in common. Null is returned if no objects in the specified region have all the tags specified.</returns>
			<param name="tags">A list of tags for which to search.</param>
			<param name="region">The name of the region to search. Tags are not supported outside regions. Therefore, a region name is required.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsByAnyTag(System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region that have any of the same tags in common.</summary>
			<returns>An enumerable list of all cached objects in the specified region that have any of the same tags in common. Null is returned if no objects in the specified region have any of the tags specified.</returns>
			<param name="tags">A list of tags for which to search.</param>
			<param name="region">The name of the region to search. Tags are not supported outside regions. Therefore, a region name is required.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsByTag(Microsoft.Data.Caching.DataCacheTag,System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region that have the specified tag.</summary>
			<returns>An enumerable list of all cached objects in the specified region that have the specified tag. Null is returned if no objects in the specified region have the tag specified.</returns>
			<param name="tag">The tag for which to search.</param>
			<param name="region">The name of the region to search. Tags are not supported outside regions. Therefore, a region name is required.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsInRegion(System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region.</summary>
			<returns>An enumerable list of all cached objects in the specified region.</returns>
			<param name="region">The name of the region for which to return a list of all resident objects.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object)">
			<summary>Adds or replaces an object in the cache. </summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion)">
			<summary>Adds or replaces an object in the cache if it is at the specified version.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.String)">
			<summary>Adds or replaces an object in the specified region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan)">
			<summary>Adds or replaces an object in the cache. Specifies the timeout value of the cached object. </summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache if it is at the specified version. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan)">
			<summary>Adds or replaces an object in the cache if it is at the specified version. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan,System.String)">
			<summary>Adds or replaces an object in the specified region. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache if it is at the specified version. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan,System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle)">
			<summary>Replaces and unlocks an object in the cache.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Replaces and unlocks an object in the cache. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.String)">
			<summary>Replaces and unlocks an object in the specified region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan)">
			<summary>Replaces and unlocks an object in the cache. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Replaces and unlocks an object in the specified region. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Replaces and unlocks an object in the cache. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.String)">
			<summary>Replaces and unlocks an object in the specified region. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.The timeout value associated with the cached object overrides expiration settings specified in the named cache configuration. For more information, see Expiration and Eviction (Velocity).</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Replaces and unlocks an object in the specified region. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String)">
			<summary>Removes an object from the cache.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String,Microsoft.Data.Caching.DataCacheItemVersion)">
			<summary>Removes an object from the cache if it is at the specified version.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be removed.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String,System.String)">
			<summary>Removes an object from the specified region.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String,Microsoft.Data.Caching.DataCacheItemVersion,System.String)">
			<summary>Removes an object from the specified region if it is at the specified version.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be removed.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.RemoveCallback(Microsoft.Data.Caching.DataCacheNotificationDescriptor)">
			<summary>Removes a cache notification callback.</summary>
			<param name="nd">The <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object that identifies the callback that should be removed.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.RemoveRegion(System.String)">
			<summary>Deletes a region. All cached objects inside the region are also removed.</summary>
			<param name="region">The name of the region.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.ResetObjectTimeout(System.String,System.TimeSpan)">
			<summary>Resets the object timeout value, defining how long objects reside in the cache before expiring. The value specified for the object overrides the default settings for the cache.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="newTimeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.ResetObjectTimeout(System.String,System.TimeSpan,System.String)">
			<summary>Resets the object timeout value, defining how long objects reside in the region before expiring. The value specified for the object overrides the default settings for the cache.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="newTimeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle)">
			<summary>Releases objects locked in the cache. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle,System.String)">
			<summary>Releases objects locked in the specified region. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan)">
			<summary>Releases objects locked in the cache. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object. Specifies a new timeout value for the cached object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.String)">
			<summary>Releases objects locked in the specified region. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object. Specifies a new timeout value for the cached object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCache.Item(System.String)">
			<summary>Allows for the use of array notation to access cached objects.</summary>
			<returns>A deserialized object that was saved to the cache cluster that uses the key.</returns>
			<param name="key">The key that is used to save the cached object.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheFactory">
			<summary>Provides methods to return <see cref="T:Microsoft.Data.Caching.DataCache" /> objects that are mapped to a named cache. This class also enables programmatic configuration of the cache client.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.#ctor">
			<summary>Used for configuring a cache client based on the application configuration file.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.#ctor(Microsoft.Data.Caching.DataCacheServerEndpoint[],System.Boolean,System.Boolean)">
			<summary>Used for configuring a cache client programmatically, based on the parameter values provided.</summary>
			<param name="servers">The cache host configuration for the cache client, for an array of <see cref="T:Microsoft.Data.Caching.DataCacheServerEndpoint" /> objects.</param>
			<param name="routingClient">True when the <see cref="M:Microsoft.Data.Caching.DataCacheFactory.GetCache(System.String)" /> method returns routing clients; otherwise, it returns simple clients.</param>
			<param name="localCache">True when local cache is enabled on the cache client; otherwise, local cache is disabled.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.#ctor(Microsoft.Data.Caching.DataCacheServerEndpoint[],System.Boolean,System.Boolean,Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy,System.Int32,System.Int32)">
			<summary>Used for configuring a cache client programmatically, based on the parameter values provided. Additional parameters provided for working with cache notifications.</summary>
			<param name="servers">The cache host configuration for the cache client, for an array of <see cref="T:Microsoft.Data.Caching.DataCacheServerEndpoint" /> objects.</param>
			<param name="routingClient">True when the <see cref="M:Microsoft.Data.Caching.DataCacheFactory.GetCache(System.String)" /> method returns routing clients; otherwise, it returns simple clients.</param>
			<param name="localCache">True when local cache is enabled on the cache client; otherwise, local cache is disabled.</param>
			<param name="syncPolicy">Specifies the way locally cached objects should be invalidated, as defined by the <see cref="T:Microsoft.Data.Caching.LocalCacheSyncPolicy" /> enumeration.</param>
			<param name="localCacheTimeout">The number of seconds that objects will remain in local cache before they are invalidated. Not applicable to notification-based invalidation. For more information, see Expiration and Eviction (Velocity).</param>
			<param name="pollInterval">The interval, in seconds, in which the cache client checks with the cache cluster for new notifications. Default value is 300 seconds. For more information, see Cache Notifications (Velocity).</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.CreateLogSinks(System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheLogSink})">
			<summary>Allows you to set the log levels on one or more log sinks for the cache client.</summary>
			<param name="sinkList">Log level settings for one or more log sinks.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.DisableLogSinks">
			<summary>Disables all log sinks on the cache client.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.Dispose">
			<summary>Closes the <see cref="T:Microsoft.Data.Caching.DataCacheFactory" /> object and releases all associated resources.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.EnableAllAvailableSinks">
			<summary>Enables all available log sinks on the cache client, with the EventTrace level equal to Warning.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.GetCache(System.String)">
			<summary>Returns the cache client, an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</summary>
			<returns>The cache client, an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</returns>
			<param name="cacheName">The named cache to use for cache operations.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.GetDefaultCache">
			<summary>Returns the cache client corresponding to the default cache; an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</summary>
			<returns>The cache client, an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheFactory.Timeout">
			<summary>The duration of time, in milliseconds, that the cache client will wait to communicate with the cache cluster before it throws a timeout exception.</summary>
			<returns>A System.Timespan object that represents the duration of time, in milliseconds, that the cache client will wait to communicate with the cache cluster before it throws a timeout exception.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheFailureNotificationCallback">
			<summary>Specifies the parameters required for a method to be invoked by a failure notification when the cache client misses cache notifications. </summary>
			<param name="cacheName">The name of the cache associated with the missing notifications.</param>
			<param name="nd">The <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object associated with the failure notification that invoked the delegate method.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy">
			<summary>Specifies the way locally cached objects should be invalidated.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy.NotificationBased">
			<summary>Specifies that objects will stay in local cache until they are automatically invalidated by a cache notification.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy.TimeoutBased">
			<summary>Specifies that objects will stay in local cache until their lifetime reaches the localCacheTimeout duration specified in the <see cref="Overload:Microsoft.Data.Caching.DataCacheCacheFactory.#ctor" /> constructor.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheNotificationCallback">
			<summary>Specifies the parameters required for a method to be invoked by a cache notification.</summary>
			<param name="CacheName">The name of the cache associated with the cache operation.</param>
			<param name="regionName">The name of the region associated with the cache operation. A zero-length string indicates that a specific region is not associated with the cache operation.</param>
			<param name="key">The name of the key associated with the cache operation. A zero-length string indicates that a specific cached item is not associated with the cache operation.</param>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> of the cached object associated with the cache operation that triggered the notification. A null version indicates that a specific cached item is not associated with the cache operation.</param>
			<param name="cacheOperation">The <see cref="T:Microsoft.Data.Caching.DataCacheOperation" /> enumeration specifying which cache event triggered the cache notification.</param>
			<param name="nd">The <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object associated with the cache notification that invoked the delegate method.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor">
			<summary>Identifies a cache notification callback. This identifier is required to remove the corresponding cache notification callback.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheNotificationDescriptor.ToString">
			<summary>Creates a copy of the <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object.</summary>
			<returns>A string value representing the <see cref="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.CacheName" /> and <see cref="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.DelegateID" /> property values.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.CacheName">
			<summary>he name of the cache triggering the cache notification.</summary>
			<returns>A string value represents the name of the cache triggering the cache notification.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.DelegateID">
			<summary>Identifier for the <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object. Used to distinguish between <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> objects.</summary>
			<returns>A System.Int64 value used to identify <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> objects.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheOperation">
			<summary>An enumeration used to specify specific item or region events that can trigger a cache notification.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.AddItem">
			<summary>Indicates that an object was added to the cache.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.ClearRegion">
			<summary>Indicates that a region in the cache was cleared with the <see cref="M:Microsoft.Data.Caching.DataCache.ClearRegion(System.String)" /> method.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.CreateRegion">
			<summary>Indicates that a region in the cache was created with the <see cref="M:Microsoft.Data.Caching.DataCache.CreateRegion(System.String,System.Boolean)" /> method.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.RemoveItem">
			<summary>Indicates that an object was removed from the cache.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.RemoveRegion">
			<summary>Indicates that a region in the cache was removed with the <see cref="M:Microsoft.Data.Caching.DataCache.RemoveRegion(System.String)" /> method.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.ReplaceItem">
			<summary>Indicates that an object was replaced in the cache.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheServerEndpoint">
			<summary>Used to specify an individual cache host when programmatically configuring the cache client.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheServerEndpoint.#ctor(System.String,System.Int32,System.String)">
			<summary>Used to define a cache host in the cache cluster for programmatic configuration of the cache client.</summary>
			<param name="hostName">The computer name of the cache server.</param>
			<param name="cachePort">The cache port number of the cache host.</param>
			<param name="cacheHostName">The Windows service name of the cache host service that is running on the cache server.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheServerEndpoint.CacheHostName">
			<summary>The Windows service name of the cache host service that is  running on the cache server.</summary>
			<returns>A string representing the Windows service name of the cache host service that is running on the cache server. The installation default value is DistributedCacheService.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheServerEndpoint.CachePort">
			<summary>The cache port on the cache server.</summary>
			<returns>A System.Int32 value that represents the cache port number on the cache server.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheServerEndpoint.HostName">
			<summary>The computer name of the cache server.</summary>
			<returns>A string representing the computer name of the cache server.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheSessionStoreProvider">
			<summary>A session storage provider that enables Web applications to store session-state data to a distributed cache system.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.#ctor">
			<summary>Initializes a new instance of the <see cref="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider" /> class.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.CreateNewStoreData(System.Web.HttpContext,System.Int32)">
			<summary>Creates a new data storage object for the current request.</summary>
			<returns>A <see cref="T:System.Web.SessionState.SessionStateStoreData" /> object, used for storing session data in the distributed cache.</returns>
			<param name="context">The HttpContext for the current request.</param>
			<param name="timeout">The session state Timeout value for the new <see cref="T:System.Web.SessionState.SessionStateStoreData" /> object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.CreateUninitializedItem(System.Web.HttpContext,System.String,System.Int32)">
			<summary>Adds a new session state to the distributed cache.</summary>
			<param name="context">The HttpContext for the current request.</param>
			<param name="id">The session identifier for the current request.</param>
			<param name="timeout">The session Timeout for the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.Dispose">
			<summary>Releases all resources used by the <see cref="T:Microsoft.Data.Caching.DataCacheSessionStoreProvider" /> class.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.EndRequest(System.Web.HttpContext)">
			<summary>Called by the <see cref="T:System.Web.SessionState.SessionStateModule" /> class at the end of a request.</summary>
			<param name="context">The HttpContext for the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.GetItem(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)">
			<summary>Returns read-only session-state data from the cache.</summary>
			<returns>A SessionStateStoreData object populated with session values and information from the cache.</returns>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier for the current request.</param>
			<param name="locked">When this method returns, contains a Boolean value that is set to true if the requested session item is locked in the cache; otherwise, false.</param>
			<param name="lockAge">When this method returns, contains a TimeSpan object that is set to the period of time that an item in the cache has been locked.</param>
			<param name="lockId">When this method returns, contains an object that is set to the lock identifier for the current request. </param>
			<param name="actions">When this method returns, contains one of the SessionStateActions values. This indicates whether the current session is an uninitialized, cookieless session.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.GetItemExclusive(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)">
			<summary>Returns and locks the read-only session-state data from the cache. </summary>
			<returns>A SessionStateStoreData object populated with session values and information from the cache.</returns>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier for the current request.</param>
			<param name="locked">When this method returns, contains a Boolean value that is set to true if a lock in the cache is successfully obtained; otherwise, false.</param>
			<param name="lockAge">When this method returns, contains a TimeSpan object that is set to the period of time that an item in the cache has been locked.</param>
			<param name="lockId">When this method returns, contains an object that is set to the lock identifier for the current request. </param>
			<param name="actions">When this method returns, contains one of the SessionStateActions values. This indicates whether the current session is an uninitialized, cookieless session.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.Initialize(System.String,System.Collections.Specialized.NameValueCollection)">
			<summary>Initializes the distributed cache provider.</summary>
			<param name="name">The name of the application.</param>
			<param name="config">The configuration details specified in the application configuration file for cacheName and regionName.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.InitializeRequest(System.Web.HttpContext)">
			<summary>Called by the SessionStateModule object for per-request initialization.</summary>
			<param name="context">The HttpContext for the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.ReleaseItemExclusive(System.Web.HttpContext,System.String,System.Object)">
			<summary>Releases a lock on the session data in the cache.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
			<param name="lockId">The lock identifier of the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.RemoveItem(System.Web.HttpContext,System.String,System.Object,System.Web.SessionState.SessionStateStoreData)">
			<summary>Deletes session data from the cache.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
			<param name="lockId">The lock identifier of the current request.</param>
			<param name="item">The SessionStateStoreData that represents the item to delete from the cache.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.ResetItemTimeout(System.Web.HttpContext,System.String)">
			<summary>Updates the expiration date and time of session data in the cache.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.SetAndReleaseItemExclusive(System.Web.HttpContext,System.String,System.Web.SessionState.SessionStateStoreData,System.Object,System.Boolean)">
			<summary>Updates the session item information in the cache with values from the current request and clears the lock on the session item.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
			<param name="item">The SessionStateStoreData object that contains the current session values to be stored.</param>
			<param name="lockId">The lock identifier for the current request.</param>
			<param name="newItem">If true, identifies the session item as a new item if true; otherwise, identifies the session item as an existing item.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.SetItemExpireCallback(System.Web.SessionState.SessionStateItemExpireCallback)">
			<summary>Sets a reference to the SessionStateItemExpireCallback delegate for the Session_OnEnd event defined in the Global.asax file.</summary>
			<returns>Cache does not support notification of the expiration; therefore this method always returns false.</returns>
			<param name="expireCallback">The SessionStateItemExpireCallback delegate for the Session_OnEnd event defined in the Global.asax file.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheSessionStoreProvider.ApplicationName">
			<summary>The name of the application, used to differentiate sessions in the cache cluster.</summary>
			<returns>A string value that represents the name of the application that uses the distributed cache to store session state.</returns>
		</member>
	</members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\XUserTests\Microsoft.XboxLive.Auth.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.XboxLive.Auth</name>
    </assembly>
    <members>
        <member name="T:Microsoft.XboxLive.Auth.AuthException">
            <summary>
            The exception that is  thrown  when  a  authorization  policy
            error occurs.
            </summary>
            <remarks>
            The AuthException class allows applications to  differentiate
            exceptions thrown by  the  system and/or  authorization  code.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor">
            <summary>Initializes a new instance of the  AuthException
            class.</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String)">
            <summary>Initializes a new instance of the  AuthException
            class with a specified error message.</summary>
            <param name="message">The error message that explains the
            reason for the exception.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String,System.String[])">
            <summary>Initializes a new instance of the  AuthException
            class with a specified error message.</summary>
            <param name="format">The error message that explains the
            reason for the exception.</param>
            <param name="args">The arguments for the format string.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the  AuthException
            class with a specified error message and a  reference  to
            the inner exception that is the cause of  this  exception.
            </summary>
            <param name="message">The error message that explains the
            reason for the exception.</param>
            <param name="innerException">The exception  that  is  the
            cause of the current exception, or a null reference if no
            inner exception is specified.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String,System.Exception,System.String[])">
            <summary>Initializes a new instance of the  AuthException
            class with the specified error formatted  message  and  a
            reference to the inner exception that is the cause of the
            exception.
            </summary>
            <param name="format">The error message that explains the
            reason for the exception.</param>
            <param name="innerException">The exception  that  is  the
            cause of the current exception, or a null reference if no
            inner exception is specified.</param>
            <param name="args">The arguments for the format string.</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.ClaimNotFoundException">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.ClaimNotFoundException.#ctor(System.String)">
            <summary>Initializes a new instance of the ClaimNotFoundException class</summary>
            <param name="claimType">The claimType that was not found</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.ClaimNotFoundException.#ctor(System.String,System.String)">
            <summary>Initializes a new instance of the ClaimNotFoundException class</summary>
            <param name="claimType">The claimType that was not found</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.ClaimNotFoundException.#ctor(System.String,System.String,System.Exception)">
            <summary>Initializes a new instance of the ClaimNotFoundException class</summary>
            <param name="claimType">The claimType that was not found</param>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">Gets the Exception instance that caused the current exception.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.ClaimNotFoundException.ClaimType">
            <summary>
            Gets the claimType  that  caused  the  current  exception
            </summary>
            <remarks>
            The type of the claimType is a string.  But  most  claims
            processing frameworks require this to be  a  well  formed
            uri.</remarks>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes"/>
            <seealso cref="T:Microsoft.IdentityModel.Claims.ClaimTypes"/>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.InvalidClaimException">
            <summary>
            The specific claim is invalid.  That claim value is not valid
            for the ClaimValueType.</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.InvalidClaimException.#ctor(Microsoft.IdentityModel.Claims.Claim)">
            <summary>Initializes a new instance of the InvalidClaimException
            class.</summary>
            <param name="claim">The claim that is invalid</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.InvalidClaimException.#ctor(Microsoft.IdentityModel.Claims.Claim,System.String)">
            <summary>Initializes a new instance of the InvalidClaimException
            class.</summary>
            <param name="claim">The claim that is invalid</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.InvalidClaimException.#ctor(Microsoft.IdentityModel.Claims.Claim,System.String,System.Exception)">
            <summary>Initializes a new instance of the InvalidClaimException
            class.</summary>
            <param name="claim">The claim that is invalid</param>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">Gets the Exception instance that caused the current exception.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.InvalidClaimException.Claim">
            <summary>
            Gets the invalid claim that caused the exception.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthHelper">
            <summary>The AuthHelper class provides a number of convenience
            methods for accessing an IClaimsPrincipal. All of the function
            herein can be had by iterating over the identities  and  claim
            sets in the IClaimsPrincipal.</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.AuthHelper.DEFAULT_ISSUER">
            <summary>
            The default issuer is the issuer used when no other issuer
            is specified.  This is true when using the  AuthHelper  as 
            well as attributes and web.config.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.AuthHelper.SYSTEM_ISSUER">
            <summary>
            The system issuer is used when authoring local claims added
            to the current principal by an  internal  process - not  by
            the security token service.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor">
            <summary>
            Initialize an AuthHelper using  the  principal from the
            current thread of execution and with the default issuer.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor(Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Initialize an AuthHelper. All tests using the helper will
            be applied against the specified claims principal and the
            default issuer.
            </summary>
            <param name="claimsPrincipal">The principal to check when
            doing claims verification.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor(System.String)">
            <summary>
            Initialize an AuthHelper and set the default issuer using
            the supplied claimIssuer.</summary>
            <param name="issuer">The issuer to check for when doing
            claims verification.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            Initialize an AuthHelper with the specified claims principal
            and claims issuer.</summary>
            <param name="claimsPrincipal">The principal to check when
            doing claims verification.</param>
            <param name="issuer">The issuer to check for when doing
            claims verification.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyExists(System.String)">
            <summary>Verify the existence of the specified claimType</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <returns>True if the claim exists, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyEquals(System.String,System.Object[])">
            <summary>Verify that the value of the specified claim is
            equal to one of the specified values.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="values">The values against which the claim value
            is compared.</param>
            <returns>True if the claim exists and is equal to one of the 
            specified values</returns>
            <remarks>The specified values are converted to the ValueType of
            the claim before comparing with the claim Value.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyGreaterThan(System.String,System.Object)">
            <summary>Verify that the value of the specified claim is
            greater than the specified value.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="value">The value against which the claim value
            is compared.</param>
            <returns>True if the claim exists and is greater than the
            specified value</returns>
            <remarks>The specified claimValue parameter is converted to the
            ValueType of the claim before comparing with the claim Value
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyLessThan(System.String,System.Object)">
            <summary>Verify that the value of the specified claim is
            less than the specified value.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="value">The value against which the claim value
            is compared.</param>
            <returns>True if the claim exists and is less than the
            specified value</returns>
            <remarks>The specified claimValue parameter is converted to the
            ValueType of the claim before comparing with the claim Value
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyContains(System.String,System.Object[])">
            <summary>Verify that the value of the specified claim type contains
            all of the specified values. The value type of the claim type must
            be an array type.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="values">The values against which the claim value
            is compared.</param>
            <returns>True if the claim exists and all of the specified values
            are contained by the claim value</returns>
            <remarks>The specified values are converted to strings and
            compared against the string values in the claim value.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.FindClaim(System.String)">
            <summary>
            Find a claim with the specified claimType from the specified
            issuer.
            </summary>
            <param name="claimType">Find claims with this claimType.</param>
            <returns>A claim, or null, if no claim is found.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyClaim(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String,Microsoft.XboxLive.Auth.Claims.AuthComparison,System.Object[])">
            <summary>
            Find a claim with the specified claimType, and compare its value
            against the supplied array of valid values.  Return true / false
            as a function of the supplied predicate.
            </summary>
            <param name="principal">Look for claims for this principal.</param>
            <param name="issuer">Look for claims from this issuer.</param>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="comparison">The operation used to verify the claim.</param>
            <param name="validValues">The list of valid values against which to compare.</param>
            <returns>True if the claim exists and values passes the comparision test</returns>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.AuthHelper.Principal">
            <summary>
            The principal to use when finding and verifying claims.
            </summary>
            <remarks>
            If not supplied at construction, the principal is taken off
            the current thread of execution.   If there is no principal
            on the current thread, vthen an anonymous principal is used
            as a default.
            </remarks>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.AuthHelper.Issuer">
            <summary>
            The issuer to use when checking for claims.
            </summary>
            <remarks>
            If not supplied at construction,  or in configuration the
            issuer defaults to "xsts.xboxlive.com".
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthTrace">
            <summary>The AuthTrace class allows for tracing of authorization
            policy.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Error(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Error or higher.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Warning(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Warning or higher.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Info(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Info or higher.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Verbose(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Verbose.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.AuthTrace.TraceSwitch">
            <summary>
            Gets the TraceSwitch that controls  tracing.  Applications
            can set the Level to programmatically control trace output
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups">
            <summary>AuthAgeGroups defines the set of possible
            values for the claimType  AuthClaimTypes.AgeGroups.
            The values are assigned to users as a function  of
            their country of record.</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups.Child">
            <summary>The user  is  considered  a  child  in
            their country of record.  Typically this  means
            less than 13 years of  age,  but it  varies  by
            country (e.g. less han 14 years of age in Korea)
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups.Teen">
            <summary>The user is considered  a teenager  in
            their country  (not a child or an adult  -  see
            definitions above/below.</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups.Adult">
            <summary>The user  is  considered  an adult  in
            their country of record.  Typically this  means
            greater than or equal to 18 years of  age,  but
            it varies by country.</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup">
            <summary>the user's agegroup</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ClientIpPort">
            <summary>the client's external ip address and port</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country">
            <summary>the country id of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DelegationToken">
            <summary>a bearer token used for delegation back to Xbox LIVE</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId">
            <summary>the unique identifier for the device</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceName">
            <summary>the identifier for the device name</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceType">
            <summary>the device type</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.FlowToken">
            <summary>the unique session identifier</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Gamertag">
            <summary>the gamertag of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language">
            <summary>the user's language</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ParentXuid">
            <summary>the parent xuid of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.PartnerDeviceId">
            <summary>the unique identifier for the device</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.PartnerParentXuid">
            <summary>the partner parent xuid for the user (based on the relying party)</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.PartnerXuid">
            <summary>the partner xuid for the user (based on the relying party)</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Privileges">
            <summary>the privileges granted to the user</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthPrivileges"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Puid">
            <summary>the passport user id (puid) of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Status">
            <summary>the user status</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthStatus"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Tier">
            <summary>the xbox live subscription tier of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId">
            <summary>the title id</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthTitles"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleVersion">
            <summary>the title version</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid">
            <summary>the xuid of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ValueTypes">
            <summary>the claim value types for all AuthClaimTypes</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Create(System.String,System.Object,System.String,System.String)">
            <summary>
            Create a Claim from an arbitrary C# object with the appropriate formatting.
            </summary>
            <param name="claimType">Type of claim to create, see AuthClaimTypes</param>
            <param name="claimValue">The claim's value, may be any basic C# type</param>
            <param name="claimValueType">Format of the claim value as a string, see AuthClaimValueTypes</param>
            <param name="issuer">Name of the issuer of this claim</param>
            <returns>New Claim with proper formatting</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.IntegerArray">
            <summary>a comma-separated list of integers</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.IpAddress">
            <summary>a "dotted 4" notation with optional port</summary>
            <example>1.2.3.4, 1.2.3.4:2000</example>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.Decimal">
            <summary>
            Microsoft.IdentityModel.Claims.ClaimValueTypes does not
            define this one.  Make this one claim value type easier
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthIdentityTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthIdentityTypes.SG">
            <summary>the machine / device identity</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthIdentityTypes.ActiveAuth">
            <summary>the user identity</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes">
            <summary>
            AuthDeviceTypes defines the set of possible
            values for the claimType AuthClaimTypes.DeviceTypes.    
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.WindowsPhone">
            <summary>
            The token was issued for a Windows Phone device.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.WindowsPhone7">
            <summary>
            The token was issued for is a Windows Phone 7 device.
            Deprecated: we can't tell the difference between WP7 and Apollo
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Web">
            <summary>
            The token was issued for a web browser or other unknown platform.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360">
            <summary>
            The token was issued for an Xbox 360 console.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC">
            <summary>
            The token was issued for a PC running Games for Windows Live.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthPrivileges">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.AddFriend">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.Multiplayer">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MultiplayerEnabledByTier">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.VideoMessagingSend">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PurchaseContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.CrossPlatformMultiplayer">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.CrossPlatformCommunications">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PreviousLiveProtocols">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.VideoCommunications">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.TradeContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MusicExplicitContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MetroAccess">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PassportSwitching">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.BillingSwitching">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MultiplayerDedicatedServer">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.UserGraduation">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PremiumVideo">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.Primetime">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.ContentAuthor">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PiiAccess">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.SocialNetworkSharing">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.SubscriptionContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.SubscriptionTitle">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PremiumContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.Family">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.UnsafeProgramming">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.ShareContent">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthStatus">
            <summary>AuthStatus defines the set of possible values
            for the claimType AuthClaimTypes.Status</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthStatus.Maintenance">
            <summary>The user account requires maintenance and
            can only access maintenance services.  The account
            must be fixed before accessing other user services
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthStatus.Ok">
            <summary>The user account is in good standing  and
            is allowed to access all user  services.</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthTiers">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.NewUser">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.Silver">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.Gold">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.FamilyGold">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthTitles">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.LiveSignup">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.Web">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.XenonDashboard">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.Zune">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.DashboardTitles">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.WebTitles">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthValue.Create(System.Object,System.String)">
            <summary>
            Create the appropriate AuthValue object as a function of the
            claimType
            </summary>
            <param name="o">The object to convert into an AuthValue</param>
            <param name="claimValueType">The type to which the object is converted</param>
            <returns>An AuthValue representing the supplied object</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthByteArray">
            <summary>
            AuthByteArray is a common class used to wrap a byte array. It
            is derived by the AuthBase64Binary and AuthHexBinary  classes.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthByteArray.#ctor">
            <summary>
            Initializes a new instance of the AuthByteArray class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthByteArray.CompareTo(System.Object)">
            <summary>
            Compare the value of the wrapped byte array with the user
            supplied value.  Arrays of different lengths are compared
            up to the length of the shorter array.  If they are equal
            at that point, then the  longer array is considered to be
            greater.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBase64Binary.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthBase64Binary  class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBase64Binary.ToString">
            <summary>
            Return the canonical representation of a base  64  string.
            This is the standard conversion from .NET.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthHexBinary">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthHexBinary.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthHexBinary class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthHexBinary.ToString">
            <summary>
            Return the canonical representation of a hex string. That
            is, 0-9, A-F,  with no lower case  and  no  leading  "0x"
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthInteger.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthInteger class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDateTime.#ctor(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDateTime.ToString">
            <summary>
            Return the canonical representation of a #time
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthString">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthString.#ctor(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthString.CompareTo(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBoolean.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthTime class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBoolean.CompareTo(System.Object)">
            <summary>
            Compare the wrapped boolean value. Return 0 if  they  are
            equal.  For the purposes of greater than  and  less  than
            assume that true is greater than false.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBoolean.ToString">
            <summary>
            Return the canonical representation of a boolean value.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Claims.AuthBoolean.Value">
            <summary>
            Get the wrapped boolean value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthTime.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthTime class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthTime.ToString">
            <summary>
            Return canonical representation of a time (hours, minutes,
            seconds and a timezone).
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDecimal.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthDecimal class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDecimal.ToString">
            <summary>
            Return the canonical representation of a decimal
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthIpAddress">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthIpAddress.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthIpAddress class.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Claims.AuthIpAddress.Address">
            <summary>
            Get the wrapped address values
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthIntegerArray">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthIntegerArray.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthIntegerArray class.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Claims.AuthIntegerArray.Values">
            <summary>
            Get the wrapped integer array value
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthConfig">
            <summary>
            The AuthConfig class is the top node in the configuration. It
            has no attributes, and is just a collection of service  nodes.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthConfig.Find(System.String,System.String)">
            <summary>
            Find configured policy for the specifed service and action
            </summary>
            <param name="serviceName">The name of  the  service. This
            varies by framework type. For instance, for ASP.NET  SOAP
            this is the [WebService] class name. For ASP.NET MVC this
            is the controller name.</param>
            <param name="actionName">The name  of  the  action.  This
            varies by framework type.  For instance, for ASP.NET SOAP
            this is the [WebMethod] name.  For WCF, this is the  name
            of the [OperationContract].   For ASP.NET MVC this is the
            action name.</param>
            <returns>The configued policy for the specificed service
            and action. If no policy is defined then null.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthConfig.Find(System.String)">
             <summary>
             Find configured global policy for  the  specifed  service
             </summary>
             <param name="serviceName">The name of  the  service. This
             varies by framework type. For instance, for ASP.NET  SOAP
             this is the [WebService] class name. For ASP.NET MVC this
             is the controller name.</param>
             <returns>The configured policy for the specificed service.
            If no policy is defined then null.</returns>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthConfig.Services">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthConfig.Issuer">
            <summary>
            By default we look for an issuer  of  "xsts.xboxlive.com".
            Setting the issuer attribute on the configuration element
            changes the default to the specified value. That value is
            used in AuthAttribute and AuthHelper code.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthConfig.Current">
            <summary>
            Return the configuration for the current thread.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthServiceCollection">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.IndexOf(System.String)">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.CreateNewElement">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.Item(System.String)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.Item(System.Int32)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.CollectionType">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.ElementName">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthServiceElement">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceElement.Name">
            <summary>
            This is the service name for which the policy is  defined.
            The use of this value varies depending on the application
            framework being used.
            
            For ASP.NET using SOAP it is the class name  of  the  web
            service.  For MVC it is the class name of the  controller.
            For WCF it is the interface name of the service  contract.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceElement.Policies">
            <summary>
            Each  service  element  can  have  zero  or  more  global
            policies to be applied to all actions.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceElement.Actions">
            <summary>
            Each service element has zero  or  more  action  elements.
            Depending  on  the  application  framework,  each  action 
            represents a method or action on which policy is  defined.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthActionCollection">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionCollection.IndexOf(System.String)">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionCollection.CreateNewElement">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.Item(System.String)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.Item(System.Int32)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.CollectionType">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.ElementName">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthActionElement">
            <summary>
            An AuthActionElement is the  root  element  for configuration
            policy on an action (e.g. web method, operation contract, etc)
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthPolicyElement">
            <summary>
            An AuthPolicyElement is the  root  element  for configuration
            policy on an action (e.g. web method, operation contract, etc)
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthPolicyElement.DeserializeElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Get the policy elements for the service or action using a
            custom deserializer.
            </summary>
            <param name="reader">XmlReader sent by the  configuration
            processing code.</param>
            <param name="serializeCollectionKey">required parameter
            in the base class.  This is unused.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthPolicyElement.Policy">
            <summary>
            This is the actual authorization policy  associated  with 
            the action. The policy has a check method that is invoked
            just before the action.
            
            The policy is configured using custom  configuration  XML
            inside of the action node.  That is,  there is no further
            definition  using  the  System.ServiceModel.Configuration
            classes.  It hooks in a custom parser by  overriding  the
            DeserializeElement method below..
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionElement.DeserializeElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Skip over parts for the current  AuthActionElement.  Then
            read the inner nodes and parse the XML to  obtain  policy
            for this action.
            </summary>
            <param name="reader">XmlReader sent by the  configuration
            processing code.</param>
            <param name="serializeCollectionKey">required parameter
            in the base class.  This is unused.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionElement.Name">
            <summary>
            This is the action  name for which the policy is  defined.
            The use of this value varies depending on the application
            framework being used.
            
            In all cases it is the name of a method that  is  invoked.
            For ASP.NET using SOAP it is the web method name, for MVC
            it the method name for the action.  For  WCF  it  is  the
            interface method  attributed  with  the  OperationContact .
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthExtensions">
            <summary>
            AuthExtensions contains a number class extensions  to  make  it
            easier to navigate IClaimsPrincipal and IClaimsIdentity objects.
            </summary>
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsIdentity,System.Predicate{Microsoft.IdentityModel.Claims.Claim})">
            <summary>
            For this identity,  check to see if there is a claim that matches the
            specified predicate.
            </summary>
            <param name="identity">The IClaimsIdentity instance that serves as "this".</param>
            <param name="predicate">The Predicate to be evaluated.</param>
            <returns>True if the predicate evaluates to true, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsIdentity,System.String,System.String@)">
            <summary>
            For this identitty, try to get the value of the specified claim (claimType)
            without respect to the issuer of the claim.
            </summary>
            <param name="identity">The IClaimsIdentity instance that serves as "this".</param>
            <param name="claimType">The claimType (name)</param>
            <param name="claimValue">The string that will receive the claimValue</param>
            <returns>True if the claim and value were found, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsIdentity,System.String,System.String,System.String@)">
            <summary>
            For this identity,  try to get the value of the specified claim (claimType)
            from the specified issuer.
            </summary>
            <param name="identity">The IClaimsIdentity instance that serves as "this".</param>
            <param name="claimType">The claimType (name)</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <param name="claimValue">The string that will receive the claimValue</param>
            <returns>True if the claim and value were found, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.FindClaims(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.Predicate{Microsoft.IdentityModel.Claims.Claim})">
            <summary>
            For this principal, find all claims that match the specified predicate.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="predicate">The predicate used to match claims</param>
            <returns>A enumerable collection of matching claims</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.FindClaims(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            For this principal, find all claims that match the specified claimType without
            to issuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <returns>A enumerable collection of matching claims</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.FindClaims(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String)">
            <summary>
            For this principal, find all claims that match the specified claimType and claimIssuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <returns>A enumerable collection of matching claims</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.Predicate{Microsoft.IdentityModel.Claims.Claim})">
            <summary>
            For this principal, check if there exists a claim matching the predicate.
             </summary>
             <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="predicate">The predicate used to match claims</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            For this principal, check if the specified claim type exists without respect to issuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String)">
            <summary>
            For this principal, check if the specified claim type from the specified issuer exists. 
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String,System.String@)">
            <summary>
            For this principal, try to get the value of the specified claim from the specified issuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <param name="claimValue">Receives the claim value</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String@)">
            <summary>
            For this principal,  try to get the value of the specified claim without respect to issuer.  
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimValue">Receives the claim value</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.GetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String)">
            <summary>
            For this principal, get the value of the specified claim from the specified
            issuer from the principal. Only the first value is returned.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <returns>The claim value</returns>
            <exception cref="T:Microsoft.XboxLive.Auth.ClaimNotFoundException">if the claim is not found</exception>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.GetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            For this principal, get the value of the specified claim from the principal
            without respect to the issuer. Only the first value is returned.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <returns>The claim value</returns>
            <exception cref="T:Microsoft.XboxLive.Auth.ClaimNotFoundException">if the claim is not found</exception>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthAttribute">
            <summary>
            Represents the base class for authorization policy attributes.
            </summary>
            <remarks>
            The authorization attributes are used to define authorization
            policy on classes, methods, and their parameters.  Each  time
            a method is invoked it is checked  for  authorization  policy.
            If there is a policy defined for a given  method   then  that
            policy is checked against the current  authorization  context
            before the method is invoked.  If the policy check fails then
            an exception is thrown and the method is not called.
            </remarks>
            <example>
            <code>
            // Example of a SOAP web method with authorization attributes
            
            [AuthExists(AuthClaimTypes.Xuid)]
            [WebMethod]
            public void ChangeGamertag(
               [VerifyClaim(AuthClaimTypes.Gamertag)] string gamertag
            );
            
            Example of a WCF operation contact with authorization attributes
            
            [VerifyPlatformId(AuthPlatforms.Xbox360)]
            [RequireClaim(AuthClaimTypes.DeviceId)]
            [OperationContract]
            public void AutoUpdateReferral()
            </code>
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthAttribute.#ctor">
            <summary>
            The constructor for all  auth attributes sets the default
            issuer.  This can be set via  configuration  or  using  a
            named attribute parameter.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Policy.AuthAttribute.ClaimType">
            <summary>
            The claim type to look for and test
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Policy.AuthAttribute.Issuer">
            <summary>
            The issuer from which claims of the specified type should
            originate.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthClassMethodAttribute">
            <summary>
            This is the base attribute for all  authorization  attributes
            placed on classes and methods.  Class and  method  attributes
            are  limited to simple claim existence checks and  comparison
            of claim values against compile time values.
            </summary>
            <remarks>This is an abstract class and cannot be instantiated.
            It is the base class for all authorization policy  attributes
            with a AttributeTarget of Class or Method.</remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthClassMethodAttribute.#ctor">
            <summary>
            protected constructor to hook into constructor  for  base
            class which sets the default issuer.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthClassMethodAttribute.GetPolicy">
            <summary>
            Abstract method for converting auth attributes AuthPolicy.
            </summary>
            
            <returns>An AuthPolicy object called later to do policy
            enforcement checks.</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthArrayAttribute">
            <summary>
            The AuthArrayAttribute is used to check claims against a  set
            of values (provided in an array).  Multiple checks are made - 
            one against each value in the array.  Allows  for  and/or  of
            results.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Policy.AuthArrayAttribute._values">
            <summary>
            Array of values used by Allowed and  Required  attributes.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthArrayAttribute.#ctor(System.String,System.Object[])">
            <summary>
            Initializes new instance of the  AuthArrayAttribute class.
            This is a protected constructor.  It is currently used to
            derive other attributes.
            </summary>
            <param name="claimType">claimType to  be  checked</param>
            <param name="values">The array values against  which  the
            claim value is checked</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AllowedValuesAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedValuesAttribute.#ctor(System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="claimType"></param>
            <param name="values"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedValuesAttribute.GetPolicy">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.RequiredValuesAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.RequiredValuesAttribute.#ctor(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="claimType"></param>
            <param name="values"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.RequiredValuesAttribute.GetPolicy">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AllowedPlatformsAttribute">
            <summary>
            The AllowedPlatformsAttribute is used to affect policy checks
            of the device type against an array of valid  platform  types
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedPlatformsAttribute.#ctor(System.String[])">
            <summary>
            Initializes an instance of AllowedPlatformsAttribute
            </summary>
            <param name="values">The array of allowed platform types</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AllowedTitlesAttribute">
            <summary>
            The AllowedTitlesAttribute is used to affect policy checks of
            the title id claim  against  an  array  of  valid  title  ids
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedTitlesAttribute.#ctor(System.UInt32[])">
            <summary>
            Initializes an instance of AllowedTitlesAttribute
            </summary>
            <param name="values">The array of allowed titles ids</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.RequiredPrivilegesAttribute">
            <summary>
            Verify that all of the  privileges  in  the  specified  array
            appear in the privileges claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.RequiredPrivilegesAttribute.#ctor(System.Byte[])">
            <summary>
            Initializes an instance of RequiredPrivilegesAttribute
            </summary>
            <param name="privileges">The array of required privileges</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthExistsAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthExistsAttribute.#ctor(System.String)">
            <summary>
            Initializes an instance of the AuthExistsAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for
            which we are checking</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthComparisonAttribute">
            <summary>
            Verify that the specified claim is present and then perform the
            specified comparison operation between the specified value  and
            the claim value.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthComparisonAttribute.#ctor(System.String,System.Object,Microsoft.XboxLive.Auth.Claims.AuthComparison)">
            <summary>
            Initializes an instance of the AuthComparisonAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
            <param name="comparison">The comparision operation to perform</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthEqualsAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            and that the claim value is  equal  to  the  specified  value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthEqualsAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an instance of the AuthEqualsAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthGreaterThanAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            and that the claim value is  equal  to  the  specified  value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthGreaterThanAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an instance of the AuthGreaterThanAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthLessThanAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            and that the claim value is less  than  the  specified  value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthLessThanAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an instance of the AuthLessThanAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthParameterAttribute">
            <summary>Represents the base class for  authorization  policy
            attributes applied to method parameters.   Class  and  method
            parameters make static checks for the  presence  of  specific
            claims or specific well know  values.   Parameter  attributes
            compare specific claims against  the  parameter  value  being
            passed into the method.</summary>
            <remarks>This is an abstract class and cannot be instantiated.
            It is the base class for all authorization policy  attributes
            with a Parameter.</remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthParameterAttribute.#ctor">
            <summary>
            protected constructor to hook into constructor  for  base
            class which sets the default issuer.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthParameterAttribute.GetPolicy(System.Reflection.ParameterInfo)">
            <summary>
            Abstract method for converting auth attributes into policy
            rexpression.  Parameter attributes differ from method  and
            class attributes in that they take a  parameter  which  is
            used to lookup the value of the  parameter  on  each  call.
            </summary>
            
            <returns>An AuthPolicy object</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthVerifyAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the specified claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthVerifyAttribute.#ctor(System.String)">
            <summary>
            Initializes an  instance  of  the AuthVerifyAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the specified claim type</remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyMachineAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the device id claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyMachineAttribute.#ctor">
            <summary>
            Initializes a new instance of the  VerifyMachineAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the well known claimType  AuthClaimTypes.DeviceId.
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyUserAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the user (xuid) claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyUserAttribute.#ctor">
            <summary>
            Initializes a new instance of the VerifyUserAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against  the  well  known  claimType  AuthClaimTypes.Xuid
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyTitleAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the title id claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyTitleAttribute.#ctor">
            <summary>
            Initializes a new instance  of  the  VerifyTitleAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the well known  claimType  AuthClaimTypes.TitleId
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyCountryAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the country claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyCountryAttribute.#ctor">
            <summary>
            Initializes a new instance of the  VerifyCountryAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the well known  claimType  AuthClaimTypes.Country
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthBehaviorElement">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthBehaviorElement.CreateBehavior">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Policy.AuthBehaviorElement.BehaviorType">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthBehavior">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthBehavior.#ctor">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthBehavior.#ctor(System.String,System.Reflection.MethodInfo,Microsoft.XboxLive.Auth.Policy.AuthPolicy)">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthComparison">
            <summary></summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthComparison.Equals">
            <summary></summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthComparison.GreaterThan">
            <summary></summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthComparison.LessThan">
            <summary></summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthInvoker">
            <summary>
            The AuthInvoker class is the main interception point for  WCF
            policy checks.  The AuthBehavior reflects over  AuthAttribute
            attributes and policies defined in the web.config and inserts
            the AuthInvoker into the OperationInvoker chain as  necessary.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthInvoker.#ctor(System.ServiceModel.Dispatcher.IOperationInvoker,System.String,System.Reflection.MethodInfo,Microsoft.XboxLive.Auth.Policy.AuthPolicy)">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthPolicy">
            <summary>
            AuthPolicy is the root class used to check policy for a given
            service and action.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthPolicy.Add(System.String,System.String,System.Reflection.MethodInfo)">
            <summary>
            Add policy for the  specified service and action. Look in
            the configuration for defined  policy,  and if  there  is
            none,  then through reflection on the supplied methodInfo
            </summary>
            <param name="serviceName">The name of the service</param>
            <param name="actionName">The name of the action</param>
            <param name="methodInfo">The methodInfo for the action</param>
            <returns>The configured policy for the service and action.
            If no policy is defined then return AuthPolicy.NullPolicy
            </returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthPolicy.GetParameter(System.Collections.Generic.IDictionary{System.String,System.Object},System.Reflection.ParameterInfo)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
            <param name="parameterInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.Initialize(System.Object)">
            <summary>
            This is a required abstract method.  We don't  need  to  do
            anything here.  It just has to be present
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.GetInitializer(System.Type)">
            <summary>
            Called when ASP.NET finds a SoapExtension in the web config
            file.  Reflect on the serviceType to find all  web  methods
            Then look to see if there is any policy defined  (it  would
            come from the config  file).  If there is none then see  if
            the code is attributed for authorization.
            </summary>
            <param name="serviceType">the method  we  are  expected  to
            initialize.  use this to get the declaring type for the web
            method (that is the web  service  class)
            </param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.GetInitializer(System.Web.Services.Protocols.LogicalMethodInfo,System.Web.Services.Protocols.SoapExtensionAttribute)">
            <summary>
            Called when ASP.NET finds a SoapExtensionAttribute on a web
            web method.  Even though this is for a  single  method,  we
            initialize the whole web service by calling back  into  the
            GetInitializer for a web.config defined SoapExtension.
            </summary>
            <param name="methodInfo">the method we are initializing. we
            use this to get the declaring type for the web method (that
            is the web service class)
            </param>
            <param name="attribute">the attribute that  triggered  this
            call. we don't need use it because the common code reflects
            </param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.ProcessMessage(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            ProcessMessage is called multiple times at different stages
            We enforce authorization policy during the AfterDeserialize
            stage.
            </summary>
            <param name="message">The request we  are  authorizing.  We
            need this to get the methodName, and then the parameters to
            do any data binding
            </param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy">
            <summary>
            Reads in authorization header.  Presents header to  token  handlers
            to see who can read the token, one of which will return a principal
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.#ctor">
            <summary>
            Null constructor required so WCF can instantiate the authorization policy
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.Evaluate(System.IdentityModel.Policy.EvaluationContext,System.Object@)">
            <summary>
            Take the request and look for authorization context on the
            headers.   If we find it and can parse it,  then create  a
            principal and put it on the thread.
            </summary>
            <param name="evaluationContext">The <see cref="T:System.IdentityModel.EvaluationContext"/> for the request.</param>
            <param name="state"></param>
            <returns>
            true if access is granted; otherwise, false. The default is true.
            </returns>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.Id">
            <summary>
            Get the id of the authorization policy object.  
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.Issuer">
            <summary>
            Get the Issuer of the authorization policy object.  
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule">
            <summary>
            XblAuthProtocolModule is an HttpModule to provide basic token authentication
            handling. It hooks into ASP.NET's AuthenticateRequest callback and consumes
            the 'Authorization' or 'X-Authorization' HTTP header. 
            </summary>
            <remarks>
            The "XblAuthProtocol" is a simple authentication protocol, vaguely similar in 
            functionality to WS-Federation but more active. The client provides the STS
            token (presumably SAML2.0, but not necessarily) in an HTTP header, and this
            module reads that token and verifies it and creates an IClaimsPrincipal.
            
            The header value must contain "XBL2.0 x=STSTOKEN", where STSTOKEN is the XML 
            token received from the XSTS service. The output of the module is an 
            IClaimsPrincipal placed in Thread.CurrentPrincipal. If no header is present,
            the module does nothing. 
            
            Authorization is left to the user of this module. Any errors that occur during
            parsing or validation are passed to a callback event, and if not cancelled, the
            exception is rethrown. ASP.Net will catch this and abort the request.
            </remarks>
            <example>
            In the configuration section of your web.config:
            
              <system.webServer>
                <modules>
                   <add name="XblAuthProtocolModule" type="Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule, Microsoft.XboxLive.Auth "/>
                </modules>
              </system.webServer>
              
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.Init(System.Web.HttpApplication)">
            <summary>
            Initialize module. Hooks into AuthenticateRequest handler.
            </summary>
            <param name="application"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.ProcessAuthenticateRequest(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Handles bulk of reading and validating the incoming token. 
            </summary>
            <param name="webHeaders">Incoming HTTP headers. Looks for Authorization header.</param>
            <param name="rawUrl">Full URL of incoming request.</param>
            <returns>Validated IClaimsPrincipal, or null if none available.</returns>
            <remarks>
            Marked public to allow for testing, but not intended for external use.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.IsFatal(System.Exception)">
            <summary>
            Determines whether an exception is fatal or whether we should attempt to 
            handle it gracefully.
            </summary>
            <param name="exception"></param>
            <returns>True if fatal</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.Trace(System.Exception,System.String,System.Object[])">
            <summary>
            Handles writing a diagnostic trace line.
            </summary>
            <param name="e">Optional exception, pass null if none</param>
            <param name="msgFormat">Optional message and format string</param>
            <param name="msgArgs">Message format arguments</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.ModuleName">
            <summary>
            Name of the HTTP module
            </summary>
        </member>
        <member name="E:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.AuthenticateError">
            <summary>
            Fires for any unhandled error during AuthenticateRequest
            </summary>
        </member>
        <member name="E:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.TraceOutput">
            <summary>
            Fires for any traceline generated during execution
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs">
            <summary>
            Arguments for handling a traceline event callback
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs.Message">
            <summary>
            The trace message
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs.Error">
            <summary>
            An exception associated with the trace, if any. May be null.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs.ToString">
            <summary>
            Helper for printing the trace event
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler">
            <summary>
            Core code that implements the "Xbox Live Auth Protocol", which is simple replacement
            for WS-Federation (ASP.NET) and WS-Trust, et al (WCF) that WIF includes out of the 
            box.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.HEADER_NAME">
            <summary>The primary header used for transporting tokens in an HttpRequest</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ALT_HEADER_NAME">
            <summary>The secondary header used for transporting tokens in an HttpRequest</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.#ctor">
            <summary>Instantiate an XblAuthProtocolHandler</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ProcessToken(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Read token from header then authenitcate it. Same as calling ReadToken() 
            and AuthenticateToken().
            </summary>
            <param name="httpHeaders">Incoming HTTP headers containing the token in the "Authorization" header.</param>
            <param name="resourceName">Resource being requested, usually the URL of the request</param>
            <returns>New IClaimsPrincipal from token, else null if none</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ReadTokens(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Attempts to parse the 'XBL2.0' token from the Authorization or X-Authorization
            header, parses the XML token value, and reads it using the WIF library. This
            allows for custom handlers and authenticators can be plugged in and configured 
            as desired.
            </summary>
            <param name="httpHeaders">Headers collection, looks for 'Authorization' or 'X-Authorization'</param>
            <returns>array of security tokens, may have zero entries</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ReadToken(System.String)">
            <summary>
            Uses WIF to read an XML formatted token.
            </summary>
            <param name="tokenXml">Token in XML format.</param>
            <returns>New SecurityToken, or else null if none.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)">
            <summary>
            Creates the value for the 'Authorization' header for the given token.
            </summary>
            <param name="token">Valid security token</param>
            <returns>Header value of encoded token</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken,Microsoft.IdentityModel.Tokens.SecurityTokenHandler)">
            <summary>
            Creates the value for the 'Authorization' header for the given token and token
            handler.
            </summary>
            <param name="token">Valid security token</param>
            <param name="handler">Handler to use for writing the token</param>
            <returns>Header value of encoded token</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.AuthenticateToken(System.IdentityModel.Tokens.SecurityToken,System.String)">
            <summary>
            Uses WIF's token authentication to authenticate a security token and extract the
            IClaimsPrincipal from it. 
            </summary>
            <param name="securityToken">Security token read from the request</param>
            <param name="resourceName">Name of requested resource. Usually this is the URL.</param>
            <returns>The resulting IClaimsPrincipal, which is also set to Thread.CurrentPrincipal. Returns null if anything fails.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.GetCurrentConfiguration">
            <summary>Get the current service configuration from the OperationContext.  If
            none is present then look in the FederatedAuthentication service configuration.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.GetSecurityTokenXml(System.Collections.Specialized.NameValueCollection)">
            <summary>Get one of the well-known Authorization headers from the collection
            of headers, strip off the protocol parts go get to the XML and then decode
            the HTTP encoded elements to generate a straight up XML string</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.TryParseAuthorizationHeader(System.Collections.Specialized.NameValueCollection,System.String@,System.String@)">
            <summary>
            Looks for "Authorization" or "X-Authorization" header and attempts to parse the 
            token. 
            </summary>
            <param name="headerCollection">HTTP headers</param>
            <param name="authName">Parsed named of auth scheme, e.g. "XBL1.0" or "WLID1.0"</param>
            <param name="authValue">Parsed value of the auth scheme, e.g. "x=..." or "t=..."</param>
            <returns>True if successful, false if not</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.TryParseAuthorizationHeader(System.String,System.String@,System.String@)">
            <summary>
            Parse the authorization header into 2 tokens.
            </summary>
            <param name="authHdrValue">HTTP header value</param>
            <param name="authName">Parsed named of auth scheme, e.g. "XBL1.0" or "WLID1.0"</param>
            <param name="authValue">Parsed value of the auth scheme, e.g. "x=..." or "t=..."</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.DecodeHeaderXml(System.String)">
            <summary>Decode HTTP encoded XML string back to straight up XML</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.EncodeHeaderXml(System.String)">
            <summary>Remove new lines and carriage returns from the XML string</summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ServiceConfig">
            <summary>
            WIF-provided configuration, either from web.config or a default.
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\XSecsupTests\Microsoft.XboxLive.Auth.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.XboxLive.Auth</name>
    </assembly>
    <members>
        <member name="T:Microsoft.XboxLive.Auth.AuthException">
            <summary>
            The exception that is  thrown  when  a  authorization  policy
            error occurs.
            </summary>
            <remarks>
            The AuthException class allows applications to  differentiate
            exceptions thrown by  the  system and/or  authorization  code.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor">
            <summary>Initializes a new instance of the  AuthException
            class.</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String)">
            <summary>Initializes a new instance of the  AuthException
            class with a specified error message.</summary>
            <param name="message">The error message that explains the
            reason for the exception.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String,System.String[])">
            <summary>Initializes a new instance of the  AuthException
            class with a specified error message.</summary>
            <param name="format">The error message that explains the
            reason for the exception.</param>
            <param name="args">The arguments for the format string.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the  AuthException
            class with a specified error message and a  reference  to
            the inner exception that is the cause of  this  exception.
            </summary>
            <param name="message">The error message that explains the
            reason for the exception.</param>
            <param name="innerException">The exception  that  is  the
            cause of the current exception, or a null reference if no
            inner exception is specified.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthException.#ctor(System.String,System.Exception,System.String[])">
            <summary>Initializes a new instance of the  AuthException
            class with the specified error formatted  message  and  a
            reference to the inner exception that is the cause of the
            exception.
            </summary>
            <param name="format">The error message that explains the
            reason for the exception.</param>
            <param name="innerException">The exception  that  is  the
            cause of the current exception, or a null reference if no
            inner exception is specified.</param>
            <param name="args">The arguments for the format string.</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.ClaimNotFoundException">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.ClaimNotFoundException.#ctor(System.String)">
            <summary>Initializes a new instance of the ClaimNotFoundException class</summary>
            <param name="claimType">The claimType that was not found</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.ClaimNotFoundException.#ctor(System.String,System.String)">
            <summary>Initializes a new instance of the ClaimNotFoundException class</summary>
            <param name="claimType">The claimType that was not found</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.ClaimNotFoundException.#ctor(System.String,System.String,System.Exception)">
            <summary>Initializes a new instance of the ClaimNotFoundException class</summary>
            <param name="claimType">The claimType that was not found</param>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">Gets the Exception instance that caused the current exception.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.ClaimNotFoundException.ClaimType">
            <summary>
            Gets the claimType  that  caused  the  current  exception
            </summary>
            <remarks>
            The type of the claimType is a string.  But  most  claims
            processing frameworks require this to be  a  well  formed
            uri.</remarks>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes"/>
            <seealso cref="T:Microsoft.IdentityModel.Claims.ClaimTypes"/>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.InvalidClaimException">
            <summary>
            The specific claim is invalid.  That claim value is not valid
            for the ClaimValueType.</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.InvalidClaimException.#ctor(Microsoft.IdentityModel.Claims.Claim)">
            <summary>Initializes a new instance of the InvalidClaimException
            class.</summary>
            <param name="claim">The claim that is invalid</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.InvalidClaimException.#ctor(Microsoft.IdentityModel.Claims.Claim,System.String)">
            <summary>Initializes a new instance of the InvalidClaimException
            class.</summary>
            <param name="claim">The claim that is invalid</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.InvalidClaimException.#ctor(Microsoft.IdentityModel.Claims.Claim,System.String,System.Exception)">
            <summary>Initializes a new instance of the InvalidClaimException
            class.</summary>
            <param name="claim">The claim that is invalid</param>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">Gets the Exception instance that caused the current exception.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.InvalidClaimException.Claim">
            <summary>
            Gets the invalid claim that caused the exception.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthHelper">
            <summary>The AuthHelper class provides a number of convenience
            methods for accessing an IClaimsPrincipal. All of the function
            herein can be had by iterating over the identities  and  claim
            sets in the IClaimsPrincipal.</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.AuthHelper.DEFAULT_ISSUER">
            <summary>
            The default issuer is the issuer used when no other issuer
            is specified.  This is true when using the  AuthHelper  as 
            well as attributes and web.config.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.AuthHelper.SYSTEM_ISSUER">
            <summary>
            The system issuer is used when authoring local claims added
            to the current principal by an  internal  process - not  by
            the security token service.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor">
            <summary>
            Initialize an AuthHelper using  the  principal from the
            current thread of execution and with the default issuer.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor(Microsoft.IdentityModel.Claims.IClaimsPrincipal)">
            <summary>
            Initialize an AuthHelper. All tests using the helper will
            be applied against the specified claims principal and the
            default issuer.
            </summary>
            <param name="claimsPrincipal">The principal to check when
            doing claims verification.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor(System.String)">
            <summary>
            Initialize an AuthHelper and set the default issuer using
            the supplied claimIssuer.</summary>
            <param name="issuer">The issuer to check for when doing
            claims verification.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.#ctor(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            Initialize an AuthHelper with the specified claims principal
            and claims issuer.</summary>
            <param name="claimsPrincipal">The principal to check when
            doing claims verification.</param>
            <param name="issuer">The issuer to check for when doing
            claims verification.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyExists(System.String)">
            <summary>Verify the existence of the specified claimType</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <returns>True if the claim exists, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyEquals(System.String,System.Object[])">
            <summary>Verify that the value of the specified claim is
            equal to one of the specified values.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="values">The values against which the claim value
            is compared.</param>
            <returns>True if the claim exists and is equal to one of the 
            specified values</returns>
            <remarks>The specified values are converted to the ValueType of
            the claim before comparing with the claim Value.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyGreaterThan(System.String,System.Object)">
            <summary>Verify that the value of the specified claim is
            greater than the specified value.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="value">The value against which the claim value
            is compared.</param>
            <returns>True if the claim exists and is greater than the
            specified value</returns>
            <remarks>The specified claimValue parameter is converted to the
            ValueType of the claim before comparing with the claim Value
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyLessThan(System.String,System.Object)">
            <summary>Verify that the value of the specified claim is
            less than the specified value.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="value">The value against which the claim value
            is compared.</param>
            <returns>True if the claim exists and is less than the
            specified value</returns>
            <remarks>The specified claimValue parameter is converted to the
            ValueType of the claim before comparing with the claim Value
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyContains(System.String,System.Object[])">
            <summary>Verify that the value of the specified claim type contains
            all of the specified values. The value type of the claim type must
            be an array type.</summary>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="values">The values against which the claim value
            is compared.</param>
            <returns>True if the claim exists and all of the specified values
            are contained by the claim value</returns>
            <remarks>The specified values are converted to strings and
            compared against the string values in the claim value.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.FindClaim(System.String)">
            <summary>
            Find a claim with the specified claimType from the specified
            issuer.
            </summary>
            <param name="claimType">Find claims with this claimType.</param>
            <returns>A claim, or null, if no claim is found.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthHelper.VerifyClaim(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String,Microsoft.XboxLive.Auth.Claims.AuthComparison,System.Object[])">
            <summary>
            Find a claim with the specified claimType, and compare its value
            against the supplied array of valid values.  Return true / false
            as a function of the supplied predicate.
            </summary>
            <param name="principal">Look for claims for this principal.</param>
            <param name="issuer">Look for claims from this issuer.</param>
            <param name="claimType">Find claims with this claimType.</param>
            <param name="comparison">The operation used to verify the claim.</param>
            <param name="validValues">The list of valid values against which to compare.</param>
            <returns>True if the claim exists and values passes the comparision test</returns>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.AuthHelper.Principal">
            <summary>
            The principal to use when finding and verifying claims.
            </summary>
            <remarks>
            If not supplied at construction, the principal is taken off
            the current thread of execution.   If there is no principal
            on the current thread, vthen an anonymous principal is used
            as a default.
            </remarks>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.AuthHelper.Issuer">
            <summary>
            The issuer to use when checking for claims.
            </summary>
            <remarks>
            If not supplied at construction,  or in configuration the
            issuer defaults to "xsts.xboxlive.com".
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthTrace">
            <summary>The AuthTrace class allows for tracing of authorization
            policy.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Error(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Error or higher.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Warning(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Warning or higher.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Info(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Info or higher.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthTrace.Verbose(System.String,System.Object[])">
            <summary>
            Writes trace information to the  trace  listeners  if  the
            TraceLevel is set to TraceLevel.Verbose.
            </summary>
            <param name="format">A composite format string. See remarks
            for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <param name="args">An object  array  that contains zero or
            more objects to format.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.AuthTrace.TraceSwitch">
            <summary>
            Gets the TraceSwitch that controls  tracing.  Applications
            can set the Level to programmatically control trace output
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups">
            <summary>AuthAgeGroups defines the set of possible
            values for the claimType  AuthClaimTypes.AgeGroups.
            The values are assigned to users as a function  of
            their country of record.</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups.Child">
            <summary>The user  is  considered  a  child  in
            their country of record.  Typically this  means
            less than 13 years of  age,  but it  varies  by
            country (e.g. less han 14 years of age in Korea)
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups.Teen">
            <summary>The user is considered  a teenager  in
            their country  (not a child or an adult  -  see
            definitions above/below.</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups.Adult">
            <summary>The user  is  considered  an adult  in
            their country of record.  Typically this  means
            greater than or equal to 18 years of  age,  but
            it varies by country.</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup">
            <summary>the user's agegroup</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthAgeGroups"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ClientIpPort">
            <summary>the client's external ip address and port</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country">
            <summary>the country id of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DelegationToken">
            <summary>a bearer token used for delegation back to Xbox LIVE</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId">
            <summary>the unique identifier for the device</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceName">
            <summary>the identifier for the device name</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceType">
            <summary>the device type</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.FlowToken">
            <summary>the unique session identifier</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Gamertag">
            <summary>the gamertag of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language">
            <summary>the user's language</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ParentXuid">
            <summary>the parent xuid of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.PartnerDeviceId">
            <summary>the unique identifier for the device</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.PartnerParentXuid">
            <summary>the partner parent xuid for the user (based on the relying party)</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.PartnerXuid">
            <summary>the partner xuid for the user (based on the relying party)</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Privileges">
            <summary>the privileges granted to the user</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthPrivileges"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Puid">
            <summary>the passport user id (puid) of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Status">
            <summary>the user status</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthStatus"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Tier">
            <summary>the xbox live subscription tier of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId">
            <summary>the title id</summary>
            <seealso cref="T:Microsoft.XboxLive.Auth.Claims.AuthTitles"/>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleVersion">
            <summary>the title version</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid">
            <summary>the xuid of the user</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ValueTypes">
            <summary>the claim value types for all AuthClaimTypes</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Create(System.String,System.Object,System.String,System.String)">
            <summary>
            Create a Claim from an arbitrary C# object with the appropriate formatting.
            </summary>
            <param name="claimType">Type of claim to create, see AuthClaimTypes</param>
            <param name="claimValue">The claim's value, may be any basic C# type</param>
            <param name="claimValueType">Format of the claim value as a string, see AuthClaimValueTypes</param>
            <param name="issuer">Name of the issuer of this claim</param>
            <returns>New Claim with proper formatting</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.IntegerArray">
            <summary>a comma-separated list of integers</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.IpAddress">
            <summary>a "dotted 4" notation with optional port</summary>
            <example>1.2.3.4, 1.2.3.4:2000</example>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.Decimal">
            <summary>
            Microsoft.IdentityModel.Claims.ClaimValueTypes does not
            define this one.  Make this one claim value type easier
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthIdentityTypes">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthIdentityTypes.SG">
            <summary>the machine / device identity</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthIdentityTypes.ActiveAuth">
            <summary>the user identity</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes">
            <summary>
            AuthDeviceTypes defines the set of possible
            values for the claimType AuthClaimTypes.DeviceTypes.    
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.WindowsPhone">
            <summary>
            The token was issued for a Windows Phone device.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.WindowsPhone7">
            <summary>
            The token was issued for is a Windows Phone 7 device.
            Deprecated: we can't tell the difference between WP7 and Apollo
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Web">
            <summary>
            The token was issued for a web browser or other unknown platform.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.Xbox360">
            <summary>
            The token was issued for an Xbox 360 console.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthDeviceTypes.PC">
            <summary>
            The token was issued for a PC running Games for Windows Live.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthPrivileges">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.AddFriend">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.Multiplayer">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MultiplayerEnabledByTier">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.VideoMessagingSend">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PurchaseContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.CrossPlatformMultiplayer">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.CrossPlatformCommunications">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PreviousLiveProtocols">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.VideoCommunications">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.TradeContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MusicExplicitContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MetroAccess">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PassportSwitching">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.BillingSwitching">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.MultiplayerDedicatedServer">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.UserGraduation">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PremiumVideo">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.Primetime">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.ContentAuthor">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PiiAccess">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.SocialNetworkSharing">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.SubscriptionContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.SubscriptionTitle">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.PremiumContent">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.Family">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.UnsafeProgramming">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthPrivileges.ShareContent">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthStatus">
            <summary>AuthStatus defines the set of possible values
            for the claimType AuthClaimTypes.Status</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthStatus.Maintenance">
            <summary>The user account requires maintenance and
            can only access maintenance services.  The account
            must be fixed before accessing other user services
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthStatus.Ok">
            <summary>The user account is in good standing  and
            is allowed to access all user  services.</summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthTiers">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.NewUser">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.Silver">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.Gold">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTiers.FamilyGold">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthTitles">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.LiveSignup">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.Web">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.XenonDashboard">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.Zune">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.DashboardTitles">
            <summary> </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthTitles.WebTitles">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthValue.Create(System.Object,System.String)">
            <summary>
            Create the appropriate AuthValue object as a function of the
            claimType
            </summary>
            <param name="o">The object to convert into an AuthValue</param>
            <param name="claimValueType">The type to which the object is converted</param>
            <returns>An AuthValue representing the supplied object</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthByteArray">
            <summary>
            AuthByteArray is a common class used to wrap a byte array. It
            is derived by the AuthBase64Binary and AuthHexBinary  classes.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthByteArray.#ctor">
            <summary>
            Initializes a new instance of the AuthByteArray class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthByteArray.CompareTo(System.Object)">
            <summary>
            Compare the value of the wrapped byte array with the user
            supplied value.  Arrays of different lengths are compared
            up to the length of the shorter array.  If they are equal
            at that point, then the  longer array is considered to be
            greater.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBase64Binary.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthBase64Binary  class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBase64Binary.ToString">
            <summary>
            Return the canonical representation of a base  64  string.
            This is the standard conversion from .NET.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthHexBinary">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthHexBinary.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthHexBinary class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthHexBinary.ToString">
            <summary>
            Return the canonical representation of a hex string. That
            is, 0-9, A-F,  with no lower case  and  no  leading  "0x"
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthInteger.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthInteger class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDateTime.#ctor(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDateTime.ToString">
            <summary>
            Return the canonical representation of a #time
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthString">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthString.#ctor(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthString.CompareTo(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBoolean.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthTime class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBoolean.CompareTo(System.Object)">
            <summary>
            Compare the wrapped boolean value. Return 0 if  they  are
            equal.  For the purposes of greater than  and  less  than
            assume that true is greater than false.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthBoolean.ToString">
            <summary>
            Return the canonical representation of a boolean value.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Claims.AuthBoolean.Value">
            <summary>
            Get the wrapped boolean value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthTime.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthTime class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthTime.ToString">
            <summary>
            Return canonical representation of a time (hours, minutes,
            seconds and a timezone).
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDecimal.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthDecimal class.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthDecimal.ToString">
            <summary>
            Return the canonical representation of a decimal
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthIpAddress">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthIpAddress.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthIpAddress class.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Claims.AuthIpAddress.Address">
            <summary>
            Get the wrapped address values
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthIntegerArray">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Claims.AuthIntegerArray.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the AuthIntegerArray class.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Claims.AuthIntegerArray.Values">
            <summary>
            Get the wrapped integer array value
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthConfig">
            <summary>
            The AuthConfig class is the top node in the configuration. It
            has no attributes, and is just a collection of service  nodes.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthConfig.Find(System.String,System.String)">
            <summary>
            Find configured policy for the specifed service and action
            </summary>
            <param name="serviceName">The name of  the  service. This
            varies by framework type. For instance, for ASP.NET  SOAP
            this is the [WebService] class name. For ASP.NET MVC this
            is the controller name.</param>
            <param name="actionName">The name  of  the  action.  This
            varies by framework type.  For instance, for ASP.NET SOAP
            this is the [WebMethod] name.  For WCF, this is the  name
            of the [OperationContract].   For ASP.NET MVC this is the
            action name.</param>
            <returns>The configued policy for the specificed service
            and action. If no policy is defined then null.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthConfig.Find(System.String)">
             <summary>
             Find configured global policy for  the  specifed  service
             </summary>
             <param name="serviceName">The name of  the  service. This
             varies by framework type. For instance, for ASP.NET  SOAP
             this is the [WebService] class name. For ASP.NET MVC this
             is the controller name.</param>
             <returns>The configured policy for the specificed service.
            If no policy is defined then null.</returns>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthConfig.Services">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthConfig.Issuer">
            <summary>
            By default we look for an issuer  of  "xsts.xboxlive.com".
            Setting the issuer attribute on the configuration element
            changes the default to the specified value. That value is
            used in AuthAttribute and AuthHelper code.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthConfig.Current">
            <summary>
            Return the configuration for the current thread.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthServiceCollection">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.IndexOf(System.String)">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.CreateNewElement">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.Item(System.String)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.Item(System.Int32)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.CollectionType">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceCollection.ElementName">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthServiceElement">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceElement.Name">
            <summary>
            This is the service name for which the policy is  defined.
            The use of this value varies depending on the application
            framework being used.
            
            For ASP.NET using SOAP it is the class name  of  the  web
            service.  For MVC it is the class name of the  controller.
            For WCF it is the interface name of the service  contract.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceElement.Policies">
            <summary>
            Each  service  element  can  have  zero  or  more  global
            policies to be applied to all actions.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthServiceElement.Actions">
            <summary>
            Each service element has zero  or  more  action  elements.
            Depending  on  the  application  framework,  each  action 
            represents a method or action on which policy is  defined.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthActionCollection">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionCollection.IndexOf(System.String)">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionCollection.CreateNewElement">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.Item(System.String)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.Item(System.Int32)">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.CollectionType">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionCollection.ElementName">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthActionElement">
            <summary>
            An AuthActionElement is the  root  element  for configuration
            policy on an action (e.g. web method, operation contract, etc)
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Config.AuthPolicyElement">
            <summary>
            An AuthPolicyElement is the  root  element  for configuration
            policy on an action (e.g. web method, operation contract, etc)
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthPolicyElement.DeserializeElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Get the policy elements for the service or action using a
            custom deserializer.
            </summary>
            <param name="reader">XmlReader sent by the  configuration
            processing code.</param>
            <param name="serializeCollectionKey">required parameter
            in the base class.  This is unused.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthPolicyElement.Policy">
            <summary>
            This is the actual authorization policy  associated  with 
            the action. The policy has a check method that is invoked
            just before the action.
            
            The policy is configured using custom  configuration  XML
            inside of the action node.  That is,  there is no further
            definition  using  the  System.ServiceModel.Configuration
            classes.  It hooks in a custom parser by  overriding  the
            DeserializeElement method below..
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Config.AuthActionElement.DeserializeElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Skip over parts for the current  AuthActionElement.  Then
            read the inner nodes and parse the XML to  obtain  policy
            for this action.
            </summary>
            <param name="reader">XmlReader sent by the  configuration
            processing code.</param>
            <param name="serializeCollectionKey">required parameter
            in the base class.  This is unused.</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Config.AuthActionElement.Name">
            <summary>
            This is the action  name for which the policy is  defined.
            The use of this value varies depending on the application
            framework being used.
            
            In all cases it is the name of a method that  is  invoked.
            For ASP.NET using SOAP it is the web method name, for MVC
            it the method name for the action.  For  WCF  it  is  the
            interface method  attributed  with  the  OperationContact .
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.AuthExtensions">
            <summary>
            AuthExtensions contains a number class extensions  to  make  it
            easier to navigate IClaimsPrincipal and IClaimsIdentity objects.
            </summary>
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsIdentity,System.Predicate{Microsoft.IdentityModel.Claims.Claim})">
            <summary>
            For this identity,  check to see if there is a claim that matches the
            specified predicate.
            </summary>
            <param name="identity">The IClaimsIdentity instance that serves as "this".</param>
            <param name="predicate">The Predicate to be evaluated.</param>
            <returns>True if the predicate evaluates to true, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsIdentity,System.String,System.String@)">
            <summary>
            For this identitty, try to get the value of the specified claim (claimType)
            without respect to the issuer of the claim.
            </summary>
            <param name="identity">The IClaimsIdentity instance that serves as "this".</param>
            <param name="claimType">The claimType (name)</param>
            <param name="claimValue">The string that will receive the claimValue</param>
            <returns>True if the claim and value were found, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsIdentity,System.String,System.String,System.String@)">
            <summary>
            For this identity,  try to get the value of the specified claim (claimType)
            from the specified issuer.
            </summary>
            <param name="identity">The IClaimsIdentity instance that serves as "this".</param>
            <param name="claimType">The claimType (name)</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <param name="claimValue">The string that will receive the claimValue</param>
            <returns>True if the claim and value were found, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.FindClaims(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.Predicate{Microsoft.IdentityModel.Claims.Claim})">
            <summary>
            For this principal, find all claims that match the specified predicate.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="predicate">The predicate used to match claims</param>
            <returns>A enumerable collection of matching claims</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.FindClaims(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            For this principal, find all claims that match the specified claimType without
            to issuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <returns>A enumerable collection of matching claims</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.FindClaims(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String)">
            <summary>
            For this principal, find all claims that match the specified claimType and claimIssuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <returns>A enumerable collection of matching claims</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.Predicate{Microsoft.IdentityModel.Claims.Claim})">
            <summary>
            For this principal, check if there exists a claim matching the predicate.
             </summary>
             <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="predicate">The predicate used to match claims</param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            For this principal, check if the specified claim type exists without respect to issuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.ClaimExists(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String)">
            <summary>
            For this principal, check if the specified claim type from the specified issuer exists. 
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String,System.String@)">
            <summary>
            For this principal, try to get the value of the specified claim from the specified issuer.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <param name="claimValue">Receives the claim value</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.TryGetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String@)">
            <summary>
            For this principal,  try to get the value of the specified claim without respect to issuer.  
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimValue">Receives the claim value</param>
            <returns>True if the claim is found, otherwise false</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.GetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String,System.String)">
            <summary>
            For this principal, get the value of the specified claim from the specified
            issuer from the principal. Only the first value is returned.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <param name="claimIssuer">Only return claims matching the claimIssuer</param>
            <returns>The claim value</returns>
            <exception cref="T:Microsoft.XboxLive.Auth.ClaimNotFoundException">if the claim is not found</exception>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.AuthExtensions.GetClaimValue(Microsoft.IdentityModel.Claims.IClaimsPrincipal,System.String)">
            <summary>
            For this principal, get the value of the specified claim from the principal
            without respect to the issuer. Only the first value is returned.
            </summary>
            <param name="principal">The IClaimsPrincipal instance that serves as "this"</param>
            <param name="claimType">Only return claims matching the claimType</param>
            <returns>The claim value</returns>
            <exception cref="T:Microsoft.XboxLive.Auth.ClaimNotFoundException">if the claim is not found</exception>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthAttribute">
            <summary>
            Represents the base class for authorization policy attributes.
            </summary>
            <remarks>
            The authorization attributes are used to define authorization
            policy on classes, methods, and their parameters.  Each  time
            a method is invoked it is checked  for  authorization  policy.
            If there is a policy defined for a given  method   then  that
            policy is checked against the current  authorization  context
            before the method is invoked.  If the policy check fails then
            an exception is thrown and the method is not called.
            </remarks>
            <example>
            <code>
            // Example of a SOAP web method with authorization attributes
            
            [AuthExists(AuthClaimTypes.Xuid)]
            [WebMethod]
            public void ChangeGamertag(
               [VerifyClaim(AuthClaimTypes.Gamertag)] string gamertag
            );
            
            Example of a WCF operation contact with authorization attributes
            
            [VerifyPlatformId(AuthPlatforms.Xbox360)]
            [RequireClaim(AuthClaimTypes.DeviceId)]
            [OperationContract]
            public void AutoUpdateReferral()
            </code>
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthAttribute.#ctor">
            <summary>
            The constructor for all  auth attributes sets the default
            issuer.  This can be set via  configuration  or  using  a
            named attribute parameter.
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Policy.AuthAttribute.ClaimType">
            <summary>
            The claim type to look for and test
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Policy.AuthAttribute.Issuer">
            <summary>
            The issuer from which claims of the specified type should
            originate.
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthClassMethodAttribute">
            <summary>
            This is the base attribute for all  authorization  attributes
            placed on classes and methods.  Class and  method  attributes
            are  limited to simple claim existence checks and  comparison
            of claim values against compile time values.
            </summary>
            <remarks>This is an abstract class and cannot be instantiated.
            It is the base class for all authorization policy  attributes
            with a AttributeTarget of Class or Method.</remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthClassMethodAttribute.#ctor">
            <summary>
            protected constructor to hook into constructor  for  base
            class which sets the default issuer.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthClassMethodAttribute.GetPolicy">
            <summary>
            Abstract method for converting auth attributes AuthPolicy.
            </summary>
            
            <returns>An AuthPolicy object called later to do policy
            enforcement checks.</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthArrayAttribute">
            <summary>
            The AuthArrayAttribute is used to check claims against a  set
            of values (provided in an array).  Multiple checks are made - 
            one against each value in the array.  Allows  for  and/or  of
            results.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Policy.AuthArrayAttribute._values">
            <summary>
            Array of values used by Allowed and  Required  attributes.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthArrayAttribute.#ctor(System.String,System.Object[])">
            <summary>
            Initializes new instance of the  AuthArrayAttribute class.
            This is a protected constructor.  It is currently used to
            derive other attributes.
            </summary>
            <param name="claimType">claimType to  be  checked</param>
            <param name="values">The array values against  which  the
            claim value is checked</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AllowedValuesAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedValuesAttribute.#ctor(System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="claimType"></param>
            <param name="values"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedValuesAttribute.GetPolicy">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.RequiredValuesAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.RequiredValuesAttribute.#ctor(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="claimType"></param>
            <param name="values"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.RequiredValuesAttribute.GetPolicy">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AllowedPlatformsAttribute">
            <summary>
            The AllowedPlatformsAttribute is used to affect policy checks
            of the device type against an array of valid  platform  types
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedPlatformsAttribute.#ctor(System.String[])">
            <summary>
            Initializes an instance of AllowedPlatformsAttribute
            </summary>
            <param name="values">The array of allowed platform types</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AllowedTitlesAttribute">
            <summary>
            The AllowedTitlesAttribute is used to affect policy checks of
            the title id claim  against  an  array  of  valid  title  ids
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AllowedTitlesAttribute.#ctor(System.UInt32[])">
            <summary>
            Initializes an instance of AllowedTitlesAttribute
            </summary>
            <param name="values">The array of allowed titles ids</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.RequiredPrivilegesAttribute">
            <summary>
            Verify that all of the  privileges  in  the  specified  array
            appear in the privileges claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.RequiredPrivilegesAttribute.#ctor(System.Byte[])">
            <summary>
            Initializes an instance of RequiredPrivilegesAttribute
            </summary>
            <param name="privileges">The array of required privileges</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthExistsAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthExistsAttribute.#ctor(System.String)">
            <summary>
            Initializes an instance of the AuthExistsAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for
            which we are checking</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthComparisonAttribute">
            <summary>
            Verify that the specified claim is present and then perform the
            specified comparison operation between the specified value  and
            the claim value.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthComparisonAttribute.#ctor(System.String,System.Object,Microsoft.XboxLive.Auth.Claims.AuthComparison)">
            <summary>
            Initializes an instance of the AuthComparisonAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
            <param name="comparison">The comparision operation to perform</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthEqualsAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            and that the claim value is  equal  to  the  specified  value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthEqualsAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an instance of the AuthEqualsAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthGreaterThanAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            and that the claim value is  equal  to  the  specified  value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthGreaterThanAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an instance of the AuthGreaterThanAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthLessThanAttribute">
            <summary>
            Verify that the specified claim is present in the  auth  data
            and that the claim value is less  than  the  specified  value
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthLessThanAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an instance of the AuthLessThanAttribute
            </summary>
            <param name="claimType">the specific claimType (name) for which we are checking</param>
            <param name="value">The value against which the claim value is compared</param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthParameterAttribute">
            <summary>Represents the base class for  authorization  policy
            attributes applied to method parameters.   Class  and  method
            parameters make static checks for the  presence  of  specific
            claims or specific well know  values.   Parameter  attributes
            compare specific claims against  the  parameter  value  being
            passed into the method.</summary>
            <remarks>This is an abstract class and cannot be instantiated.
            It is the base class for all authorization policy  attributes
            with a Parameter.</remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthParameterAttribute.#ctor">
            <summary>
            protected constructor to hook into constructor  for  base
            class which sets the default issuer.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthParameterAttribute.GetPolicy(System.Reflection.ParameterInfo)">
            <summary>
            Abstract method for converting auth attributes into policy
            rexpression.  Parameter attributes differ from method  and
            class attributes in that they take a  parameter  which  is
            used to lookup the value of the  parameter  on  each  call.
            </summary>
            
            <returns>An AuthPolicy object</returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthVerifyAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the specified claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthVerifyAttribute.#ctor(System.String)">
            <summary>
            Initializes an  instance  of  the AuthVerifyAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the specified claim type</remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyMachineAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the device id claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyMachineAttribute.#ctor">
            <summary>
            Initializes a new instance of the  VerifyMachineAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the well known claimType  AuthClaimTypes.DeviceId.
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyUserAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the user (xuid) claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyUserAttribute.#ctor">
            <summary>
            Initializes a new instance of the VerifyUserAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against  the  well  known  claimType  AuthClaimTypes.Xuid
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyTitleAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the title id claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyTitleAttribute.#ctor">
            <summary>
            Initializes a new instance  of  the  VerifyTitleAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the well known  claimType  AuthClaimTypes.TitleId
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.VerifyCountryAttribute">
            <summary>
            Verify that the attributed parameter is equal to the value of
            the country claim.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.VerifyCountryAttribute.#ctor">
            <summary>
            Initializes a new instance of the  VerifyCountryAttribute
            </summary>
            <remarks>Compare the value  of  the  declaring  parameter
            against the well known  claimType  AuthClaimTypes.Country
            </remarks>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthBehaviorElement">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthBehaviorElement.CreateBehavior">
            <summary> </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Policy.AuthBehaviorElement.BehaviorType">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthBehavior">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthBehavior.#ctor">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthBehavior.#ctor(System.String,System.Reflection.MethodInfo,Microsoft.XboxLive.Auth.Policy.AuthPolicy)">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Claims.AuthComparison">
            <summary></summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthComparison.Equals">
            <summary></summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthComparison.GreaterThan">
            <summary></summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Claims.AuthComparison.LessThan">
            <summary></summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthInvoker">
            <summary>
            The AuthInvoker class is the main interception point for  WCF
            policy checks.  The AuthBehavior reflects over  AuthAttribute
            attributes and policies defined in the web.config and inserts
            the AuthInvoker into the OperationInvoker chain as  necessary.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthInvoker.#ctor(System.ServiceModel.Dispatcher.IOperationInvoker,System.String,System.Reflection.MethodInfo,Microsoft.XboxLive.Auth.Policy.AuthPolicy)">
            <summary> </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthPolicy">
            <summary>
            AuthPolicy is the root class used to check policy for a given
            service and action.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthPolicy.Add(System.String,System.String,System.Reflection.MethodInfo)">
            <summary>
            Add policy for the  specified service and action. Look in
            the configuration for defined  policy,  and if  there  is
            none,  then through reflection on the supplied methodInfo
            </summary>
            <param name="serviceName">The name of the service</param>
            <param name="actionName">The name of the action</param>
            <param name="methodInfo">The methodInfo for the action</param>
            <returns>The configured policy for the service and action.
            If no policy is defined then return AuthPolicy.NullPolicy
            </returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthPolicy.GetParameter(System.Collections.Generic.IDictionary{System.String,System.Object},System.Reflection.ParameterInfo)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
            <param name="parameterInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension">
            <summary> </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.Initialize(System.Object)">
            <summary>
            This is a required abstract method.  We don't  need  to  do
            anything here.  It just has to be present
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.GetInitializer(System.Type)">
            <summary>
            Called when ASP.NET finds a SoapExtension in the web config
            file.  Reflect on the serviceType to find all  web  methods
            Then look to see if there is any policy defined  (it  would
            come from the config  file).  If there is none then see  if
            the code is attributed for authorization.
            </summary>
            <param name="serviceType">the method  we  are  expected  to
            initialize.  use this to get the declaring type for the web
            method (that is the web  service  class)
            </param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.GetInitializer(System.Web.Services.Protocols.LogicalMethodInfo,System.Web.Services.Protocols.SoapExtensionAttribute)">
            <summary>
            Called when ASP.NET finds a SoapExtensionAttribute on a web
            web method.  Even though this is for a  single  method,  we
            initialize the whole web service by calling back  into  the
            GetInitializer for a web.config defined SoapExtension.
            </summary>
            <param name="methodInfo">the method we are initializing. we
            use this to get the declaring type for the web method (that
            is the web service class)
            </param>
            <param name="attribute">the attribute that  triggered  this
            call. we don't need use it because the common code reflects
            </param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Policy.AuthSoapExtension.ProcessMessage(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            ProcessMessage is called multiple times at different stages
            We enforce authorization policy during the AfterDeserialize
            stage.
            </summary>
            <param name="message">The request we  are  authorizing.  We
            need this to get the methodName, and then the parameters to
            do any data binding
            </param>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy">
            <summary>
            Reads in authorization header.  Presents header to  token  handlers
            to see who can read the token, one of which will return a principal
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.#ctor">
            <summary>
            Null constructor required so WCF can instantiate the authorization policy
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.Evaluate(System.IdentityModel.Policy.EvaluationContext,System.Object@)">
            <summary>
            Take the request and look for authorization context on the
            headers.   If we find it and can parse it,  then create  a
            principal and put it on the thread.
            </summary>
            <param name="evaluationContext">The <see cref="T:System.IdentityModel.EvaluationContext"/> for the request.</param>
            <param name="state"></param>
            <returns>
            true if access is granted; otherwise, false. The default is true.
            </returns>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.Id">
            <summary>
            Get the id of the authorization policy object.  
            </summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthorizationPolicy.Issuer">
            <summary>
            Get the Issuer of the authorization policy object.  
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule">
            <summary>
            XblAuthProtocolModule is an HttpModule to provide basic token authentication
            handling. It hooks into ASP.NET's AuthenticateRequest callback and consumes
            the 'Authorization' or 'X-Authorization' HTTP header. 
            </summary>
            <remarks>
            The "XblAuthProtocol" is a simple authentication protocol, vaguely similar in 
            functionality to WS-Federation but more active. The client provides the STS
            token (presumably SAML2.0, but not necessarily) in an HTTP header, and this
            module reads that token and verifies it and creates an IClaimsPrincipal.
            
            The header value must contain "XBL2.0 x=STSTOKEN", where STSTOKEN is the XML 
            token received from the XSTS service. The output of the module is an 
            IClaimsPrincipal placed in Thread.CurrentPrincipal. If no header is present,
            the module does nothing. 
            
            Authorization is left to the user of this module. Any errors that occur during
            parsing or validation are passed to a callback event, and if not cancelled, the
            exception is rethrown. ASP.Net will catch this and abort the request.
            </remarks>
            <example>
            In the configuration section of your web.config:
            
              <system.webServer>
                <modules>
                   <add name="XblAuthProtocolModule" type="Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule, Microsoft.XboxLive.Auth "/>
                </modules>
              </system.webServer>
              
            </example>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.Init(System.Web.HttpApplication)">
            <summary>
            Initialize module. Hooks into AuthenticateRequest handler.
            </summary>
            <param name="application"></param>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.ProcessAuthenticateRequest(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Handles bulk of reading and validating the incoming token. 
            </summary>
            <param name="webHeaders">Incoming HTTP headers. Looks for Authorization header.</param>
            <param name="rawUrl">Full URL of incoming request.</param>
            <returns>Validated IClaimsPrincipal, or null if none available.</returns>
            <remarks>
            Marked public to allow for testing, but not intended for external use.
            </remarks>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.IsFatal(System.Exception)">
            <summary>
            Determines whether an exception is fatal or whether we should attempt to 
            handle it gracefully.
            </summary>
            <param name="exception"></param>
            <returns>True if fatal</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.Trace(System.Exception,System.String,System.Object[])">
            <summary>
            Handles writing a diagnostic trace line.
            </summary>
            <param name="e">Optional exception, pass null if none</param>
            <param name="msgFormat">Optional message and format string</param>
            <param name="msgArgs">Message format arguments</param>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.ModuleName">
            <summary>
            Name of the HTTP module
            </summary>
        </member>
        <member name="E:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.AuthenticateError">
            <summary>
            Fires for any unhandled error during AuthenticateRequest
            </summary>
        </member>
        <member name="E:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.TraceOutput">
            <summary>
            Fires for any traceline generated during execution
            </summary>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs">
            <summary>
            Arguments for handling a traceline event callback
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs.Message">
            <summary>
            The trace message
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs.Error">
            <summary>
            An exception associated with the trace, if any. May be null.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.TraceEventArgs.ToString">
            <summary>
            Helper for printing the trace event
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler">
            <summary>
            Core code that implements the "Xbox Live Auth Protocol", which is simple replacement
            for WS-Federation (ASP.NET) and WS-Trust, et al (WCF) that WIF includes out of the 
            box.
            </summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.HEADER_NAME">
            <summary>The primary header used for transporting tokens in an HttpRequest</summary>
        </member>
        <member name="F:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ALT_HEADER_NAME">
            <summary>The secondary header used for transporting tokens in an HttpRequest</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.#ctor">
            <summary>Instantiate an XblAuthProtocolHandler</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ProcessToken(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Read token from header then authenitcate it. Same as calling ReadToken() 
            and AuthenticateToken().
            </summary>
            <param name="httpHeaders">Incoming HTTP headers containing the token in the "Authorization" header.</param>
            <param name="resourceName">Resource being requested, usually the URL of the request</param>
            <returns>New IClaimsPrincipal from token, else null if none</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ReadTokens(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Attempts to parse the 'XBL2.0' token from the Authorization or X-Authorization
            header, parses the XML token value, and reads it using the WIF library. This
            allows for custom handlers and authenticators can be plugged in and configured 
            as desired.
            </summary>
            <param name="httpHeaders">Headers collection, looks for 'Authorization' or 'X-Authorization'</param>
            <returns>array of security tokens, may have zero entries</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ReadToken(System.String)">
            <summary>
            Uses WIF to read an XML formatted token.
            </summary>
            <param name="tokenXml">Token in XML format.</param>
            <returns>New SecurityToken, or else null if none.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)">
            <summary>
            Creates the value for the 'Authorization' header for the given token.
            </summary>
            <param name="token">Valid security token</param>
            <returns>Header value of encoded token</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken,Microsoft.IdentityModel.Tokens.SecurityTokenHandler)">
            <summary>
            Creates the value for the 'Authorization' header for the given token and token
            handler.
            </summary>
            <param name="token">Valid security token</param>
            <param name="handler">Handler to use for writing the token</param>
            <returns>Header value of encoded token</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.AuthenticateToken(System.IdentityModel.Tokens.SecurityToken,System.String)">
            <summary>
            Uses WIF's token authentication to authenticate a security token and extract the
            IClaimsPrincipal from it. 
            </summary>
            <param name="securityToken">Security token read from the request</param>
            <param name="resourceName">Name of requested resource. Usually this is the URL.</param>
            <returns>The resulting IClaimsPrincipal, which is also set to Thread.CurrentPrincipal. Returns null if anything fails.</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.GetCurrentConfiguration">
            <summary>Get the current service configuration from the OperationContext.  If
            none is present then look in the FederatedAuthentication service configuration.
            </summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.GetSecurityTokenXml(System.Collections.Specialized.NameValueCollection)">
            <summary>Get one of the well-known Authorization headers from the collection
            of headers, strip off the protocol parts go get to the XML and then decode
            the HTTP encoded elements to generate a straight up XML string</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.TryParseAuthorizationHeader(System.Collections.Specialized.NameValueCollection,System.String@,System.String@)">
            <summary>
            Looks for "Authorization" or "X-Authorization" header and attempts to parse the 
            token. 
            </summary>
            <param name="headerCollection">HTTP headers</param>
            <param name="authName">Parsed named of auth scheme, e.g. "XBL1.0" or "WLID1.0"</param>
            <param name="authValue">Parsed value of the auth scheme, e.g. "x=..." or "t=..."</param>
            <returns>True if successful, false if not</returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.TryParseAuthorizationHeader(System.String,System.String@,System.String@)">
            <summary>
            Parse the authorization header into 2 tokens.
            </summary>
            <param name="authHdrValue">HTTP header value</param>
            <param name="authName">Parsed named of auth scheme, e.g. "XBL1.0" or "WLID1.0"</param>
            <param name="authValue">Parsed value of the auth scheme, e.g. "x=..." or "t=..."</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.DecodeHeaderXml(System.String)">
            <summary>Decode HTTP encoded XML string back to straight up XML</summary>
        </member>
        <member name="M:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.EncodeHeaderXml(System.String)">
            <summary>Remove new lines and carriage returns from the XML string</summary>
        </member>
        <member name="P:Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler.ServiceConfig">
            <summary>
            WIF-provided configuration, either from web.config or a default.
            </summary>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\PropManagerCAP.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PropManagerCAP</name>
    </assembly>
    <members>
        <member name="M:PropManagerCAP.PropManager.InitAppGlobals">
            <summary>
            Initializes global application settings, controls, and variables.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.SetAppState">
            <summary>
            Sets the application's state to a mode such as Test Mode or Maintenance Mode.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.InitLogging">
            <summary>
            Pulls the logging setup info out of the web.config file and enables or disables logging appropiately.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.IsPermissionValid(System.String,System.String)">
            <summary>
            Determines whether a user has permission to the passed option.
            </summary>
            <param name="optionName">The name of the request option to test permissions against.</param>
            <param name="envName">The name of the environment to test permissions against.</param>
            <returns>boolean value to indicate success or failure</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.GetWorkflowName(System.String,System.String)">
            <summary>
            Retrieves the workflow name used in launching a request's workflow.
            </summary>
            <param name="optionName">The name of the request option, as defined in the workflows.xml file.</param>
            <param name="optionName">The name of the request option's environment, as defined in the web.config file.</param>
            <returns>string value containing the workflow name for the given option/environment pair.</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.GetAutoPropState(System.String,System.String)">
            <summary>
            Retrieves the boolean value as to whether or not this is an AutoProp request.
            </summary>
            <param name="optionName">The name of the request option, as defined in the workflows.xml file.</param>
            <param name="optionName">The name of the request option's environment, as defined in the web.config file.</param>
            <returns>A string value containing whether or not the given request option/environment pair should utilize AutoProp.</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.InitXML">
            <summary>
            Loads the 'permissions.xml' data and the 'permissions.xsd' configuration files into memeory.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.InitWorkflowXML">
            <summary>
            Loads the 'workflows.xml' data and the 'workflows.xsd' configuration files into memeory.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.InitConfigXML">
            <summary>
            Loads the 'PMConfig.xml' data and the 'PMConfig.xsd' configuration files into memeory.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.FindFiles(System.String,System.String)">
            <summary>
            Looks for all files in a given directory with a certain extension
            </summary>
            <param name="folderPath">The path to search for files</param>
            <param name="extension">The extension of files to find</param>
            <returns>Path to every file found in the given directory with the given extension</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.GetTitleName(System.String,System.String)">
            <summary>
            Grabs a title's name based on it's id
            </summary>
            <param name="titleID">Title ID (in HEX, 0x00000000)</param>
            <returns>The title's name. Returns "" if the title id doesn't exist</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.HexToDec(System.String)">
            <summary>
            Converts a 0x... hex value to a decimal value.
            </summary>
            <param name="hexVal">The hexadecimal value to be converted to decimal</param>
        </member>
        <member name="M:PropManagerCAP.PropManager.GetSensibleByteSize(System.Int64)">
            <summary>
            Converts an amount of bytes into a more easily readable size.
            </summary>
            <param name="bytes">A long value that that specifies the byte amount.</param>
            <returns>A string value that is formatted for human readability.</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.VerifyBugID(System.String,System.String,System.String,System.String,System.String,System.String,System.Web.UI.WebControls.Label@)">
            <summary>
            
            </summary>
            <param name="bugID"></param>
            <param name="envName"></param>
            <param name="bugOption"></param>
            <param name="titleID"></param>
            <param name="Isclosed"></param>
            <param name="label">Friendly name of Environments to be displayed in error messages and on UI</param>
            <param name="lError"></param>
            <returns></returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.ConnectToProductStudio(ProductStudio.Directory@,ProductStudio.Product@,ProductStudio.Datastore@)">
            <summary>
            Connects to Product Studio using the connection refs given.
            </summary>
            <returns>Whether or not a connection was successfully established.</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.ValidateFields(System.Web.UI.WebControls.Label@,System.Web.UI.WebControls.RadioButtonList@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.DropDownList@,System.Web.UI.WebControls.DropDownList@,System.Web.UI.WebControls.TextBox@,System.Web.UI.WebControls.TextBox@)">
            <summary>
            Accepts all the possible controls of an Option for comprehensive field validation. If an Option doesn't have certain fields, send [ref g_tbDummy] instead
            </summary>
            <param name="errCtrl">The error label</param>
            <param name="rList">The environment radio button list</param>
            <param name="titleIDCtrl">The title id textbox</param>
            <param name="bugIDCtrl">The bug id textbox</param>
            <param name="offerIDCtrl">The offer id textbox</param>
            <param name="xemIDCtrl">The xemid/xmid textbox</param>
            <param name="subIDCtrl">The subid textbox</param> 
            <param name="baseVerCtrl">The base version textbox</param>
            <param name="updateVerCtrl">The update version textbox</param>
            <param name="consoleIDListCtrl">The console id textbox</param>
            <param name="leaderboardIDListCtrl">The leaderboard id textbox</param>
            <param name="ccListCtrl">The cclist textbox</param>
            <param name="resolvedByCtrl">The resolved by textbox</param>
            <param name="propDateTimeCtrl">The prop date/time textbox</param>
            <returns>Indicates whether all the fields in the sent Option are valid</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.IsFieldValid(System.String,System.String)">
            <summary>
            Gets sent a value and a type then returns whether that value is valid.
            </summary>
            <param name="val">Content to validate. This is usually a control's text</param>
            <param name="type">The type to check it agaist. Available types are listed inside the method</param>
            <returns>Indicates whether 'val' is a valid 'type'</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.VerifyOfferIDs(System.String,System.String)">
            <summary>
            Verifies that all the Offer IDs in the list exist in the given env
            </summary>
            <param name="offerList">A newline separated list of Offer IDs</param>
            <param name="env">A Title Verification-valid environment number</param>
            <returns>Every Offer ID that did not exist. If none, it will just be empty</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.VerifyVersions(System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            Confirms that the given versions along with the console type actually exist in selected Environment
            </summary>
            <param name="verStr">Version number (in HEX) of the given type</param>
            <param name="consoleType">Console type</param>
            <param name="envStr">Title Verification-valid environment number</param>
            <param name="titleID">The title id (in HEX)</param>
            <param name="consoleType">The Console Type </param>
            <param name="type">0=base, 1=update, 2=beta</param>
            <returns>Indicates whether the version exists as the given type</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.VerifyVersions(System.String,System.String,System.String,System.Int32)">
            <summary>
            Confirms that the given versions actually exist in selected Environment
            </summary>
            <param name="verStr">Version number (in HEX) of the given type</param>
            <param name="envStr">Title Verification-valid environment number</param>
            <param name="titleID">The title id (in HEX)</param>
            <param name="consoleType">The Console Type </param>
            <param name="type">0=base, 1=update, 2=beta</param>
            <returns>Indicates whether the version exists as the given type</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.VerifyEnvironment(System.String,System.String,System.Web.UI.WebControls.Label@)">
            <summary>
            Check to see if the given title id exists in the given environment
            </summary>
            <param name="env">Title Verification-valid environment number</param>
            <param name="titleID">Title ID (in HEX)</param>
            <param name="errCtrl">A reference to the error label of this Option </param>
            <returns>Indicates whether the Title ID exists in the given environment</returns>
        </member>
        <member name="M:PropManagerCAP.PropManager.EnableLogging">
            <summary>
            Determines if the StreamWriter object is still stored in the Cache or if we need a new one.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.DisableLogging">
            <summary>
            Disables application logging.
            </summary>
        </member>
        <member name="M:PropManagerCAP.PropManager.LogMessage(System.String)">
            <summary>
            Writes formatted messages to the log file.
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:PropManagerCAP.PropManager.FireEvent(System.String,System.Int32,System.Int32)">
            <summary>
            Fires an event into the eventlog (originally written by shawnbe, modified by v-mikma)
            </summary>
            <param name="EvtText">String to include in the event description.</param>
            <param name="EventID">Event ID</param>
            <param name="Severity">Event Type (1=Error,2=Warning,4=Info)</param>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\PropManagerWorkflow.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PropManagerWorkflow</name>
    </assembly>
    <members>
        <member name="M:PropManagerWorkflow.PropManagerApprovalTaskForm.WriteToTaskHistory(System.String)">
            <summary>
            Writes a formatted message to the Task History textbox on the Approval Task.
            </summary>
            <param name="msg">A string value containing the custom message desired for safe-keeping in the Task History.</param>
        </member>
        <member name="M:PropManagerWorkflow.PropManagerApprovalTaskForm.IsPermissionValid(System.String,System.String)">
            <summary>
            Determines whether a user has permission to the passed option.
            </summary>
            <param name="optionName">The name of the request option to test permissions against.</param>
            <param name="envName">The name of the environment to test permissions against.</param>
            <returns>boolean value to indicate success or failure</returns>
        </member>
        <member name="M:PropManagerWorkflow.PropManagerApprovalTaskForm.SplitByString(System.String,System.String)">
            <summary>
             Splits a string based on a string delimeter
            </summary>
            <param name="stringToSplit">A string value that is to be split</param>
            <param name="delimeter">A string value that is the delimeter on which to split the string by</param>
            <returns>An array of strings containing each split</returns>
        </member>
        <member name="M:PropManagerWorkflow.PropManagerModificationForm.SplitByString(System.String,System.String)">
            <summary>
             Splits a string based on a string delimeter
            </summary>
            <param name="stringToSplit">A string value that is to be split</param>
            <param name="delimeter">A string value that is the delimeter on which to split the string by</param>
            <returns>An array of strings containing each split</returns>
        </member>
        <member name="T:PropManagerWorkflow.ToolsMgmt">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.#ctor">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionTable">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginGetActionTable(System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndGetActionTable(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionTableAsync">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionTableAsync(System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginWork(PropManagerWorkflow.BeginWorkInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginBeginWork(PropManagerWorkflow.BeginWorkInfo,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndBeginWork(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginWorkAsync(PropManagerWorkflow.BeginWorkInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginWorkAsync(PropManagerWorkflow.BeginWorkInfo,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.WorkFilesReady(PropManagerWorkflow.WorkFilesReadyInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginWorkFilesReady(PropManagerWorkflow.WorkFilesReadyInfo,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndWorkFilesReady(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.WorkFilesReadyAsync(PropManagerWorkflow.WorkFilesReadyInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.WorkFilesReadyAsync(PropManagerWorkflow.WorkFilesReadyInfo,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetWorkStatus(PropManagerWorkflow.GetWorkStatusInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginGetWorkStatus(PropManagerWorkflow.GetWorkStatusInfo,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndGetWorkStatus(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetWorkStatusAsync(PropManagerWorkflow.GetWorkStatusInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetWorkStatusAsync(PropManagerWorkflow.GetWorkStatusInfo,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CreateJob(System.String,PropManagerWorkflow.JobInfo@)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginCreateJob(System.String,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndCreateJob(System.IAsyncResult,PropManagerWorkflow.JobInfo@)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CreateJobAsync(System.String)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CreateJobAsync(System.String,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.AddAction(PropManagerWorkflow.ActionInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginAddAction(PropManagerWorkflow.ActionInfo,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndAddAction(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.AddActionAsync(PropManagerWorkflow.ActionInfo)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.AddActionAsync(PropManagerWorkflow.ActionInfo,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.ExecuteJob(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginExecuteJob(System.Int64,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndExecuteJob(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.ExecuteJobAsync(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.ExecuteJobAsync(System.Int64,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CancelJob(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginCancelJob(System.Int64,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndCancelJob(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CancelJobAsync(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CancelJobAsync(System.Int64,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetJobStatus(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginGetJobStatus(System.Int64,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndGetJobStatus(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetJobStatusAsync(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetJobStatusAsync(System.Int64,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionStatus(System.Int64,System.Int32)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginGetActionStatus(System.Int64,System.Int32,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndGetActionStatus(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionStatusAsync(System.Int64,System.Int32)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionStatusAsync(System.Int64,System.Int32,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionResult(System.Int64,System.Int32)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginGetActionResult(System.Int64,System.Int32,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndGetActionResult(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionResultAsync(System.Int64,System.Int32)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetActionResultAsync(System.Int64,System.Int32,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CleanupJob(System.UInt64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginCleanupJob(System.UInt64,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndCleanupJob(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CleanupJobAsync(System.UInt64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CleanupJobAsync(System.UInt64,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetJobLog(System.Int32,PropManagerWorkflow.JobLogEntry[]@)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.BeginGetJobLog(System.Int32,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.EndGetJobLog(System.IAsyncResult,PropManagerWorkflow.JobLogEntry[]@)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetJobLogAsync(System.Int32)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.GetJobLogAsync(System.Int32,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.ToolsMgmt.CancelAsync(System.Object)">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.GetActionTableCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.BeginWorkCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.WorkFilesReadyCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.GetWorkStatusCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.CreateJobCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.AddActionCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.ExecuteJobCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.CancelJobCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.GetJobStatusCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.GetActionStatusCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.GetActionResultCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.CleanupJobCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.ToolsMgmt.GetJobLogCompleted">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.BeginWorkInfo">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.BeginWorkInfo.workType">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.BeginWorkInfo.titleId">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.JobLogEntry">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobLogEntry.logged">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobLogEntry.level">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobLogEntry.log">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.ActionResult">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionResult.state">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionResult.returnCode">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionResult.consoleOutput">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.JobState">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Created">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Pending">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Download">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Running">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Canceled">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Complete">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.JobState.Failed">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.Parameter">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.Parameter.name">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.Parameter.value">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.ActionInfo">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionInfo.jobId">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionInfo.toolFileName">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionInfo.parameters">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ActionInfo.files">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.JobInfo">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobInfo.jobId">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobInfo.spaceAvailable">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobInfo.uploadPath">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetWorkStatusResult">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetWorkStatusResult.workComplete">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetWorkStatusResult.returnCode">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetWorkStatusResult.consoleOutput">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetWorkStatusInfo">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetWorkStatusInfo.workId">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.WorkFilesReadyResult">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.WorkFilesReadyResult.success">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.WorkFilesReadyInfo">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.WorkFilesReadyInfo.workId">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.WorkFilesReadyInfo.relativePath">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.BeginWorkResult">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.BeginWorkResult.workId">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.BeginWorkResult.spaceAvailable">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetActionTableCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetActionTableCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetActionTableCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.BeginWorkCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.BeginWorkCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.BeginWorkCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.WorkFilesReadyCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.WorkFilesReadyCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.WorkFilesReadyCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetWorkStatusCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetWorkStatusCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetWorkStatusCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.CreateJobCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.CreateJobCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.CreateJobCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.CreateJobCompletedEventArgs.jobInfo">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.AddActionCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.AddActionCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.AddActionCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.ExecuteJobCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.ExecuteJobCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.ExecuteJobCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.CancelJobCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetJobStatusCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetJobStatusCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetJobStatusCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetActionStatusCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetActionStatusCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetActionStatusCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetActionResultCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetActionResultCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetActionResultCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.CleanupJobCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.CleanupJobCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.CleanupJobCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetJobLogCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetJobLogCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetJobLogCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetJobLogCompletedEventArgs.jobLog">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.InitWorkflow_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Initializes the workflow's global values and deserializes the request initiation data and the workflow's association data.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.PSBug_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Generates a Product Studio bug based on the initiation data provided by a Prop Manager request.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.PSBugAttachFiles_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Attaches all requested files to the newly created PS bug.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.DeterminePropState_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Determines which request types should utilize propping functionality.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.TransferFilesInit_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Transfers required files from the user file drop point to the XOFT environment endpoints.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.SendMail_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Generates an E-mail based on the initiation data provided by a Prop Manager request.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.ComputePropDelay_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Computes how long the workflow should wait before propping this request. 0 = prop now.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.PropRequest_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Runs the commands saved from the Approval Task against the Tools Management Web Service.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.ResolveBugAs_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Resolves the PS bug based on the outcome of a prop.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.SendFinalEmail_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            [Will only occur if a prop was initially approved] If an automated prop succeeded or failed, an e-mail will be sent out to the original request on its result
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.psWorkNotComplete_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Checks the status of the PS bug generated earlier by this workflow. It must be Resolved and NOT assigned to 'xladmins' before letting the workflow complete. Note: Not a full workflow step. No failure tasks.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.AttachRequestXMLToBug_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            Attaches a new request XML file containing the most recent data from the workflow to the PS bug.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.End_ExecuteCode(System.Object,System.EventArgs)">
            <summary>
            The workflow is complete. Clean-up loose ends.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.PopulateVars">
            <summary>
            Populates all relevant global variables for use throughout the workflow
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.InitStep(System.String)">
            <summary>
            Prepares the workflow for the current step
            </summary>
            <param name="stepName">A string representing the name of the step.</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.CompleteStep(System.String,System.String)">
            <summary>
            Prepares workflow variables for the next step while finishing the current step
            </summary>
            <param name="stepName">A string representing the name of the step.</param>
            <param name="completionMsg">The message to be displayed in the workflow history on step completion.</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.GetSensibleByteSize(System.Int64)">
            <summary>
            Converts an amount of bytes into an easily readable string.
            </summary>
            <param name="bytes">A long value that that specifies the byte amount.</param>
            <returns>A string value that is formatted for human readability.</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.CreateToolsMgmtObj">
            <summary>
            Initializes the global Tools Management object (g_toolsMgmt) with where the web service is and what certificate is should use.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.LoadCertificate(System.String)">
            <summary>
            Loads a certificate from the local machine's certificate store
            </summary>
            <param name="certName">String: The name of the certificate.</param>
            <returns>The X509Certificate desired. If it doesn't exist, the certificate will be empty.</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.DoWeProp(System.String,System.String)">
            <summary>
            Determines whether this request has any established prop commands. If not, it won't try to prop the request.
            </summary>
            <param name="optionName">String: The name of the request type/option</param>
            <param name="environmentName">String: The name of the environment.</param>
            <returns></returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.GetTaskDisplayFormLink(Microsoft.SharePoint.SPWeb,Microsoft.SharePoint.SPList,System.Int32)">
            <summary>
            Gets the task display form Url.
            </summary>
            <param name="web">The web.</param>
            <param name="list">The list.</param>
            <param name="itemId">The item id.</param>
            <returns>Task display form link</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.SplitByString(System.String,System.String)">
            <summary>
             Splits a string based on a string delimeter
            </summary>
            <param name="stringToSplit">A string value that is to be split</param>
            <param name="delimeter">A string value that is the delimeter on which to split the string by</param>
            <returns>An array of strings containing each split</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.FireEvent(System.String,System.Int32,System.Int32)">
            <summary>
            Fires an event into the EventLog
            </summary>
            <param name="EvtText">String to include in the event description.</param>
            <param name="EventID">Event ID</param>
            <param name="Severity">Event Type (1=Error,2=Warning,4=Info)</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.RetryStep(System.String,System.String,System.Int32)">
            <summary>
            Updates retry variables and writes to the workflow history page
            </summary>
            <param name="stepName">A string value that represents the name of the current step.</param>
            <param name="errMsg">A string value that represents the last error that occurred.</param>
            <param name="eventID">An integer value that represents the Event ID of the error. Provide 0 for no event logging.</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.WriteToWorkflowHistory(Microsoft.SharePoint.Workflow.SPWorkflowHistoryEventType,System.String,System.String,System.String,System.String)">
            <summary>
            Writes an entry in the workflow's History section.
            </summary>
            <param name="stepName">The name of the step the workflow is currently processesing (empty string for in between steps).</param>
            <param name="description">The text in the HistoryDescription field.</param>
            <param name="outcome">The text in the HistoryOutcome field.</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.ConnectToProductStudio(ProductStudio.Directory@,ProductStudio.Product@,ProductStudio.Datastore@,System.Boolean)">
            <summary>
            Connects to Product Studio using the connection refs given.
            </summary>
            <returns>Whether or not a connection was successfully established.</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.AttachFilesToPSBug(System.Int32,System.Collections.ArrayList,System.String)">
            <summary>
            Attach files to a Bug
            </summary>
            <param name="bugID">The Bug ID that you wish to attach files to</param>
            <param name="files">List of file paths to attach to the bug</param>
            <returns>Indicates whether there were any problems attaching the files or not</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.AddTextToPSBug(System.String,System.String,System.Boolean)">
            <summary>
            Adds passed text to the bug's description and/or repro steps. Also adds a link to the failure task for the error (if any)
            </summary>
            <param name="appendDesc">A string value containing the text to add to the description</param>
            <param name="appendRepro">A string value containing the text to add to the repro steps</param>
            <param name="taskID">A Guid representing the task id for the failure task (null if none)</param>
            <param name="failure">A boolean value describing whether or not we're writing to the PS bug because a failure occurred</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.GetBug(ProductStudio.Datastore,System.String,System.Int32)">
            <summary>
            Gets a bug object. 
            </summary>
            <param name="datastore">A PS DataStore object.</param>
            <param name="database">The PS database where the bug number provided is located.</param>
            <param name="bugId">The bug number desired.</param>
            <returns>A Product Studio DatastoreItem containing the actual bug.</returns>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.InitLogging">
            <summary>
            Pulls the logging setup info out of the web.config file and enables or disables logging appropiately.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.EnableLogging">
            <summary>
            Determines if the StreamWriter object is still stored in the HttpContext.Current.Cache or if we need a new one.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.DisableLogging">
            <summary>
            Disables application logging.
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.LogMessage(System.String)">
            <summary>
            Writes formatted messages to the log file.
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.RefreshLogging">
            <summary>
            Refreshes the StreamWriter so that it's never null
            </summary>
        </member>
        <member name="M:PropManagerWorkflow.Workflow.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:WorkflowAssociationData">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.XlTrans">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.#ctor">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.TransferFile(System.String,System.String,System.String,System.String)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.BeginTransferFile(System.String,System.String,System.String,System.String,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.EndTransferFile(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.TransferFileAsync(System.String,System.String,System.String,System.String)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.TransferFileAsync(System.String,System.String,System.String,System.String,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.GetTransferStatusEx(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.BeginGetTransferStatusEx(System.Int64,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.EndGetTransferStatusEx(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.GetTransferStatusExAsync(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.GetTransferStatusExAsync(System.Int64,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.JobTransferFile(System.String,System.String,System.String,System.Int64,System.String)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.BeginJobTransferFile(System.String,System.String,System.String,System.Int64,System.String,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.EndJobTransferFile(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.JobTransferFileAsync(System.String,System.String,System.String,System.Int64,System.String)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.JobTransferFileAsync(System.String,System.String,System.String,System.Int64,System.String,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.GetTransferStatus(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.BeginGetTransferStatus(System.Int64,System.AsyncCallback,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.EndGetTransferStatus(System.IAsyncResult)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.GetTransferStatusAsync(System.Int64)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.GetTransferStatusAsync(System.Int64,System.Object)">
            <remarks/>
        </member>
        <member name="M:PropManagerWorkflow.XlTrans.CancelAsync(System.Object)">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.XlTrans.TransferFileCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.XlTrans.GetTransferStatusExCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.XlTrans.JobTransferFileCompleted">
            <remarks/>
        </member>
        <member name="E:PropManagerWorkflow.XlTrans.GetTransferStatusCompleted">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.TransferStatus">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.TransferStatus.state">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.TransferStatus.errorcode">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.TransferStatus.message">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.TransferState">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.TransferState.NotFound">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.TransferState.Failed">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.TransferState.Pending">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.TransferState.Running">
            <remarks/>
        </member>
        <member name="F:PropManagerWorkflow.TransferState.Complete">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.TransferFileCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.TransferFileCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.TransferFileCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetTransferStatusExCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetTransferStatusExCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetTransferStatusExCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.JobTransferFileCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.JobTransferFileCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.JobTransferFileCompletedEventArgs.Result">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetTransferStatusCompletedEventHandler">
            <remarks/>
        </member>
        <member name="T:PropManagerWorkflow.GetTransferStatusCompletedEventArgs">
            <remarks/>
        </member>
        <member name="P:PropManagerWorkflow.GetTransferStatusCompletedEventArgs.Result">
            <remarks/>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\Debug\i386\zunevideofeedtest\Resources\config.xml ===
﻿<DBSchemaConfig xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:dbschema-config">
  <SuppressTypes>
    <Regex>^wsp_MS.*$</Regex>
    <Name>WspAddAccountToRole</Name>
    <Regex>^.*FSSLatency$</Regex>
    <Regex>^Merge_.*$</Regex>
    <Regex>^Merged_.*$</Regex>
    <Name>CatalogWatcherUpdateProductMedia</Name>
    <Name>GetProductDocuments</Name>
    <Name>GetSpeechDocuments</Name>
  </SuppressTypes>

  <SuppressElements>
    <Name>modifiedDate</Name> <!-- set by triggers -->
  </SuppressElements>

  
  <SuppressElementsByType>
    <Type>
      <Name>MediaUserRatingAggregate</Name>
      <SuppressElements>
        <Name>roundedAggregate</Name>
        <Name>modifiedDate2</Name>
        <Name>sku</Name>
      </SuppressElements>
    </Type>
  </SuppressElementsByType>
  

  <!-- Optional elements at a global level -->
  <OptionalElements>
        <Name>categoryId</Name>
        <Name>categoryIds</Name>
        <Name>categorySystemId</Name>
        <Name>contributorLimit</Name>
        <Name>detailView</Name>
	<Name>imageTypeIds</Name>
        <Name>legalLocale</Name>
        <Name>locale</Name>
        <Name>mediaIds</Name>
        <Name>mediaRelationshipTypes</Name>
        <Name>now</Name>
        <Name>offerIds</Name>
        <Name>offerFilterLevel</Name>
        <Name>pageNum</Name>
        <Name>pageSize</Name>
        <Name>ratingIds</Name>
	<Name>relations</Name>
        <Name>store</Name>
	<Name>titleFilters</Name>
	<Name>userTypes</Name>
	<Name>userTypes</Name>
	<Name>videoFilter</Name>
  </OptionalElements>

  <OptionalElementsByType>
    <Type>
      <Name>CategoryCorporationUpsert</Name>
      <OptionalElements>
        <Name>htmlDescription</Name>
        <Name>website</Name>
        <Name>rssFeatures</Name>
        <Name>rssAnnouncements</Name>
        <Name>rssNews</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>CategoryUpsert</Name>
      <OptionalElements>
        <Name>parentCategoryId</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>MediaContributor</Name>
      <OptionalElements>
        <Name>contributorAliasId</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>Provider</Name>
      <OptionalElements>
        <Name>accountNumber</Name>
        <Name>contactInfo</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>VideoInstance</Name>
      <OptionalElements>
        <Name>audioChannel</Name>
        <Name>audioSamplingRate</Name>
        <Name>audioCC</Name>
        <Name>audioSubtitle</Name>
        <Name>audioBitRate</Name>
        <Name>videoFrame</Name>
      </OptionalElements>
    </Type>    
  </OptionalElementsByType>

  <TypeDependencies>
    <Type>
      <Name>CategoryCorporationUpsert</Name>
      <DependsOn>
        <Name>ImageSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>LicenseType</Name>
      <DependsOn>
        <Name>LegalText</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>MediaSet</Name>
      <DependsOn>
        <Name>ContributorSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>OfferSave</Name>
      <DependsOn>
        <Name>VideoSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSave</Name>
      <DependsOn>
        <Name>VideoSeasonSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSeasonSave</Name>
      <DependsOn>
        <Name>VideoSeriesSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSeriesSave</Name>
      <DependsOn>
        <Name>CategoryCorporationUpsert</Name>
      </DependsOn>
    </Type>
  </TypeDependencies>

  <ExternalSchemaReferencesByType>
    <Type>
      <Name>ContributorSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Contributor.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>GameContentSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>GameContent.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>GameSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Game.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>ImageSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Image.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>OfferSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Offer.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Video.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSeasonSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>VideoSeason.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSeriesSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>VideoSeries.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
  </ExternalSchemaReferencesByType>

  <PublishSchemas>
    <Schema>
      <Name>Game</Name>
      <Elements>
        <Name>GameContentSave</Name>
        <Name>GameSave</Name>
        <Name>OfferSave</Name>
      </Elements>
    </Schema>
    <Schema>
      <Name>Video</Name>
      <Elements>
        <Name>CategoryCorporationUpsert</Name>
        <Name>CategoryUpsert</Name>
        <Name>ContributorSave</Name>
        <Name>ImageSave</Name>
        <Name>OfferSave</Name>
        <Name>VideoSave</Name>
        <Name>VideoSeasonSave</Name>
        <Name>VideoSeriesSave</Name>
      </Elements>
    </Schema>
  </PublishSchemas>

  <LogicalObjects>
    <Elements>
      <Type>xmlData</Type>
      <Type>Offer.xsd.Data.Custom</Type>
      <Type>TestData</Type>
      <Type>ArcadeGame</Type>
      <Type>Xbox360Game</Type>
      <Type>XboxOriginal</Type>
      <Type>XNAGame</Type>
      <Type>GamerTagChangeProduct</Type>
      <Type>PointsBundleProduct</Type>
      <Type>Bundle</Type>
      <Type>OfferSaveLegacy</Type>
      <Type>OfferSaveCurrent</Type>
      <Type>OfferSaveBundle</Type>
      <Type>GameTrailer</Type>
      <Type>GameVideo</Type>
    </Elements>
    <Types>

      <Type>
        <Name>TestData</Name>
        <Includes>
          <Type minOccurs="0" maxOccurs="unbounded">ArcadeGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">Xbox360Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">XboxOriginal</Type>
          <Type minOccurs="0" maxOccurs="unbounded">XNAGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">Bundle</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveLegacy</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveCurrent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveBundle</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>ArcadeGame/ArcadeGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ArcadeGame/ArcadeGameFullVersion/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>Xbox360Game/GameTitle/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>XboxOriginal/XboxGame/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>XNAGame/XNAGameFullVersion/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>Bundle/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveCurrent/xmlData/Offer.xsd.Data.Custom/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
	      <KeyRef>
                <Selector>OfferSaveBundle/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstance</Selector>
            <Fields>
              <Field>offerInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstance</Selector>
                <Fields>
                  <Field>offerInstanceId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstanceProviderTerm</Selector>
                <Fields>
                  <Field>offerInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTerm</Selector>
            <Fields>
              <Field>providerTermId</Field>
            </Fields>
            <KeyRefs>              
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTermGameContentInstance</Selector>
                <Fields>
                  <Field>providerTermId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTermMediaInstanceClientType</Selector>
                <Fields>
                  <Field>providerTermId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>          
        </Keys>
      </Type>
      <Type>
        <Name>ArcadeGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">ArcadeGameFullVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ArcadeGameTrialVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrial</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>ArcadeGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ArcadeGameTrialVersion/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrial/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>ArcadeGameFullVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">23</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>ArcadeGameTrialVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameTrial</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>AvatarContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentAvatarItem</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">18</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameDemo</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">19</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameTitle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>          
          <Type minOccurs="1" maxOccurs="unbounded">GameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaContributor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="1">ThisToThis</Type>
        </Includes>       
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">1</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GenericConsumableContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameConsumable</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">24</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GenericGameContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">18</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>OwnerToThis</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">MediaRelationship</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PicturePack</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">22</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>      
      <Type>
        <Name>ThemePack</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">20</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>ThisToThis</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">MediaRelationship</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Xbox360Game</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">GameTitle</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameDemo</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameTitle/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>GameDemo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XboxGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
	  <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
	  <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">21</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>XboxOriginal</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">XboxGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>XboxGame/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XNAGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">XNAGameFullVersion</Type>
          <Type minOccurs="0" maxOccurs="1">XNAGameTrialVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrial</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>XNAGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>XNAGameTrialVersion/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
	      <KeyRef>
                <Selector>GameTrial/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XNAGameFullVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">23</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>XNAGameTrialVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GamerTagChangeProduct</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaRevenueSku</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">GamerTagChange</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GamerTagChangeProductOffers</Type>
        </Includes>
      </Type>
      <Type>
        <Name>GamerTagChangeProductOffers</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceUserType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceMedia</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PointsBundleProduct</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaRevenueSku</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">PointsBundle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">PointsBundleProductOffers</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PointsBundleProductOffers</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceUserType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceMedia</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Bundle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstanceClientType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">36</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>OfferSaveBundle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="1">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceUserType</Type>
        </Includes>
      </Type>
      <Type>
        <Name>OfferSaveCurrent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">xmlData</Type>
        </Includes>
      </Type>
      <Type>
        <Name>OfferSaveLegacy</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">xmlData</Type>          
        </Includes>
      </Type>
      <Type>
        <Name>xmlData</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer.xsd.Data.Custom</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Offer.xsd.Data.Custom</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="1">OfferStore</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstance</Type>          
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTerm</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermGameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermMediaInstanceClientType</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceProviderTerm</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceUserType</Type>
        </Includes>
      </Type>
      <Type>
        <Name>GameTrailer</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PreviewMediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoSubtitle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">Video</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>Video</Selector>
                <Fields>
                  <Field>videoMediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">34</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameVideo</Name>
        <Includes>
          <Type minOccurs="0" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PreviewMediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoSubtitle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">Video</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>Video</Selector>
                <Fields>
                  <Field>videoMediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">30</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
    </Types>    
  </LogicalObjects>

</DBSchemaConfig>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\client\XblLoginClient.xml ===
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XblLoginClient</name>
    </assembly>
    <members>
        <member name="T:xonline.login.client.partner.Partner">
            <summary>A partner is any external entity with which we communicate. They
            have names, have a unique identifier, and associated metadata</summary>
        </member>
        <member name="M:xonline.login.client.partner.Partner.Get(System.Int32)">
             <summary>Returns a partner object.</summary>
             <param name="id">the unique identifier of the partner to return.</param>
             <returns>A partner object with the specified id.</returns>
             <exception cref="T:System.Exception">Thrown when the specified partner is not found.</exception>
            
             <remarks>
             This method currently makes direct use of the  underlying  server
             side object model resulting in direct access to the backing store.
             This is temporary.  Once the server is developed, this method will
             will be reimplemented to call that server.  That is,  this will be
             a remote call.
             </remarks>
        </member>
        <member name="M:xonline.login.client.partner.Partner.Get(System.String)">
             <summary>Returns a partner object.</summary>
             <param name="name">the name of the partner to return.</param>
             <returns>The partner object with the specified name.</returns>
             <exception cref="T:System.Exception">Thrown when the specified partner is not found.</exception>
            
             <remarks>
             This method currently makes direct use of the  underlying  server
             side object model resulting in direct access to the backing store.
             This is temporary.  Once the server is developed, this method will
             will be reimplemented to call that server.  That is,  this will be
             a remote call.
             </remarks>
        </member>
        <member name="P:xonline.login.client.partner.Partner.Id">
            <summary>The Id property represents the unique integer identifier of the partner.</summary>
            <value>The Id property gets the unique identifier for the partner</value>
        </member>
        <member name="P:xonline.login.client.partner.Partner.Name">
            <summary> Returns the friendly name for the partner</summary>
        </member>
        <member name="P:xonline.login.client.partner.Partner.Data">
             <summary>Returns XML data associated the  partner.   Currently  there
             is no schema enforcement for the data.  It must simply be well-formed.
             However,  it is recommended that different  domains  coordinate  both
             the root element and any sub-elements.  for example: </summary>
            
             <example><code>
             <root>
                 <community>
                 </community>
                 <marketplace>
                 </marketplace>
             </root>
             </code></example>
        </member>
        <member name="T:xonline.login.client.partner.PartnerUser">
            <summary>A partner user is a pairwise user for communicating with a partner .
            The partner user may store credentials and other data for communicating with
            that partner.  Additionally, each partner user has a pairwise xuid  that  is
            specific to that partner and can be used in place of the real user xuid  for
            purposes of protecting the user's xuid which  could  otherwise  be  used  to
            correlate user pii.</summary>
        </member>
        <member name="M:xonline.login.client.partner.PartnerUser.Save">
            <summary>Saves the ParterUser to the database.   All values will be written
            whether they are modified or not.</summary>
            <exception cref="T:System.Exception">Thrown when the specified partner is not found.</exception>
        </member>
        <member name="M:xonline.login.client.partner.PartnerUser.GetPartnerXuid(System.Int32,xonline.common.service.Puid)">
             <summary>Get a record of the partner user matching the specified partner id and xuid.  If
             no record is found, then one will be created to establish the relationship between the
             user and partner.</summary>
            
             <param name="partnerId">partnerId - the unique identifier of the partner for this user.</param>
             <param name="xuid">xuid - the xbox user id of the user (without respect to .</param>
             <returns>A partner object with the specified id.</returns>
             <exception cref="T:System.Exception">Thrown when the specified partner is not found.</exception>
            
             <remark>
             This method currently makes direct use of the  underlying  server
             side object model resulting in direct access to the backing store.
             This is temporary.  Once the server is developed, this method will
             will be reimplemented to call that server.  That is,  this will be
             a remote call.
             </remark>
        </member>
        <member name="M:xonline.login.client.partner.PartnerUser.GetPartnerUser(xonline.common.service.Puid)">
             <summary>Get a record of the partner user matching the specified partner xuid.  
            </summary>
            
             <param name="partner_xuid">partner_xuid - the partner xuid that maps to the partnerId and the user</param>
             <returns>A partner object with the specified partner and user id.</returns>
             <exception cref="T:System.Exception">Thrown when the specified partner xuid is not found.</exception>
            
             <remark>
             This method currently makes direct use of the  underlying  server
             side object model resulting in direct access to the backing store.
             This is temporary.  Once the server is developed, this method will
             will be reimplemented to call that server.  That is,  this will be
             a remote call.
             </remark>
        </member>
        <member name="M:xonline.login.client.partner.PartnerUser.LookupPartnerXuid(System.Int32,System.String[])">
             <summary>Reverse lookup partner users by their partner user ids</summary>
             <param name="partnerId">partnerId - the unique identifier of the partner for this user.</param>
             <param name="userIds">userIds - an array of userIds to lookup.</param>
            
             <returns>A an array of PartnerUser objects.  The array will contain
             one entry for every partner user found.  The array can be zero length.
             The order of the partner users in the array is indeterminate, callers
             must not make assumptions about the order of elements.</returns>
            
             <remarks>
             This method currently makes direct use of the  underlying  server
             side object model resulting in direct access to the backing store.
             This is temporary.  Once the server is developed, this method will
             will be reimplemented to call that server.  That is,  this will be
             a remote call.
             </remarks>
        </member>
        <member name="P:xonline.login.client.partner.PartnerUser.Data">
             <summary>The Data property represents partner specific data associated with the partner user.  Like
             the Data property for Partner object.  There is no enforced schema for the XML.   It must simply be
             well-formed. However,  it is recommended that different  domains  coordinate  both the root element
             and any sub-elements, and take care to not alter data in other domains</summary>
            
             <example><code>
             <root>
                 <community>
                 </community>
                 <marketplace>
                 </marketplace>
             </root>
             </code></example>
        </member>
        <member name="P:xonline.login.client.partner.PartnerUser.PartnerXuid">
            <summary>The PartnerXuid property represents the pairwise xuid used when communicating with the partner system.</summary>
            <value>The Token property gets the pairwise xuid used when communicating with the partner system</value>
        </member>
        <member name="P:xonline.login.client.partner.PartnerUser.Token">
            <summary>The Token property represents the user credentials used to log into the partner system</summary>
            <value>The Token property gets/sets the user credentials partner user uses to log into the partner system.  The value can be null</value>
        </member>
        <member name="P:xonline.login.client.partner.PartnerUser.UserId">
            <summary>The UserId property represents the unique user id the partner user uses to log into the partner system</summary>
            <value>The Id property gets/sets the unique user id the partner user uses to log into the partner system.  The value can be null</value>
        </member>
        <member name="P:xonline.login.client.partner.PartnerUser.Xuid">
            <summary>The Xuid property represents the unique xbox live user xuid for the partner user.</summary>
            <value>The Id property gets the unique xbox live user xuid for the partner user</value>
        </member>
    </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\symbad.txt ===
osql.exe
ErrSay.exe
msvcp70.dll
msvcr70.dll
msvcp71.dll
msvcr71.dll
PtsCommon.dll
delnode.exe
gdiplus.dll
capicom.dll
PassportToggler.exe
GenOnlineKey.exe
spac_1.00.0000.0.exe
spac_1.01.0000.0.exe
spac_1.02.0000.0.exe
spac_1.03.0000.0.exe
certimp.exe
GetDom.dll
Microsoft.PicassoTest.dll
Microsoft.Wtt.Log.dll
ScreenShots.dll
UIAFsupp.dll
WebRunner.ISTAF.dll
WebRunner.Loggers.dll
WebRunner.SDK.dll
psclobj.dll
EnrollObj.dll
licenseserver.dll
WMRMObjs.dll
WMRMRehd.dll
msizap.exe
Microsoft.DynamicImplementations.dll
spac_1.04.0000.0.exe
WPFVisifire.Charts.dll
Microsoft.IdentityModel.dll
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\checkinCreatePS.ini ===
<Component>
 <ClassName>CheckinCreatePS.clsCheckinCreatePS</ClassName>
 <InetRootPath>tools\autocheckin\CheckinCreatePS.dll</InetRootPath>
 <Prepare>Yes</Prepare>
 <Submit>Yes</Submit>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\AutoCheckin.ini ===
<?xml version="1.0" standalone="yes"?>

<!-- Input File for AutoCheckin tool -->
<!-- Contains Component Definitions for calling external components in the tool -->
<!-- Contains Application variables -->
<!-- 06/25/01  a-raslam created -->
<!-- 01/30/03 bhernon: public\ext\tools\ is going to be busted on shared COREXT systems -->
<!--          someone who knows this tool can fix that as time permits -->

<INI>
 <Components>
	<include>build\autocheckin\PreSD_components.ini</include>
	<Component>
		<ClassName>CheckinSD.clsCheckinSD</ClassName>
		<InetRootPath>tools\AutoCheckin\CheckinSD.dll</InetRootPath>
		<Prepare>Yes</Prepare>
		<Submit>Yes</Submit>
	</Component>
	<include>build\autocheckin\PostSD_components.ini</include>
 </Components>
 <Constants>
  <Smartmail>public\ext\tools\x86\smartmail.exe</Smartmail>
  <SmartmailOptions>auth:sspi</SmartmailOptions>
  <include>build\autocheckin\constants.ini</include>
 </Constants>
</INI>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinDetails.ini ===
<Component>
 <ClassName>CheckinDetails.clsCheckinDetails</ClassName>
 <InetRootPath>tools\autocheckin\CheckinDetails.dll</InetRootPath>
 <Prepare>Yes</Prepare>
 <Submit>Yes</Submit>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinDetailsFields.xml ===
<Fields>
<include>build\autocheckin\CheckinDetailsFields.xml</include>
</Fields>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\VelocityInterop\CacheBaseLibrary.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
	<assembly>
		<name>CacheBaseLibrary</name>
	</assembly>
	<members>
		<member name="T:Microsoft.Data.Caching.DataCacheErrorCode">
			<summary>A static class used to store global error codes.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.CacheItemVersionMismatch">
			<summary>The object in the cache does not match with the specified version; integer value equals 1.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.CacheServerUnavailable">
			<summary>One or more specified cache servers are unavailable; integer value equals 19.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ClientServerVersionMismatch">
			<summary>The cache client assemblies are a different version than the cache host assemblies; integer value equals 24.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.InvalidArgument">
			<summary>The argument is not valid; integer value equals 5.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.InvalidCacheLockHandle">
			<summary>The specified lock handle is not valid; integer value equals 15.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.InvalidEnumerator">
			<summary>An invalid enumerator is specified; integer value equals 16.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.KeyAlreadyExists">
			<summary>The key is already present in the cache or region; integer value equals 10.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.KeyDoesNotExist">
			<summary>An object cached with the specified key does not exist in the cache or region; integer value equals 8.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.MaxNamedCacheCountExceeded">
			<summary>The named cache count exceeded the maximum value; integer value equals 12.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NamedCacheDoesNotExist">
			<summary>The named cache does not exist; integer value equals 11.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NotificationNotSupported">
			<summary>Cache notifications are not supported because the cache client is a simple client or the named cache has been created without notifications enabled; integer value equals 20.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NotPermittedForDefaultRegions">
			<summary>The operation is only supported in regions that you explicitly create with the <see cref="M:Microsoft.Data.Caching.DataCache.CreateRegion(System.String,System.Boolean)" /> method; integer value equals 18.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.NullArgument">
			<summary>A null has been specified as an argument; integer value equals 3.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ObjectLocked">
			<summary>The cached object has already been locked; integer value equals 13.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ObjectNotLocked">
			<summary>The object is not locked; integer value equals 14.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.RegionAlreadyExists">
			<summary>The region already exists; integer value equals 9.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.RegionDoesNotExist">
			<summary>The region does not exist; integer value equals 7.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.RetryLater">
			<summary>Temporary failure, retry the operation later; integer value equals 22.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.SerializationException">
			<summary>An exception was encountered during object serialization; integer value equals 25.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.ServerNull">
			<summary>The servers parameter of the <see cref="Overload:Microsoft.Data.Caching.DataCacheFactory.#ctor" /> constructor or one of the items in the array is null; integer value equals 26.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.Timeout">
			<summary>Communications with the cache cluster have experienced a delay past the timeout value; integer value equals 23.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheErrorCode.UndefinedError">
			<summary>Unknown error; integer value equals 6. </summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheException">
			<summary>Used for cache-related exceptions.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor(System.String)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class; allows you to provide a message with the exception.</summary>
			<param name="message">The message describing the exception.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class; allows you to provide serialization information with the exception.</summary>
			<param name="info">Stores serialization information about an object.</param>
			<param name="context">Describes the source, destination, and context of a serialized stream.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.#ctor(System.String,System.Exception)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheException" /> class; allows you to provide a message and another exception with the exception.</summary>
			<param name="message">The message describing the exception.</param>
			<param name="innerException">Another exception related to this exception.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
			<summary>The interface that is used for serialization.</summary>
			<param name="info">The SerializationInfo class used to store all the data that you need to serialize the exception.</param>
			<param name="context">The StreamingContext class used to describe the source and destination of the exception.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheException.ErrorCode">
			<summary>The integer used to identify the type of exception encountered.</summary>
			<returns>An integer specifying the type of exception encountered.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheException.Message">
			<summary>The description of the exception encountered.</summary>
			<returns>A string that describes the type of exception encountered.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheItem">
			<summary>Used to retrieve all information associated with the cached object in the cluster.</summary>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.CacheName">
			<summary>The name of the cache where the object is stored.</summary>
			<returns>A string value that represents the name of the cache where the object is stored.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Key">
			<summary>The identifier that is used to distinguish the cached object in the cache or region.</summary>
			<returns>A string value that represents the identifier that is used to distinguish the cached object in the cache or region.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.RegionName">
			<summary>If applicable, the name of the region where the object is stored.</summary>
			<returns>A string value that represents, if applicable, the name of the region where the object is stored.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Tags">
			<summary>A generic list of tags associated with the cached object.</summary>
			<returns>An generic list of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects associated with the cached object.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Value">
			<summary>The object stored in cache.</summary>
			<returns>An object representing the deserialized form of the cached object.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheItem.Version">
			<summary>The version of the cached object.</summary>
			<returns>The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> is updated every time the object is updated. Only the latest version of the object is stored on the cache cluster. Due to the distributed nature of the cluster, the cache client may not have the latest copy of the object. For this reason, the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> class is essential for concurrency operations. For more information, see Concurrency Models (Velocity) and Concurrency Methods (Velocity).When using cache notifications, the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object corresponding to an item-related cache operation can be returned to your application with the version parameter of the <see cref="T:Microsoft.Data.Caching.DataCacheNotificationCallback" /> delegate method. For more information, see <see cref="Cache Notifications (Velocity)" />.Version comparisons are only meaningful when comparing versions of the same item specified with the same key. Comparison methods may return a result, but the result is only valid for versions of the same key. </returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheItemVersion">
			<summary>Used to represent the version of a cached object.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheItemVersion.CompareTo(Microsoft.Data.Caching.DataCacheItemVersion)">
			<summary>Used to compare two versions of the same item, specified with the same key.</summary>
			<returns>An integer value: 0 if the versions are equal, greater than zero if the instance is greater than the version parameter value, or less than zero if the instance is less than the version parameter value.</returns>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> to be compared.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheItemVersion.Equals(System.Object)">
			<summary>Used to determine whether another object is the same.</summary>
			<returns>A Boolean value: true, if the objects are the same; false, if they are different.</returns>
			<param name="obj">Another object for comparison.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheItemVersion.GetHashCode">
			<summary>Returns the hash code of the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object.</summary>
			<returns>An integer value that represents the hash code of the <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object. </returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheLockHandle">
			<summary>The structure used as a key to lock and unlock cached objects in a pessimistic concurency scenario.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLockHandle.ToString">
			<summary>Returns the string representation of the lock handle.</summary>
			<returns>A string representing the lock handle.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheLogSink">
			<summary>Used to specify an individual log sink.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLogSink.#ctor(Microsoft.Data.Caching.DataCacheSinkType)">
			<summary>Defines the type of log sink and assigns a TraceLevel of Warning.</summary>
			<param name="sinkType">The type of log sink, represented by the <see cref="T:Microsoft.Data.Caching.DataCacheSinkType" /> enumeration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLogSink.#ctor(Microsoft.Data.Caching.DataCacheSinkType,System.Diagnostics.TraceLevel)">
			<summary>Defines the type of log sink and assigns the specified TraceLevel.</summary>
			<param name="sinkType">The type of log sink, represented by the <see cref="T:Microsoft.Data.Caching.DataCacheSinkType" /> enumeration.</param>
			<param name="logLevel">The TraceLevel of the log sink, represented by the <see cref="T:System.Diagnostics.TraceLevel" /> enumeration. Available options include: No tracing, Error, Warning, Information, and Verbose.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheLogSink.#ctor(Microsoft.Data.Caching.DataCacheSinkType,System.Diagnostics.TraceLevel,System.String)">
			<summary>Defines the type of log sink and assigns the specified TraceLevel. This overload also enables setting additional log sink parameters.</summary>
			<param name="sinkType">The type of log sink, represented by the <see cref="T:Microsoft.Data.Caching.DataCacheSinkType" /> enumeration.</param>
			<param name="logLevel">The TraceLevel of the log sink, represented by the <see cref="T:System.Diagnostics.TraceLevel" /> enumeration. Available options include: No tracing, Error, Warning, Information, and Verbose.</param>
			<param name="sinkParam">Only used for file-based logging to specify the file naming convention of the log file.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheSinkType">
			<summary>Used to specify the type of log sink used to trace events on the cache client.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheSinkType.CONSOLE">
			<summary>Used to specify console-based log sinks. </summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheSinkType.ETW">
			<summary>Used to specify Event Tracing for Windows (ETW)-based log sinks.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheSinkType.FILE">
			<summary>Used to specify file-based log sinks.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheTag">
			<summary>Represents an optional string-based identifier that you can associate with a cached object.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.#ctor(System.String)">
			<summary>Initializes a new instance of the <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> class.</summary>
			<param name="tag">The string-based identifier to associate with a cached object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.Equals(System.Object)">
			<summary>Compares the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object for equality with the specified <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</summary>
			<returns>True if the object implements the ToString method and its value is the same as the string representation of the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" />; otherwise, false.</returns>
			<param name="obj">The object whose string representation is compared for equality to the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.GetHashCode">
			<summary>Returns the hash code for the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</summary>
			<returns>An integer representing the hash code for the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</returns>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheTag.ToString">
			<summary>Returns the string representation of the current <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object.</summary>
			<returns>A string representing the current value of the <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> object. </returns>
		</member>
	</members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinEmail.ini ===
<Component>
 <ClassName>CheckinEmail.clsCheckinEmail</ClassName>
 <InetRootPath>tools\autocheckin\CheckinEmail.dll</InetRootPath>
 <Submit>Yes</Submit>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\VelocityInterop\ClientLibrary.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
	<assembly>
		<name>ClientLibrary</name>
	</assembly>
	<members>
		<member name="N:Microsoft.Data.Caching">
			<summary>The <see cref="N:MIcrosoft.Data.Caching" /> namespace provides access to an in-memory application cache application for developing scalable, high-performance applications. This namespace can be used to cache any common language runtime (CLR) object and provides access through simple APIs.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCache">
			<summary>The object that is used by cache-enabled applications for storing and retrieving objects from the cache cluster. An instance of this object is referred to as the cache client. </summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object)">
			<summary>Adds an object to the cache.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds an object to the cache. This method enables associating tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.String)">
			<summary>Adds an object to a region in the cache.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="region">The name of the region to save the object in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan)">
			<summary>Adds an object to the cache. This method provides the ability to specify when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds an object to a region in the cache. This method enables associating tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
			<param name="region">The name of the region to save the object in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds an object to the cache. This method enables associating tags with the cached object and specifying when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan,System.String)">
			<summary>Adds an object to a region in the cache. This method provides the ability to specify when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region to save the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Add(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds an object to a region in the cache. This method enables associating tags with the cached object and specifying when the object should be expired.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">A unique value that is used to store and retrieve the object from the cache.</param>
			<param name="value">The object saved to the cache cluster.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">An array of <see cref="T:Microsoft.Data.Caching.DataCacheTag" /> objects to associate with the cached object.</param>
			<param name="region">The name of the region to save the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddCacheLevelCallback(Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback)">
			<summary>Adds a cache notification callback for cache operations occurring on all regions and items.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback. </returns>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddFailureNotificationCallback(Microsoft.Data.Caching.DataCacheFailureNotificationCallback)">
			<summary>Adds a failure notification callback, for notifications indicating that a client has missed one or more cache notifications.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="failureCallback">The name of the method that you want to invoke when the failure notification occurs.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddItemLevelCallback(System.String,Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback)">
			<summary>Adds a cache notification callback for cache operations occurring on one specific item that is not stored in a region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="key">The key used to store the object in the cache.</param>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddItemLevelCallback(System.String,Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback,System.String)">
			<summary>Adds a cache notification callback for cache operations occurring on one specific item that is stored in region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="key">The key used to store the object in the cache.</param>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
			<param name="regionName">The name of the region where the object is stored.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.AddRegionLevelCallback(System.String,Microsoft.Data.Caching.DataCacheOperation,Microsoft.Data.Caching.DataCacheNotificationCallback)">
			<summary>Adds a cache notification callback for cache operations occurring on one specific region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object used to identify the cache notification callback.</returns>
			<param name="regionName">The name of the region for which the specified item or region operations can trigger cache notifications.</param>
			<param name="filter">The type of cache operation(s) that will trigger cache notifications.</param>
			<param name="clientCallback">The name of the method you want to invoke when these notifications occur.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.ClearRegion(System.String)">
			<summary>Deletes all objects in the specified region.</summary>
			<param name="region">The name of the region whose objects are removed.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.CreateRegion(System.String,System.Boolean)">
			<summary>Creates a region and specifies if resident objects may be evicted.</summary>
			<param name="region">The name of the region that is created.</param>
			<param name="evictionOn">True if objects in the region can be evicted.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String)">
			<summary>Gets an object from the cache using the specified key.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String,Microsoft.Data.Caching.DataCacheItemVersion@)">
			<summary>Gets an object from the cache using the specified key. You may also provide the version to obtain the specific version of a key, if that version is still the most current in the cache.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist. Even if the key does exist, null may also be returned because the object has been updated to a new version.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="version">The version of the desired object. If this parameter is null, the version of the current object is retrieved.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String,System.String)">
			<summary>Gets an object from the specified region by using the specified key.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Get(System.String,Microsoft.Data.Caching.DataCacheItemVersion@,System.String)">
			<summary>Gets an object from the specified region by using the specified key. You may also provide the version to obtain the specific version of a key, if that version is still the most current in the region.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the key does not exist. Even if the key does exist, null may also be returned because the object has been updated to a new version.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="version">The version of the desired object. If this parameter is null, the version of the current object is retrieved.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetAndLock(System.String,System.TimeSpan,Microsoft.Data.Caching.DataCacheLockHandle@)">
			<summary>Returns and locks the cached object (if present).</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the object has already been locked or the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="timeout">A non-zero value indicating how many minutes the object remains locked.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object required to unlock the object. The lockHandle output parameter is passed by reference.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetAndLock(System.String,System.TimeSpan,Microsoft.Data.Caching.DataCacheLockHandle@,System.String)">
			<summary>Returns and locks the cached object (if present). For objects stored in regions.</summary>
			<returns>The object that was cached by using the specified key. Null is returned if the object has already been locked or the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="timeout">A non-zero value indicating how many minutes the object remains locked.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object required to unlock the object. The lockHandle output parameter is passed by reference.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetCacheItem(System.String)">
			<summary>Gets a <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object to retrieve all information associated with your cached object in the cluster.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object that contains all information associated with your cached object. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetCacheItem(System.String,System.String)">
			<summary>Gets a <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object to retrieve all information associated with your cached object in the cluster. For objects stored in regions.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItem" /> object that contains all information associated with your cached object. Null is returned if the key does not exist.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetIfNewer(System.String,Microsoft.Data.Caching.DataCacheItemVersion@)">
			<summary>Gets an object from the cache, but only if a newer version of the object resides in the cache.</summary>
			<returns>If the version in the cache differs from the version parameter, the corresponding cached object is returned. If the version in the cache is the same as the version parameter, null is returned.</returns>
			<param name="key">The unique value that is used to identify the object in the cache. If this parameter is null, an exception is thrown.</param>
			<param name="version">The version of the desired object, passed by reference. If this parameter is null, an exception is thrown.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetIfNewer(System.String,Microsoft.Data.Caching.DataCacheItemVersion@,System.String)">
			<summary>Gets an object from the specified region, but only if a newer version of the object resides in the region. </summary>
			<returns>If the version in the region differs from the version parameter, the corresponding cached object is returned. If the version in the region is the same as the version parameter, null is returned.</returns>
			<param name="key">The unique value that is used to identify the object in the cache. If this parameter is null, an exception is thrown.</param>
			<param name="version">The version of the desired object, passed by reference. If this parameter is null, an exception is thrown.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsByAllTags(System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region that have all the same tags in common.</summary>
			<returns>An enumerable list of all cached objects in the specified region that have all the same tags in common. Null is returned if no objects in the specified region have all the tags specified.</returns>
			<param name="tags">A list of tags for which to search.</param>
			<param name="region">The name of the region to search. Tags are not supported outside regions. Therefore, a region name is required.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsByAnyTag(System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region that have any of the same tags in common.</summary>
			<returns>An enumerable list of all cached objects in the specified region that have any of the same tags in common. Null is returned if no objects in the specified region have any of the tags specified.</returns>
			<param name="tags">A list of tags for which to search.</param>
			<param name="region">The name of the region to search. Tags are not supported outside regions. Therefore, a region name is required.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsByTag(Microsoft.Data.Caching.DataCacheTag,System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region that have the specified tag.</summary>
			<returns>An enumerable list of all cached objects in the specified region that have the specified tag. Null is returned if no objects in the specified region have the tag specified.</returns>
			<param name="tag">The tag for which to search.</param>
			<param name="region">The name of the region to search. Tags are not supported outside regions. Therefore, a region name is required.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.GetObjectsInRegion(System.String)">
			<summary>Gets an enumerable list of all cached objects in the specified region.</summary>
			<returns>An enumerable list of all cached objects in the specified region.</returns>
			<param name="region">The name of the region for which to return a list of all resident objects.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object)">
			<summary>Adds or replaces an object in the cache. </summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion)">
			<summary>Adds or replaces an object in the cache if it is at the specified version.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.String)">
			<summary>Adds or replaces an object in the specified region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan)">
			<summary>Adds or replaces an object in the cache. Specifies the timeout value of the cached object. </summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache if it is at the specified version. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan)">
			<summary>Adds or replaces an object in the cache if it is at the specified version. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan,System.String)">
			<summary>Adds or replaces an object in the specified region. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Adds or replaces an object in the cache if it is at the specified version. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan,System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Put(System.String,System.Object,Microsoft.Data.Caching.DataCacheItemVersion,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Adds or replaces an object in the specified region if it is at the specified version. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the object saved to the cache under the key value.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="oldVersion">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be replaced.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle)">
			<summary>Replaces and unlocks an object in the cache.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Replaces and unlocks an object in the cache. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.String)">
			<summary>Replaces and unlocks an object in the specified region.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan)">
			<summary>Replaces and unlocks an object in the cache. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Replaces and unlocks an object in the specified region. Associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag})">
			<summary>Replaces and unlocks an object in the cache. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the cache.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.String)">
			<summary>Replaces and unlocks an object in the specified region. Specifies the timeout value of the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.The timeout value associated with the cached object overrides expiration settings specified in the named cache configuration. For more information, see Expiration and Eviction (Velocity).</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.PutAndUnlock(System.String,System.Object,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheTag},System.String)">
			<summary>Replaces and unlocks an object in the specified region. Specifies the timeout value and associates tags with the cached object.</summary>
			<returns>A <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object after it has been updated by this method. If the lockHandle parameter is not equal to the <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object obtained from the method that is used to lock the object, null is returned and the object is not updated.</returns>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="value">The object to add or replace.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="tags">A list of tags to associate with the object.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String)">
			<summary>Removes an object from the cache.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String,Microsoft.Data.Caching.DataCacheItemVersion)">
			<summary>Removes an object from the cache if it is at the specified version.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be removed.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String,System.String)">
			<summary>Removes an object from the specified region.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Remove(System.String,Microsoft.Data.Caching.DataCacheItemVersion,System.String)">
			<summary>Removes an object from the specified region if it is at the specified version.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> object that represents the version of the cached object that is to be removed.</param>
			<param name="region">The name of the region the object resides in.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.RemoveCallback(Microsoft.Data.Caching.DataCacheNotificationDescriptor)">
			<summary>Removes a cache notification callback.</summary>
			<param name="nd">The <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object that identifies the callback that should be removed.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.RemoveRegion(System.String)">
			<summary>Deletes a region. All cached objects inside the region are also removed.</summary>
			<param name="region">The name of the region.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.ResetObjectTimeout(System.String,System.TimeSpan)">
			<summary>Resets the object timeout value, defining how long objects reside in the cache before expiring. The value specified for the object overrides the default settings for the cache.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="newTimeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.ResetObjectTimeout(System.String,System.TimeSpan,System.String)">
			<summary>Resets the object timeout value, defining how long objects reside in the region before expiring. The value specified for the object overrides the default settings for the cache.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="newTimeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle)">
			<summary>Releases objects locked in the cache. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle,System.String)">
			<summary>Releases objects locked in the specified region. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan)">
			<summary>Releases objects locked in the cache. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object. Specifies a new timeout value for the cached object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCache.Unlock(System.String,Microsoft.Data.Caching.DataCacheLockHandle,System.TimeSpan,System.String)">
			<summary>Releases objects locked in the specified region. This method supports pessimistic concurrency by making sure that the appropriate <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> is used for unlocking the object. Specifies a new timeout value for the cached object.</summary>
			<param name="key">The unique value that is used to identify the object in the region.</param>
			<param name="lockHandle">The <see cref="T:Microsoft.Data.Caching.DataCacheLockHandle" /> object that was returned when the object was locked.</param>
			<param name="timeout">A non-zero value that is used to specify how many minutes the object should reside in the cache before expiration.</param>
			<param name="region">The name of the region where the object resides.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCache.Item(System.String)">
			<summary>Allows for the use of array notation to access cached objects.</summary>
			<returns>A deserialized object that was saved to the cache cluster that uses the key.</returns>
			<param name="key">The key that is used to save the cached object.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheFactory">
			<summary>Provides methods to return <see cref="T:Microsoft.Data.Caching.DataCache" /> objects that are mapped to a named cache. This class also enables programmatic configuration of the cache client.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.#ctor">
			<summary>Used for configuring a cache client based on the application configuration file.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.#ctor(Microsoft.Data.Caching.DataCacheServerEndpoint[],System.Boolean,System.Boolean)">
			<summary>Used for configuring a cache client programmatically, based on the parameter values provided.</summary>
			<param name="servers">The cache host configuration for the cache client, for an array of <see cref="T:Microsoft.Data.Caching.DataCacheServerEndpoint" /> objects.</param>
			<param name="routingClient">True when the <see cref="M:Microsoft.Data.Caching.DataCacheFactory.GetCache(System.String)" /> method returns routing clients; otherwise, it returns simple clients.</param>
			<param name="localCache">True when local cache is enabled on the cache client; otherwise, local cache is disabled.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.#ctor(Microsoft.Data.Caching.DataCacheServerEndpoint[],System.Boolean,System.Boolean,Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy,System.Int32,System.Int32)">
			<summary>Used for configuring a cache client programmatically, based on the parameter values provided. Additional parameters provided for working with cache notifications.</summary>
			<param name="servers">The cache host configuration for the cache client, for an array of <see cref="T:Microsoft.Data.Caching.DataCacheServerEndpoint" /> objects.</param>
			<param name="routingClient">True when the <see cref="M:Microsoft.Data.Caching.DataCacheFactory.GetCache(System.String)" /> method returns routing clients; otherwise, it returns simple clients.</param>
			<param name="localCache">True when local cache is enabled on the cache client; otherwise, local cache is disabled.</param>
			<param name="syncPolicy">Specifies the way locally cached objects should be invalidated, as defined by the <see cref="T:Microsoft.Data.Caching.LocalCacheSyncPolicy" /> enumeration.</param>
			<param name="localCacheTimeout">The number of seconds that objects will remain in local cache before they are invalidated. Not applicable to notification-based invalidation. For more information, see Expiration and Eviction (Velocity).</param>
			<param name="pollInterval">The interval, in seconds, in which the cache client checks with the cache cluster for new notifications. Default value is 300 seconds. For more information, see Cache Notifications (Velocity).</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.CreateLogSinks(System.Collections.Generic.List{Microsoft.Data.Caching.DataCacheLogSink})">
			<summary>Allows you to set the log levels on one or more log sinks for the cache client.</summary>
			<param name="sinkList">Log level settings for one or more log sinks.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.DisableLogSinks">
			<summary>Disables all log sinks on the cache client.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.Dispose">
			<summary>Closes the <see cref="T:Microsoft.Data.Caching.DataCacheFactory" /> object and releases all associated resources.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.EnableAllAvailableSinks">
			<summary>Enables all available log sinks on the cache client, with the EventTrace level equal to Warning.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.GetCache(System.String)">
			<summary>Returns the cache client, an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</summary>
			<returns>The cache client, an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</returns>
			<param name="cacheName">The named cache to use for cache operations.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheFactory.GetDefaultCache">
			<summary>Returns the cache client corresponding to the default cache; an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</summary>
			<returns>The cache client, an instance of the <see cref="T:Microsoft.Data.Caching.DataCache" /> object.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheFactory.Timeout">
			<summary>The duration of time, in milliseconds, that the cache client will wait to communicate with the cache cluster before it throws a timeout exception.</summary>
			<returns>A System.Timespan object that represents the duration of time, in milliseconds, that the cache client will wait to communicate with the cache cluster before it throws a timeout exception.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheFailureNotificationCallback">
			<summary>Specifies the parameters required for a method to be invoked by a failure notification when the cache client misses cache notifications. </summary>
			<param name="cacheName">The name of the cache associated with the missing notifications.</param>
			<param name="nd">The <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object associated with the failure notification that invoked the delegate method.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy">
			<summary>Specifies the way locally cached objects should be invalidated.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy.NotificationBased">
			<summary>Specifies that objects will stay in local cache until they are automatically invalidated by a cache notification.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheLocalCacheSyncPolicy.TimeoutBased">
			<summary>Specifies that objects will stay in local cache until their lifetime reaches the localCacheTimeout duration specified in the <see cref="Overload:Microsoft.Data.Caching.DataCacheCacheFactory.#ctor" /> constructor.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheNotificationCallback">
			<summary>Specifies the parameters required for a method to be invoked by a cache notification.</summary>
			<param name="CacheName">The name of the cache associated with the cache operation.</param>
			<param name="regionName">The name of the region associated with the cache operation. A zero-length string indicates that a specific region is not associated with the cache operation.</param>
			<param name="key">The name of the key associated with the cache operation. A zero-length string indicates that a specific cached item is not associated with the cache operation.</param>
			<param name="version">The <see cref="T:Microsoft.Data.Caching.DataCacheItemVersion" /> of the cached object associated with the cache operation that triggered the notification. A null version indicates that a specific cached item is not associated with the cache operation.</param>
			<param name="cacheOperation">The <see cref="T:Microsoft.Data.Caching.DataCacheOperation" /> enumeration specifying which cache event triggered the cache notification.</param>
			<param name="nd">The <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object associated with the cache notification that invoked the delegate method.</param>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor">
			<summary>Identifies a cache notification callback. This identifier is required to remove the corresponding cache notification callback.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheNotificationDescriptor.ToString">
			<summary>Creates a copy of the <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object.</summary>
			<returns>A string value representing the <see cref="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.CacheName" /> and <see cref="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.DelegateID" /> property values.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.CacheName">
			<summary>he name of the cache triggering the cache notification.</summary>
			<returns>A string value represents the name of the cache triggering the cache notification.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheNotificationDescriptor.DelegateID">
			<summary>Identifier for the <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> object. Used to distinguish between <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> objects.</summary>
			<returns>A System.Int64 value used to identify <see cref="T:Microsoft.Data.Caching.DataCacheNotificationDescriptor" /> objects.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheOperation">
			<summary>An enumeration used to specify specific item or region events that can trigger a cache notification.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.AddItem">
			<summary>Indicates that an object was added to the cache.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.ClearRegion">
			<summary>Indicates that a region in the cache was cleared with the <see cref="M:Microsoft.Data.Caching.DataCache.ClearRegion(System.String)" /> method.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.CreateRegion">
			<summary>Indicates that a region in the cache was created with the <see cref="M:Microsoft.Data.Caching.DataCache.CreateRegion(System.String,System.Boolean)" /> method.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.RemoveItem">
			<summary>Indicates that an object was removed from the cache.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.RemoveRegion">
			<summary>Indicates that a region in the cache was removed with the <see cref="M:Microsoft.Data.Caching.DataCache.RemoveRegion(System.String)" /> method.</summary>
		</member>
		<member name="F:Microsoft.Data.Caching.DataCacheOperation.ReplaceItem">
			<summary>Indicates that an object was replaced in the cache.</summary>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheServerEndpoint">
			<summary>Used to specify an individual cache host when programmatically configuring the cache client.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheServerEndpoint.#ctor(System.String,System.Int32,System.String)">
			<summary>Used to define a cache host in the cache cluster for programmatic configuration of the cache client.</summary>
			<param name="hostName">The computer name of the cache server.</param>
			<param name="cachePort">The cache port number of the cache host.</param>
			<param name="cacheHostName">The Windows service name of the cache host service that is running on the cache server.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheServerEndpoint.CacheHostName">
			<summary>The Windows service name of the cache host service that is  running on the cache server.</summary>
			<returns>A string representing the Windows service name of the cache host service that is running on the cache server. The installation default value is DistributedCacheService.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheServerEndpoint.CachePort">
			<summary>The cache port on the cache server.</summary>
			<returns>A System.Int32 value that represents the cache port number on the cache server.</returns>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheServerEndpoint.HostName">
			<summary>The computer name of the cache server.</summary>
			<returns>A string representing the computer name of the cache server.</returns>
		</member>
		<member name="T:Microsoft.Data.Caching.DataCacheSessionStoreProvider">
			<summary>A session storage provider that enables Web applications to store session-state data to a distributed cache system.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.#ctor">
			<summary>Initializes a new instance of the <see cref="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider" /> class.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.CreateNewStoreData(System.Web.HttpContext,System.Int32)">
			<summary>Creates a new data storage object for the current request.</summary>
			<returns>A <see cref="T:System.Web.SessionState.SessionStateStoreData" /> object, used for storing session data in the distributed cache.</returns>
			<param name="context">The HttpContext for the current request.</param>
			<param name="timeout">The session state Timeout value for the new <see cref="T:System.Web.SessionState.SessionStateStoreData" /> object.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.CreateUninitializedItem(System.Web.HttpContext,System.String,System.Int32)">
			<summary>Adds a new session state to the distributed cache.</summary>
			<param name="context">The HttpContext for the current request.</param>
			<param name="id">The session identifier for the current request.</param>
			<param name="timeout">The session Timeout for the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.Dispose">
			<summary>Releases all resources used by the <see cref="T:Microsoft.Data.Caching.DataCacheSessionStoreProvider" /> class.</summary>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.EndRequest(System.Web.HttpContext)">
			<summary>Called by the <see cref="T:System.Web.SessionState.SessionStateModule" /> class at the end of a request.</summary>
			<param name="context">The HttpContext for the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.GetItem(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)">
			<summary>Returns read-only session-state data from the cache.</summary>
			<returns>A SessionStateStoreData object populated with session values and information from the cache.</returns>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier for the current request.</param>
			<param name="locked">When this method returns, contains a Boolean value that is set to true if the requested session item is locked in the cache; otherwise, false.</param>
			<param name="lockAge">When this method returns, contains a TimeSpan object that is set to the period of time that an item in the cache has been locked.</param>
			<param name="lockId">When this method returns, contains an object that is set to the lock identifier for the current request. </param>
			<param name="actions">When this method returns, contains one of the SessionStateActions values. This indicates whether the current session is an uninitialized, cookieless session.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.GetItemExclusive(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)">
			<summary>Returns and locks the read-only session-state data from the cache. </summary>
			<returns>A SessionStateStoreData object populated with session values and information from the cache.</returns>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier for the current request.</param>
			<param name="locked">When this method returns, contains a Boolean value that is set to true if a lock in the cache is successfully obtained; otherwise, false.</param>
			<param name="lockAge">When this method returns, contains a TimeSpan object that is set to the period of time that an item in the cache has been locked.</param>
			<param name="lockId">When this method returns, contains an object that is set to the lock identifier for the current request. </param>
			<param name="actions">When this method returns, contains one of the SessionStateActions values. This indicates whether the current session is an uninitialized, cookieless session.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.Initialize(System.String,System.Collections.Specialized.NameValueCollection)">
			<summary>Initializes the distributed cache provider.</summary>
			<param name="name">The name of the application.</param>
			<param name="config">The configuration details specified in the application configuration file for cacheName and regionName.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.InitializeRequest(System.Web.HttpContext)">
			<summary>Called by the SessionStateModule object for per-request initialization.</summary>
			<param name="context">The HttpContext for the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.ReleaseItemExclusive(System.Web.HttpContext,System.String,System.Object)">
			<summary>Releases a lock on the session data in the cache.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
			<param name="lockId">The lock identifier of the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.RemoveItem(System.Web.HttpContext,System.String,System.Object,System.Web.SessionState.SessionStateStoreData)">
			<summary>Deletes session data from the cache.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
			<param name="lockId">The lock identifier of the current request.</param>
			<param name="item">The SessionStateStoreData that represents the item to delete from the cache.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.ResetItemTimeout(System.Web.HttpContext,System.String)">
			<summary>Updates the expiration date and time of session data in the cache.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.SetAndReleaseItemExclusive(System.Web.HttpContext,System.String,System.Web.SessionState.SessionStateStoreData,System.Object,System.Boolean)">
			<summary>Updates the session item information in the cache with values from the current request and clears the lock on the session item.</summary>
			<param name="context">The HttpContext of the current request.</param>
			<param name="id">The session identifier of the current request.</param>
			<param name="item">The SessionStateStoreData object that contains the current session values to be stored.</param>
			<param name="lockId">The lock identifier for the current request.</param>
			<param name="newItem">If true, identifies the session item as a new item if true; otherwise, identifies the session item as an existing item.</param>
		</member>
		<member name="M:Microsoft.Data.Caching.DataCacheSessionStoreProvider.SetItemExpireCallback(System.Web.SessionState.SessionStateItemExpireCallback)">
			<summary>Sets a reference to the SessionStateItemExpireCallback delegate for the Session_OnEnd event defined in the Global.asax file.</summary>
			<returns>Cache does not support notification of the expiration; therefore this method always returns false.</returns>
			<param name="expireCallback">The SessionStateItemExpireCallback delegate for the Session_OnEnd event defined in the Global.asax file.</param>
		</member>
		<member name="P:Microsoft.Data.Caching.DataCacheSessionStoreProvider.ApplicationName">
			<summary>The name of the application, used to differentiate sessions in the cache cluster.</summary>
			<returns>A string value that represents the name of the application that uses the distributed cache to store session state.</returns>
		</member>
	</members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinLockDown.ini ===
<Component>
 <ClassName>CheckinRAID.clsCheckinLockDown</ClassName>
 <InetRootPath>tools\autocheckin\CheckinRAID.dll</InetRootPath>
 <Prepare>Yes</Prepare>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinLockDownConfig.xml ===
<LockDown>
	<include>build\autocheckin\CheckinLockDownConfig.xml</include>
</LockDown>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\target\i386\XboxDotComFeedTest\Resources\config.xml ===
﻿<DBSchemaConfig xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:dbschema-config">
  <SuppressTypes>
    <Regex>^wsp_MS.*$</Regex>
    <Name>WspAddAccountToRole</Name>
    <Regex>^.*FSSLatency$</Regex>
    <Regex>^Merge_.*$</Regex>
    <Regex>^Merged_.*$</Regex>
    <Name>CatalogWatcherUpdateProductMedia</Name>
    <Name>GetProductDocuments</Name>
    <Name>GetSpeechDocuments</Name>
  </SuppressTypes>

  <SuppressElements>
    <Name>modifiedDate</Name> <!-- set by triggers -->
  </SuppressElements>

  
  <SuppressElementsByType>
    <Type>
      <Name>MediaUserRatingAggregate</Name>
      <SuppressElements>
        <Name>roundedAggregate</Name>
        <Name>modifiedDate2</Name>
        <Name>sku</Name>
      </SuppressElements>
    </Type>
  </SuppressElementsByType>
  

  <!-- Optional elements at a global level -->
  <OptionalElements>
        <Name>categoryId</Name>
        <Name>categoryIds</Name>
        <Name>categorySystemId</Name>
        <Name>contributorLimit</Name>
        <Name>detailView</Name>
	<Name>imageTypeIds</Name>
        <Name>legalLocale</Name>
        <Name>locale</Name>
        <Name>mediaIds</Name>
        <Name>mediaRelationshipTypes</Name>
        <Name>now</Name>
        <Name>offerIds</Name>
        <Name>offerFilterLevel</Name>
        <Name>pageNum</Name>
        <Name>pageSize</Name>
        <Name>ratingIds</Name>
	<Name>relations</Name>
        <Name>store</Name>
	<Name>titleFilters</Name>
	<Name>userTypes</Name>
	<Name>userTypes</Name>
	<Name>videoFilter</Name>
  </OptionalElements>

  <OptionalElementsByType>
    <Type>
      <Name>CategoryCorporationUpsert</Name>
      <OptionalElements>
        <Name>htmlDescription</Name>
        <Name>website</Name>
        <Name>rssFeatures</Name>
        <Name>rssAnnouncements</Name>
        <Name>rssNews</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>CategoryUpsert</Name>
      <OptionalElements>
        <Name>parentCategoryId</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>MediaContributor</Name>
      <OptionalElements>
        <Name>contributorAliasId</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>Provider</Name>
      <OptionalElements>
        <Name>accountNumber</Name>
        <Name>contactInfo</Name>
      </OptionalElements>
    </Type>
    <Type>
      <Name>VideoInstance</Name>
      <OptionalElements>
        <Name>audioChannel</Name>
        <Name>audioSamplingRate</Name>
        <Name>audioCC</Name>
        <Name>audioSubtitle</Name>
        <Name>audioBitRate</Name>
        <Name>videoFrame</Name>
      </OptionalElements>
    </Type>    
  </OptionalElementsByType>

  <TypeDependencies>
    <Type>
      <Name>CategoryCorporationUpsert</Name>
      <DependsOn>
        <Name>ImageSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>LicenseType</Name>
      <DependsOn>
        <Name>LegalText</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>MediaSet</Name>
      <DependsOn>
        <Name>ContributorSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>OfferSave</Name>
      <DependsOn>
        <Name>VideoSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSave</Name>
      <DependsOn>
        <Name>VideoSeasonSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSeasonSave</Name>
      <DependsOn>
        <Name>VideoSeriesSave</Name>
      </DependsOn>
    </Type>
    <Type>
      <Name>VideoSeriesSave</Name>
      <DependsOn>
        <Name>CategoryCorporationUpsert</Name>
      </DependsOn>
    </Type>
  </TypeDependencies>

  <ExternalSchemaReferencesByType>
    <Type>
      <Name>ContributorSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Contributor.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>GameContentSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>GameContent.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>GameSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Game.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>ImageSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Image.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>OfferSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Offer.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>Video.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSeasonSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>VideoSeason.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
    <Type>
      <Name>VideoSeriesSave</Name>
      <ExternalSchemaReference>
        <Element>xmlData</Element>
        <File>VideoSeries.xsd</File>
        <Node>Data</Node>
      </ExternalSchemaReference>
    </Type>
  </ExternalSchemaReferencesByType>

  <PublishSchemas>
    <Schema>
      <Name>Game</Name>
      <Elements>
        <Name>GameContentSave</Name>
        <Name>GameSave</Name>
        <Name>OfferSave</Name>
      </Elements>
    </Schema>
    <Schema>
      <Name>Video</Name>
      <Elements>
        <Name>CategoryCorporationUpsert</Name>
        <Name>CategoryUpsert</Name>
        <Name>ContributorSave</Name>
        <Name>ImageSave</Name>
        <Name>OfferSave</Name>
        <Name>VideoSave</Name>
        <Name>VideoSeasonSave</Name>
        <Name>VideoSeriesSave</Name>
      </Elements>
    </Schema>
  </PublishSchemas>

  <LogicalObjects>
    <Elements>
      <Type>xmlData</Type>
      <Type>Offer.xsd.Data.Custom</Type>
      <Type>TestData</Type>
      <Type>ArcadeGame</Type>
      <Type>Xbox360Game</Type>
      <Type>XboxOriginal</Type>
      <Type>XNAGame</Type>
      <Type>GamerTagChangeProduct</Type>
      <Type>PointsBundleProduct</Type>
      <Type>Bundle</Type>
      <Type>OfferSaveLegacy</Type>
      <Type>OfferSaveCurrent</Type>
      <Type>OfferSaveBundle</Type>
      <Type>GameTrailer</Type>
      <Type>GameVideo</Type>
    </Elements>
    <Types>

      <Type>
        <Name>TestData</Name>
        <Includes>
          <Type minOccurs="0" maxOccurs="unbounded">ArcadeGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">Xbox360Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">XboxOriginal</Type>
          <Type minOccurs="0" maxOccurs="unbounded">XNAGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">Bundle</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveLegacy</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveCurrent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferSaveBundle</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>ArcadeGame/ArcadeGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ArcadeGame/ArcadeGameFullVersion/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>Xbox360Game/GameTitle/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>XboxOriginal/XboxGame/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>XNAGame/XNAGameFullVersion/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>Bundle/Media</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveCurrent/xmlData/Offer.xsd.Data.Custom/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
	      <KeyRef>
                <Selector>OfferSaveBundle/Offer</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstance</Selector>
            <Fields>
              <Field>offerInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstance</Selector>
                <Fields>
                  <Field>offerInstanceId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/OfferInstanceProviderTerm</Selector>
                <Fields>
                  <Field>offerInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTerm</Selector>
            <Fields>
              <Field>providerTermId</Field>
            </Fields>
            <KeyRefs>              
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTermGameContentInstance</Selector>
                <Fields>
                  <Field>providerTermId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>OfferSaveLegacy/xmlData/Offer.xsd.Data.Custom/ProviderTermMediaInstanceClientType</Selector>
                <Fields>
                  <Field>providerTermId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>          
        </Keys>
      </Type>
      <Type>
        <Name>ArcadeGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">ArcadeGameFullVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ArcadeGameTrialVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrial</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>ArcadeGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ArcadeGameTrialVersion/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrial/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>ArcadeGameFullVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">23</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>ArcadeGameTrialVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameTrial</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>AvatarContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentAvatarItem</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">18</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameDemo</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">19</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameTitle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>          
          <Type minOccurs="1" maxOccurs="unbounded">GameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaContributor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="1">ThisToThis</Type>
        </Includes>       
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">1</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GenericConsumableContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameConsumable</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">24</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GenericGameContent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">18</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>OwnerToThis</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">MediaRelationship</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PicturePack</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">22</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>      
      <Type>
        <Name>ThemePack</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">20</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>ThisToThis</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">MediaRelationship</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Xbox360Game</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">GameTitle</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameDemo</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameTitle/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>GameDemo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XboxGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
	  <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
	  <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="1" maxOccurs="1">GameContent</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="1" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">21</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>XboxOriginal</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">XboxGame</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>XboxGame/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XNAGame</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">XNAGameFullVersion</Type>
          <Type minOccurs="0" maxOccurs="1">XNAGameTrialVersion</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrial</Type>
          <Type minOccurs="0" maxOccurs="unbounded">AvatarContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericGameContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ThemePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PicturePack</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GenericConsumableContent</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameTrailer</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameVideo</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>XNAGameFullVersion/Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>XNAGameTrialVersion/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
	      <KeyRef>
                <Selector>GameTrial/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>AvatarContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericGameContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>ThemePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>PicturePack/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GenericConsumableContent/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameTrailer/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
              <KeyRef>
                <Selector>GameVideo/OwnerToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
      </Type>
      <Type>
        <Name>XNAGameFullVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="1" maxOccurs="1">Game</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountry</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameCapabilityCountryMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GameLocale</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">ThisToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>ThisToThis/MediaRelationship</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>ThisToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">23</Predicate>
          </SearchCondition>
          <SearchCondition Type="MediaRelationship">
            <Predicate LogicalOperation="And" XPath="mediaRelationshipTypeId" Operation="NotEquals">2</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>XNAGameTrialVersion</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRatingDescriptor</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="1">GameContent</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="1">GameContentInstanceEncryptedKey</Type>
          <Type minOccurs="0" maxOccurs="unbounded">GameContentInstanceFile</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>GameContentInstance</Selector>
            <Fields>
              <Field>gameContentInstanceId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaInstanceId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">5</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GamerTagChangeProduct</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaRevenueSku</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">GamerTagChange</Type>
          <Type minOccurs="1" maxOccurs="unbounded">GamerTagChangeProductOffers</Type>
        </Includes>
      </Type>
      <Type>
        <Name>GamerTagChangeProductOffers</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceUserType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceMedia</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PointsBundleProduct</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaRevenueSku</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="1" maxOccurs="1">PointsBundle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">PointsBundleProductOffers</Type>
        </Includes>
      </Type>
      <Type>
        <Name>PointsBundleProductOffers</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceUserType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstanceMedia</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Bundle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstance</Type>
          <Type minOccurs="1" maxOccurs="1">MediaInstanceClientType</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="1" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>MediaInstance</Selector>
                <Fields>
                  <Field>mediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">36</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>OfferSaveBundle</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="1">OfferStore</Type>
          <Type minOccurs="1" maxOccurs="unbounded">OfferInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceUserType</Type>
        </Includes>
      </Type>
      <Type>
        <Name>OfferSaveCurrent</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">xmlData</Type>
        </Includes>
      </Type>
      <Type>
        <Name>OfferSaveLegacy</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">xmlData</Type>          
        </Includes>
      </Type>
      <Type>
        <Name>xmlData</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer.xsd.Data.Custom</Type>
        </Includes>
      </Type>
      <Type>
        <Name>Offer.xsd.Data.Custom</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Offer</Type>
          <Type minOccurs="1" maxOccurs="1">OfferStore</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstance</Type>          
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTerm</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermGameContentInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">ProviderTermMediaInstanceClientType</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceProviderTerm</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceMediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OfferInstanceUserType</Type>
        </Includes>
      </Type>
      <Type>
        <Name>GameTrailer</Name>
        <Includes>
          <Type minOccurs="1" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PreviewMediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoSubtitle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">Video</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>Video</Selector>
                <Fields>
                  <Field>videoMediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">34</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
      <Type>
        <Name>GameVideo</Name>
        <Includes>
          <Type minOccurs="0" maxOccurs="1">Media</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaCategory</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocale</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaLocaleMap</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRating</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaRelationship</Type>
          <Type minOccurs="0" maxOccurs="unbounded">MediaInstance</Type>
          <Type minOccurs="0" maxOccurs="unbounded">PreviewMediaInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoInstance</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoFile</Type>
          <Type minOccurs="1" maxOccurs="unbounded">VideoSubtitle</Type>
          <Type minOccurs="1" maxOccurs="unbounded">Video</Type>
          <Type minOccurs="0" maxOccurs="unbounded">OwnerToThis</Type>
        </Includes>
        <Keys>
          <Key>
            <Selector>Media</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
            <KeyRefs>
              <KeyRef>
                <Selector>Video</Selector>
                <Fields>
                  <Field>videoMediaId</Field>
                </Fields>
              </KeyRef>
            </KeyRefs>
          </Key>
        </Keys>
        <KeyRefHints>
          <KeyRefHint>
            <Selector>MediaRelationship</Selector>
            <Fields>
              <Field>mediaId</Field>
            </Fields>
          </KeyRefHint>
          <KeyRefHint>
            <Selector>OwnerToThis/MediaRelationship</Selector>
            <Fields>
              <Field>relatedMediaId</Field>
            </Fields>
          </KeyRefHint>
        </KeyRefHints>
        <DBSchemaSearchCondition>
          <SearchCondition Type="Media">
            <Predicate LogicalOperation="And" XPath="mediaTypeId" Operation="Equals">30</Predicate>
          </SearchCondition>
        </DBSchemaSearchCondition>
      </Type>
    </Types>    
  </LogicalObjects>

</DBSchemaConfig>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinEmailData.xml ===
<CheckinEmail>
	<User>AutoCheck/CheckinSD/User</User>
        <ChangeList>AutoCheck/CheckinSD/Changelist</ChangeList>
	<Description>AutoCheck/CheckinSD/Description</Description>
	<Files>AutoCheck/CheckinSD/Files/File/DepotPath</Files>
	<BugNos>AutoCheck/CheckinProductStudio/BugNos</BugNos>
	<BugID>AutoCheck/CheckinProductStudio/Bugs/Bug/Field[@Name="ID"]</BugID>
	<Title>AutoCheck/CheckinProductStudio/Bugs/Bug/Field[@Name="Title"]</Title>
	<Comment>AutoCheck/CheckinDetails/Controls/Comment</Comment>
	<SourceTree>AutoCheck/CheckinSD/SourceTree</SourceTree>
	<Product>AutoCheck/CheckinDetails/Controls/Product</Product>
	<BugCause>AutoCheck/CheckinDetails/Controls/BugCause</BugCause>
	<CodeReviewer>AutoCheck/CheckinSD/CodeReviewer</CodeReviewer>
	<BuddyBuildBy>AutoCheck/CheckinSD/BuddyBuildBy</BuddyBuildBy>
	<CheckinTestError>AutoCheck/Env/CheckinTestError</CheckinTestError>
	<CheckinTestDescription>AutoCheck/Env/CheckinTestDescription</CheckinTestDescription>
	<CheckinTestSource>AutoCheck/Env/CheckinTestSource</CheckinTestSource>
	<CheckinTestGenDescription>AutoCheck/Env/CheckinTestGenDescription</CheckinTestGenDescription>
	<InetRootPathFiles></InetRootPathFiles>
	<TestImpact>AutoCheck/CheckinDetails/Fields/TestImpact</TestImpact>
</CheckinEmail>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\checkinProductStudio.ini ===
<Component>
 <ClassName>CheckinPS.clsCheckinPS</ClassName>
 <InetRootPath>tools\autocheckin\CheckinPS.dll</InetRootPath>
 <Prepare>Yes</Prepare>
 <Submit>Yes</Submit>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinPSFields.xml ===
<Fields>
<include>build\autocheckin\CheckinPSFields.xml</include>
</Fields>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinProductStudio.xml ===
<CheckinProductStudio>
<include>build\autocheckin\CheckinProductStudio.xml</include>
</CheckinProductStudio>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinPSLockDownConfig.xml ===
<LockDown>
	<include>build\autocheckin\CheckinPSLockDownConfig.xml</include>
</LockDown>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\Checkinraiddbs.xml ===
<CheckinRAID>
<include>build\autocheckin\CheckinRAIDDBs.xml</include>
</CheckinRAID>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinRAID.ini ===
<Component>
 <ClassName>CheckinRAID.clsCheckinRAID</ClassName>
 <InetRootPath>tools\autocheckin\CheckinRAID.dll</InetRootPath>
 <Prepare>Yes</Prepare>
 <Submit>Yes</Submit>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinRAIDFields.xml ===
<Fields>
<include>build\autocheckin\CheckinRAIDFields.xml</include>
</Fields>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\psfields.xml ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\checkintest.ini ===
<Component>
	<ClassName>CheckinTest.clsCheckinTest</ClassName>
	<InetRootPath>tools\AutoCheckin\CheckinTest.dll</InetRootPath>
	<Prepare>Yes</Prepare>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinPSLockDown.ini ===
<Component>
 <ClassName>CheckinPS.clsCheckinLockDownPS</ClassName>
 <InetRootPath>tools\autocheckin\CheckinPS.dll</InetRootPath>
 <Prepare>Yes</Prepare>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinVulnscan.ini ===
<Component>
	<ClassName>CheckinVulnscanGUI.clsVulnscanGUI</ClassName>
	<InetRootPath>tools\AutoCheckin\CheckinVulnScanGUI.dll</InetRootPath>
	<Prepare>Yes</Prepare>
	<Submit>No</Submit>
</Component>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinVulnscanConstants.ini ===
<VulnscanPath>tools\AutoCheckin\CheckinVulnscanVulns.xml</VulnscanPath>
<VulnscanLevel>3</VulnscanLevel>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinTestDBs.xml ===
<CheckinTest>
<include>build\autocheckin\CheckinTestDBs.xml</include>
</CheckinTest>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\automation\BldPropExcludes.txt ===
public\ext
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\automation\v2\docs\.README.txt ===
#
#  CoreXT Build Automation Scripts - v2
#
#  [zackrun][roborr] - 2008
#

http://sharepoint/sites/corext/LivingDocs/BuildAutomationV2

@ Overview @
Autogenerated documentation created from bin\XmlDocExtractor.exe by running it over the 
target files in the v2 automation system.  The tool currently finds comments that conform to
the below format, and builds an xml metadata file.  This is then transformed using the xsl
files in the bin directory.  The transform was thrown together to show a possible implementation
of a document viewer, but updates to these transforms in corext would be very welcome.

--begin common msbuild--
    <!-- 
      ============================================================
      ** TARGET DESCRIPTION
      ** [IN]
      ** $(InputProperty)  : PropertyDescription
      ** @(InputItem)      : Aligned Colon delimiter - ItemDescription
      **   %(ItemMetadata) : Aligned Colon delimiter - MetadataDescription
      ** 
      ** [OUT]
      ** $(OutputProperty) : PropertyDescription
      ** @(OutputItem)     : ItemDescription
      **   %(ItemMetadata) : MetadataDescription
    -->
--end common msbuild--


@ Extensions @
If you create your own extensions, or if targets get added, removed, or manipulated, the docs
should be regenerated.  Pass all targets files to the generator and a directory for output.  Check
in the htm* files.  For teams that create extensions, create your own build\automation\vs\docs folder
and run the generator on all files including your own, instead of altering these docs and worrying
about corext mirror conflicts.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\automation\v2\Unpack\.README.txt ===
#
#  CoreXT Build Automation Scripts - v2
#
#  [zackrun][roborr] - 2008
#


@ Overview @
This folder is used to shadow copy dependencies and then unpack a pack file. It can be copied
to an %ExternalUnpackDrop% or build\automation\v2\Unpack with altered files to test or extend
the scripts.  This project is called from Launch.cmd.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\autocheckin\CheckinVulnscanVulns.xml ===
<?xml  version="1.0" standalone="yes"?>
<!-- Input File for VulnScan -->
<!-- Contains definitions of potential vulnerabilites and the risks associated with them -->
<!-- Revision History -->
<!-- 06/05/01  t-cclark  created -->
<!-- 06/18/01  t-cclark  Removed TEMP,SECUR*,COOKIE vulns -->
<!-- 06/29/01  t-cclark  Modified Vulnerabilities for speed -->
<!-- 10/22/01  mpriest   Removed vulns and extensions for non-C code -->
<!--                     Added Except clauses for exceptions -->
<!--                     Improved risk descriptions -->
<!--                     Added fixed-width buffer vuln -->
<!DOCTYPE Vulnscan [
    <!ELEMENT Vulnscan (Scantypes ,Vulnlist)>
    <!ELEMENT Scantypes (Extension+) >
    <!ELEMENT Vulnlist (Vuln+) >
    <!ELEMENT Extension ( #PCDATA ) >
    <!ELEMENT Vuln (Sev,Description,Regexp+,Except*,Risk) >
    <!ELEMENT Sev ( #PCDATA ) >
    <!ELEMENT Description ( #PCDATA ) >
    <!ELEMENT Regexp ( #PCDATA ) >
    <!ATTLIST Regexp WholeWord CDATA "0" >
    <!ELEMENT Except ( #PCDATA ) >
    <!ELEMENT Risk  ( #PCDATA ) >
    ]>

<Vulnscan>
    <Scantypes>
        <Extension>cpp</Extension>
        <Extension>c</Extension>
	<Extension>h</Extension>
	<Extension>hpp</Extension>
    </Scantypes>
    <Vulnlist>
        <Vuln>
            <Sev>1</Sev>
            <Description>Fixed-Width Buffer</Description>
            <Regexp WholeWord="1">\[:d+\]</Regexp>
            <Risk>Fixed width buffers are crashable by malicious input.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>STRCPY family</Description>
            <Regexp WholeWord="1">(wcs|str|lstr)cpy</Regexp>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>STRCAT family</Description>
            <Regexp WholeWord="1">(str|wcs)cat</Regexp>
            <Regexp WholeWord="1">lstrcat(a|w)?</Regexp>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>Char width converters</Description>
            <Regexp WholeWord="1">A2W</Regexp>
            <Regexp WholeWord="1">W2A</Regexp>
            <Regexp WholeWord="1">W2T</Regexp>
            <Regexp WholeWord="1">T2W</Regexp>
            <Regexp WholeWord="1">multibytetowidechar</Regexp>
            <Regexp WholeWord="1">widechartomultibyte</Regexp>
	    <Except>StrW2A</Except>
	    <Except>StrA2W</Except>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>STRDUP family</Description>
            <Regexp WholeWord="1">(wc|str)dup</Regexp>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>SPRINTF family</Description>
            <Regexp WholeWord="1">(vw|w)?sprintf(a|w)?</Regexp>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>SCANF family</Description>
            <Regexp WholeWord="1">(w|fw|f|s|sw)?scanf</Regexp>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>GETS family</Description>
            <Regexp WholeWord="1">(f)?get(w)?s</Regexp>
            <Risk>No width check. Malicious input can exceed allocated buffer.</Risk>
        </Vuln>
        <Vuln>
            <Sev>1</Sev>
            <Description>GETENV</Description>
            <Regexp WholeWord="1">getenv</Regexp>
            <Risk>Environmental variables can be set to malicious values.</Risk>
        </Vuln>
        <Vuln>
            <Sev>2</Sev>
            <Description>STRTOK Family</Description>
            <Regexp WholeWord="1">(str|wc|_mb)tok</Regexp>
            <Risk>Functions in the StrTok family modify their input strings.</Risk>
        </Vuln>
        <Vuln>
            <Sev>2</Sev>
            <Description>STRNCPY family</Description>
            <Regexp WholeWord="1">(wcs|str)ncpy</Regexp>
            <Regexp WholeWord="1">(l)?strcpyn(w|a)?</Regexp>
            <Regexp WholeWord="1">(wcs|str)xfrm</Regexp>
            <Except>sizeof</Except>
            <Risk>Count argument must be tied to sizeof(buffer), not a constant.</Risk>      
        </Vuln>
        <Vuln>
            <Sev>2</Sev>
            <Description>STRNCMP family</Description>
            <Regexp WholeWord="1">(wcs|str)ncmp</Regexp>
            <Regexp WholeWord="1">lstrcmpn(a|w)?</Regexp>
            <Regexp WholeWord="1">(wcs|str)ni(coll|cmp)</Regexp>
            <Except>sizeof</Except>
            <Risk>Count argument must be tied to sizeof(buffer), not a constant.</Risk>      
        </Vuln>
        <Vuln>
            <Sev>2</Sev>
            <Description>STRNCAT family</Description>
            <Regexp WholeWord="1">(wcs|str)ncat</Regexp>
            <Regexp WholeWord="1">lstrcatn(a|w)?</Regexp>
            <Except>sizeof</Except>
            <Risk>Count argument must be tied to sizeof(buffer), not a constant.</Risk>             </Vuln>
        <Vuln>
            <Sev>2</Sev>
            <Description>SNPRINTF family</Description>
            <Regexp WholeWord="1">(v)?sn(w)?printf</Regexp>
            <Except>sizeof</Except>
            <Risk>Count argument must be tied to sizeof(buffer), not a constant.</Risk>             </Vuln>
        <Vuln>
            <Sev>3</Sev>
            <Description>SYSTEM family</Description>
            <Regexp WholeWord="1">system</Regexp>
            <Regexp WholeWord="1">exec</Regexp>
            <Regexp WholeWord="1">CreateProcess(AsUser|WithLogonW|WithLogonA)?</Regexp>
            <Regexp WholeWord="1">WinExec</Regexp>
            <Risk>Never pass unsanitized user inputs to new processes.</Risk>                     </Vuln>
        <Vuln>
            <Sev>3</Sev>
            <Description>STRSTR family</Description>
            <Regexp WholeWord="1">(wcs|str)(str|spn|pbrk|cspn)</Regexp>
            <Risk>Malicious input may lack NULL terminator</Risk>
        </Vuln>
        <Vuln>
            <Sev>3</Sev>
            <Description>STRLEN family</Description>
            <Regexp WholeWord="1">(wcs|str)len</Regexp>
            <Regexp WholeWord="1">lstrlen(a|w)?</Regexp>
            <Risk>Malicious input may lack NULL terminator</Risk>
        </Vuln>
        <Vuln>
            <Sev>3</Sev>
            <Description>_STRREV family</Description>
            <Regexp WholeWord="1">(wcs|str)rev</Regexp>
            <Regexp WholeWord="1">(wcs|str)(lwr|upr)</Regexp>
            <Risk>Input may lack NULL terminator</Risk>
        </Vuln>
        <Vuln>
            <Sev>3</Sev>
            <Description>STRCMP family</Description>
            <Regexp WholeWord="1">(wcs|str)(i)?cmp</Regexp>
            <Regexp WholeWord="1">lstrcmp(i)?(a|w)?</Regexp>
            <Regexp WholeWord="1">(wcs|str)(i)?coll</Regexp>
            <Risk>Malicious input may lack null terminator.</Risk>
        </Vuln>
    </Vulnlist>
</Vulnscan>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\automation\v2\Unpack\LaunchShadow.txt ===
#
#  Shadow copying is required to ensure we run our unpack from a stable system.
#
#  Batch-unpack would be a simpler solution, but the extensibility of such a system gets difficult over time.
#  Instead, we'll copy these files into a staging directory and execute the unpack from there.
#
#  The LaunchShadow.txt is copied along with the Unpack directory, so it may come from %ExternalUnpackDrop%,
#  from the build\automation\v2\Unpack folder, or from tools\build\automation\v2\Unpack.
#
#  * '#' at the start of a line is a comment
#  * All paths are %INETROOT%-rooted
#  * Path format is <DIR><tab><FileMatches> passed to robocopy as: robocopy <DIR> <staging> <FileMatches> <switches>
#

# Basic msbuild executable and config file
public\ext\tools\x86\managed\urt\v3.5	MsBuild.exe*

# Tasks and loggers used during unpack execution
public\ext\tools	Microsoft.Build.Common.Tasks.dll
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\automation\v2\.README.txt ===
#
#  CoreXT Build Automation Scripts - v2
#
#  [zackrun][roborr] - 2008
#

http://sharepoint/sites/corext/LivingDocs/BuildAutomationV2

@ Overview @
The original build scripts at tools\build\automation do a fine job of running a build, but
they have existed as batch scripts since March of 2001.  Since that time, the batch script
has been slowly evolving to react to new infrastructure and new team requirements.  This
evolution has left behind many undocumented or poorly understood features that continue to
be maintained because "someone might be using them".  This backward compatability requirement
is crippling to shared advances.  Additionally, the contribution from many sources has led
to a number of styles, and the addition of team-specific features that couldn't be easily
added into the corext extensibility model.

@ Goals @
The goal of the v2 rewrite is to start with a simple and fresh state and a renewed focus on
supporting important shared functionality while leaving teams free to add their own actions
outside of these core libraries and scripts.  Additionally, the style of shared updates must
be standardized to help delay the trend toward entropy and increased maintenance and risk.

  * Provide a core of functionality for fundamental build operations
      * Build a specific type or architecture
      * Save results
      * Save logs
      * Email
  * Support for multiple build scenarios including change testing
      * Official lab execution
      * Ability to test changes, including scripts themselves, without checkin
      * Local execution
  * Create an extensible infrastructure
      * Individual teams should be able to augment or override existing actions
      * Team additions should be physically separate from corext infrastructure for reflect
  * Fail on Failure.  Too many script 'breaks' go unnoticed or take too much investigation.

@ Technology @
Batch will still be used to wrap the new automation, to keep the launch dependencies small
and well understood.  This launch layer will be minimized and used primarily as a setup and
transport service between systems (such as between the BuildTracker system and the build)

MsBuild will be the primary automation driver.  There is a definite need for a workflow
management system when dealing with build action ordering and extensibility.  As an internal
technology we are betting on to eventually build all our products, MsBuild is the obvious
engine of choice.  As an externally shipping dependency and workflow engine, it also has
more support and third party extensions than would be expected with any internal tool.

@ Style Guide @

Batch:
  * Four spaces used in place of tabs, and used for all indenting
  * Keyword all-caps: FOR /F "delims=" %%I IN ('some command') DO (CALL SET foo=bar)
  * Inline comments preceeded with "@REM -- "
  * CALL :Subroutine is preferred over GOTO jumping
  * Subroutine separation with dividers and comments as shown at the end of this section
  * See more at http://sharepoint/sites/corext/LivingDocs/BatchPrimer.aspx
  * The following Subroutines should be in every script and used for all top-level exits
      * Exits from subroutines may GOTO :EOF

--begin common batch--
  @REM -----------------------------------------------------------------------------
  @REM -- SetError <reason>
  :SetError
  SET _err=1
  IF NOT "%~1"=="" ECHO %~1
  EXIT /B 1

  @REM -----------------------------------------------------------------------------
  @REM -- Exit
  :SetError
  IF "%_err%"=="" SET _err=0
  EXIT /B %_err%
--end common batch--

MsBuild:
  * Four spaces used in place of tabs, and used for all indenting
  * Start and end comment markers should be on their own line except for single-line comments
  * The first node attribute should be on the same line as the node.
  * If multiple attributes run outside ~80 cols, all beyond the first should be on separate
    lines, aligning with the first attribute on the node line.
  * All targets 'Foo' need to have a DependsOnTargets '$(FooDependsOn)'
  * Leave an empty line after the opening <Target> and before the closing </Target>
  * Use a 'Condition' on a Target to control execution and not a Condition on the Property that
    adds it to the sequence.  This way, detailed trace tells why something did or did not run
  * Every target must declare inputs/outputs in the standard format below.  This is so
    the docs\XmlDocExtractor tool can parse and organize the build scripts.

--begin common msbuild--
    <!-- 
      ============================================================
      ** TARGET DESCRIPTION
      ** [IN]
      ** $(InputProperty)  : PropertyDescription
      ** @(InputItem)      : Aligned Colon delimiter - ItemDescription
      **   %(ItemMetadata) : Aligned Colon delimiter - MetadataDescription
      ** 
      ** [OUT]
      ** $(OutputProperty) : PropertyDescription
      ** @(OutputItem)     : ItemDescription
      **   %(ItemMetadata) : MetadataDescription
    -->
--end common msbuild--
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\buildtracker\jobs.xml ===
<?xml version='1.0' encoding='utf-8' ?>
<Jobs>
  <Job>
    <Name>Buddy Build - Debug Only</Name>
    <Description>Debug only buddy build</Description>
    <Type>Build</Type>
    <Priority>Buddy</Priority>
    <UrgentDefault>True</UrgentDefault>
    <Concurrent>True</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Parameters>
      <Parameter>
        <Name>bldRequestType</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>BUDDY</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bbpackPath</Name>
        <Type>String</Type>
        <Description>UNC path to bbpack.  *Note bbpack must be on a public share.</Description>
      </Parameter>
      <Parameter>
        <Name>ignoreSyncResolve</Name>
        <Type>DropDownList</Type>
        <Description>If Must Sync/Resolve errors occur unpacking bbpack, ignore and continue.</Description>
        <Values>
          <Value>
            <Value>False</Value>
          </Value>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bldMailTo</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to receive mail. *Requester is mailed automatically.</Description>
      </Parameter>
      <Parameter>
        <Name>bldMailCC</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to be cc'd on build mails.</Description>
      </Parameter>
      <Parameter>
        <Name>dropPath</Name>
        <Type>String</Type>
        <Description>Share to which the binaries will be dropped.</Description>
        <Required>True</Required>
      </Parameter>
      <Parameter>
        <Name>dropSources</Name>
        <Type>DropDownList</Type>
        <Description>Enable/disable dropping of sources</Description>
        <Values>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>True</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>sourcePath</Name>
        <Type>String</Type>
        <Description>Share to which the sources will be dropped</Description>
      </Parameter>
      <Parameter>
        <Name>dropSymbols</Name>
        <Type>DropDownList</Type>
        <Description>Enable/disable dropping of symbols</Description>
        <Values>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>False</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>indexSymbols</Name>
        <Type>DropDownList</Type>
        <Description>Enable/disable indexing of dropped sources (requires project setup to support this)</Description>
        <Values>
          <Value>
            <Value>True</Value>
          </Value>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
    </Parameters>
    <Legs>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Description>build debug</Description>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg debug</Parameters>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>9</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Buddy Build - Retail and Debug</Name>
    <Description>Retail and debug buddy build</Description>
    <Type>Build</Type>
    <Priority>Buddy</Priority>
    <UrgentDefault>True</UrgentDefault>
    <Concurrent>True</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Parameters>
      <Parameter>
        <Name>bldRequestType</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>BUDDY</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bbpackPath</Name>
        <Type>String</Type>
        <Description>UNC path to bbpack.  *Note bbpack must be on a public share.</Description>
      </Parameter>
      <Parameter>
        <Name>ignoreSyncResolve</Name>
        <Type>DropDownList</Type>
        <Description>If Must Sync/Resolve errors occur unpacking bbpack, ignore and continue.</Description>
        <Values>
          <Value>
            <Value>False</Value>
          </Value>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bldMailTo</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to receive mail. *Requester is mailed automatically.</Description>
      </Parameter>
      <Parameter>
        <Name>bldMailCC</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to be cc'd on build mails.</Description>
      </Parameter>
      <Parameter>
        <Name>dropPath</Name>
        <Type>String</Type>
        <Description>Share to which the binaries will be dropped.</Description>
        <Required>True</Required>
      </Parameter>
      <Parameter>
        <Name>dropSources</Name>
        <Type>DropDownList</Type>
        <Description>Enable/disable dropping of sources</Description>
        <Values>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>True</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>sourcePath</Name>
        <Type>String</Type>
        <Description>Share to which the sources will be dropped</Description>
      </Parameter>
      <Parameter>
        <Name>dropSymbols</Name>
        <Type>DropDownList</Type>
        <Description>Enable/disable dropping of symbols</Description>
        <Values>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>False</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>indexSymbols</Name>
        <Type>DropDownList</Type>
        <Description>Enable/disable indexing of dropped sources (requires project setup to support this)</Description>
        <Values>
          <Value>
            <Value>True</Value>
          </Value>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
    </Parameters>
    <Legs>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Description>build debug</Description>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg debug</Parameters>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg retail</Parameters>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>9</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Distributed Dot</Name>
    <Description>Dot build with debug and retail in parallel.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg start</Parameters>
      </Leg>
      <Leg>
        <Name>sync</Name>
        <Type>Sync</Type>
        <Priority>0</Priority>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg source</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg retail</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg debug</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Distributed Full</Name>
    <Description>Full build with debug and retail in parallel.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg start</Parameters>
      </Leg>
      <Leg>
        <Name>sync</Name>
        <Type>Sync</Type>
        <Priority>0</Priority>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg retail</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg debug</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Distributed Matrix</Name>
    <Description>Full matrix (x86 amd64 ia64) x (debug retail cover)</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg start</Parameters>
      </Leg>
      <Leg>
        <Name>sync</Name>
        <Type>Sync</Type>
        <Priority>0</Priority>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail-x86</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build retail arch x86</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug-x86</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build debug arch x86</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>cover-x86</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build cover arch x86</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail-ia64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build retail arch ia64</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug-ia64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build debug arch ia64</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>cover-ia64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build cover arch ia64</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail-amd64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build retail arch amd64</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug-amd64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build debug arch amd64</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>cover-amd64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build cover arch amd64</Parameters>
        <Dependencies>
          <Dependency>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Dot</Name>
    <Description>Dot build.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>dot</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Full</Name>
    <Description>Full build.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>full</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
</Jobs>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\buildtracker\jobs_bt26.xml ===
<?xml version='1.0' encoding='ISO-8859-1' ?>
<Jobs>
  <Job>
    <Name>Buddy Build - Debug Only</Name>
    <Description>Debug only buddy build</Description>
    <Type>Build</Type>
    <Priority>Buddy</Priority>
    <UrgentDefault>True</UrgentDefault>
    <Concurrent>True</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Parameters>
      <Parameter>
        <Name>bldRequestType</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>BUDDY</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bbpackPath</Name>
        <Type>File</Type>
        <Description>UNC path to bbpack.  *Note bbpack must be on a public share.</Description>
      </Parameter>
      <Parameter>
        <Name>ignoreSyncResolve</Name>
        <Type>Choice</Type>
        <Description>If Must Sync/Resolve errors occur unpacking bbpack, ignore and continue.</Description>
        <Values>
          <Value>
            <Value>False</Value>
          </Value>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bldMailTo</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to receive mail. *Requester is mailed automatically.</Description>
      </Parameter>
      <Parameter>
        <Name>bldMailCC</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to be cc'd on build mails.</Description>
      </Parameter>
      <Parameter>
        <Name>dropPath</Name>
        <Type>Directory</Type>
        <Description>Share to which the binaries will be dropped.</Description>
        <Required>True</Required>
      </Parameter>
      <Parameter>
        <Name>dropSources</Name>
        <Type>Choice</Type>
        <Description>Enable/disable dropping of sources</Description>
        <Values>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>True</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>sourcePath</Name>
        <Type>Directory</Type>
        <Description>Share to which the sources will be dropped</Description>
      </Parameter>
      <Parameter>
        <Name>dropSymbols</Name>
        <Type>Choice</Type>
        <Description>Enable/disable dropping of symbols</Description>
        <Checked>True</Checked>
        <Values>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>False</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>indexSymbols</Name>
        <Type>Choice</Type>
        <Description>Enable/disable indexing of dropped sources (requires project setup to support this)</Description>
        <Checked>True</Checked>
        <Values>
          <Value>
            <Value>True</Value>
          </Value>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
    </Parameters>
    <Legs>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Description>build debug</Description>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg debug</Parameters>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>9</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Buddy Build - Retail and Debug</Name>
    <Description>Retail and debug buddy build</Description>
    <Type>Build</Type>
    <Priority>Buddy</Priority>
    <UrgentDefault>True</UrgentDefault>
    <Concurrent>True</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Parameters>
      <Parameter>
        <Name>bldRequestType</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>BUDDY</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bbpackPath</Name>
        <Type>File</Type>
        <Description>UNC path to bbpack.  *Note bbpack must be on a public share.</Description>
      </Parameter>
      <Parameter>
        <Name>ignoreSyncResolve</Name>
        <Type>Choice</Type>
        <Description>If Must Sync/Resolve errors occur unpacking bbpack, ignore and continue.</Description>
        <Values>
          <Value>
            <Value>False</Value>
          </Value>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>bldMailTo</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to receive mail. *Requester is mailed automatically.</Description>
      </Parameter>
      <Parameter>
        <Name>bldMailCC</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list of users to be cc'd on build mails.</Description>
      </Parameter>
      <Parameter>
        <Name>dropPath</Name>
        <Type>Directory</Type>
        <Description>Share to which the binaries will be dropped.</Description>
        <Required>True</Required>
      </Parameter>
      <Parameter>
        <Name>dropSources</Name>
        <Type>Choice</Type>
        <Description>Enable/disable dropping of sources</Description>
        <Values>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>True</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>sourcePath</Name>
        <Type>Directory</Type>
        <Description>Share to which the sources will be dropped</Description>
      </Parameter>
      <Parameter>
        <Name>dropSymbols</Name>
        <Type>Choice</Type>
        <Description>Enable/disable dropping of symbols</Description>
        <Checked>True</Checked>
        <Values>
          <Value>
            <Value>True</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>False</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>indexSymbols</Name>
        <Type>Choice</Type>
        <Description>Enable/disable indexing of dropped sources (requires project setup to support this)</Description>
        <Checked>True</Checked>
        <Values>
          <Value>
            <Value>True</Value>
          </Value>
          <Value>
            <Value>False</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
    </Parameters>
    <Legs>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Description>build debug</Description>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg debug</Parameters>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg retail</Parameters>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>9</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>9</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Distributed Dot</Name>
    <Description>Dot build with debug and retail in parallel.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg start</Parameters>
      </Leg>
      <Leg>
        <Name>sync</Name>
        <Type>Sync</Type>
        <Priority>0</Priority>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>start</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg source</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg retail</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg debug</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Distributed Full</Name>
    <Description>Full build with debug and retail in parallel.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg start</Parameters>
      </Leg>
      <Leg>
        <Name>sync</Name>
        <Type>Sync</Type>
        <Priority>0</Priority>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>start</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg retail</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg debug</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Distributed Matrix</Name>
    <Description>Full matrix (x86 amd64 ia64) x (debug retail cover)</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg start</Parameters>
      </Leg>
      <Leg>
        <Name>sync</Name>
        <Type>Sync</Type>
        <Priority>0</Priority>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>start</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>source</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg source</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail-x86</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build retail arch x86</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug-x86</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build debug arch x86</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>cover-x86</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build cover arch x86</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail-ia64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build retail arch ia64</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug-ia64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build debug arch ia64</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>cover-ia64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build cover arch ia64</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail-amd64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build retail arch amd64</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>debug-amd64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build debug arch amd64</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>cover-amd64</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg build cover arch amd64</Parameters>
        <Dependencies>
          <Dependency>
            <Type>Leg</Type>
            <Name>sync</Name>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>leg end</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Dot</Name>
    <Description>Dot build.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>dot</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
        <Parameters>dot</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Full</Name>
    <Description>Full build.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <UrgentDefault>False</UrgentDefault>
    <Concurrent>False</Concurrent>
    <AllowSync>False</AllowSync>
    <Sync>True</Sync>
    <Legs>
      <Leg>
        <Name>full</Name>
        <Type>Command</Type>
        <Priority>0</Priority>
        <Command>tools\build\automation\BldTree.cmd</Command>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
</Jobs>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\buildtracker\jobs_v2.xml ===
<?xml version='1.0' encoding='UTF-8' ?>
<Jobs>
  <Job>
    <Name>Buddy Build [v2]</Name>
    <Type>Build</Type>
    <Priority>Buddy</Priority>
    <Concurrent>True</Concurrent>
    <RunLegsOnSameMachine>False</RunLegsOnSameMachine>
    <AllowSync>True</AllowSync>
    <Sync>True</Sync>
    <Parameters>
      <Parameter>
        <Name>BuildOptions</Name>
        <Type>String</Type>
        <Description>optional flags/dirs turned on across the build</Description>
        <ReadOnly>True</ReadOnly>
      </Parameter>
      <Parameter>
        <Name>DropPath</Name>
        <Type>String</Type>
        <Required>True</Required>
        <Values>
          <Value>
            <Value>\\YourBuddyDrop</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>ExternalUnpackDrop</Name>
        <Type>String</Type>
        <Description>Pull launch scripts from a public mirror of the build\automation\unpack folder instead of using the checked-in versions (for testing script updates)</Description>
      </Parameter>
      <Parameter>
        <Name>IsOfficialBuild</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>false</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>LaunchEnvironment</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>BuildTracker</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>LaunchParams</Name>
        <Type>String</Type>
        <Description>Add quoted "name=value" pairs to set these values into the environment after the parameters parsed from the script commandline</Description>
      </Parameter>
      <Parameter>
        <Name>LaunchVerbosity</Name>
        <Type>DropDownList</Type>
        <Values>
          <Value>
            <Value>detailed</Value>
          </Value>
          <Value>
            <Value>diagnostic</Value>
          </Value>
          <Value>
            <Value>minimal</Value>
          </Value>
          <Value>
            <Value>normal</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>quiet</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>MailCC</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list for sending build results (CC)</Description>
        <Values>
          <Value>
            <Value>none</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>MailTo</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list for sending build results (Requester is mailed automatically)</Description>
        <Values>
          <Value>
            <Value>none</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>PackPath</Name>
        <Type>String</Type>
        <Description>UNC path to pack (*.cmd|*.bat|*.jj|*.dpk). Must be a public share.</Description>
      </Parameter>
    </Parameters>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>(start) do not roll the version</Description>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"LaunchProject=BuildStart.proj"</Parameters>
        <PublishedParameters>
          <PublishedParameter>
            <Name>BuildVersion</Name>
            <TargetName>BuildVersion</TargetName>
            <Out>True</Out>
          </PublishedParameter>
          <PublishedParameter>
            <Name>DropLocation</Name>
            <TargetName>DropLocation</TargetName>
            <Out>True</Out>
          </PublishedParameter>
          <PublishedParameter>
            <Name>DropLocationSource</Name>
            <TargetName>DropLocationSource</TargetName>
            <Out>True</Out>
          </PublishedParameter>
        </PublishedParameters>
      </Leg>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>Build debug x86</Description>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"BuildType=debug" "BuildArchitecture=x86"</Parameters>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
            <DependencyType>OnSuccess</DependencyType>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>Build retail x86</Description>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"BuildType=retail" "BuildArchitecture=x86"</Parameters>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
            <DependencyType>OnSuccess</DependencyType>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"LaunchProject=BuildFinal.proj"</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"LaunchProject=BuildFinal.proj"</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
  <Job>
    <Name>Official Daily Build [v2]</Name>
    <Description>Official Build increments the buildnumber and drops all files.</Description>
    <Type>Build</Type>
    <Priority>Official</Priority>
    <Concurrent>False</Concurrent>
    <RunLegsOnSameMachine>False</RunLegsOnSameMachine>
    <AllowSync>True</AllowSync>
    <Sync>True</Sync>
    <Parameters>
      <Parameter>
        <Name>BuildOptions</Name>
        <Type>String</Type>
        <Description>optional flags/dirs turned on across the build</Description>
        <ReadOnly>True</ReadOnly>
      </Parameter>
      <Parameter>
        <Name>ENABLE_PRS_DELAYSIGN</Name>
        <Type>DropDownList</Type>
        <Values>
          <Value>
            <Value>0</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>1</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>IsOfficialBuild</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>true</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>LaunchEnvironment</Name>
        <Type>String</Type>
        <Required>True</Required>
        <ReadOnly>True</ReadOnly>
        <Values>
          <Value>
            <Value>BuildTracker</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>LaunchParams</Name>
        <Type>String</Type>
        <Description>Add quoted "name=value" pairs to set these values into the environment after the parameters parsed from the script commandline</Description>
      </Parameter>
      <Parameter>
        <Name>LaunchVerbosity</Name>
        <Type>DropDownList</Type>
        <Values>
          <Value>
            <Value>detailed</Value>
          </Value>
          <Value>
            <Value>diagnostic</Value>
          </Value>
          <Value>
            <Value>minimal</Value>
          </Value>
          <Value>
            <Value>normal</Value>
            <Default>True</Default>
          </Value>
          <Value>
            <Value>quiet</Value>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>MailCC</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list for sending build results (CC) </Description>
        <Values>
          <Value>
            <Value>none</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
      <Parameter>
        <Name>MailTo</Name>
        <Type>String</Type>
        <Description>semi-colon delimited list for sending build results (Requester is mailed automatically) </Description>
        <Values>
          <Value>
            <Value>corext-r</Value>
            <Default>True</Default>
          </Value>
        </Values>
      </Parameter>
    </Parameters>
    <Legs>
      <Leg>
        <Name>start</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>(start)roll the version</Description>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"LaunchProject=BuildStart.proj"</Parameters>
        <PublishedParameters>
          <PublishedParameter>
            <Name>BuildVersion</Name>
            <TargetName>BuildVersion</TargetName>
            <Out>True</Out>
          </PublishedParameter>
          <PublishedParameter>
            <Name>DropLocation</Name>
            <TargetName>DropLocation</TargetName>
            <Out>True</Out>
          </PublishedParameter>
          <PublishedParameter>
            <Name>DropLocationSource</Name>
            <TargetName>DropLocationSource</TargetName>
            <Out>True</Out>
          </PublishedParameter>
        </PublishedParameters>
      </Leg>
      <Leg>
        <Name>debug</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>Build debug x86</Description>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"BuildType=debug" "BuildArchitecture=x86"</Parameters>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
            <DependencyType>OnSuccess</DependencyType>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>retail</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>Build retail x86</Description>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"BuildType=retail" "BuildArchitecture=x86"</Parameters>
        <Dependencies>
          <Dependency>
            <Name>start</Name>
            <DependencyType>OnSuccess</DependencyType>
          </Dependency>
        </Dependencies>
      </Leg>
      <Leg>
        <Name>error</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"LaunchProject=BuildFinal.proj"</Parameters>
      </Leg>
      <Leg>
        <Name>success</Name>
        <Type>Command</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Priority>0</Priority>
        <Command>tools\build\automation\v2\launch.cmd</Command>
        <Parameters>"LaunchProject=BuildFinal.proj"</Parameters>
      </Leg>
      <Leg>
        <Name>complete</Name>
        <Type>Complete</Type>
        <ReportFailStatus>True</ReportFailStatus>
        <DependencyLogic>And</DependencyLogic>
        <Description>Created by system.</Description>
        <Priority>0</Priority>
      </Leg>
    </Legs>
    <AutoDiscoverBuild>True</AutoDiscoverBuild>
    <SaveLogs>True</SaveLogs>
  </Job>
</Jobs>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\build\options\envkeep.txt ===
build\aliases\user.pub

# generated on enlistment open to allow compiled-in %INETROOT% references
build\environment\Environment.cs

# copied from myenv.cmd to allow 'sd sync' of these files
build\path1st\sd.cmd
public\ext\tools\amd64\sd.exe
public\ext\tools\ia64\sd.exe
public\ext\tools\x86\sd.exe
tools\path1st\sd.cmd

build\preenv.cmd
build\userenv.cmd
build\userpreenv.cmd
OACRTemp
public\ext\tools\amd64\managed
public\ext\tools\ia64\managed
public\ext\tools\x86\managed
tools\build\automation\automation.log
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\CheckinWizard\readme.txt ===
CheckinWizard - Extensible/configurable checkin automation tool

For more information, see the Toolbox entries at:

http://toolbox/details/details.aspx?ToolID=22145


and the related development environment...


http://toolbox/details/details.aspx?ToolID=22141


For usage questions or help configuring or creating extensions, use the corext alias or micahk.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\CheckinWizard\Config\config.xml ===
<?xml version="1.0" encoding="utf-8" ?>

<!-- Summary:  This is a the main configuration file for AutoProcess which specifies all 
               the components which plug into it and their settings.  To reduce the size of
               this file, it may be broken up into multiple smaller XML files which can be 
               included by use of the <?Include <filename>?> processing instruction -->

<CoreData>
    <!-- <Overrides: the overrides rewrite parts of the XML config file after it has been loaded.
             This saves duplicating the info all over the place or having to place the info
             off in some strange place. This is good to use when you have multiple similar 
             configurations >
             <Override: (may be multiple)
                action - "overwrite" overwrites (or adds if not there) the specified attribute
                         "remove" removes the specified element/attribute
                         "addelement" adds the inner element at the location specified
                xpath - the path (from the root of the config file) to operate on
                [attribute] - only used with "overwrite" action.  Specifies the attribute to
                              overwrite.  To modify the text of the selected node, omit the
                              attribute name.
                [<text>] - only used with "overwrite" action.  Specifies the new value to use. >
            </Override>
        </Overrides>
    -->
    <Overrides>
    </Overrides>

    <!-- Config is the main configuration node (called GlobalConfig in the code) -->
    <Config>
        <?Include Application.Xml?>
        
        <!-- Custom is the container for all global config related to specific components -->
        <Custom>
            <?Include BugDatabase.Xml?>
            <?Include FormData.Xml?>
            <?Include SourceControl.Xml?>
            
            <!-- Mail: configuration for the mail component
                    transform - path to a file which contains an XML transform to apply against the SharedData
                                in order to produce an HTML mail message
                    smtp - the SMTP server to use (for smartmail)
                    defaultDomain - the email domain to apply to all bare email names in the message
                    [auth] - default is sspi.  Authorization type to use (for smartmail). 
                             For anonymous mail use "false".
                    [useOutlook] - default is false.  Whether to use Outlook by default to send mail
                    [enableOutlook] - default is false.  Whether to allow user to choose to send mail via
                                      Outlook.
                    [noMail] - default is false.  Whether to send mail
                    [enableNoMail] - default is false.  Whether to allow user to choose to not send mail -->
            <Mail transform="CheckinMail.xslt" 
                  smtp="smtphost.redmond.corp.microsoft.com" 
                  defaultDomain="microsoft.com" 
                  auth="sspi" 
                  useOutlook="false" 
                  enableOutlook="true"
                  noMail="false" 
                  enableNoMail="false">

            <!-- Viewers: configuration used within the checkin mail transform to build links to
                          view the change list or bugs
                    htaPath - path to a web server directory which has the appropriate viewer HTAs 
                              available (note there isn't any real need to modify these as the 
                              viewers should work for any depot or PS db)
                    toolPath - UNC path to a place that has tools that can be run by the HTAs.  -->
                  <Viewers buildTracker="http://buildlab/BuildTracker"
                           toolPath="\\TKFilToolBox\Tools\22141\AutoProcess\Script\bin" />
            </Mail>
        </Custom>

        <!-- ComponentRunOrder: controls the components that get run and the order they get run in
            <Component:  (may be multiple of these) provides info for a component to be loaded and run.  May
                         contain arbitrary additional attributes and elements which are acccessed through the 
                         LocalConfig in component code.
                id - the key used to differentiate this component from others.  It is used in calls to the
                     controller which are meant to affect another component.
                [hasUI] - default is false.  Used by Wizard to determine whether next/previous buttons should
                          be enabled or not.  >
                <Object: provide dll/class information so that the an object which implements IComponent can
                         be loaded.
                    dll - The Dll to load the object from.  Path is relative to the path of the main EXE.
                    class - The fully qualified name of the class to be loaded from the Dll.  The class must
                            implement the IComponent interface. >
                </Object>
            </Component>
        -->
        <ComponentRunOrder>
            <Component id="LoadSC" caption="Initialize file list">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.InitSC" />
            </Component>
            <Component id="EditSC" caption="Choose files" hasUI="true">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.EditSC" />
            </Component>
            <Component id="CheckSC" caption="Verify file selection">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.CheckSC" />
            </Component>
            <Component id="InitCheckinFields" caption="Initialize checkin details">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.OtherUI.InitCheckinFields" />
            </Component>
            <Component id="CheckinFields" caption="Checkin details" hasUI="true">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.OtherUI.CheckinFields" />
            </Component>
            <Component id="InitQueryData" caption="Initialize PS query">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.BugDatabase.InitQueryData" />
            </Component>
            <Component id="QueryBugs" caption="Choose bugs" hasUI="true">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.BugDatabase.QueryBugs" />
            </Component>
            <Component id="EditBugs" hasUI="true">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.BugDatabase.EditBug" />
            </Component>
            <Component id="LoadMail" caption="Initialize mail">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.Mail.InitMail" />
            </Component>
            <Component id="EditMail" caption="Checkin mail" hasUI="true">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.Mail.EditMail" />
            </Component>
            <Component id="SaveNewBugs" caption="Create new bugs" saveNew="true">
                <!-- [saveNew] - default is false.  Controls whether the SaveBugs component only attempts
                                 to create new bugs or if it trys to save everything all at once. -->
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.BugDatabase.SaveBugs" />
            </Component>
            <Component id="SubmitSC" caption="Submit changes">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.Submit" />
            </Component>
            <Component id="SaveBugs" caption="Update bugs">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.BugDatabase.SaveBugs" />
            </Component>
            <Component id="SendMail" caption="Send mail">
                <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.Mail.SendMail" />
            </Component>
        </ComponentRunOrder>
    </Config>

    <!-- Component data section.  An Element is created under here for each Component when it runs and is 
         accessible with the LocalData variable.  A component might use this as a way to cache calculated 
         data or settings which are not applicable to other components -->
    <ComponentData></ComponentData>

    <!-- Shared data section.  Components can share data under here -->
    <SharedData>
        <Defaults>
            <Default name="OverrideTo">$(Reviewer);$(Tester)</Default>
        </Defaults>
    </SharedData>
</CoreData>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\downlevel\config\symarch.ini ===
BuildLabPhone=None
ContactPeople=dexxbld
Project=Xonline
StatusMail=dexxbld
UserName=xonblder
SubmitToArchive=pdb
#Build=08.02.0113.01
#Build=08.02.0113.03
#Build=08.02.0113.04
#Build=08.02.0113.05
#Build=08.02.0113.06
#Build=08.02.0113.06
#Build=08.02.0113.06
#Build=08.02.0113.06
#Build=08.02.0113.06
#Build=08.02.0113.06
#Build=08.02.0113.07
#Build=08.02.0113.08
#Build=08.02.0113.09
#Build=08.02.0113.06
#Build=08.02.0113.10
#Build=08.02.0113.10
#Build=08.02.0113.11
#Build=08.02.0113.12
Build=08.02.0113.13
ProductGroup=EDGE
ProductName=Xonline_Summer09 
Release=RTW
SubmitToInternet=no
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\CheckinWizard\Config\SourceControl.xml ===
<!-- SourceControl is the configuration node for the SourceControl system in use -->      
<SourceControl transform="SDDescription.xslt"
    syncCommand="sd.exe sync -i"  resolveCommand="sd.exe resolve"
    enableDiffs="true" differ="windiff.exe"
    enableEdits="true" editor="notepad.exe"
    enableHistory="true" historian="sdv.exe">
    <!-- transform - path to an XML transform file used against the SharedData to generate the
                        description which will be stored in Source Depot 
         syncCommand - command used to sync files 
         resolveCommand - command used to resolve files 
         enableDiffs - show "Diff Files" button on file selection screen and context menu
         differ - name of diffing program (may include path with environment variables)
         enableEdits - show "Edit File" context menu item
         editor - name of (text) editor (may include path with environment variables)
         enableHistory - show "History" context menu item
         historian - name of history viewer (may include path with environment variables) -->
    
    <!-- ConnectInfo: connection info for connecting to SourceDepot
            [auto] - default is false.  Allow SD to figure out for itself how to connect based on
                        the current directory and various environment settings.  -->
    <ConnectInfo auto="true" />

    <!-- Validation: validation checks to be performed on the selected files -->
    <Validation>
	<!-- Check: definition of a validation check 
            [id] - name of the check... must be unique
            [enabled] - default is false.  Whether the check is enabled or not -->
        <Check id="DeletedFileCheck" enabled="true">
            <!-- Object: identifying info to create the object which does the check
                 [dll] - name of the dll the object is in
                 [class] - name of the class in that dll that the object is in -->
            <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.Checks.DeletedFileCheck" />
        </Check>
        <Check id="FileReadyCheck" enabled="true" allowUnsyncedFiles="false">
    <!--    [allowUnsyncedFiles] - default is false.  Whether to allow the checkin to proceed even 
                                though there are some files needing to be synced/merged. -->
            <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.Checks.FileReadyCheck" />
        </Check>
        <Check id="MergeMarkerCheck" enabled="true">
            <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.Checks.MergeMarkerCheck" />
        </Check>
        <Check id="MissingFileCheck" enabled="true">
            <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.Checks.MissingFileCheck" />
        </Check>
        <Check id="UnchangedFileCheck" enabled="true">
            <Object dll="CoreComp.dll" class="Microsoft.AutoProcess.Component.SourceControl.Checks.UnchangedFileCheck" />
        </Check>
    </Validation>
</SourceControl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\Malevich\ReadMe.txt ===
This directory contains binaries belonging to the Malevich code review tool
(http://malevich.codeplex.com)

Malevich was approved by LCA only for use by the Xbox Shell and Platform Team 
for code review purposes on 12/3/2009.

If you would like to make use of Malevich for your own team, please visit
http://malevich.codeplex.com for more information, and seek approval from 
LCA for its use prior to putting it in place.

For information on Malevich use by the Shell and Platform team, please contact
JWale.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\CheckinWizard\Config\application.xml ===
<!-- Application.xml - main app settings, result codes, and strings -->

<Application singleInstance="true" noWizard="false" unattended="false">
    <!-- singleInstance - controls whether more than one instance of the app (with the same Title)
                          can be run at the same time.
         noWizard - suppress the wizard UI (i.e., completely console app)
         unattended - don't ask the user questions (lab use) -->
    <Title>Checkin Wizard</Title>
    
    <!-- Enable crash recovery to have AutoProcess save the current state as the user progresses through
         forms.  Should the app crash or otherwise stop abnormally, the user will be able to recover their
         work the next time the app runs.  Specify a path to store the recovery files at. -->
    <CrashRecovery enabled="true" path="%TEMP%\CheckinWizard" />
    
    <!-- Give a path for all temp files created by the process -->
    <TemporaryFiles path="%TEMP%\CheckinWizard" />
    
    <!-- Enable logging and specify a full path to the log -->
    <LogFile enabled="true" path="%TEMP%\CheckinWizard\CheckinWizard.log" />

    <!-- Possible application result codes (strings) and what process exit codes they will be converted to -->
    <ResultCodes displayAtExit="true">
        <!-- displayAtExit - Whether to display the error string upon exiting the app or not -->
        
        <!-- ResultCode:
                name - The textual name used within the code to identify the result
                value - The numerical value returned by the process if it ends in this result
                <text> - The text to show to the user if the process ends in this result -->
        <ResultCode name="Success"            value="0">The checkin completed successfully.</ResultCode>
        <ResultCode name="Usage"              value="1">Usage error.</ResultCode>
        <ResultCode name="GenericFailure"     value="2">The checkin failed.</ResultCode>
        <ResultCode name="UnhandledException" value="3">Unexpected exception.</ResultCode>
        <ResultCode name="Cancel"             value="4">The checkin was not completed.</ResultCode>
        <ResultCode name="SingleInstance"     value="5">Only one checkin can be processed at a time in a user's session.

Please complete the first checkin and retry.</ResultCode>
        <ResultCode name="FilesOutOfSync"     value="10">Some files need to be synced/resolved.</ResultCode>

        <!-- Warning result codes.  By convention, greater than 200.  Note that PERL has problems with result 
             codes over 255 -->
        <ResultCode name="Hibernate"          value="200">Checkin recovery information has been saved.</ResultCode>
        <ResultCode name="BugNotSaved"        value="201">Some bugs could not be saved.</ResultCode>
        <ResultCode name="MailNotSent"        value="202">Mail could not be sent.</ResultCode>
    </ResultCodes>
    <StyleCopReview>
		<CommandPath>C:\Program Files\Microsoft StyleCop 2003\</CommandPath>
		<Command>StyleCopCMD</Command>
		<StyleCopExceptionFileName>StyleCopViolations.xml</StyleCopExceptionFileName>
		<StyleCopXPathExpression>StyleCopViolations/Violation</StyleCopXPathExpression>
		<NumberOfFiles>10</NumberOfFiles>
    </StyleCopReview>
</Application>

<!-- StringTable:  (may specify multiple of these)
    name - name of the string table as used in calls to LookupString
    <String:  (may specify multiple of these)
        name - name of this string.  Must be unique within this string table.  Used as second
               parameter to LookupString
        <text> - the text of the message.  May contain formatting characters if the code is
                 expecting them (i.e., using FormatString)>
    </String>  -->
     
<!-- Application string table - generic strings used by the core app -->
<StringTable name="Application">
    <String name="Recoverable">Recovery data exists.  Would you like to recover from the previous run?</String>
</StringTable>

<!-- Wizard string table - strings used by the wizard UI -->
<StringTable name="Wizard">
    <String name="CancelWithRecovery">Your work up until this page has been saved.  Would you like to keep this?

Yes:	Save work up to current page
No:	Close and remove work
Cancel:	Do not close</String>
    <String name="CancelNoRecovery">Are you sure you want to Cancel?</String>
    <String name="UndoPage">Are you sure you want to undo all changes made to this page?</String>
</StringTable>

<!-- Bugs string table - strings used in the Bug UI -->
<StringTable name="Bugs">
    <String name="NoBugSelected">Please select one or more bugs before continuing.</String>
    <String name="ResolvingNewBug">You have chosen to create a new bug entry and resolve it as well.  Choose 'OK' to continue or 'Cancel' to change your options before continuing.</String>
    <String name="SingleBugRequired">You must select a single bug.  Data from this checkin will be stored in the Triage entry associated with this bug.</String>
    <String name="InvalidBugId">The specified bug ID is not valid.  Please enter a valid bug number greater than zero.</String>
    <String name="BugNotFound">The bug was not found in the database.  Please enter a valid number.</String>
    <String name="BugNotActive">The bug specified is not an active bug.  Please choose an active bug.</String>
    <String name="StatusQuerying">Querying Product Studio...</String>
    <String name="StatusEnumerating">Retrieving query results...</String>
    <String name="NewBugTitle">Create a new bug with this checkin</String>
    <String name="PreparingQuery">Preparing bug query form...</String>
    <String name="CreatedBug">Created new bug {0}</String>
    <String name="ResolvedBug">Resolved bug {0}</String>
    <String name="UpdatedBug">Updated bug {0}</String>
    <String name="CreatingBug">Creating new bug in {0}...</String>
    <String name="SavingBug">Saving changes to bug {0}...</String>
    <String name="StatusSavingBugs">Saving bug changes...</String>
    <String name="BugEditCaption">Editing bug {0}</String>
    <String name="PreparingForm">Preparing bug form...</String>
    <String name="ErrorQueryingBugs">Error querying for bugs.  The bug database may be unavailable.  (View the log at $(LogPath) for more details)
    
    Would you like to retry the query?
    </String>
    <String name="ErrorPSNotInstalled">Error querying for bugs.  ProductStudio does not appear to be installed.  (View the log at $(LogPath) for more details)</String>
    <String name="ErrorQueryingBug">Error querying for bug.  The bug database may be unavailable.  (View the log at $(LogPath) for more details)</String>
    <String name="ErrorSavingBug">Error saving bug {0}:{1}.  The bug database may be unavailable or some fields in the bug may be invalid. (View the log at $(LogPath) for more details)

Abort:	Exit the current checkin
Retry:	Try to save the bug again
Ignore:	Skip saving this bug and continue</String>
    <String name="BugAlreadyResolved">Bug {0}:{1} has already been resolved.  No updates made.</String>
    <String name="InvalidAliasDescription">Alias '{0}' in the Assigned to field is not valid.  Assigning to bug resolver for followup.
    
    {1}
    </String>
    <String name="StatusInvalidAlias">Bug {0}:{1} cannot be resolved to '{2}'.  Attempting to resolve to '{3}' instead.</String>
    <String name="StatusCannotUndoChanges">Bug {0}:{1} already saved.  Cannot undo changes.</String>
</StringTable>

<!-- Mail string table - strings used in the Mail UI -->
<StringTable name="Mail">
    <String name="NoOutlook">Outlook does not appear to be installed or is not configured correctly.  Mail will be sent through the default method instead.</String>
    <String name="GeneratingPreview">Generating preview...</String>
    <String name="ViewingPreview">Displaying preview (close browser to continue)...</String>
    <String name="PlainTitle">$(Projects)Checkin</String>
    <String name="BugTitle">$(Projects)Checkin bug #$(BugList)</String>
    <String name="NonBugTitle">$(Projects)Non bug related checkin</String>
    <String name="StatusSending">Sending checkin mail...</String>
    <String name="CheckinMailSent">Sent checkin mail to the following: {0}</String>
    <String name="ErrorPreviewFailed">Error displaying mail preview.  (View the log at $(LogPath) for more details)</String>
    <String name="ErrorSendingMail">Error sending checkin mail.  (View the log at $(LogPath) for more details)

Abort:	Exit the current checkin
Retry:	Try to send mail again
Ignore:	Skip sending mail and continue</String>
    <String name="StatusMailAlreadySent">Mail already sent.  Cannot undo.</String>
    <String name="PromptUseOutlook">Would you like to use Outlook to send your mail instead?</String>
    <String name="InvalidRecipientCharacters">The {0}: field contains invalid characters.  Valid characters are the printable ASCII characters not including the following:

:  (colon)
&quot;  (double quote)
'  (single quote)
[] (square brackets)
&gt;&lt; (greater than/less than)

Spaces may not be used within an email alias but may preceed or follow it.  Please review the expanded text below the {0}: field as the invalid characters may be from one of the variables used.  (If necessary, remove the variable and replace it with any valid parts of what it contained)</String>
</StringTable>

<!-- DetailsForm string table - strings used on the Details form -->
<StringTable name="DetailsForm">
    <String name="RequiredField">Please complete the '{0}' field.</String>
</StringTable>

<!-- SourceControl string table - strings used on the source control UI -->
<StringTable name="SourceControl">
    <String name="StatusInitializing">Preparing changelist...</String>
    <String name="StatusValidating">Verifying files...</String>
    <String name="StatusConnecting">Connecting to depot...</String>
    <String name="StatusQuerying">Querying Source Depot...</String>
    <String name="NoFilesSelected">Please select one or more files to submit before continuing.</String>
    <String name="PromptAddedFiles">The following files have already been added (by another user) and cannot be checked in:
{0}

This checkin will not succeed unless these files are removed from the change list or merged and converted to edit operations.  NOTE:  After this checkin completes, you can manually run 'sd revert' on these files.

Would you like to remove these files now?</String>
    <String name="PromptDeletedFiles">The following files have been deleted (by another user) and cannot be checked in:
{0}

This checkin will not succeed unless these files are removed from the change list.  NOTE:  After this checkin completes, you can manually run 'sd revert' on these files.

Would you like to remove these files now?</String>
    <String name="PromptRepointedFiles">The following files have suspicious mappings and may be repointed files or files left from a previous set of client mappings:
{0}

This checkin may not succeed with these files in the change list.  Repointed files can be synced back into the current branch using "sd sync -i".  For other mapping problems it will be necessary to revert the files and manually merge changes into the appropriate files.

Would you like to remove these files now?</String>
    <String name="PromptFilesNotSynced">The following files are not fully synced/resolved:
{0}

The checkin will not succeed unless all files are fully synced/resolved.

Would you like to sync/resolve these files now?</String>
    <String name="PromptFilesUnchanged">The following files have not been changed and do not need to be checked in:
{0}

This checkin will succeed even if they are left in the change list.  However, leaving them in uses extra space on the Depot and inaccurately reflects the actual files modified.  NOTE:  After this checkin completes, you can manually run 'sd revert -a' and it will revert all unchanged files.

Would you like to remove these files from the change list now?
</String>
    <String name="PromptFilesMissing">The following files cannot be found on the local machine:
{0}

This checkin will not succeed unless these files are removed from the change list or the files are created.

Would you like to remove these files now?</String>
    <String name="PromptMergeConflicts">The following files contain merge conflict markers:
{0}

This checkin would succeed even if these files are not removed from the change list.  However, this is almost certainly an error which needs to be fixed.  NOTE:  After fixing the merge conflicts, you can try this check again.

Would you like to remove these files now?</String>
    <String name="PromptNoFilesChanged">None of the selected files have been changed.  Most likely another user has already submitted these files.
    
Would you like enter the changelist number now and continue to resolve bugs and send mail?</String>
    <String name="PromptChangeList">Enter a changelist Id</String>
    <String name="ErrorInvalidChangeNumber">Invalid changelist Id.  Please specify a valid number greater than zero.</String>
    <String name="ErrorInvalidPendingChange">The changelist specified has not been submitted.  Please specify the changelist ID of a submitted changelist.</String>
    <String name="ErrorRetrievingChange">The changelist specified does not exist.  Please specify the changelist ID of a submitted changelist.</String>
    <String name="ErrorAddedFiles">The following files have already been added (by another user) and cannot be checked in:
{0}

This checkin will not succeed until these files are removed from the change list.</String>
    <String name="ErrorDeletedFiles">The following files have been deleted (by another user) and cannot be checked in:
{0}

This checkin will not succeed until these files are removed from the change list.</String>
    <String name="ErrorRepointedFiles">The following files have suspicious mappings and may be repointed files or files left from a previous set of client mappings:
{0}

This checkin will not succeed until these files are removed from the change list. (not allowed in unattended mode)</String>
    <String name="ErrorFilesNotSynced">The following files are not fully synced/resolved:
{0}

The checkin will not succeed unless all files are fully synced/resolved.</String>
    <String name="ErrorFilesUnchanged">The following files have not been changed and do not need to be checked in:
{0}

This checkin will succeed even if they are left in the change list.  However, leaving them in uses extra space on the Depot and inaccurately reflects the actual files modified.</String>
    <String name="ErrorFilesMissing">The following files cannot be found on the local machine:
{0}

This checkin will not succeed unless these files are removed from the change list or the files are created.</String>
    <String name="ErrorMergeConflicts">The following files contain merge conflict markers:
{0}

This checkin would succeed even if these files are not removed from the change list.  However, this is almost certainly an error which needs to be fixed.

NOTE:  After fixing the merge conflicts, you can try this check again.</String>
    <String name="StatusResolving">Waiting for external sync/resolve to complete...</String>
    <String name="ResolveTitle">Checkin sync/resolve</String>
    <String name="ResolveStatus">Syncing and resolving files...</String>
    <String name="ResolveTitle">Checkin sync/resolve</String>
    <String name="ResolveDone">Done.  Please close this window if it does not close automatically.</String>
    <String name="UsageMultipleChanges">It is not valid to pass multiple changelist Ids</String>
    <String name="UsageMultipleFileSpecs">It is not valid to pass multiple file specifications</String>
    <String name="UsageNoFilesInChange">The specified changelist contains no files. (did you specify the correct changelist number? Use '-c all' to view all files regardless of which changelist they are in.)</String>
    <String name="UsageNoFilesMatched">No files matching the specification were found. (did you specify a changelist number, but not use the -c parameter?).</String>
    <String name="UsageNoFilesOpened">No files are opened in the default changelist. (maybe your files are opened in another changelist?  If so, use the -c parameter.)</String>
    <String name="StatusSubmitting">Submitting files to Source Depot...</String>
    <String name="StatusPreparingChange">Preparing changelist...</String>
    <String name="ChangeSubmittedAndRenamed">Change {0} renamed to {1} and submitted with {2} file(s).</String>
    <String name="ChangeSubmitted">Change {0} submitted with {1} file(s).</String>
    <String name="ErrorReopeningFiles">Error reopening files in preparation for submission to the depot.  The depot may be unavailable.  (View the log at $(LogPath) for more details)</String>
    <String name="ErrorSubmittingFiles">Error submitting files to the depot.

Details:
{0}
(View the log at $(LogPath) for more details)

Would you like to retry the submission?

Yes:	Retry the submission now
No:	Return to UI to make changes
Cancel:	Exit $(ApplicationTitle)</String>
    <String name="ErrorSubmittingFilesTrigger">Error submitting files to the depot.  It appears that a checkin validation trigger has failed.

NOTE:	Checkin validation triggers often require some special text in the change description.  The 
	details below may contain the required text.  Choose 'Yes' to enter the required text and
	retry the submission.

Details:
{0}
(View the log at $(LogPath) for more details)

Would you like to retry the submission?

Yes:	Enter trigger override text and retry the submission now
No:	Return to UI to make changes
Cancel:	Exit $(ApplicationTitle)</String>
    <String name="PromptTriggerText">Enter trigger override text:</String>
    <String name="ChangeAlreadySubmitted">Change {0} has already been submitted to the depot.</String>
    <String name="StatusCannotUndoChange">Change {0} has already been submitted to the depot.  Cannot undo submission.</String>
    <String name="ErrorNoFilesSelected">No files are selected for diffing.</String>
    <String name="ErrorStartingProgram">Errors starting {0}.  (View the log at $(LogPath) for more details)</String>
    <String name="ProblemRepointedFile">repointed or mis-mapped</String>
    <String name="ProblemMissingFile">file missing</String>
    <String name="ProblemDeletedFile">depot file deleted</String>
    <String name="ProblemAlreadyAddedFile">file already added</String>
    <String name="ProblemUnsyncedFile">not synced</String>
    <String name="ProblemUnresolvedFile">not resolved</String>
    <String name="ExplainRepointedFile">The file does not appear to be mapped correctly (note that this may not be an error).  Look at the depot path compared to other files to see possible differences.  This file may be repointed (sd sync -b) or could have been opened under a different set of client mappings.
    
Repointed files can be synced back into client-mapped files by using "sd sync -i".  Other mapping errors can be corrected by making a backup of the file, reverting it, syncing it, opening it for edit again, restoring (or merging) the file, and reviewing the changes.</String>
    <String name="ExplainMissingFile">The file was not found at the expected location on this machine and is not opened for delete.</String>
    <String name="ExplainDeletedFile">The file has been deleted in the depot already by another user.  Changes should be reverted and either abandoned or re-applied as an "add" operation.</String>
    <String name="ExplainAlreadyAddedFile">The file has been added to the depot already by another user.  Changes should be reverted and either abandoned or re-applied as an "edit" operation.</String>
    <String name="ExplainUnsyncedFile">The file is not fully synced.  SD will not allow the file to be submitted until it has been synced and resolved at the latest revision.</String>
    <String name="ExplainUnresolvedFile">The file is not fully resolved.  SD will not allow the file to be submitted until it has been synced and resolved at the latest revision.</String>
    <String name="ErrorInvalidChangelistId">The specified changelist '{0}' is not valid.</String>
</StringTable>
<!-- StyleCop string table - strings used on the Style Cop checks -->
<StringTable name="StyleCop">
<String name="PromptFilesNotStyleCopped">The following files are not StyleCop compliant:
{0}
Do you wish to continue?
</String>
<String name="StyleCopNumberOfFiles">Because of the large number of files being checked in, StyleCop has not been run.
Do you wish to run StyleCop on these files?
</String>
<String name="Status">Running StyleCop against files being checked in...
</String>
</StringTable>

<!-- Replacements:
    <Replacement:  (may specify multiple of these)
        name - name of the replacement string.  Must be unique.  Used as replacements during
               string lookups (e.g. "See log at $(LogPath)" will have $(LogPath) converted to
               whatever gets evaluated below)
        <text> - the value of the replacement.  Can be straight text, an Eval element, or a
                 Lookup element.  Eval elements have executable code in them which will be
                 compiled and executed at replacement time to determine the value.  Lookup 
                 elements have an xpath parameter that resolves to a single string value.
                 XPaths can be relative to certain known points (Config, SharedData, LocalData)>
    </Replacement>  -->
     
<Replacements>
    <Replacement name="ApplicationTitle"><Lookup xpath="Config/Application/Title/text()" /></Replacement>
    <Replacement name="LogPath"><Eval>Component.GetLogPath()</Eval></Replacement>
    <Replacement name="Depot"><Lookup xpath="SharedData/SourceControlData/ClientInfo/@server" /></Replacement>
    <Replacement name="Client"><Lookup xpath="SharedData/SourceControlData/ClientInfo/@name" /></Replacement>
    <Replacement name="ChangeId"><Lookup xpath="SharedData/SourceControlData/Change/@id" /></Replacement>
    <Replacement name="Reviewer"><Lookup xpath="SharedData/FormData/Field[@name='ReviewedBy']/text()" /></Replacement>
    <Replacement name="Tester"><Lookup xpath="SharedData/FormData/Field[@name='TestedBy']/text()" /></Replacement>
    <Replacement name="BugList"><Eval><![CDATA[
        string sBugList = null;

        ArrayList alBugs = new ArrayList(SharedData.GetMultipleIntValues("BugData/Bug/@id"));
        alBugs.Sort();

        foreach(int iBug in alBugs)
        {
            if (sBugList != null)
            {
                sBugList += ", ";
            }
            sBugList += (iBug == 0) ? "<new>" : iBug.ToString();
        }
        return sBugList; ]]>
    </Eval></Replacement>
    <Replacement name="Projects"><Eval><![CDATA[
        string sResult = null;

        foreach(string sName in SharedData.GetMultipleValues("EmailMappings/Mapping[@selected='true']/@name"))
        {
            if (sResult != null)
            {
                sResult += "/";
            }
            sResult += sName;
        }

        if (sResult != null)
        {
            sResult = "[" + sResult + "] ";
        }
        
        return sResult; ]]>
    </Eval></Replacement>
    <Replacement name="BugContacts"><Eval><![CDATA[
        string sResult = null;

        foreach(string sContact in SharedData.GetMultipleValues("BugData/Bug/Field[@name='Assigned to']/text()"))
        {
            if (sContact.ToLower() != "active")
            {
                if (sResult != null)
                {
                    sResult += ";";
                }
                sResult += sContact;
            }
        }

        return sResult; ]]>
    </Eval></Replacement>
</Replacements>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\.README.txt ===
c:\Program Files (x86)\MSBuild
 {Microsoft}
  Windows Workflow Foundation\... -> WindowsWorkflowFoundation\...
 {Microsoft.Cpp}
 Microsoft.Office.InfoPath.targets
 Microsoft.VisualStudio.OfficeTools.targets

(customizations -- don't write over these if updating versions)
-...\ImportBefore\...
-...\ImportAfter\...
.\Override
.\v4.0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\CheckinWizard\Config\FormData.xml ===
﻿<FormData labelWidth="100">
    <!-- Field: Defines the fields to display on the form.
            name - name of the field. Must be unique.
            order - arbitrary number specifying order. Lower numbers will appear first.
                    Numbers must be unique.
            type - specifies the type of the field.  One of 'bool', 'shorttext', or 'longtext'.
                    'bool' fields are displayed as a checkbox, 'shorttext' as a non-resizable, 
                    fairly small text box, and 'longtext' is the full length of the form and 
                    automatically grows to fit however much text is typed into it. Also see minLines
                    and maxLines below.
            label - the text to show in the UI for this field.
            required - [optional] default is false. Whether this field must be completed before 
                        continuing.
            default - Default value for this field.
            withPrevious - [optional] default is false. Puts this field on the same UI line as the previous field.
                            Only applies to shortext fields.
            minLines - [optional] Specifies the min height of a longtext field. Default is 1.
            maxLines - [optional] Specifies the max height of a longtext field. Default is 8.  -->
    <Field name="ProblemDescription" order="1"   type="longtext"     label="Description of problem" required="true" default="Defaults/Default[@name='Description']/text()" />
    <Field name="FixDescription"     order="2"   type="longtext"     label="Description of fix" required="true" />
    <Field name="ReviewedBy"         order="3"   type="shorttext"    label="Reviewed by" required="true" />
    <Field name="TestedBy"           order="4"   type="shorttext"    label="Tested by"  withPrevious="true"/>
    <Field name="TestingImpact"      order="5"   type="longtext"     label="Testing impact" />
    <Field name="OperationsImpact"   order="6"   type="longtext"     label="Operations impact" />
    <Field name="UAImpact"           order="7"   type="longtext"     label="UA impact" />
    <Field name="InternationalImpact" order="8"  type="longtext"     label="International impact" />
    <Field name="SetupImpact"        order="9"   type="longtext"     label="Setup impact" />
    <Field name="Destabilization"    order="10"  type="longtext"     label="Potential destabilization" />
    <Field name="BuildInstructions"  order="11"  type="longtext"     label="Build instructions" />
    <Field name="BuildModules"       order="12"  type="longtext"     label="Build modules affected" />
    <Field name="ResourcesModified"  order="13"  type="bool"         label="Anything added or removed from resource files?" />
    <Field name="PerformanceAnalysis" order="14" type="bool"         label="Performance analysis completed?" />
    <Field name="PerformanceImpact"  order="15"  type="longtext"     label="Performance impact" />
</FormData>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft\Expression\Blend\Silverlight\v4.0\_prerelease.txt ===
From Blend 4.0 RC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\CheckinWizard\Config\BugDatabase.xml ===
﻿<!-- BugDatabases element contains BugDatabase elements and controls behavior of the bug UI forms -->
<BugDatabases allowNonBugRelatedCheckin="true" 
              defaultNonBugRelated="false"
              allowChooseBugById="true" 
              defaultResolve="true" 
              forceResolve="false" 
              requireSingle="false"
              continueOnError="false"
              skipIfUnavailable="false">
    <!-- [allowNonBugRelatedCheckin] - default false.  Whether the user has the option to not choose 
                                       a bug with the checkin
         [defaultNonBugRelated] - default false.  Whether option to not choose a bug is selected by
                                  default or not
         [allowChooseBugById] - default false.  Whether the user can enter a bug ID directly
         [defaultResolve] - default false.  Whether the Resolve bugs checkbox is checked by default
         [forceResolve] - default false.  Whether the default is changeable from the UI
         [requireSingle] - default false.  Whether a single bug is required
         [continueOnError] - default false.  Whether to exit if there is a problem saving bugs or to
                             allow the process to continue and just return a warning code 
         [skipIfUnavailable] - default false.  Whether to skip the bug stuff altogether (with no
                               error presented to the user) if the PS client object cannot be created -->
                             
    <BugDatabase name="CoreXT NT Build Environment" default="true" allowNewBugs="true" transform="RaidDescription.xslt">
        <!-- name - PS DB name
             [default] - default false.  Is this the default bug database?  only one should be selected
             [allowNewBugs] - default false.  Can new bugs be created in this database?
             transform - Name of a XML transform file to generate the text used in the description.
                         Path is relative to config directory -->

        <!-- ConnectInfo:
            name - name of bug database as it shows in Product Studio UI
            [domain] - domain of bug database... defaults to corp.microsoft.com
            [user] - name of a user to connect to the database as
            [password] - password of the user -->
        <ConnectInfo name="CoreXT NT Build Environment"/>
        
        <!-- Depots element contains Depot elements and is used to match up depot server info from the
             files selected for checkin with the descriptive name used natively by Product Studio to
             describe the depot.  Adding an entry here, and adding the appropriate info in the Product
             Studio admin, allows bugs to be saved along with changelist info -->
        <Depots>
            <!-- Depot:
                name - the name of the depot as it shows up in the Product Studio UI
                server - the server:port of the depot as reported by sd info -->
            <Depot name="corext master source-depot" server="bgit-sdcorext:2732" />
        </Depots>
        
        <!-- Queries element contains Query elements which describe the queries which will be available
             for selection from the dropdown in the bug query page -->
        <Queries>
        
            <!-- Query element contains a Title element and a Where element.  The Title is what will 
                 show in the query UI.  The Where is an XML WHERE clause as defined by PSOM.  It 
                 supports embedding C# code into the queries.  The C# code must be contained in an
                 <Eval> element and has access to the Component object and the GlobalConfig, LocalConfig,
                 SharedData, and LocalData XML blocks.  See PSOM documentation for more info on the
                 schema of the query contained within the Where element. -->
            <Query>
                <!-- [default] - default is false.  Whether this is the default query to run -->
                <Title>All active bugs</Title>
                <Where>
                    <Expression Column="Status" Operator="equals">
                        <String>Active</String>
                    </Expression>    
                </Where>
            </Query>
            <Query default="true">
                <Title>Bugs assigned to me</Title>
                <Where>
                    <Group GroupOperator="and">
                        <Expression Column="Assigned to" Operator="equals">
                            <String><Eval>SharedData.GetValue("Environment/@user")</Eval></String>
                        </Expression>
                        <Expression Column="Status" Operator="equals">
                            <String>Active</String>
                        </Expression>    
                    </Group>
                </Where>
            </Query>
        </Queries>
        
        <!-- Layout: describes the layout of the bug form.
            <Group:  (may be multiple) corresponds to a group of controls in the bug UI
                    [noLayout] - default is false.  Prevents the generic layout code from running on these
                                 fields.  Only makes sense for the Title, TreeId, and Description fields
                                 which the code handles specially  >
                <Field: (may be multiple) corresponds to a field in the PSOM
                    name - name for the field in the PSOM
                    [label] - a different name to use in the UI
                    [readOnly] - force the field to read-only even if PSOM allows writes
                    [default] - an XML path into the <SharedData> which contains the default value for
                                the field.  Defaults can contain a literal string, an XPath expression, 
                                or the location of some dynamic code.  Examples:
Literal string:
             <Field name="Resolution" default="LITERAL:Fixed" />
            - uses the string following "LITERAL:" as the default

XPath expression:
            <Field name="Resolved by" label="By" default="Defaults/Default[@name='OverrideUser']/text()" override='true' />
            - uses the string from the XPath expression as the default.

Dynamic code:
             <Field name="Fix Build" default="Defaults/Default[@name='BuildNumber']" override='true' />
             - executes the code in the location specified by the XPath expression.
             - dynamic code should be encapsulated within an <Eval> node, like:
                 <Defaults><Default name="BuildNumber"><Eval>return "Dynamic" + "Value";</Eval></Default></Defaults>

                    [hidden] - default is false.  When set, field is not shown in the UI.
                    [override] - default is false.  Whether the default should override the pre-existing
                                 value in the PS field or only fill it in if it is blank. >
                </Field>
            </Group>
        -->
        <Layout>
            <Group name="Status">
                <Field name="Status" readOnly="true" />
                <Field name="Assigned to" />
                <Field name="Issue type" />
                <Field name="Severity" />
                <Field name="Priority" />
                <Field name="Changed date" label="Date"/>
                <Field name="Changed by" label="By" default="Defaults/Default[@name='OverrideUser']/text()" override='true' />
            </Group>
            <Group name="Opened">
                <Field name="Opened date" label="Date" />
                <Field name="Opened by" label="By"/>
                <Field name="Open build" label="Build" />
                <Field name="Source" />
                <Field name="Source ID" />
                <Field name="How found" />
            </Group>
            <Group name="Resolved">
                <Field name="Resolved date" label="Date" />
                <Field name="Resolved by" label="By" default="Defaults/Default[@name='OverrideUser']/text()" override='true' />
                <Field name="Resolution" default="LITERAL:Fixed" />
                <Field name="Fix build" default="Defaults/Default[@name='BuildVersion']/PS/text()" override='true' />
                <Field name="Cause" />
                <Field name="Change" />
            </Group>
            <Group name="Environment">
                <Field name="Environment" />
            </Group>
            <Group name="Special" noLayout="true">
                <Field name="Title" />
                <Field name="TreeID" label="Path" />
                <Field name="Description" />
            </Group>
        </Layout>
    </BugDatabase>
</BugDatabases>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\FSharp\v2.0\.README.txt ===
c:\Program Files\Microsoft F#\

That directory in a Visual Studio 2010 install has a set of files.  
But those files are .NET 4.0 assemblies, and the CoreXT environment 
typically has the following environment variable set:
    COMPLUS_VERSION=v2.0.50727
which means CLR2.  So I've taken the same set of files found in
    c:\Program Files\Microsoft F#\v4.0\
but actually got those files from an F# "CTP" install, which has the
same assemblies compiled for .NET 2.0, and dropped them here.

Furthermore, the 2.0 FSharp.Core.dll is added here, so as to be next to
FSharp.Build.dll and the compiler.  This way these tools can be used on a 
machine that has .NET 2.0/3.0/3.5, even without an install of the F# Redist.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\alink.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="ALink" xmlns="http://schemas.microsoft.com/build/2009/properties" />
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\build_events.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="ConfigurationBuildEvents" 
      DisplayName="Build Events" 
      PageTemplate="tool" 
      Order="90"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <Rule.Categories>
    <Category Name="PreBuild" DisplayName="Pre-Build Event"/>
    <Category Name="PreLink" DisplayName="Pre-Link Event"/>
    <Category Name="PostBuild" DisplayName="Post-Build Event"/>
  </Rule.Categories>
  <StringProperty Name="PreBuildCommand"
                  Category="PreBuild"
                  DisplayName="Command Line"
                  Description="Specifies a command line for the pre-build event tool to run."
                  F1Keyword="VC.Project.IVCEventTool.CommandLine">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="PreBuildEvent" PersistedName="Command" />
    </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="PreBuildMessage" Category="PreBuild" DisplayName="Description" Description="Specifies a description for the pre-build event tool to display." F1Keyword="VC.Project.IVCEventTool.Description">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="PreBuildEvent" PersistedName="Message" />
    </StringProperty.DataSource>
  </StringProperty>
  <BoolProperty Name="PreBuildEventUseInBuild" Category="PreBuild" DisplayName="Use In Build" Description="Specifies whether this build event is excluded from the build for the current configuration." F1Keyword="VC.Project.IVCEventTool.ExcludedFromBuild">
  </BoolProperty>

  <StringProperty Name="PreLinkCommand" Category="PreLink" DisplayName="Command Line" Description="Specifies a command line for the pre-link event tool to run." F1Keyword="VC.Project.IVCEventTool.CommandLine">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="PreLinkEvent" PersistedName="Command" />
    </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="PreLinkMessage" Category="PreLink" DisplayName="Description" Description="Specifies a description for the pre-link event tool to display." F1Keyword="VC.Project.IVCEventTool.Description">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="PreLinkEvent" PersistedName="Message" />
    </StringProperty.DataSource>
  </StringProperty>
  <BoolProperty Name="PreLinkEventUseInBuild" Category="PreLink" DisplayName="Use In Build" Description="Specifies whether this build event is excluded from the build for the current configuration." F1Keyword="VC.Project.IVCEventTool.ExcludedFromBuild">
  </BoolProperty>

  <StringProperty Name="PostBuildCommand" Category="PostBuild" DisplayName="Command Line" Description="Specifies a command line for the post-build event tool to run." F1Keyword="VC.Project.IVCEventTool.CommandLine">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="PostBuildEvent" PersistedName="Command" />
    </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="PostBuildMessage" Category="PostBuild" DisplayName="Description" Description="Specifies a description for the post-build event tool to display." F1Keyword="VC.Project.IVCEventTool.Description">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="PostBuildEvent" PersistedName="Message" />
    </StringProperty.DataSource>
  </StringProperty>
  <BoolProperty Name="PostBuildEventUseInBuild" Category="PostBuild" DisplayName="Use In Build" Description="Specifies whether this build event is excluded from the build for the current configuration." F1Keyword="VC.Project.IVCEventTool.ExcludedFromBuild">
  </BoolProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft\VisualStudio\v10.0\VSSDK\ProjectItemsSchema.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<ProjectSchemaDefinitions xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib" xmlns:my="http://schemas.microsoft.com/developer/msbuild/tasks/2005">
  <ContentType Name="PkgdefFile" DisplayName="Pkgdef File" ItemType="PkgdefFile" />
  <ItemType Name="PkgdefFile" DisplayName="Pkgdef File" />
  <FileExtension Name=".pkgdef" ContentType="PkgdefFile" />

  <ContentType Name="IsolatedShellFiles" DisplayName="Isolated Shell File" ItemType="IsolatedShellFiles" />
  <ItemType Name="IsolatedShellFiles" DisplayName="Isolated Shell File" />
</ProjectSchemaDefinitions>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\bscmake.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="BSCMake" PageTemplate="tool" DisplayName="Browse Information" SwitchPrefix="/" Order="80" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Bscmake" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Runs without displaying standard Microsoft copyright data. (/nologo)" Category="General" Switch="nologo" F1Keyword="VC.Project.VCBscMakeTool.SuppressStartupBanner">
  </BoolProperty>
  <StringProperty Subtype="file" Name="OutputFile" DisplayName="Output File" Description="Overrides the default output file name (/o[file])" Category="General" Switch="o" F1Keyword="VC.Project.VCBscMakeTool.OutputFile">
  </StringProperty>
  <BoolProperty Name="PreserveSBR" DisplayName="Preserve SBR Files" Description="Causes bscmake.exe to do full builds that preserve the .sbr files.  This is to enable use  of alternate incremental build methods. (/n)" Category="General" Switch="n" F1Keyword="VC.Project.VCBscMakeTool.PreserveSBR">
  </BoolProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\fxcop.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<Rule Name="Microsoft.CodeAnalysis" PageTemplate="Microsoft.CodeAnalysis.Template" SwitchPrefix="/" Order="200" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.DisplayName>
    <sys:String>Code Analysis</sys:String>
  </Rule.DisplayName>

  <Rule.Categories>
    <Category Name="General">
      <Category.DisplayName>
        <sys:String>General</sys:String>
      </Category.DisplayName>
    </Category>
  </Rule.Categories>

  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" />
  </Rule.DataSource>

  <StringProperty Name="CodeAnalysisCulture" />
  <StringProperty Name="CodeAnalysisModuleSuppressionsFile" />
  <StringProperty Name="CodeAnalysisInputAssembly" />
  <StringProperty Name="CodeAnalysisLogFile" />
  <StringProperty Name="CodeAnalysisRuleAssemblies" />
  <StringProperty Name="CodeAnalysisRules" />
  <StringProperty Name="CodeAnalysisRuleDirectories" />
  <StringProperty Name="CodeAnalysisRuleSet" />
  <StringProperty Name="CodeAnalysisRuleSetDirectories" />
  <BoolProperty Name="CodeAnalysisUseTypeNameInSuppression" />
  <BoolProperty Name="CodeAnalysisIgnoreGeneratedCode" />
  <BoolProperty Name="RunCodeAnalysis" />
  <BoolProperty Name="CodeAnalysisOverrideRuleVisibilities" />
  <BoolProperty Name="CodeAnalysisFailOnMissingRules" />
  <BoolProperty Name="CodeAnalysisIgnoreBuiltInRuleSets" />
  <BoolProperty Name="CodeAnalysisIgnoreBuiltInRules" />
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\custom_build_step.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule 
  Name="ConfigurationCustomBuildStep" 
  DisplayName="Custom Build Step" 
  Order="100" 
  PageTemplate="tool"
  xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="CustomBuildStep" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
  </Rule.Categories>
  <StringProperty Name="Command" Category="General" DisplayName="Command Line" Description="Specifies a command line for the custom build step." F1Keyword="VC.Project.VCCustomBuildStep.Command">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="Message" Category="General" DisplayName="Description" Description="Specifies a description for the custom build step." F1Keyword="VC.Project.VCCustomBuildStep.Message"/>
  <StringListProperty Name="Outputs" Category="General" DisplayName="Outputs" Description="Specifies the output files the custom build step generates." F1Keyword="VC.Project.VCCustomBuildStep.Outputs"/>
  <StringListProperty Name="Inputs" Category="General" DisplayName="Additional Dependencies" Description="Specifies any additional input files to use for the custom build step." F1Keyword="VC.Project.VCCustomBuildStep.AdditionalInputs"/>
  <DynamicEnumProperty Name="CustomBuildAfterTargets" Category="General" DisplayName="Execute After" Description="Specifies the targets for the custom build step to run after." F1Keyword="VC.Project.VCCustomBuildStep.CustomBuildAfterTargets"
                       EnumProvider="Targets">
    <DynamicEnumProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="" />
    </DynamicEnumProperty.DataSource>
    <DynamicEnumProperty.ProviderSettings>
      <NameValuePair Name="Exclude" Value="^CustomBuild|^Compute"/>
    </DynamicEnumProperty.ProviderSettings>
  </DynamicEnumProperty>
  <DynamicEnumProperty Name="CustomBuildBeforeTargets" Category="General" DisplayName="Execute Before" Description="Specifies the targets for the custom build step to run before." F1Keyword="VC.Project.VCCustomBuildStep.CustomBuildBeforeTargets"
                       EnumProvider="Targets">
    <DynamicEnumProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="" />
    </DynamicEnumProperty.DataSource>
    <DynamicEnumProperty.ProviderSettings>
      <NameValuePair Name="Exclude" Value="^CustomBuild|^Compute"/>
    </DynamicEnumProperty.ProviderSettings>
  </DynamicEnumProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\cl.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="CL" PageTemplate="tool" DisplayName="C/C++" SwitchPrefix="/" Order="10" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Optimization" DisplayName="Optimization" />
    <Category Name="Preprocessor" DisplayName="Preprocessor" />
    <Category Name="Code Generation" DisplayName="Code Generation" />
    <Category Name="Language" DisplayName="Language" />
    <Category Name="Precompiled Headers" DisplayName="Precompiled Headers" />
    <Category Name="Output Files" DisplayName="Output Files" />
    <Category Name="Browse Information" DisplayName="Browse Information" />
    <Category Name="Advanced" DisplayName="Advanced" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="ClCompile" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <StringListProperty Subtype="folder" Name="AdditionalIncludeDirectories" DisplayName="Additional Include Directories" Description="Specifies one or more directories to add to the include path; separate with semi-colons if more than one.     (/I[path])" Category="General" Switch="I" F1Keyword="VC.Project.VCCLCompilerTool.AdditionalIncludeDirectories">
  </StringListProperty>
  <StringListProperty Subtype="folder" Name="AdditionalUsingDirectories" DisplayName="Resolve #using References" Description="Specifies one or more directories (separate directory names with a semicolon) to be searched to resolve names passed to a #using directive.  (/AI[path])" Category="General" Switch="AI" F1Keyword="VC.Project.VCCLCompilerTool.AdditionalUsingDirectories">
  </StringListProperty>
  <EnumProperty Name="DebugInformationFormat" DisplayName="Debug Information Format" Description="Specifies the type of debugging information generated by the compiler.  You must also change linker settings appropriately to match.    (/Z7, Zd, /Zi, /ZI)" Category="General" F1Keyword="VC.Project.VCCLCompilerTool.DebugInformationFormat">
    <EnumValue Name="OldStyle" Switch="Z7" DisplayName="C7 compatible" Description="Select the type of debugging information created for your program and whether this information is kept in object (.obj) files or in a program database (PDB).">
    </EnumValue>
    <EnumValue Name="ProgramDatabase" Switch="Zi" DisplayName="Program Database" Description="Produces a program database (PDB) that contains type information and symbolic debugging information for use with the debugger. The symbolic debugging information includes the names and types of variables, as well as functions and line numbers. ">
    </EnumValue>
    <EnumValue Name="EditAndContinue" Switch="ZI" DisplayName="Program Database for Edit And Continue" Description="Produces a program database, as described above, in a format that supports the Edit and Continue feature.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="CompileAsManaged" DisplayName="Common Language RunTime Support" Description="Use the .NET runtime service.  This switch is incompatible with some other switches; see the documentation on the /clr family of switches for details." Category="General" F1Keyword="VC.Project.VCCLCompilerTool.CompileAsManaged">
    <EnumValue Name="false" Switch="" DisplayName="No Common Language RunTime Support" Description="No Common Language RunTime Support">
    </EnumValue>
    <EnumValue Name="true" Switch="clr" DisplayName="Common Language RunTime Support" Description="Creates metadata for your application that can be consumed by other CLR applications, and allows your application to consume types and data in the metadata of other CLR components.">
    </EnumValue>
    <EnumValue Name="Pure" Switch="clr:pure" DisplayName="Pure MSIL Common Language RunTime Support" Description="Produces an MSIL-only output file with no native executable code, although it can contain native types compiled to MSIL.">
    </EnumValue>
    <EnumValue Name="Safe" Switch="clr:safe" DisplayName="Safe MSIL Common Language RunTime Support" Description="Produces an MSIL-only (no native executable code) and verifiable output file.">
    </EnumValue>
    <EnumValue Name="OldSyntax" Switch="clr:oldSyntax" DisplayName="Common Language RunTime Support, Old Syntax" Description="Enables Managed Extensions for C++ syntax, the original Visual C++ syntax for CLR programming.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="nologo-" Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Suppresses the display of the sign-on banner when the compiler starts up and display of informational messages during compiling." Category="General" Switch="nologo" F1Keyword="VC.Project.VCCLCompilerTool.SuppressStartupBanner">
  </BoolProperty>
  <EnumProperty Name="WarningLevel" DisplayName="Warning Level" Description="Select how strict you want the compiler to be about code errors.     (/W0 - /W4)" Category="General" F1Keyword="VC.Project.VCCLCompilerTool.WarningLevel">
    <EnumValue Name="TurnOffAllWarnings" Switch="W0" DisplayName="Turn Off All Warnings" Description="Level 0 disables all warnings.">
    </EnumValue>
    <EnumValue Name="Level1" Switch="W1" DisplayName="Level1" Description="Level 1 displays severe warnings. Level 1 is the default warning level at the command line.">
    </EnumValue>
    <EnumValue Name="Level2" Switch="W2" DisplayName="Level2" Description="Level 2 displays all level 1 warnings and warnings less severe than level 1.">
    </EnumValue>
    <EnumValue Name="Level3" Switch="W3" DisplayName="Level3" Description="Level 3 displays all level 2 warnings and all other warnings recommended for production purposes.">
    </EnumValue>
    <EnumValue Name="Level4" Switch="W4" DisplayName="Level4" Description="Level 4 displays all level 3 warnings plus informational warnings, which in most cases can be safely ignored.">
    </EnumValue>
    <EnumValue Name="EnableAllWarnings" Switch="Wall" DisplayName="EnableAllWarnings" Description="Enables all warnings, including those disabled by default.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="WX-" Name="TreatWarningAsError" DisplayName="Treat Warnings As Errors" Description="Treats all compiler warnings as errors. For a new project, it may be best to use /WX in all compilations; resolving all warnings will ensure the fewest possible hard-to-find code defects." Category="General" Switch="WX" F1Keyword="VC.Project.VCCLCompilerTool.WarnAsError">
  </BoolProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <BoolProperty Name="MultiProcessorCompilation" DisplayName="Multi-processor Compilation" Description="Multi-processor Compilation" Category="General" Switch="MP" F1Keyword="VC.Project.VCCLCompilerTool.MultiProcessorCompilation">
    <Argument Property="ProcessorNumber" IsRequired="false" />
  </BoolProperty>
  <IntProperty Name="ProcessorNumber" DisplayName="Number of processors" Description="Number of processors." Category="General" Visible="false">
  </IntProperty>
  <EnumProperty Name="Optimization" DisplayName="Optimization" Description="Select option for code optimization; choose Custom to use specific optimization options.     (/Od, /O1, /O2, /Ox)" Category="Optimization" F1Keyword="VC.Project.VCCLCompilerTool.Optimization">
    <EnumValue Name="Disabled" Switch="Od" DisplayName="Disabled" Description="Disable optimization.">
    </EnumValue>
    <EnumValue Name="MinSpace" Switch="O1" DisplayName="Minimize Size" Description="Equivalent to /Og /Os /Oy /Ob2 /Gs /GF /Gy">
    </EnumValue>
    <EnumValue Name="MaxSpeed" Switch="O2" DisplayName="Maximize Speed" Description="Equivalent to /Og /Oi /Ot /Oy /Ob2 /Gs /GF /Gy">
    </EnumValue>
    <EnumValue Name="Full" Switch="Ox" DisplayName="Full Optimization" Description="Equivalent to /Og /Oi /Ot /Oy /Ob2">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="InlineFunctionExpansion" DisplayName="Inline Function Expansion" Description="Select the level of inline function expansion for the build.     (/Ob1, /Ob2)" Category="Optimization" F1Keyword="VC.Project.VCCLCompilerTool.InlineFunctionExpansion">
    <EnumValue Name="Default" Switch="" DisplayName="Default">
    </EnumValue>
    <EnumValue Name="Disabled" Switch="Ob0" DisplayName="Disabled" Description="Disables inline expansion, which is on by default.">
    </EnumValue>
    <EnumValue Name="OnlyExplicitInline" Switch="Ob1" DisplayName="Only __inline" Description="Expands only functions marked as inline, __inline, __forceinline or __inline or, in a C++ member function, defined within a class declaration.">
    </EnumValue>
    <EnumValue Name="AnySuitable" Switch="Ob2" DisplayName="Any Suitable" Description="Expands functions marked as inline or __inline and any other function that the compiler chooses (expansion occurs at the compiler's discretion, often referred to as auto-inlining).">
    </EnumValue>
  </EnumProperty>
  <BoolProperty Name="IntrinsicFunctions" DisplayName="Enable Intrinsic Functions" Description="Enables intrinsic functions.  Using intrinsic functions generates faster, but possibly larger, code.     (/Oi)" Category="Optimization" Switch="Oi" F1Keyword="VC.Project.VCCLCompilerTool.EnableIntrinsicFunctions">
  </BoolProperty>
  <EnumProperty Name="FavorSizeOrSpeed" DisplayName="Favor Size Or Speed" Description="Whether to favor code size or code speed; 'Global Optimization' must be turned on.     (/Ot, /Os)" Category="Optimization" F1Keyword="VC.Project.VCCLCompilerTool.FavorSizeOrSpeed">
    <EnumValue Name="Size" Switch="Os" DisplayName="Favor small code" Description="Favor Small Code. Minimizes the size of EXEs and DLLs by instructing the compiler to favor size over speed.">
    </EnumValue>
    <EnumValue Name="Speed" Switch="Ot" DisplayName="Favor fast code" Description="Favor Fast Code. Maximizes the speed of EXEs and DLLs by instructing the compiler to favor speed over size. (This is the default.) ">
    </EnumValue>
    <EnumValue Name="Neither" Switch="" DisplayName="Neither" Description="No size nor speed optimization.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="Oy-" Name="OmitFramePointers" DisplayName="Omit Frame Pointers" Description="Suppresses creation of frame pointers on the call stack." Category="Optimization" Switch="Oy" F1Keyword="VC.Project.VCCLCompilerTool.OmitFramePointers">
  </BoolProperty>
  <BoolProperty Name="EnableFiberSafeOptimizations" DisplayName="Enable Fiber-Safe Optimizations" Description="Enables memory space optimization when using fibers and thread local storage access.     (/GT)" Category="Optimization" Switch="GT" F1Keyword="VC.Project.VCCLCompilerTool.EnableFiberSafeOptimizations">
  </BoolProperty>
  <BoolProperty Name="WholeProgramOptimization" DisplayName="Whole Program Optimization" Description="Enables cross-module optimizations by delaying code generation to link time; requires that linker option 'Link Time Code Generation' be turned on.     (/GL)" Category="Optimization" Switch="GL" F1Keyword="VC.Project.VCCLWCECompilerTool.WholeProgramOptimization">
  </BoolProperty>
  <StringListProperty Name="PreprocessorDefinitions" DisplayName="Preprocessor Definitions" Description="Defines a preprocessing symbols for your source file." Category="Preprocessor" Switch="D " F1Keyword="VC.Project.VCCLCompilerTool.PreprocessorDefinitions">
  </StringListProperty>
  <StringListProperty Name="UndefinePreprocessorDefinitions" DisplayName="Undefine Preprocessor Definitions" Description="Specifies one or more preprocessor undefines.     (/U[macro])" Category="Preprocessor" Switch="U" F1Keyword="VC.Project.VCCLCompilerTool.UndefinePreprocessorDefinitions">
  </StringListProperty>
  <BoolProperty Name="UndefineAllPreprocessorDefinitions" DisplayName="Undefine All Preprocessor Definitions" Description="Undefine all previously defined preprocessor values.     (/u)" Category="Preprocessor" Switch="u" F1Keyword="VC.Project.VCCLCompilerTool.UndefineAllPreprocessorDefinitions">
  </BoolProperty>
  <BoolProperty Name="IgnoreStandardIncludePath" DisplayName="Ignore Standard Include Paths" Description="Prevents the compiler from searching for include files in directories specified in the INCLUDE environment variables." Category="Preprocessor" Switch="X" F1Keyword="VC.Project.VCCLCompilerTool.IgnoreStandardIncludePath">
  </BoolProperty>
  <BoolProperty Name="PreprocessToFile" DisplayName="Preprocess to a File" Description="Preprocesses C and C++ source files and writes the preprocessed output to a file. This option suppresses compilation, thus it does not produce an .obj file." Category="Preprocessor" Switch="P" F1Keyword="VC.Project.VCCLCompilerTool.GeneratePreprocessedFile">
  </BoolProperty>
  <StringProperty Name="PreprocessOutputPath" DisplayName="Preprocess Output Path" Description="Specify the output path for the preprocesser. The default location is the same as the source file(s)." Category="Preprocessor" Switch="Fi" Visible="false">
  </StringProperty>
  <BoolProperty Name="PreprocessSuppressLineNumbers" DisplayName="Preprocess Suppress Line Numbers" Description="Preprocess without #line directives." Category="Preprocessor" Switch="EP" F1Keyword="VC.Project.VCCLCompilerTool.GeneratePreprocessedFile">
  </BoolProperty>
  <BoolProperty Name="PreprocessKeepComments" DisplayName="Keep Comments" Description="Suppresses comment strip from source code; requires that one of the 'Preprocessing' options be set.     (/C)" Category="Preprocessor" Switch="C" F1Keyword="VC.Project.VCCLCompilerTool.KeepComments">
  </BoolProperty>
  <BoolProperty ReverseSwitch="GF-" Name="StringPooling" DisplayName="Enable String Pooling" Description="Enables the compiler to create a single read-only copy of identical strings in the program image and in memory during execution, resulting in smaller programs, an optimization called string pooling. /O1, /O2, and /ZI  automatically set /GF option. " Category="Code Generation" Switch="GF" F1Keyword="VC.Project.VCCLCompilerTool.StringPooling">
  </BoolProperty>
  <BoolProperty ReverseSwitch="Gm-" Name="MinimalRebuild" DisplayName="Enable Minimal Rebuild" Description="Enables minimal rebuild, which determines whether C++ source files that include changed C++ class definitions (stored in header (.h) files) need to be recompiled." Category="Code Generation" Switch="Gm" F1Keyword="VC.Project.VCCLCompilerTool.MinimalRebuild">
  </BoolProperty>
  <EnumProperty Name="ExceptionHandling" DisplayName="Enable C++ Exceptions" Description="Specifies the model of exception handling to be used by the compiler." Category="Code Generation" F1Keyword="VC.Project.VCCLCompilerTool.ExceptionHandling">
    <EnumValue Name="Async" Switch="EHa" DisplayName="Yes with SEH Exceptions" Description="The exception-handling model that catches asynchronous (structured) and synchronous (C++) exceptions (/EHa)">
    </EnumValue>
    <EnumValue Name="Sync" Switch="EHsc" DisplayName="Yes" Description="The exception-handling model that catches C++ exceptions only and tells the compiler to assume that extern C functions never throw a C++ exception. (/EHsc)">
    </EnumValue>
    <EnumValue Name="SyncCThrow" Switch="EHs" DisplayName="Yes with Extern C functions" Description="The exception-handling model that catches C++ exceptions only and tells the compiler to assume that extern C functions do throw an exception. (/EHs)">
    </EnumValue>
    <EnumValue Name="false" Switch="" DisplayName="No" Description="No exception handling.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty Name="SmallerTypeCheck" DisplayName="Smaller Type Check" Description="Enable checking for conversion to smaller types, incompatible with any optimization type other than debug.     (/RTCc)" Category="Code Generation" Switch="RTCc" F1Keyword="VC.Project.VCCLCompilerTool.SmallerTypeCheck">
  </BoolProperty>
  <EnumProperty Name="BasicRuntimeChecks" DisplayName="Basic Runtime Checks" Description="Perform basic runtime error checks, incompatible with any optimization type other than debug.     (/RTCs, /RTCu, /RTC1)" Category="Code Generation" F1Keyword="VC.Project.VCCLCompilerTool.BasicRuntimeChecks">
    <EnumValue Name="StackFrameRuntimeCheck" Switch="RTCs" DisplayName="Stack Frames" Description="Enables stack frame run-time error checking">
    </EnumValue>
    <EnumValue Name="UninitializedLocalUsageCheck" Switch="RTCu" DisplayName="Uninitialized variables" Description="Reports when a variable is used without having been initialized.">
    </EnumValue>
    <EnumValue Name="EnableFastChecks" Switch="RTC1" DisplayName="Both (/RTC1, equiv. to /RTCsu)" Description="Equivalent of /RTCsu">
    </EnumValue>
    <EnumValue Name="Default" Switch="" DisplayName="Default" Description="Default runtime checks.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="RuntimeLibrary" DisplayName="Runtime Library" Description="Specify runtime library for linking.     (/MT, /MTd, /MD, /MDd)" Category="Code Generation" F1Keyword="VC.Project.VCCLCompilerTool.RuntimeLibrary">
    <EnumValue Name="MultiThreaded" Switch="MT" DisplayName="Multi-threaded" Description="Causes your application to use the multithread, static version of the run-time library.">
    </EnumValue>
    <EnumValue Name="MultiThreadedDebug" Switch="MTd" DisplayName="Multi-threaded Debug" Description="Defines _DEBUG and _MT. This option also causes the compiler to place the library name LIBCMTD.lib into the .obj file so that the linker will use LIBCMTD.lib to resolve external symbols.">
    </EnumValue>
    <EnumValue Name="MultiThreadedDLL" Switch="MD" DisplayName="Multi-threaded DLL" Description="Causes your application to use the multithread- and DLL-specific version of the run-time library. Defines _MT and _DLL and causes the compiler to place the library name MSVCRT.lib into the .obj file.">
    </EnumValue>
    <EnumValue Name="MultiThreadedDebugDLL" Switch="MDd" DisplayName="Multi-threaded Debug DLL" Description="Defines _DEBUG, _MT, and _DLL and causes your application to use the debug multithread- and DLL-specific version of the run-time library. It also causes the compiler to place the library name MSVCRTD.lib into the .obj file.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="StructMemberAlignment" DisplayName="Struct Member Alignment" Description="Specifies 1, 2, 4, or 8-byte boundaries for struct member alignment.     (/Zp[num])" Category="Code Generation" F1Keyword="VC.Project.VCCLCompilerTool.StructMemberAlignment">
    <EnumValue Name="1Byte" Switch="Zp1" DisplayName="1 Byte" Description="Packs structures on 1-byte boundaries. Same as /Zp.">
    </EnumValue>
    <EnumValue Name="2Bytes" Switch="Zp2" DisplayName="2 Bytes" Description="Packs structures on 2-byte boundaries.">
    </EnumValue>
    <EnumValue Name="4Bytes" Switch="Zp4" DisplayName="4 Byte" Description="Packs structures on 4-byte boundaries.">
    </EnumValue>
    <EnumValue Name="8Bytes" Switch="Zp8" DisplayName="8 Bytes" Description="Packs structures on 8-byte boundaries (default).">
    </EnumValue>
    <EnumValue Name="16Bytes" Switch="Zp16" DisplayName="16 Bytes" Description="Packs structures on 16-byte boundaries.">
    </EnumValue>
    <EnumValue Name="Default" Switch="" DisplayName="Default" Description="Default alignment settings.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="GS-" Name="BufferSecurityCheck" DisplayName="Buffer Security Check" Description="Check for buffer overruns; useful for closing hackable loopholes on internet servers.  The default is enabled.     (/GS-)" Category="Code Generation" Switch="GS" F1Keyword="VC.Project.VCCLCompilerTool.BufferSecurityCheck">
  </BoolProperty>
  <BoolProperty ReverseSwitch="Gy-" Name="FunctionLevelLinking" DisplayName="Enable Function-Level Linking" Description="Allows the compiler to package individual functions in the form of packaged functions (COMDATs). Required for edit and continue to work.     (/Gy)" Category="Code Generation" Switch="Gy" F1Keyword="VC.Project.VCCLCompilerTool.EnableFunctionLevelLinking">
  </BoolProperty>
  <EnumProperty Name="EnableEnhancedInstructionSet" DisplayName="Enable Enhanced Instruction Set" Description="Enable use of instructions found on processors that support enhanced instruction sets, e.g., the SSE and SSE2 enhancements to the IA-32. Currently only available when building for the x86 architecture.   (/arch:SSE, /arch:SSE2)" Category="Code Generation" F1Keyword="VC.Project.VCCLCompilerTool.EnableEnhancedInstructionSet">
    <EnumValue Name="StreamingSIMDExtensions" Switch="arch:SSE" DisplayName="Streaming SIMD Extensions (/arch:SSE)" Description="Streaming SIMD Extensions (/arch:SSE)">
    </EnumValue>
    <EnumValue Name="StreamingSIMDExtensions2" Switch="arch:SSE2" DisplayName="Streaming SIMD Extensions 2 (/arch:SSE2)" Description="Streaming SIMD Extensions 2 (/arch:SSE2)">
    </EnumValue>
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set" Description="Not Set.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="FloatingPointModel" DisplayName="Floating Point Model" Description="Sets the floating point model.     (/fp:precise, /fp:strict, /fp:fast)" Category="Code Generation" F1Keyword="VC.Project.VCCLCompilerTool.floatingPointModel">
    <EnumValue Name="Precise" Switch="fp:precise" DisplayName="Precise" Description="Default. Improves the consistency of floating-point tests for equality and inequality.">
    </EnumValue>
    <EnumValue Name="Strict" Switch="fp:strict" DisplayName="Strict" Description="The strictest floating-point model. /fp:strict causes fp_contract to be OFF and fenv_access to be ON. /fp:except is implied and can be disabled by explicitly specifying /fp:except-. When used with /fp:except-, /fp:strict enforces strict floating-point semantics but without respect for exceptional events.">
    </EnumValue>
    <EnumValue Name="Fast" Switch="fp:fast" DisplayName="Fast" Description="Creates the fastest code in the majority of cases. ">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="fp:except-" Name="FloatingPointExceptions" DisplayName="Enable Floating Point Exceptions" Description="Reliable floating-point exception model. Exceptions will be raised immediately after they are triggered.      (/fp:except)" Category="Code Generation" Switch="fp:except" F1Keyword="VC.Project.VCCLCompilerTool.FloatingPointExceptions">
  </BoolProperty>
  <BoolProperty Name="CreateHotpatchableImage" DisplayName="Create Hotpatchable Image" Description="When hotpatching is on, the compiler ensures that first instruction of each function is two bytes, which is required for hot patching.  (/hotpatch)" Category="Code Generation" Switch="hotpatch" F1Keyword="VC.Project.VCCLCompilerTool.CreateHotpatchableImage">
  </BoolProperty>
  <BoolProperty Name="DisableLanguageExtensions" DisplayName="Disable Language Extensions" Description="Suppresses or enables language extensions.     (/Za)" Category="Language" Switch="Za" F1Keyword="VC.Project.VCCLCompilerTool.DisableLanguageExtensions">
  </BoolProperty>
  <BoolProperty ReverseSwitch="Zc:wchar_t-" Name="TreatWChar_tAsBuiltInType" DisplayName="Treat WChar_t As Built in Type" Description="When specified, the type wchar_t becomes a native type that maps to __wchar_t in the same way that short maps to __int16. /Zc:wchar_t is on by default." Category="Language" Switch="Zc:wchar_t" F1Keyword="VC.Project.VCCLCompilerTool.TreatWChar_tAsBuiltInType">
  </BoolProperty>
  <BoolProperty ReverseSwitch="Zc:forScope-" Name="ForceConformanceInForLoopScope" DisplayName="Force Conformance in For Loop Scope" Description="Used to implement standard C++ behavior for the for statement loops with Microsoft extensions (/Za, /Ze (Disable Language Extensions)). /Zc:forScope is on by default." Category="Language" Switch="Zc:forScope" F1Keyword="VC.Project.VCCLCompilerTool.ForceConformanceInForLoopScope">
  </BoolProperty>
  <BoolProperty ReverseSwitch="GR-" Name="RuntimeTypeInfo" DisplayName="Enable Run-Time Type Information" Description="Adds code for checking C++ object types at run time (runtime type information).     (/GR, /GR-)" Category="Language" Switch="GR" F1Keyword="VC.Project.VCCLCompilerTool.RuntimeTypeInfo">
  </BoolProperty>
  <BoolProperty ReverseSwitch="openmp-" Name="OpenMPSupport" DisplayName="Open MP Support" Description="Enable OpenMP 2.0 language extensions.     (/openmp)" Category="Language" Switch="openmp" F1Keyword="VC.Project.VCCLCompilerTool.OpenMP">
  </BoolProperty>
  <EnumProperty Name="PrecompiledHeader" DisplayName="Precompiled Header" Description="Create/Use Precompiled Header : Enables creation or use of a precompiled header during the build.     (/Yc, /Yu)" Category="Precompiled Headers" F1Keyword="VC.Project.VCCLCompilerTool.UsePrecompiledHeader">
    <EnumValue Name="Create" Switch="Yc" DisplayName="Create" Description="Instructs the compiler to create a precompiled header (.pch) file that represents the state of compilation at a certain point.">
      <Argument Property="PrecompiledHeaderFile" IsRequired="false" />
    </EnumValue>
    <EnumValue Name="Use" Switch="Yu" DisplayName="Use" Description="Instructs the compiler to use an existing precompiled header (.pch) file in the current compilation.">
      <Argument Property="PrecompiledHeaderFile" IsRequired="false" />
    </EnumValue>
    <EnumValue Name="NotUsing" Switch="" DisplayName="Not Using Precompiled Headers" Description="Not using precompiled headers. ">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="file" Name="PrecompiledHeaderFile" DisplayName="Precompiled Header File" Description="Specifies header file name to use when creating or using a precompiled header file. (/Yc[name], /Yu[name])" Category="Precompiled Headers" F1Keyword="VC.Project.VCCLCompilerTool.PrecompiledHeaderThrough">
  </StringProperty>
  <StringProperty Subtype="file" Name="PrecompiledHeaderOutputFile" DisplayName="Precompiled Header Output File" Description="Specifies the path and/or name of the generated precompiled header file. (/Fp[name])" Category="Precompiled Headers" Switch="Fp" F1Keyword="VC.Project.VCCLCompilerTool.PrecompiledHeaderFile">
  </StringProperty>
  <BoolProperty Name="ExpandAttributedSource" DisplayName="Expand Attributed Source" Description="Create listing file with expanded attributes injected into source file.     (/Fx)" Category="Output Files" Switch="Fx" F1Keyword="VC.Project.VCCLCompilerTool.ExpandAttributedSource">
  </BoolProperty>
  <EnumProperty Name="AssemblerOutput" DisplayName="Assembler Output" Description="Specifies the contents of assembly language output file.     (/FA, /FAc, /FAs, /FAcs)" Category="Output Files" F1Keyword="VC.Project.VCCLCompilerTool.AssemblerOutput">
    <EnumValue Name="NoListing" Switch="" DisplayName="No Listing" Description="No listing. ">
    </EnumValue>
    <EnumValue Name="AssemblyCode" Switch="FA" DisplayName="Assembly-Only Listing" Description="Assembly code; .asm">
    </EnumValue>
    <EnumValue Name="AssemblyAndMachineCode" Switch="FAc" DisplayName="Assembly With Machine Code" Description="Machine and assembly code; .cod">
    </EnumValue>
    <EnumValue Name="AssemblyAndSourceCode" Switch="FAs" DisplayName="Assembly With Source Code" Description="Source and assembly code; .asm">
    </EnumValue>
    <EnumValue Name="All" Switch="FAcs" DisplayName="Assembly, Machine Code and Source" Description="Assembly, machine code and source code; .cod">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="file" Name="AssemblerListingLocation" DisplayName="ASM List Location" Description="Specifies relative path and/or name for ASM listing file; can be file or directory name.     (/Fa[name])" Category="Output Files" Switch="Fa" F1Keyword="VC.Project.VCCLCompilerTool.AssemblerListingLocation">
  </StringProperty>
  <StringProperty Subtype="file" Name="ObjectFileName" DisplayName="Object File Name" Description="Specifies a name to override the default object file name; can be file or directory name.     (/Fo[name])" Category="Output Files" Switch="Fo" F1Keyword="VC.Project.VCCLCompilerTool.ObjectFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="ProgramDataBaseFileName" DisplayName="Program Database File Name" Description="Specifies a name for a compiler-generated PDB file; also specifies base name for the required compiler-generated IDB file; can be file or directory name.     (/Fd[name])" Category="Output Files" Switch="Fd" F1Keyword="VC.Project.VCCLCompilerTool.ProgramDataBaseFileName">
  </StringProperty>
  <BoolProperty Name="GenerateXMLDocumentationFiles" DisplayName="Generate XML Documentation Files" Description="Specifies that the compiler should generate XML documentation comment files (.XDC).     (/doc)" Category="Output Files" Switch="doc" F1Keyword="VC.Project.VCCLCompilerTool.GenerateXMLDocumentationFiles">
    <Argument Property="XMLDocumentationFileName" IsRequired="false" />
  </BoolProperty>
  <StringProperty Subtype="file" Name="XMLDocumentationFileName" DisplayName="XML Documentation File Name" Description="Specifies the name of the generated XML documentation files; can be file or directory name.     (/doc[name])" Category="Output Files" F1Keyword="VC.Project.VCCLCompilerTool.XMLDocumentationFileName">
  </StringProperty>
  <BoolProperty Name="BrowseInformation" DisplayName="Enable Browse Information" Description="Enable Browse Information : Specifies level of browse information in .bsc file.     (/FR)" Category="Browse Information" Switch="FR" F1Keyword="VC.Project.VCCLCompilerTool.BrowseInformation">
    <Argument Property="BrowseInformationFile" IsRequired="false" />
  </BoolProperty>
  <StringProperty Subtype="file" Name="BrowseInformationFile" DisplayName="Browse Information File" Description="Browse File : Specifies optional name for browser information file.     (/FR[name])" Category="Browse Information" F1Keyword="VC.Project.VCCLCompilerTool.BrowseInformationFile">
  </StringProperty>
  <EnumProperty Name="CallingConvention" DisplayName="Calling Convention" Description="Select the default calling convention for your application (can be overridden by function).     (/Gd, /Gr, /Gz)" Category="Advanced" F1Keyword="VC.Project.VCCLCompilerTool.CallingConvention">
    <EnumValue Name="Cdecl" Switch="Gd" DisplayName="__cdecl" Description="Specifies the __cdecl calling convention for all functions except C++ member functions and functions marked __stdcall or __fastcall.">
    </EnumValue>
    <EnumValue Name="FastCall" Switch="Gr" DisplayName="__fastcall" Description="Specifies the __fastcall calling convention for all functions except C++ member sfunctions and functions marked __cdecl or __stdcall. All __fastcall functions must have prototypes.">
    </EnumValue>
    <EnumValue Name="StdCall" Switch="Gz" DisplayName="__stdcall" Description="Specifies the __stdcall calling convention for all functions except C++ member functions and functions marked __cdecl or __fastcall. All __stdcall functions must have prototypes.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="CompileAs" DisplayName="Compile As" Description="Select compile language option for .c and .cpp files.     (/TC, /TP)" Category="Advanced" F1Keyword="VC.Project.VCCLCompilerTool.CompileAs">
    <EnumValue Name="Default" Switch="" DisplayName="Default" Description="Default.">
    </EnumValue>
    <EnumValue Name="CompileAsC" Switch="TC" DisplayName="Compile as C Code" Description="Compile as C Code">
    </EnumValue>
    <EnumValue Name="CompileAsCpp" Switch="TP" DisplayName="Compile as C++ Code" Description="Compile as C++ Code">
    </EnumValue>
  </EnumProperty>
  <StringListProperty Name="DisableSpecificWarnings" DisplayName="Disable Specific Warnings" Description="Disable the desired warning numbers; put numbers in a semi-colon delimited list.     (/wd[num])" Category="Advanced" Switch="wd" F1Keyword="VC.Project.VCCLCompilerTool.DisableSpecificWarnings">
  </StringListProperty>
  <StringListProperty Subtype="file" Name="ForcedIncludeFiles" DisplayName="Forced Include File" Description="one or more forced include files.     (/FI[name])" Category="Advanced" Switch="FI" F1Keyword="VC.Project.VCCLCompilerTool.ForcedIncludeFiles">
  </StringListProperty>
  <StringListProperty Subtype="file" Name="ForcedUsingFiles" DisplayName="Forced #using File" Description="Specifies one or more forced #using files.     (/FU[name])" Category="Advanced" Switch="FU" F1Keyword="VC.Project.VCCLCompilerTool.ForcedUsingFiles">
  </StringListProperty>
  <BoolProperty Name="ShowIncludes" DisplayName="Show Includes" Description="Generates a list of include files with compiler output.     (/showIncludes)" Category="Advanced" Switch="showIncludes" F1Keyword="VC.Project.VCCLCompilerTool.ShowIncludes">
  </BoolProperty>
  <BoolProperty ReverseSwitch="analyze-" Name="EnablePREfast" DisplayName="Enable Code Analysis" Description="Enables code analysis functionality that identifies common coding defects in C/C++ code.     (/analyze)" Category="Advanced" Switch="analyze" Visible="false" F1Keyword="VC.Project.VCCLCompilerTool.EnablePREfast">
  </BoolProperty>
  <BoolProperty Name="UseFullPaths" DisplayName="Use Full Paths" Description="Use full paths in diagnostic messages.     (/FC)" Category="Advanced" Switch="FC" F1Keyword="VC.Project.VCCLCompilerTool.UseFullPaths">
  </BoolProperty>
  <BoolProperty Name="OmitDefaultLibName" DisplayName="Omit Default Library Name" Description="Do not include default library names in .obj files.     (/Zl)" Category="Advanced" Switch="Zl" F1Keyword="VC.Project.VCCLCompilerTool.OmitDefaultLibName">
  </BoolProperty>
  <EnumProperty Name="ErrorReporting" DisplayName="Internal Compiler Error Reporting" Description="Specifies how internal tool errors should be reported back to Microsoft.  The default in the IDE is prompt.  The default from command line builds is queue.     (/errorReport:[method])" Category="Advanced" F1Keyword="VC.Project.VCCLCompilerTool.ErrorReporting">
    <EnumValue Name="None" Switch="errorReport:none" DisplayName="Do Not Send Report" Description="Reports about internal compiler errors will not be collected or sent to Microsoft.">
    </EnumValue>
    <EnumValue Name="Prompt" Switch="errorReport:prompt" DisplayName="Prompt Immediately" Description="Prompts you to send a report when you receive an internal compiler error.">
    </EnumValue>
    <EnumValue Name="Queue" Switch="errorReport:queue" DisplayName="Queue For Next Login" Description="Queues the error report. When you log in with administrator privileges, a pop-up window is displayed and allows you to report any failures since the last time you were logged in (you will not be prompted to send reports for failures more than once every three days). queue is the default when compiling an application at the command line.">
    </EnumValue>
    <EnumValue Name="Send" Switch="errorReport:send" DisplayName="Send Automatically" Description="Automatically sends reports of internal compiler errors to Microsoft. To enable this option, you must first agree to Microsoft%27s data collection policy. The first time you specify /errorReport:send on a computer, a compiler message will refer you to a website that contains Microsoft%27s data collection policy.">
    </EnumValue>
  </EnumProperty>
  <StringListProperty Name="TreatSpecificWarningsAsErrors" DisplayName="Treat Specific Warnings As Errors" Description="Treats the specific compiler warning as an error where n is a compiler warning." Category="Advanced" Switch="we" F1Keyword="VC.Project.VCCLCompilerTool.TreatSpecificWarningsAsErrors">
  </StringListProperty>
  <BoolProperty Name="UseUnicodeForAssemblerListing" DisplayName="Use Unicode For Assembler Listing" Description="Causes the output file to be created in UTF-8 format. " Switch="FAu" F1Keyword="VC.Project.VCCLCompilerTool.UseUnicodeForAssemblerListing">
  </BoolProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
  <BoolProperty Name="BuildingInIDE" Visible="false">
  </BoolProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\custom_build_tool.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="ConfigurationCustomBuildTool" 
      DisplayName="Custom Build Tool" 
      Order="110" 
      PageTemplate="tool"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="CustomBuild" HasConfigurationCondition="true"  />
  </Rule.DataSource>
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
  </Rule.Categories>
  <StringProperty Name="Command" Category="General" DisplayName="Command Line" Description="Specifies a command line for the custom build tool." F1Keyword="VC.Project.VCCustomBuildTool.Command" >
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="Message" Category="General" DisplayName="Description" Description="Specifies a description for the custom build tool." F1Keyword="VC.Project.VCCustomBuildTool.Message" />
  <StringListProperty Name="Outputs" Category="General" DisplayName="Outputs" Description="Specifies the output files the custom build tool generates." F1Keyword="VC.Project.VCCustomBuildTool.Outputs" />
  <StringListProperty Name="AdditionalInputs" Category="General" DisplayName="Additional Dependencies" Description="Specifies any additional input files to use for the custom build tool." F1Keyword="VC.Project.VCCustomBuildTool.AdditionalInputs" />
  <StringListProperty Name="CustomBuildToolAfterTargets" Category="General" DisplayName="Execute After" F1Keyword="VC.Project.VCCustomBuildTool.CustomBuildToolAfterTargets" ReadOnly="true"
                      Description="Specifies the targets for the custom build tool to run after.  This is always the same as the Custom Build Step and must be set there.">
    <StringListProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="" />
    </StringListProperty.DataSource>
  </StringListProperty>
  <StringListProperty Name="CustomBuildToolBeforeTargets" Category="General" DisplayName="Execute Before" F1Keyword="VC.Project.VCCustomBuildTool.CustomBuildToolBeforeTargets" ReadOnly="true"
                      Description="Specifies the targets for the custom build tool to run before.  This is always the same as the Custom Build Step and must be set there.">
    <StringListProperty.DataSource>
      <DataSource Persistence="ProjectFile" HasConfigurationCondition="true" ItemType="" />
    </StringListProperty.DataSource>
  </StringListProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\debugger_mpi_cluster.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<Rule Name="MpiClusterDebugger" 
      DisplayName="MPI Cluster Debugger" 
      Description="MPI Cluster Debugger options" 
      PageTemplate="debugger" 
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="UserFile">
    </DataSource>
  </Rule.DataSource>
  <StringProperty Name="MpiDebuggerSchedulerNode" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerSchedulerNode" DisplayName="Run Environment" Description="String that includes the head node, number of processes, and the allocation of processes to machines, if specified." Subtype="HpcNode">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Edit Hpc Node...&gt;" EditorType="HpcNodeEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerDeploymentDirectory" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerDeploymentDirectory" DisplayName="Deployment Directory" Description="Directory where the project output files will be placed to facilitate debugger startup. This should be a network share." Subtype="folder" />
  <StringProperty Name="MpiDebuggerWorkingDirectory" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerWorkingDirectory" DisplayName="Working Directory" Description="Working directory used by each process. If not specified the default is the project output directory (for local debugging); %tmp% (for cluster debugging)." Subtype="folder" />
  <StringProperty Name="MpiDebuggerApplicationCommand" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerApplicationCommand" DisplayName="Application Command" Description="Application name or the application path on the local machine." Default="$(TargetFileName)">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Edit...&gt;" EditorType="DefaultStringPropertyEditor" />
      <ValueEditor DisplayName="&lt;Browse...&gt;" EditorType="DefaultFilePropertyEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerApplicationArguments" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerApplicationArguments" DisplayName="Application Arguments" Description="Arguments to be passed to the application." />
  <StringProperty Name="MpiDebuggerShimLocation" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerShimLocation" DisplayName="MPIShim Location" Description="Location of MPIShim executable on local machine.">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Browse...&gt;" EditorType="DefaultFilePropertyEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerMpiExecCommand" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerMpiExecCommand" DisplayName="MPIExec Command" Description="Application used to launch the MPI processes (typically named MPIExec).">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Browse...&gt;" EditorType="DefaultFilePropertyEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerAdditionalMpiExecArguments" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerAdditionalMpiExecArguments" DisplayName="Additional MPIExec Arguments" Description="Additional arguments to the MPIExec command." />
  <EnumProperty Name="MpiDebuggerNetworkSecurityMode" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerNetworkSecurityMode" DisplayName="MPI Network Security Mode" Description="IP addresses allowed to connect to the current instance of the Visual Studio IDE.">
    <EnumValue Name="LocalSubnet" DisplayName="Accept connections from a local subnet only" Description="Accept connections from a local subnet only" />
    <EnumValue Name="SpecifiedRange" DisplayName="Accept connections from a specified range of addresses" Description="Accept connections from a specified range of addresses" />
    <EnumValue Name="AnyAddress" DisplayName="Accept connections from any address" Description="Accept connections from any address" />
  </EnumProperty>
  <StringProperty Name="MpiDebuggerNetworkFilter" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerNetworkFilter" DisplayName="MPI Network Filter" Description="IP address mask from which to accept connections (if MPI Network Security Mode is set to 'Accept connections from a specified range of addresses' above)." />
  <EnumProperty Name="MpiDebuggerDebuggerType" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerDebuggerType" DisplayName="Debugger Type" Description="Specifies the debugger type to use. When set to Auto, the debugger type will be selected based on contents of the exe file.">
    <EnumValue Name="NativeOnly" DisplayName="Native Only" Description="Native Only" />
    <EnumValue Name="ManagedOnly" DisplayName="Managed Only" Description="Managed Only" />
    <EnumValue Name="Mixed" DisplayName="Mixed" Description="Mixed" />
    <EnumValue Name="Auto" DisplayName="Auto" Description="Auto" />
    <EnumValue Name="Script" DisplayName="Script" Description="Script" />
  </EnumProperty>
  <StringProperty Name="MpiDebuggerJobDescriptionFile" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerJobDescriptionFile" DisplayName="Job Description File" Description="Job description file containing tasks for the job submitted to the cluster.">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Edit...&gt;" EditorType="DefaultStringPropertyEditor" />
      <ValueEditor DisplayName="&lt;Browse...&gt;" EditorType="DefaultFilePropertyEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerAdditionalFileToDeploy" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerAdditionalFileToDeploy" DisplayName="Additional Files to Deploy" Description="Files and directories to be copied to the deployment directory, in addition to those required by the project and its dependencies.">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Edit File...&gt;" EditorType="HpcFileEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <IntProperty Name="MpiDebuggerSchedulerTimeout" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerSchedulerTimeout" DisplayName="Scheduler Timeout (ms)" Description="Timeout limit in milliseconds after which Visual Studio will  /stop attempting to contact a head node." Default="5000" />
  <BoolProperty Name="MpiDebuggerDeployCommonRuntime" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerDeployCommonRuntime" DisplayName="Deploy CRT" Description="Whether Visual Studio will deploy the CRT assemblies." Default="true" />
  <BoolProperty Name="MpiDebuggerCleanupDeployment" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerCleanupDeployment" DisplayName="Cleanup Deployment" Description="Whether Visual Studio will delete deployed files and directories after debugging terminates." Default="true" />
  <StringProperty Name="MpiDebuggerPreDebugScript" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerPreDebugScript" DisplayName="Pre-Debug Script" Description="Script that will run (on the same machine as Visual Studio), before debugging starts.">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Edit...&gt;" EditorType="DefaultStringPropertyEditor" />
      <ValueEditor DisplayName="&lt;Browse...&gt;" EditorType="DefaultFilePropertyEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerPreDebugScriptArguments" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerPreDebugScriptArguments" DisplayName="Pre-Debug Script Arguments" Description="Argument string that is passed to the Pre-Debug Script." />
  <StringProperty Name="MpiDebuggerPostDebugScript" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerPostDebugScript" DisplayName="Post-Debug Script" Description="Script that will run (on the same machine as Visual Studio), after debugging stops.">
    <StringProperty.ValueEditors>
      <ValueEditor DisplayName="&lt;Edit...&gt;" EditorType="DefaultStringPropertyEditor" />
      <ValueEditor DisplayName="&lt;Browse...&gt;" EditorType="DefaultFilePropertyEditor" />
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="MpiDebuggerPostDebugScriptArguments" F1Keyword="VC.Project.IVCMPIClusterDebuggerPageObject.MpiDebuggerPostDebugScriptArguments" DisplayName="Post-Debug Script Arguments" Description="Argument string that is passed to the Post-Debug Script." />
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\debugger_local_windows.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="WindowsLocalDebugger"
      DisplayName="Local Windows Debugger"
      PageTemplate="debugger"
      Description="Local Windows Debugger options"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="UserFile" />
  </Rule.DataSource>
  <StringProperty Name="LocalDebuggerCommand" DisplayName="Command"
                  Description="The debug command to execute."
                  F1Keyword="VC.Project.IVCLocalDebugPageObject.Command">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultFindFullPathPropertyEditor" DisplayName="&lt;regsvr32.exe&gt;">
        <ValueEditor.Metadata>
          <NameValuePair Name="Exename" Value="regsvr32.exe" />
        </ValueEditor.Metadata>
      </ValueEditor>
      <ValueEditor EditorType="DefaultStringPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
      <ValueEditor EditorType="DefaultFilePropertyEditor" DisplayName="&lt;Browse...&gt;"/>
    </StringProperty.ValueEditors>
  </StringProperty>
    
  <StringProperty Name="LocalDebuggerCommandArguments" DisplayName="Command Arguments"
                  Description="The command line arguments to pass to the application."
                  F1Keyword="VC.Project.IVCLocalDebugPageObject.CommandArguments">
    <Argument Property="LocalDebuggerCommand" />
  </StringProperty>
  <StringProperty Name="LocalDebuggerWorkingDirectory" DisplayName="Working Directory"
                Description="The application's working directory. By default, the directory containing the project file."
                Subtype="folder"
                F1Keyword="VC.Project.IVCLocalDebugPageObject.WorkingDirectory"/>
  <BoolProperty Name="LocalDebuggerAttach" DisplayName="Attach"
                Description="Specifies whether the debugger should attempt to attach to an existing process when debugging starts."
                F1Keyword="VC.Project.IVCLocalDebugPageObject.Attach"/>
  <EnumProperty Name="LocalDebuggerDebuggerType" DisplayName="Debugger Type"
                Description="Specifies the debugger type to use. When set to Auto, the debugger type will be selected based on contents of the exe file."
                F1Keyword="VC.Project.IVCLocalDebugPageObject.DebuggerType">
    <EnumValue Name="NativeOnly" DisplayName="Native Only" Description="Native Only" />
    <EnumValue Name="ManagedOnly" DisplayName="Managed Only" Description="Managed Only" />
    <EnumValue Name="Mixed" DisplayName="Mixed" Description="Mixed" />
    <EnumValue Name="Auto" DisplayName="Auto" Description="Auto" />
    <EnumValue Name="Script" DisplayName="Script" Description="Script" />
  </EnumProperty>
  <StringListProperty Name="LocalDebuggerEnvironment" DisplayName="Environment"
                      Description="Specifies the environment for the debugee, or variables to merge with existing environment."
                      Separator="&#xA;"
                      F1Keyword="VC.Project.IVCLocalDebugPageObject.Environment"/>
  <BoolProperty Name="LocalDebuggerMergeEnvironment" DisplayName="Merge Environment"
                Description="Merge specified environment variables with existing environment."
                F1Keyword="VC.Project.IVCLocalDebugPageObject.EnvironmentMerge"/>
  <BoolProperty Name="LocalDebuggerSQLDebugging" DisplayName="SQL Debugging"
                Description="Attach the SQL debugger."
                F1Keyword="VC.Project.IVCLocalDebugPageObject.SQLDebugging"/>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\debugger_general.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="DebuggerGeneralProperties"
      DisplayName="Debugger General Properties"
      Description="General Debugger options"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="UserFile" />
  </Rule.DataSource>
  
  <StringProperty Name="SymbolsPath" DisplayName="Symbol Search Path"
                  Description="The search path used by the debugger to locate symbols.">
  </StringProperty>

  <StringProperty Name="DebuggerFlavor" Visible="false"
                  Description="The debug rule selected as the active debugger.">
  </StringProperty>

  <EnumProperty Name="ImageClrType" Visible="false"
                  Description="The 'hidden' property we pass to debuggers to let them know if this is a managed project.">
    <EnumProperty.DataSource>
      <DataSource Persistence="UserFile" HasConfigurationCondition="false" PersistedName="_TargetImageClrType" />
    </EnumProperty.DataSource>
    <EnumValue Name="Native" DisplayName="Native Image" Description="The executable image to debug is a fully native application." />
    <EnumValue Name="Mixed" DisplayName="Mixed Image" Description="The executable image to debug is a mixture of native and managed code." />
    <EnumValue Name="Managed" DisplayName="Managed Image" Description="The executable image to debug is a fully managed application." />
  </EnumProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\debugger_web_browser.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="WebBrowserDebugger"
      DisplayName="Web Browser Debugger"
      PageTemplate="debugger"
      Description="Web Browser Debugger options"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="UserFile" />
  </Rule.DataSource>
  <StringProperty Name="WebBrowserDebuggerHttpUrl" DisplayName="HTTP URL"
                Description="Specifies the URL for the project."
                  F1Keyword="VC.Project.VCDebugSettings.WebBrowser.WebBrowserDebuggerHttpUrl" />
  <EnumProperty Name="WebBrowserDebuggerDebuggerType" DisplayName="Debugger Type"
                Description="Specifies the debugger type to use. When set to Auto, the debugger type will be selected based on contents of the exe file."
                F1Keyword="VC.Project.VCDebugSettings.WebBrowser.DebuggerType" >
    <EnumValue Name="NativeOnly" DisplayName="Native Only" Description="Native Only" />
    <EnumValue Name="ManagedOnly" DisplayName="Managed Only" Description="Managed Only" />
    <EnumValue Name="Mixed" DisplayName="Mixed" Description="Mixed" />
    <EnumValue Name="Auto" DisplayName="Auto" Description="Auto" />
    <EnumValue Name="Script" DisplayName="Script" Description="Script" />
  </EnumProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\debugger_web_service.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="WebServiceDebugger"
      DisplayName="Web Service Debugger"
      PageTemplate="debugger"
      Description="Web Service Debugger options"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="UserFile" />
  </Rule.DataSource>
  <StringProperty Name="WebServiceDebuggerHttpUrl" DisplayName="HTTP URL"
                Description="Specifies the URL for the project."
                F1Keyword="VC.Project.IVCWebSvcDebugPageObject.HttpUrl"/>
  <EnumProperty Name="WebServiceDebuggerDebuggerType" DisplayName="Debugger Type"
                Description="Specifies the debugger type to use. When set to Auto, the debugger type will be selected based on contents of the exe file."
                F1Keyword="VC.Project.IVCWebSvcDebugPageObject.DebuggerType">
    <EnumValue Name="NativeOnly" DisplayName="Native Only" Description="Native Only" />
    <EnumValue Name="ManagedOnly" DisplayName="Managed Only" Description="Managed Only" />
    <EnumValue Name="Mixed" DisplayName="Mixed" Description="Mixed" />
    <EnumValue Name="Auto" DisplayName="Auto" Description="Auto" />
    <EnumValue Name="Script" DisplayName="Script" Description="Script" />
  </EnumProperty>
  <BoolProperty Name="WebServiceDebuggerSQLDebugging" DisplayName="SQL Debugging"
                Description="Attach the SQL debugger."
                F1Keyword="VC.Project.IVCWebSvcDebugPageObject.SQLDebugging"/>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\envvars.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="VCEnvironmentVariables"
      DisplayName="VC++ Environment Variables"
      Order="8"
      PageTemplate="generic"
      Description="Tool search directories"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="Env" DisplayName="Environment" Description="Visual C++ Environment Variables" />
    <Category Name="Dirs" DisplayName="Directories" Description="Visual C++ Directories" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" />
  </Rule.DataSource>
  <StringListProperty Name="Path" DisplayName="PATH"
                      Description="Path to use when searching for executable files while building a VC++ project.  Corresponds to environment variable PATH."
                      F1Keyword="VC.Project.UseEnvVars.Path"
                      Category="Env" Separator=";" ReadOnly="true" />
  <StringListProperty Name="Include" DisplayName="INCLUDE"
                      Description="Path to use when searching for include files while building a VC++ project.  Corresponds to environment variable INCLUDE."
                      F1Keyword="VC.Project.UseEnvVars.Include"
                      Category="Env" Separator=";" ReadOnly="true" />
  <StringListProperty Name="LibPath" DisplayName="LIBPATH"
                      Description="Path to use when searching for files brought in via #using while building a VC++ project.  Corresponds to environment variable LIBPATH."
                      F1Keyword="VC.Project.UseEnvVars.ReferencePath"
                      Category="Env" Separator=";" ReadOnly="true" />
  <StringListProperty Name="Lib" DisplayName="LIB"
                      Description="Path to use when searching for library files while building a VC++ project.  Corresponds to environment variable LIB."
                      F1Keyword="VC.Project.UseEnvVars.LibraryPath"
                      Category="Env" Separator=";" ReadOnly="true" />
  <StringListProperty Name="SourcePath" DisplayName="Source Directories"
                      Description="Path to use when searching for source files to use for Intellisense."
                      F1Keyword="VC.Project.VCDirectories.SourcePath"
                      Category="Dirs" Separator=";" Subtype="folder" />
  <StringListProperty Name="ExcludePath" DisplayName="Exclude Directories"
                      Description="Path to skip when searching for scan dependencies."
                      F1Keyword="VC.Project.UseEnvVars.ExcludePath"
                      Category="Dirs" Separator=";" Subtype="folder" />
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\debugger_remote_windows.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="WindowsRemoteDebugger"
      DisplayName="Remote Windows Debugger"
      PageTemplate="debugger"
      Description="Remote Windows Debugger options"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="UserFile" />
  </Rule.DataSource>
  <StringProperty Name="RemoteDebuggerCommand" DisplayName="Remote Command"
                Description="The debug command to execute." 
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.RemoteCommand"/>
  <StringProperty Name="RemoteDebuggerCommandArguments" DisplayName="Remote Command Arguments"
                Description="The command line arguments to pass to the application."
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.CommandArguments">
    <Argument Property="RemoteDebuggerCommand" />
  </StringProperty>
  <StringProperty Name="RemoteDebuggerWorkingDirectory" DisplayName="Working Directory"
                Description="The application's working directory. By default, the directory containing the project file."
                Subtype="folder" 
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.WorkingDirectory"/>
  <StringProperty Name="RemoteDebuggerServerName" DisplayName="Remote Server Name"
                Description="Specifies a remote server name."
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.RemoteMachine"/>
  <EnumProperty Name="RemoteDebuggerConnection" DisplayName="Connection"
                Description="Specifies the connection type."
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.Remote">
    <EnumValue Name="RemoteWithAuthentication" DisplayName="Remote with Windows authentication"
               Description="Remote with Windows authentication" />
    <EnumValue Name="RemoteWithoutAuthentication" DisplayName="Remote with no authentication (Native only)"
               Description="Remote with no authentication (Native only)" />
  </EnumProperty>
  <EnumProperty Name="RemoteDebuggerDebuggerType" DisplayName="Debugger Type"
                Description="Specifies the debugger type to use. When set to Auto, the debugger type will be selected based on contents of the exe file."
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.DebuggerType">
    <EnumValue Name="NativeOnly" DisplayName="Native Only" Description="Native Only" />
    <EnumValue Name="ManagedOnly" DisplayName="Managed Only" Description="Managed Only" />
    <EnumValue Name="Mixed" DisplayName="Mixed" Description="Mixed" />
    <EnumValue Name="Auto" DisplayName="Auto" Description="Auto" />
    <EnumValue Name="Script" DisplayName="Script" Description="Script" />
  </EnumProperty>
  <BoolProperty Name="RemoteDebuggerAttach" DisplayName="Attach"
                Description="Specifies whether the debugger should attempt to attach to an existing process when debugging starts."
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.Attach"/>
  <BoolProperty Name="RemoteDebuggerSQLDebugging" DisplayName="SQL Debugging"
                Description="Attach the SQL debugger."
                F1Keyword="VC.Project.IVCRemoteDebugPageObject.SQLDebugging"/>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\directories.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="ConfigurationDirectories"
      DisplayName="VC++ Directories"
      Order="8"
      PageTemplate="generic"
      Description="Tool search directories"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="VC++" DisplayName="General" Description="Visual C++ Directories" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" />
  </Rule.DataSource>
  <StringListProperty Name="ExecutablePath" DisplayName="Executable Directories"
                      Description="Path to use when searching for executable files while building a VC++ project.  Corresponds to environment variable PATH."
                      F1Keyword="VC.Project.VCDirectories.ExecutablePath"
                      Category="VC++" Separator=";" Subtype="folder" />
  <StringListProperty Name="IncludePath" DisplayName="Include Directories"
                      Description="Path to use when searching for include files while building a VC++ project.  Corresponds to environment variable INCLUDE."
                      F1Keyword="VC.Project.VCDirectories.IncludePath"
                      Category="VC++" Separator=";" Subtype="folder" />
  <StringListProperty Name="ReferencePath" DisplayName="Reference Directories"
                      Description="Path to use when searching for files brought in via #using while building a VC++ project.  Corresponds to environment variable LIBPATH."
                      F1Keyword="VC.Project.VCDirectories.ReferencePath"
                      Category="VC++" Separator=";" Subtype="folder" />
  <StringListProperty Name="LibraryPath" DisplayName="Library Directories"
                      Description="Path to use when searching for library files while building a VC++ project.  Corresponds to environment variable LIB."
                      F1Keyword="VC.Project.VCDirectories.LibraryPath"
                      Category="VC++" Separator=";" Subtype="folder" />
  <StringListProperty Name="SourcePath" DisplayName="Source Directories"
                      Description="Path to use when searching for source files to use for Intellisense."
                      F1Keyword="VC.Project.VCDirectories.SourcePath"
                      Category="VC++" Separator=";" Subtype="folder" />
  <StringListProperty Name="ExcludePath" DisplayName="Exclude Directories"
                      Description="Path to skip when searching for scan dependencies."
                      F1Keyword="VC.Project.VCDirectories.ExcludePath"
                      Category="VC++" Separator=";" Subtype="folder" />
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\general.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="ConfigurationGeneral"
      DisplayName="General"
      PageTemplate="generic"
      Description="General"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
    <Category Name="ProjectDefaults" DisplayName="Project Defaults" Description="Project Defaults" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" Label="Configuration" />
  </Rule.DataSource>
  <StringProperty Name="OutDir" DisplayName="Output Directory"
                  Description="Specifies a relative path to the output file directory; can include environment variables."
                  Category="General" Default="$(SolutionDir)$(Configuration)\"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.OutputDirectory">
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="IntDir" DisplayName="Intermediate Directory"
                  Description="Specifies a relative path to the intermediate file directory; can include environment variables."
                  Category="General" Default="$(Configuration)\"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.IntermediateDirectory">
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="TargetName" DisplayName="Target Name"
                  Description="Specifies a file name that this project will generate."
                  F1Keyword="VC.Project.VCConfiguration.TargetName"
                  Category="General" Default="$(ProjectName)"
                  >
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="TargetExt" DisplayName="Target Extension"
                  Description="Specifies a file extension that this project will generate. (Example: .exe or .dll)"
                  F1Keyword="VC.Project.VCConfiguration.TargetExt"
                  Category="General"
                  >
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringListProperty Name="ExtensionsToDeleteOnClean" DisplayName="Extensions to Delete on Clean"
                      Description="Semi-colon delimited wildcard specification for which files in the intermediate directory to delete on clean or rebuild."
                      Category="General" Separator=";"
                      F1Keyword="VC.Project.VCConfiguration.DeleteExtensionsOnClean">
                      <StringListProperty.DataSource>
                            <DataSource Persistence="ProjectFile" Label="" />
                      </StringListProperty.DataSource>
  </StringListProperty>
  <StringProperty Name="BuildLogFile" DisplayName="Build Log File"
                  Description="Specifies the build log file to write to when build logging is enabled."
                  F1Keyword="VC.Project.VCConfiguration.BuildLogFile"
                  Category="General" Default="$(ProjectDir)\$(MSBuildProjectName).log"
                  Subtype="file">
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" ItemType="BuildLog" PersistedName="Path" />
                  </StringProperty.DataSource>
  </StringProperty>
  <!-- There is no InheritProjectPropertySheets in the project file. The property sheets will be expressed as explicit Imports.
  <StringListProperty Name="InheritProjectPropertySheets" DisplayName="Inherit Project Property Sheets"
                      Description="Specifies the project property sheets this configuration or property sheet inherits from."
                      Category="General" Separator=";" Subtype="file" /> -->
  <DynamicEnumProperty Name="PlatformToolset" DisplayName="Platform Toolset" EnumProvider="Toolsets"
                       Description="Specifies the toolset used for building the current configuration; If not set, the default toolset is used"
                       F1Keyword="VC.Project.VCConfiguration.PlatformToolset"
                       Category="General" />
  <EnumProperty Name="ConfigurationType" DisplayName="Configuration Type"
                Description="Specifies the type of output this configuration generates."
                Category="ProjectDefaults"
                F1Keyword="VC.Project.VCConfiguration.ConfigurationType">
    <EnumValue Name="Makefile" DisplayName="Makefile" Description="Makefile" />
    <EnumValue Name="Application" DisplayName="Application (.exe)" Description="Application (.exe)" />
    <EnumValue Name="DynamicLibrary" DisplayName="Dynamic Library (.dll)" Description="Dynamic Library (.dll)" />
    <EnumValue Name="StaticLibrary" DisplayName="Static library (.lib)" Description="Static Library (.lib)" />
    <EnumValue Name="Utility" DisplayName="Utility" Description="Utility" />
  </EnumProperty>
  <EnumProperty Name="UseOfMfc" DisplayName="Use of MFC"
                Description="Specifies how MFC is used by the configuration."
                Category="ProjectDefaults"
                F1Keyword="VC.Project.VCConfiguration.useOfMfc">
    <EnumValue Name="false" DisplayName="Use Standard Windows Libraries" Description="Use Standard Windows Libraries" />
    <EnumValue Name="Static" DisplayName="Use MFC in a Static Library" Description="Use MFC in a Static Library" />
    <EnumValue Name="Dynamic" DisplayName="Use MFC in a Shared DLL" Description="Use MFC in a Shared DLL" />
  </EnumProperty>
  <EnumProperty Name="UseOfAtl" DisplayName="Use of ATL"
                Description="Specifies how ATL is used by the configuration."
                Category="ProjectDefaults"
                F1Keyword="VC.Project.VCConfiguration.useOfATL">
    <EnumValue Name="false" DisplayName="Not Using ATL" Description="Not Using ATL" />
    <EnumValue Name="Static" DisplayName="Static Link to ATL" Description="Static Link to ATL" />
    <EnumValue Name="Dynamic" DisplayName="Dynamic Link to ATL" Description="Dynamic Link to ATL" />
  </EnumProperty>
  <EnumProperty Name="CharacterSet" DisplayName="Character Set"
                Description="Tells the compiler to use the specified character set; aids in localization issues."
                Category="ProjectDefaults"
                F1Keyword="VC.Project.VCConfiguration.CharacterSet">
    <EnumValue Name="NotSet" DisplayName="Not Set" Description="Not Set" />
    <EnumValue Name="Unicode" DisplayName="Use Unicode Character Set" Description="Use Unicode Character Set" />
    <EnumValue Name="MultiByte" DisplayName="Use Multi-Byte Character Set" Description="Use Multi-Byte Character Set" />
  </EnumProperty>
  <EnumProperty Name="CLRSupport" DisplayName="Common Language Runtime Support"
                Description="Specifies whether this configuration supports the Common Language Runtime. This is incompatible with some other settings, e.g. runtime checks. See help for /clr family of C++ compiler switches for full list of conflicts."
                Category="ProjectDefaults"
                F1Keyword="VC.Project.VCConfiguration.ManagedExtensions">
    <EnumValue Name="false" DisplayName="No Common Language Runtime Support"
               Description="No Common Language Runtime Support" />
    <EnumValue Name="true" DisplayName="Common Language Runtime Support (/clr)"
               Description="Common Language Runtime Support (/clr)"/>
    <EnumValue Name="Pure" DisplayName="Pure MSIL Common Language Runtime Support (/clr:pure)"
               Description="Pure MSIL Common Language Runtime Support (/clr:pure)" />
    <EnumValue Name="Safe" DisplayName="Safe MSIL Common Language Runtime Support (/clr:safe)"
               Description="Safe MSIL Common Language Runtime Support (/clr:safe)" />
    <EnumValue Name="OldSyntax" DisplayName="Common Language Runtime Support, Old Syntax (/clr:oldSyntax)"
               Description="Common Language Runtime Support, Old Syntax (/clr:oldSyntax)" />
  </EnumProperty>
  <EnumProperty Name="WholeProgramOptimization" DisplayName="Whole Program Optimization"
                Description="Specifies that the program will be optimized across .obj boundaries; works best if C/C++ optimizations are turned on."
                Category="ProjectDefaults"
                F1Keyword="VC.Project.VCConfiguration.WholeProgramOptimization">
    <EnumValue Name="false" DisplayName="No Whole Program Optimization"
               Description="No Whole Program Optimization" />
    <EnumValue Name="true" DisplayName="Use Link Time Code Generation"
               Description="Use Link Time Code Generation"/>
    <EnumValue Name="PGInstrument" DisplayName="Profile Guided Optimization - Instrument"
               Description="Profile Guided Optimization - Instrument"/>
    <EnumValue Name="PGOptimize" DisplayName="Profile Guided Optimization - Optimize"
               Description="Profile Guided Optimization - Optimize"/>
    <EnumValue Name="PGUpdate" DisplayName="Profile Guided Optimization - Update"
               Description="Profile Guided Optimization - Update"/>
  </EnumProperty>
  <BoolProperty Name="UseDebugLibraries" DisplayName="Use Debug Libraries"
                Description="Specifies whether this configuration should use debug libraries and debug switches"
                Category="ProjectDefaults" Visible="false">
  </BoolProperty>
  <StringProperty Name="_ProjectFileVersion" DisplayName="Project File Version"
                Description="Specifies the version of the conversion tool used to create this project file."
                Category="General" Visible="false">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" />
    </StringProperty.DataSource>
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\general_makefile_ps.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="ConfigurationGeneral"
      DisplayName="General"
      PageTemplate="generic"
      Description="General"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" Label="Configuration" />
  </Rule.DataSource>
  <StringProperty Name="OutDir" DisplayName="Output Directory"
                  Description="Specifies a relative path to the output file directory; can include environment variables."
                  Category="General" Default="$(SolutionDir)$(ConfigurationName)"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.OutputDirectory"/>
  <StringProperty Name="IntDir" DisplayName="Intermediate Directory"
                  Description="Specifies a relative path to the intermediate file directory; can include environment variables."
                  Category="General" Default="$(ConfigurationName)"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.IntermediateDirectory"/>
  <EnumProperty Name="CLRSupport" DisplayName="Common Language Runtime Support"
                Description="Select the Common Language Runtime support your code uses."
                Category="General"
                F1Keyword="VC.Project.VCConfiguration.ManagedExtensions">
    <EnumValue Name="false" DisplayName="No Common Language RunTime Support"  Description="No Common Language RunTime Support" />
    <EnumValue Name="true" Switch="clr" DisplayName="Common Language RunTime Support"  Description="Creates metadata for your application that can be consumed by other CLR applications, and allows your application to consume types and data in the metadata of other CLR components." />
    <EnumValue Name="Pure" Switch="clr:pure"  DisplayName="Pure MSIL Common Language RunTime Support"  Description="Produces an MSIL-only output file with no native executable code, although it can contain native types compiled to MSIL." />
    <EnumValue Name="Safe" Switch="clr:safe"  DisplayName="Safe MSIL Common Language RunTime Support"  Description="Produces an MSIL-only (no native executable code) and verifiable output file." />
    <EnumValue Name="OldSyntax" Switch="clr:oldSyntax"  DisplayName="Common Language RunTime Support, Old Syntax"  Description="Enables Managed Extensions for C++ syntax, the original Visual C++ syntax for CLR programming." />
  </EnumProperty>
  <StringProperty Name="BuildLogFile" DisplayName="Build Log File"
                  Description="Specifies the build log file to write to when build logging is enabled."
                  F1Keyword="VC.Project.VCConfiguration.BuildLogFile"
                  Category="General" Default="$(ProjectDir)\$(MSBuildProjectName).log"
                  Subtype="file">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="BuildLog" PersistedName="Path" />
    </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="_ProjectFileVersion" DisplayName="Project File Version"
                Description="Specifies the version of the conversion tool used to create this project file."
                Category="General" Visible="false">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" />
    </StringProperty.DataSource>
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\general_makefile.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="ConfigurationGeneral"
      DisplayName="General"
      PageTemplate="generic"
      Description="General"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" Label="Configuration" />
  </Rule.DataSource>
  <StringProperty Name="OutDir" DisplayName="Output Directory"
                  Description="Specifies a relative path to the output file directory; can include environment variables."
                  Category="General" Default="$(SolutionDir)$(ConfigurationName)"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.OutputDirectory"/>
  <StringProperty Name="IntDir" DisplayName="Intermediate Directory"
                  Description="Specifies a relative path to the intermediate file directory; can include environment variables."
                  Category="General" Default="$(ConfigurationName)"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.IntermediateDirectory"/>
  <EnumProperty Name="ConfigurationType" DisplayName="Configuration Type"
                Description="Specifies the type of output this configuration generates."
                Category="General"
                F1Keyword="VC.Project.VCConfiguration.ConfigurationType">
    <EnumValue Name="Makefile" DisplayName="Makefile" Description="Makefile" />
    <EnumValue Name="Application" DisplayName="Application (.exe)" Description="Application (.exe)" />
    <EnumValue Name="DynamicLibrary" DisplayName="Dynamic Library (.dll)" Description="Dynamic Library (.dll)" />
    <EnumValue Name="StaticLibrary" DisplayName="Static library (.lib)" Description="Static Library (.lib)" />
    <EnumValue Name="Utility" DisplayName="Utility" Description="Utility" />
  </EnumProperty>
  <EnumProperty Name="CLRSupport" DisplayName="Common Language Runtime Support"
                Description="Select the Common Language Runtime support your code uses."
                Category="General"
                F1Keyword="VC.Project.VCConfiguration.ManagedExtensions">
    <EnumValue Name="false" DisplayName="No Common Language RunTime Support"  Description="No Common Language RunTime Support" />
    <EnumValue Name="true" Switch="clr" DisplayName="Common Language RunTime Support"  Description="Creates metadata for your application that can be consumed by other CLR applications, and allows your application to consume types and data in the metadata of other CLR components." />
    <EnumValue Name="Pure" Switch="clr:pure"  DisplayName="Pure MSIL Common Language RunTime Support"  Description="Produces an MSIL-only output file with no native executable code, although it can contain native types compiled to MSIL." />
    <EnumValue Name="Safe" Switch="clr:safe"  DisplayName="Safe MSIL Common Language RunTime Support"  Description="Produces an MSIL-only (no native executable code) and verifiable output file." />
    <EnumValue Name="OldSyntax" Switch="clr:oldSyntax"  DisplayName="Common Language RunTime Support, Old Syntax"  Description="Enables Managed Extensions for C++ syntax, the original Visual C++ syntax for CLR programming." />
  </EnumProperty>
  <StringProperty Name="BuildLogFile" DisplayName="Build Log File"
                  Description="Specifies the build log file to write to when build logging is enabled."
                  F1Keyword="VC.Project.VCConfiguration.BuildLogFile"
                  Category="General" Default="$(ProjectDir)\$(MSBuildProjectName).log"
                  Subtype="file">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="BuildLog" PersistedName="Path" />
    </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="_ProjectFileVersion" DisplayName="Project File Version"
                Description="Specifies the version of the conversion tool used to create this project file."
                Category="General" Visible="false">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" />
    </StringProperty.DataSource>
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\link.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="Link" PageTemplate="tool" DisplayName="Linker" SwitchPrefix="/" Order="20" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Input" DisplayName="Input" />
    <Category Name="Manifest File" DisplayName="Manifest File" />
    <Category Name="Debugging" DisplayName="Debugging" />
    <Category Name="System" DisplayName="System" />
    <Category Name="Optimization" DisplayName="Optimization" />
    <Category Name="Embedded IDL" DisplayName="Embedded IDL" />
    <Category Name="Advanced" DisplayName="Advanced" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Link" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <StringProperty Subtype="file" Name="OutputFile" DisplayName="Output File" Description="The /OUT option overrides the default name and location of the program that the linker creates." Category="General" Switch="OUT" Separator=":" F1Keyword="VC.Project.VCLinkerTool.OutputFile">
  </StringProperty>
  <EnumProperty Name="ShowProgress" DisplayName="Show Progress" Description="Prints Linker Progress Messages" Category="General" F1Keyword="VC.Project.VCLinkerTool.ShowProgress">
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set" Description="No verbosity.">
    </EnumValue>
    <EnumValue Name="LinkVerbose" Switch="VERBOSE" DisplayName="Display all progress messages" Description="Displays all progress messages. ">
    </EnumValue>
    <EnumValue Name="LinkVerboseLib" Switch="VERBOSE:Lib" DisplayName="For Libraries Searched" Description="Displays progress messages indicating just the libraries searched">
    </EnumValue>
    <EnumValue Name="LinkVerboseICF" Switch="VERBOSE:ICF" DisplayName="About COMDAT folding during optimized linking" Description="Displays information about COMDAT folding during optimized linking">
    </EnumValue>
    <EnumValue Name="LinkVerboseREF" Switch="VERBOSE:REF" DisplayName="About data removed during optimized linking" Description="Displays information about functions and data removed during optimized linking">
    </EnumValue>
    <EnumValue Name="LinkVerboseSAFESEH" Switch="VERBOSE:SAFESEH" DisplayName="About Modules incompatible with SEH" Description="Displays information about modoules incompatible with Safe Exception Handling ">
    </EnumValue>
    <EnumValue Name="LinkVerboseCLR" Switch="VERBOSE:CLR" DisplayName="About linker activity related to managed code" Description="Display information about linker activity related to managed code">
    </EnumValue>
  </EnumProperty>
  <StringProperty Name="Version" DisplayName="Version" Description="The /VERSION option tells the linker to put a version number in the header of the .exe or .dll file. Use DUMPBIN /HEADERS to see the image version field of the OPTIONAL HEADER VALUES to see the effect of /VERSION." Category="General" Switch="VERSION" Separator=":" F1Keyword="VC.Project.VCLinkerTool.Version">
  </StringProperty>
  <BoolProperty ReverseSwitch="INCREMENTAL:NO" Name="LinkIncremental" DisplayName="Enable Incremental Linking" Description="Enables incremental linking.     (/INCREMENTAL, /INCREMENTAL:NO)" Category="General" Switch="INCREMENTAL" F1Keyword="VC.Project.VCLinkerTool.LinkIncremental">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="The /NOLOGO option prevents display of the copyright message and version number. " Category="General" Switch="NOLOGO" F1Keyword="VC.Project.VCLinkerTool.SuppressStartupBanner">
  </BoolProperty>
  <BoolProperty Name="IgnoreImportLibrary" DisplayName="Ignore Import Library" Description="Specifies that the import library generated by this configuration should not be imported into dependent projects." Category="General" F1Keyword="VC.Project.VCLinkerTool.IgnoreImportLibrary">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <BoolProperty Name="RegisterOutput" DisplayName="Register Output" Description="Specifies whether to register the primary output of this build." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCLinkerTool.RegisterOutput">
  </BoolProperty>
  <BoolProperty Name="PerUserRedirection" DisplayName="Per-user Redirection" Description="When Register Output is enabled, Per-user redirection forces registry writes to HKEY_CLASSES_ROOT to be redirected to HKEY_CURRENT_USER." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCLinkerTool.PerUserRedirection">
  </BoolProperty>
  <StringListProperty Subtype="folder" Name="AdditionalLibraryDirectories" DisplayName="Additional Library Directories" Description="Allows the user to override the environmental library path (/LIBPATH:folder)" Category="General" Switch="LIBPATH:" F1Keyword="VC.Project.VCLinkerTool.AdditionalLibraryDirectories">
  </StringListProperty>
  <BoolProperty Name="LinkLibraryDependencies" DisplayName="Link Library Dependencies" Description="Specifies whether or not library outputs from project dependencies are automatically linked in." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCLinkerTool.LinkLibraryDependencies">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="ProjectReference" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <BoolProperty Name="UseLibraryDependencyInputs" DisplayName="Use Library Dependency Inputs" Description="Specifies whether or not the inputs to the librarian tool are used rather than the library file itself when linking in library outputs of project dependencies." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCLinkerTool.UseLibraryDependencyInputs">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="ProjectReference" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <BoolProperty ReverseSwitch="LTCG:NOSTATUS" Name="LinkStatus" DisplayName="Link Status" Description="Specifies whether the linker should display a progress indicator showing what percentage of the link is complete. The default is to not display this status information. (/LTCG:STATUS|LTCG:NOSTATUS)" Category="General" Switch="LTCG:STATUS" F1Keyword="VC.Project.VCLinkerTool.LinkStatus">
  </BoolProperty>
  <BoolProperty ReverseSwitch="ALLOWBIND:NO" Name="PreventDllBinding" DisplayName="Prevent Dll Binding" Description="/ALLOWBIND:NO sets a bit in a DLL's header that indicates to Bind.exe that the image is not allowed to be bound. You may not want a DLL to be bound if it has been digitally signed (binding invalidates the signature)." Category="General" Switch="ALLOWBIND" F1Keyword="VC.Project.VCLinkerTool.PreventDLLBinding">
  </BoolProperty>
  <BoolProperty ReverseSwitch="WX:NO" Name="TreatLinkerWarningAsErrors" DisplayName="Treat Linker Warning As Errors" Description="/WX causes no output file to be generated if the linker generates a warning." Category="General" Switch="WX" F1Keyword="VC.Project.VCLinkerTool.TreatLinkerWarningsAsErrors">
  </BoolProperty>
  <EnumProperty Name="ForceFileOutput" DisplayName="Force File Output" Description="The /FORCE option tells the linker to create an .exe file or DLL even if a symbol is referenced but not defined or is multiply defined. It may create invalid exe file." Category="General" F1Keyword="VC.Project.VCLinkerTool.ForceFileOutput">
    <EnumValue Name="Enabled" Switch="FORCE" DisplayName="Enabled" Description="/FORCE with no arguments implies both multiple and unresolved.">
    </EnumValue>
    <EnumValue Name="MultiplyDefinedSymbolOnly" Switch="FORCE:MULTIPLE" DisplayName="Multiply Defined Symbol Only" Description="Use /FORCE:MULTIPLE to create an output file whether or not LINK finds more than one definition for a symbol.">
    </EnumValue>
    <EnumValue Name="UndefinedSymbolOnly" Switch="FORCE:UNRESOLVED" DisplayName="Undefined Symbol Only" Description="Use /FORCE:UNRESOLVED to create an output file whether or not LINK finds an undefined symbol. /FORCE:UNRESOLVED is ignored if the entry point symbol is unresolved.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="CreateHotPatchableImage" DisplayName="Create Hot Patchable Image" Description="Prepares an image for hotpatching." Category="General" F1Keyword="VC.Project.VCLinkerTool.CreateHotPatchableImage">
    <EnumValue Name="Enabled" Switch="FUNCTIONPADMIN" DisplayName="Enabled" Description="Prepares an image for hotpatching.">
    </EnumValue>
    <EnumValue Name="X86Image" Switch="FUNCTIONPADMIN:5" DisplayName="X86 Image Only" Description="Prepares an X86 image for hotpatching.">
    </EnumValue>
    <EnumValue Name="X64Image" Switch="FUNCTIONPADMIN:6" DisplayName="X64 Image Only" Description="Prepares an X64 image for hotpatching.">
    </EnumValue>
    <EnumValue Name="ItaniumImage" Switch="FUNCTIONPADMIN:16" DisplayName="Itanium Image Only" Description="Prepares an Itanium image for hotpatching.">
    </EnumValue>
  </EnumProperty>
  <StringProperty Name="SpecifySectionAttributes" DisplayName="Specify Section Attributes" Description="The /SECTION option changes the attributes of a section, overriding the attributes set when the .obj file for the section was compiled." Category="General" Switch="SECTION" Separator=":" F1Keyword="VC.Project.VCLinkerTool.SpecifySectionAttributes">
  </StringProperty>
  <StringProperty Subtype="file" Name="MSDOSStubFileName" DisplayName="MS-DOS Stub File Name" Description="The /STUB option attaches an MS-DOS stub program to a Win32 program. " Category="General" Switch="STUB" Separator=":" Visible="false">
  </StringProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker log directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringListProperty Subtype="file" Name="AdditionalDependencies" DisplayName="Additional Dependencies" Description="Specifies additional items to add to the link command line [i.e. kernel32.lib] " Category="Input" F1Keyword="VC.Project.VCLinkerTool.AdditionalDependencies">
  </StringListProperty>
  <BoolProperty Name="IgnoreAllDefaultLibraries" DisplayName="Ignore All Default Libraries" Description="The /NODEFAULTLIB option tells the linker to remove one or more default libraries from the list of libraries it searches when resolving external references. " Category="Input" Switch="NODEFAULTLIB" F1Keyword="VC.Project.VCLinkerTool.IgnoreAllDefaultLibraries">
  </BoolProperty>
  <StringListProperty Subtype="file" Name="IgnoreSpecificDefaultLibraries" DisplayName="Ignore Specific Default Libraries" Description="Specifies one or more names of default libraries to ignore; separate multiple libraries with semi-colons.     (/NODEFAULTLIB:[name, name, ...])" Category="Input" Switch="NODEFAULTLIB:" F1Keyword="VC.Project.VCLinkerTool.IgnoreDefaultLibraryNames">
  </StringListProperty>
  <StringProperty Subtype="file" Name="ModuleDefinitionFile" DisplayName="Module Definition File" Description="The /DEF option passes a module-definition file (.def) to the linker. Only one .def file can be specified to LINK. " Category="Input" Switch="DEF" Separator=":" F1Keyword="VC.Project.VCLinkerTool.ModuleDefinitionFile">
  </StringProperty>
  <StringListProperty Subtype="file" Name="AddModuleNamesToAssembly" DisplayName="Add Module to Assembly" Description="The /ASSEMBLYMODULE option allows you to add a module reference to an assembly. Type information in the module will not be available to the assembly program that added the module reference. However, type information in the module will be available to any program that references the assembly." Category="Input" Switch="ASSEMBLYMODULE:" F1Keyword="VC.Project.VCLinkerTool.AddModuleNamesToAssembly">
  </StringListProperty>
  <StringListProperty Subtype="file" Name="EmbedManagedResourceFile" DisplayName="Embed Managed Resource File" Description="/ASSEMBLYRESOURCE embeds a resource file in the output file." Category="Input" Switch="ASSEMBLYRESOURCE:" F1Keyword="VC.Project.VCLinkerTool.EmbedManagedResourceFile">
  </StringListProperty>
  <StringListProperty Subtype="file" Name="ForceSymbolReferences" DisplayName="Force Symbol References" Description="The /INCLUDE option tells the linker to add a specified symbol to the symbol table." Category="Input" Switch="INCLUDE:" F1Keyword="VC.Project.VCLinkerTool.ForceSymbolReferences">
  </StringListProperty>
  <StringListProperty Subtype="file" Name="DelayLoadDLLs" DisplayName="Delay Loaded Dlls" Description="The /DELAYLOAD option causes delayed loading of DLLs. The dllname specifies a DLL to delay load. " Category="Input" Switch="DELAYLOAD:" F1Keyword="VC.Project.VCLinkerTool.DelayLoadDLLS">
  </StringListProperty>
  <StringListProperty Subtype="file" Name="AssemblyLinkResource" DisplayName="Assembly Link Resource" Description="The /ASSEMBLYLINKRESOURCE option creates a link to a .NET Framework resource in the output file; the resource file is not placed in the output file. " Category="Input" Switch="ASSEMBLYLINKRESOURCE:" F1Keyword="VC.Project.VCLinkerTool.AssemblyLinkResource">
  </StringListProperty>
  <BoolProperty ReverseSwitch="MANIFEST:NO" Name="GenerateManifest" DisplayName="Generate Manifest" Description="/MANIFEST specifies that the linker should create a side-by-side manifest file." Category="Manifest File" Switch="MANIFEST" F1Keyword="VC.Project.VCLinkerTool.GenerateManifest">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <StringProperty Subtype="file" Name="ManifestFile" DisplayName="Manifest File" Description="/MANIFESTFILE lets you change the default name of the manifest file. The default name of the manifest file is the file name with .manifest appended." Category="Manifest File" Switch="ManifestFile" Separator=":" F1Keyword="VC.Project.VCLinkerTool.ManifestFile">
  </StringProperty>
  <StringListProperty Subtype="file" Name="AdditionalManifestDependencies" DisplayName="Additional Manifest Dependencies" Description="/MANIFESTDEPENDENCY lets you specify attributes that will be placed in the dependency section of the manifest file." Category="Manifest File" Switch="MANIFESTDEPENDENCY:" F1Keyword="VC.Project.VCLinkerTool.AdditionalManifestDependencies">
  </StringListProperty>
  <BoolProperty ReverseSwitch="ALLOWISOLATION:NO" Name="AllowIsolation" DisplayName="Allow Isolation" Description="Specifies behavior for manifest lookup. (/ALLOWISOLATION:NO)" Category="Manifest File" Switch="ALLOWISOLATION" F1Keyword="VC.Project.VCLinkerTool.AllowIsolation">
  </BoolProperty>
  <BoolProperty ReverseSwitch="MANIFESTUAC:NO" Name="EnableUAC" DisplayName="Enable User Account Control (UAC)" Description="Specifies whether or not User Account Control is enabled.  (/MANIFESTUAC, /MANIFESTUAC:NO)" Category="Manifest File" Switch="MANIFESTUAC:" F1Keyword="VC.Project.VCLinkerTool.EnableUAC">
    <Argument Property="UACExecutionLevel" IsRequired="true" />
    <Argument Property="UACUIAccess" IsRequired="true" Separator=" " />
  </BoolProperty>
  <EnumProperty Name="UACExecutionLevel" DisplayName="UAC Execution Level" Description="Specifies the requested execution level for the application when running with User Account Control.  (/MANIFESTUAC:level=[value])" SwitchPrefix="" Category="Manifest File" F1Keyword="VC.Project.VCLinkerTool.UACExecutionLevel">
    <EnumValue Name="AsInvoker" Switch="level='asInvoker'" DisplayName="asInvoker" Description="UAC Execution Level: as invoker.">
    </EnumValue>
    <EnumValue Name="HighestAvailable" Switch="level='highestAvailable'" DisplayName="highestAvailable" Description="UAC Execution Level: highest available.">
    </EnumValue>
    <EnumValue Name="RequireAdministrator" Switch="level='requireAdministrator'" DisplayName="requireAdministrator" Description="UAC Execution Level: require administrator.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="uiAccess='false'" Name="UACUIAccess" DisplayName="UAC Bypass UI Protection" Description="UAC Bypass UI Protection : Specifies whether or not to bypass user interface protection levels for other windows on the desktop.  Set this property to 'Yes' only for accessibility applications.  (/MANIFESTUAC:uiAccess=[true | false])" SwitchPrefix="" Category="Manifest File" Switch="uiAccess='true'" F1Keyword="VC.Project.VCLinkerTool.UACUIAccess">
  </BoolProperty>
  <BoolProperty Name="GenerateDebugInformation" DisplayName="Generate Debug Info" Description="The /DEBUG option creates debugging information for the .exe file or DLL." Category="Debugging" Switch="DEBUG" F1Keyword="VC.Project.VCLinkerTool.GenerateDebugInformation">
  </BoolProperty>
  <StringProperty Subtype="file" Name="ProgramDatabaseFile" DisplayName="Generate Program Database File" Description="By default, when /DEBUG is specified, the linker creates a program database (PDB) which holds debugging information. The default file name for the PDB has the base name of the program and the extension .pdb." Category="Debugging" Switch="PDB" Separator=":" F1Keyword="VC.Project.VCLinkerTool.ProgramDatabaseFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="StripPrivateSymbols" DisplayName="Strip Private Symbols" Description="The /PDBSTRIPPED option creates a second program database (PDB) file when you build your program image with any of the compiler or linker options that generate a PDB file (/DEBUG, /Z7, /Zd, or /Zi)." Category="Debugging" Switch="PDBSTRIPPED" Separator=":" F1Keyword="VC.Project.VCLinkerTool.StripPrivateSymbols">
  </StringProperty>
  <BoolProperty Name="GenerateMapFile" DisplayName="Generate Map File" Description="The /MAP option tells the linker to create a mapfile." Category="Debugging" Switch="MAP" F1Keyword="VC.Project.VCLinkerTool.GenerateMapFile">
    <Argument Property="MapFileName" IsRequired="false" />
  </BoolProperty>
  <StringProperty Subtype="file" Name="MapFileName" DisplayName="Map File Name" Description="A user-specified name for the mapfile. It replaces the default name." Category="Debugging" Separator=":" F1Keyword="VC.Project.VCLinkerTool.MapFileName">
  </StringProperty>
  <BoolProperty Name="MapExports" DisplayName="Map Exports" Description="The /MAPINFO option tells the linker to include the specified information in a mapfile, which is created if you specify the /MAP option. EXPORTS tells the linker to include exported functions." Category="Debugging" Switch="MAPINFO:EXPORTS" F1Keyword="VC.Project.VCLinkerTool.MapExports">
  </BoolProperty>
  <BoolProperty ReverseSwitch="ASSEMBLYDEBUG:DISABLE" Name="AssemblyDebug" DisplayName="Debuggable Assembly" Description="/ASSEMBLYDEBUG emits the DebuggableAttribute attribute with debug information tracking and disables JIT optimizations." Category="Debugging" Switch="ASSEMBLYDEBUG" F1Keyword="VC.Project.VCLinkerTool.AssemblyDebug">
  </BoolProperty>
  <EnumProperty Name="SubSystem" DisplayName="SubSystem" Description="The /SUBSYSTEM option tells the operating system how to run the .exe file.The choice of subsystem affects the entry point symbol (or entry point function) that the linker will choose." Category="System" F1Keyword="VC.Project.VCLinkerTool.SubSystem">
    <EnumProperty.Arguments>
      <Argument Property="MinimumRequiredVersion" IsRequired="false" />
    </EnumProperty.Arguments>
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set" Description="No subsystem set.">
    </EnumValue>
    <EnumValue Name="Console" Switch="SUBSYSTEM:CONSOLE" DisplayName="Console" Description="Win32 character-mode application. Console applications are given a console by the operating system. If main or wmain is defined, CONSOLE is the default.">
    </EnumValue>
    <EnumValue Name="Windows" Switch="SUBSYSTEM:WINDOWS" DisplayName="Windows" Description="Application does not require a console, probably because it creates its own windows for interaction with the user. If WinMain or wWinMain is defined, WINDOWS is the default.">
    </EnumValue>
    <EnumValue Name="Native" Switch="SUBSYSTEM:NATIVE" DisplayName="Native" Description="Device drivers for Windows NT. If /DRIVER:WDM is specified, NATIVE is the default.">
    </EnumValue>
    <EnumValue Name="EFI Application" Switch="SUBSYSTEM:EFI_APPLICATION" DisplayName="EFI Application" Description="EFI Application">
    </EnumValue>
    <EnumValue Name="EFI Boot Service Driver" Switch="SUBSYSTEM:EFI_BOOT_SERVICE_DRIVER" DisplayName="EFI Boot Service Driver" Description="EFI Boot Service Driver">
    </EnumValue>
    <EnumValue Name="EFI ROM" Switch="SUBSYSTEM:EFI_ROM" DisplayName="EFI ROM" Description="EFI ROM">
    </EnumValue>
    <EnumValue Name="EFI Runtime" Switch="SUBSYSTEM:EFI_RUNTIME_DRIVER" DisplayName="EFI Runtime" Description="EFI Runtime">
    </EnumValue>
    <EnumValue Name="WindowsCE" Switch="SUBSYSTEM:WINDOWSCE" DisplayName="WindowsCE" Description="Application that runs on a Windows CE device.">
    </EnumValue>
    <EnumValue Name="POSIX" Switch="SUBSYSTEM:POSIX" DisplayName="POSIX" Description="Application that runs with the POSIX subsystem in Windows NT.">
    </EnumValue>
  </EnumProperty>
  <StringProperty Name="MinimumRequiredVersion" DisplayName="Minimum Required Version" Description="Specify the minimum required version of the subsystem. The arguments are decimal numbers in the range 0 through 65,535." Category="System" Separator="," F1Keyword="VC.Project.VCLinkerTool.MinimumRequiredVersion">
  </StringProperty>
  <StringProperty Name="HeapReserveSize" DisplayName="Heap Reserve Size" Description="Specifies total heap allocation size in virtual memory. Default is 1MB.    (/HEAP:reserve)" Category="System" Switch="HEAP" Separator=":" F1Keyword="VC.Project.VCLinkerTool.HeapReserveSize">
    <Argument Property="HeapCommitSize" IsRequired="false" Separator="," />
  </StringProperty>
  <StringProperty Name="HeapCommitSize" DisplayName="Heap Commit Size" Description="Specifies total heap allocation size in physical memory. Default is 4KB.    (/HEAP:reserve,commit)" Category="System" F1Keyword="VC.Project.VCLinkerTool.HeapCommitSize">
  </StringProperty>
  <StringProperty Name="StackReserveSize" DisplayName="Stack Reserve Size" Description="Specifies the total stack allocation size in virtual memory. Default is 1MB.     (/STACK:reserve)" Category="System" Switch="STACK" Separator=":" F1Keyword="VC.Project.VCLinkerTool.StackReserveSize">
    <Argument Property="StackCommitSize" IsRequired="false" Separator="," />
  </StringProperty>
  <StringProperty Name="StackCommitSize" DisplayName="Stack Commit Size" Description="Specifies the total stack allocation size in physical memory. Default is 4KB.     (/STACK:reserve,commit)" Category="System" F1Keyword="VC.Project.VCLinkerTool.StackCommitSize">
  </StringProperty>
  <BoolProperty ReverseSwitch="LARGEADDRESSAWARE:NO" Name="LargeAddressAware" DisplayName="Enable Large Addresses" Description="The /LARGEADDRESSAWARE option tells the linker that the application can handle addresses larger than 2 gigabytes. By default, /LARGEADDRESSAWARE:NO is enabled if /LARGEADDRESSAWARE is not otherwise specified on the linker line." Category="System" Switch="LARGEADDRESSAWARE" F1Keyword="VC.Project.VCLinkerTool.LargeAddressAware">
  </BoolProperty>
  <BoolProperty ReverseSwitch="TSAWARE:NO" Name="TerminalServerAware" DisplayName="Terminal Server" Description="The /TSAWARE option sets a flag in the IMAGE_OPTIONAL_HEADER DllCharacteristics field in the program image's optional header. When this flag is set, Terminal Server will not make certain changes to the application." Category="System" Switch="TSAWARE" F1Keyword="VC.Project.VCLinkerTool.TerminalServerAware">
  </BoolProperty>
  <BoolProperty Name="SwapRunFromCD" DisplayName="Swap Run From CD" Description="The /SWAPRUN option tells the operating system to first copy the linker output to a swap file, and then run the image from there. This is a Windows NT 4.0 (and later) feature.When CD is specified, the operating system will copy the image on a removable disk to a page file and then load it." Category="System" Switch="SWAPRUN:CD" F1Keyword="VC.Project.VCLinkerTool.SwapRunFromCD">
  </BoolProperty>
  <BoolProperty Name="SwapRunFromNET" DisplayName="Swap Run From Network" Description="The /SWAPRUN option tells the operating system to first copy the linker output to a swap file, and then run the image from there. This is a Windows NT 4.0 (and later) feature. If NET is specified, the operating system will first copy the binary image from the network to a swap file and load it from there. This option is useful for running applications over the network." Category="System" Switch="SWAPRUN:NET" F1Keyword="VC.Project.VCLinkerTool.SwapRunFromNet">
  </BoolProperty>
  <EnumProperty Name="Driver" DisplayName="Driver" Description="Use the /DRIVER linker option to build a Windows NT kernel mode driver." Category="System" F1Keyword="VC.Project.VCLinkerTool.driver">
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set" Description="Default driver setting.">
    </EnumValue>
    <EnumValue Name="Driver" Switch="Driver" DisplayName="Driver" Description="Driver">
    </EnumValue>
    <EnumValue Name="UpOnly" Switch="DRIVER:UPONLY" DisplayName="UP Only" Description="/DRIVER:UPONLY causes the linker to add the IMAGE_FILE_UP_SYSTEM_ONLY bit to the characteristics in the output header to specify that it is a uniprocessor (UP) driver. The operating system will refuse to load a UP driver on a multiprocessor (MP) system.">
    </EnumValue>
    <EnumValue Name="WDM" Switch="DRIVER:WDM" DisplayName="WDM" Description="/DRIVER:WDM causes the linker to set the IMAGE_DLLCHARACTERISTICS_WDM_DRIVER bit in the optional header's DllCharacteristics field.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="OPT:NOREF" Name="OptimizeReferences" DisplayName="References" Description="/OPT:REF eliminates functions and/or data that are never referenced while /OPT:NOREF keeps functions and/or data that are never referenced. " Category="Optimization" Switch="OPT:REF" F1Keyword="VC.Project.VCLinkerTool.OptimizeReferences">
  </BoolProperty>
  <BoolProperty ReverseSwitch="OPT:NOICF" Name="EnableCOMDATFolding" DisplayName="Enable COMDAT Folding" Description="Use /OPT:ICF[=iterations] to perform identical COMDAT folding. " Category="Optimization" Switch="OPT:ICF" F1Keyword="VC.Project.VCLinkerTool.EnableCOMDATFolding">
  </BoolProperty>
  <StringProperty Subtype="file" Name="FunctionOrder" DisplayName="Function Order" Description="The /ORDER option tells LINK to optimize your program by placing certain COMDATs into the image in a predetermined order. LINK places the functions in the specified order within each section in the image." Category="Optimization" Switch="ORDER" Separator=":@" F1Keyword="VC.Project.VCLinkerTool.FunctionOrder">
  </StringProperty>
  <StringProperty Subtype="file" Name="ProfileGuidedDatabase" DisplayName="Profile Guided Database" Description="Specify .pgd file for profile guided optionizations. (/PGD)" Category="Optimization" Switch="PGD" Separator=":" F1Keyword="VC.Project.VCLinkerTool.ProfileGuidedDatabase">
  </StringProperty>
  <EnumProperty Name="LinkTimeCodeGeneration" DisplayName="Link Time Code Generation" Description="Specifies link-time code generation" Category="Optimization" F1Keyword="VC.Project.VCLinkerTool.LinkTimeCodeGeneration">
    <EnumValue Name="Default" Switch="" DisplayName="Default" Description="Default LTCG setting.">
    </EnumValue>
    <EnumValue Name="UseLinkTimeCodeGeneration" Switch="LTCG" DisplayName="Use Link Time Code Generation" Description="Use Link Time Code Generation">
    </EnumValue>
    <EnumValue Name="PGInstrument" Switch="LTCG:PGInstrument" DisplayName="Profile Guided Optimization - Instrument" Description="Specifies link-time code generation">
    </EnumValue>
    <EnumValue Name="PGOptimization" Switch="LTCG:PGOptimize" DisplayName="Profile Guided Optimization - Optimization" Description="Specifies that the linker should use the profile data created after running the instrumented binary to create an optimized image.">
    </EnumValue>
    <EnumValue Name="PGUpdate" Switch="LTCG:PGUpdate" DisplayName="Profile Guided Optimization - Update" Description="Allows and tracks list of input files to be added or modified from what was specified in the :PGINSTRUMENT phase.">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="file" Name="MidlCommandFile" DisplayName="MIDL Commands" Description="Specify MIDL command line Options (/MIDL:@responsefile)" Category="Embedded IDL" Switch="MIDL" Separator=":@" F1Keyword="VC.Project.VCLinkerTool.MidlCommandFile">
  </StringProperty>
  <BoolProperty Name="IgnoreEmbeddedIDL" DisplayName="Ignore Embedded IDL" Description="The /IGNOREIDL option specifies that any IDL attributes in source code should not be processed into an .idl file." Category="Embedded IDL" Switch="IGNOREIDL" F1Keyword="VC.Project.VCLinkerTool.IgnoreEmbeddedIDL">
  </BoolProperty>
  <StringProperty Subtype="file" Name="MergedIDLBaseFileName" DisplayName="Merged IDL Base File Name" Description="The /IDLOUT option specifies the name and extension of the .idl file." Category="Embedded IDL" Switch="IDLOUT" Separator=":" F1Keyword="VC.Project.VCLinkerTool.MergedIDLBaseFileName">
  </StringProperty>
  <StringProperty Subtype="file" Name="TypeLibraryFile" DisplayName="Type Library" Description="The /TLBOUT option specifies the name and extension of the .tlb file." Category="Embedded IDL" Switch="TLBOUT" Separator=":" F1Keyword="VC.Project.VCLinkerTool.TypeLibraryFile">
  </StringProperty>
  <IntProperty Name="TypeLibraryResourceID" DisplayName="TypeLib Resource ID" Description="Allows you to specify the resource ID of the linker-generated type library. (/TLBID:id)" Category="Embedded IDL" Switch="TLBID" Separator=":" F1Keyword="VC.Project.VCLinkerTool.TypeLibraryResourceID">
  </IntProperty>
  <StringProperty Name="EntryPointSymbol" DisplayName="Entry Point" Description="The /ENTRY option specifies an entry point function as the starting address for an .exe file or DLL." Category="Advanced" Switch="ENTRY" Separator=":" F1Keyword="VC.Project.VCLinkerTool.EntryPointSymbol">
  </StringProperty>
  <BoolProperty Name="NoEntryPoint" DisplayName="No Entry Point" Description="The /NOENTRY option is required for creating a resource-only DLL.Use this option to prevent LINK from linking a reference to _main into the DLL." Category="Advanced" Switch="NOENTRY" F1Keyword="VC.Project.VCLinkerTool.ResourceOnlyDLL">
  </BoolProperty>
  <BoolProperty Name="SetChecksum" DisplayName="Set Checksum" Description="The /RELEASE option sets the Checksum in the header of an .exe file." Category="Advanced" Switch="RELEASE" F1Keyword="VC.Project.VCLinkerTool.SetChecksum">
  </BoolProperty>
  <StringProperty Name="BaseAddress" DisplayName="Base Address" Description="Sets a base address for the program (/BASE:{address[,size] | @filename,key})" Category="Advanced" Switch="BASE" Separator=":" F1Keyword="VC.Project.VCLinkerTool.BaseAddress">
  </StringProperty>
  <BoolProperty ReverseSwitch="DYNAMICBASE:NO" Name="RandomizedBaseAddress" DisplayName="Randomized Base Address" Description="Randomized Base Address (/DYNAMICBASE[:NO])" Category="Advanced" Switch="DYNAMICBASE" F1Keyword="VC.Project.VCLinkerTool.RandomizedBaseAddress">
  </BoolProperty>
  <BoolProperty ReverseSwitch="FIXED:NO" Name="FixedBaseAddress" DisplayName="Fixed Base Address" Description="Creates a program that can be loaded only at its preferred base address (/FIXED[:NO])" Category="Advanced" Switch="FIXED" F1Keyword="VC.Project.VCLinkerTool.FixedBaseAddress">
  </BoolProperty>
  <BoolProperty ReverseSwitch="NXCOMPAT:NO" Name="DataExecutionPrevention" DisplayName="Data Execution Prevention (DEP)" Description="Marks an executable as having been tested to be compatible with Windows Data Execution Prevention feature. (/NXCOMPAT[:NO])" Category="Advanced" Switch="NXCOMPAT" F1Keyword="VC.Project.VCLinkerTool.DataExecutionPrevention">
  </BoolProperty>
  <BoolProperty Name="TurnOffAssemblyGeneration" DisplayName="Turn Off Assembly Generation" Description="The /NOASSEMBLY option tells the linker to create an image for the current output file without a .NET Framework assembly." Category="Advanced" Switch="NOASSEMBLY" F1Keyword="VC.Project.VCLinkerTool.TurnOffAssemblyGeneration">
  </BoolProperty>
  <BoolProperty Name="SupportUnloadOfDelayLoadedDLL" DisplayName="Unload delay loaded DLL" Description="The UNLOAD qualifier tells the delay-load helper function to support explicit unloading of the DLL. (/DELAY:UNLOAD)" Category="Advanced" Switch="DELAY:UNLOAD" F1Keyword="VC.Project.VCLinkerTool.SupportUnloadOfDelayLoadedDLL">
  </BoolProperty>
  <BoolProperty Name="SupportNobindOfDelayLoadedDLL" DisplayName="Nobind delay loaded DLL" Description="The NOBIND qualifier tells the linker not to include a bindable IAT in the final image. The default is to create the bindable IAT for delay-loaded DLLs. (/DELAY:NOBIND)" Category="Advanced" Switch="DELAY:NOBIND" F1Keyword="VC.Project.VCLinkerTool.SupportNobindOfDelayLoadedDLL">
  </BoolProperty>
  <StringProperty Subtype="file" Name="ImportLibrary" DisplayName="Import Library" Description="Overrides the default import library name (/IMPLIB:filename)" Category="Advanced" Switch="IMPLIB" Separator=":" F1Keyword="VC.Project.VCLinkerTool.ImportLIbrary">
  </StringProperty>
  <StringProperty Name="MergeSections" DisplayName="Merge Sections" Description="The /MERGE option combines the first section (from) with the second section (to), naming the resulting section to. For example, /merge:.rdata=.text." Category="Advanced" Switch="MERGE" Separator=":" F1Keyword="VC.Project.VCLinkerTool.MergeSections">
  </StringProperty>
  <EnumProperty Name="TargetMachine" DisplayName="Target Machine" Description="The /MACHINE option specifies the target platform for the program." Category="Advanced" F1Keyword="VC.Project.VCLinkerTool.TargetMachine">
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set">
    </EnumValue>
    <EnumValue Name="MachineARM" Switch="MACHINE:ARM" DisplayName="MachineARM">
    </EnumValue>
    <EnumValue Name="MachineEBC" Switch="MACHINE:EBC" DisplayName="MachineEBC">
    </EnumValue>
    <EnumValue Name="MachineIA64" Switch="MACHINE:IA64" DisplayName="MachineIA64">
    </EnumValue>
    <EnumValue Name="MachineMIPS" Switch="MACHINE:MIPS" DisplayName="MachineMIPS">
    </EnumValue>
    <EnumValue Name="MachineMIPS16" Switch="MACHINE:MIPS16" DisplayName="MachineMIPS16">
    </EnumValue>
    <EnumValue Name="MachineMIPSFPU" Switch="MACHINE:MIPSFPU" DisplayName="MachineMIPSFPU">
    </EnumValue>
    <EnumValue Name="MachineMIPSFPU16" Switch="MACHINE:MIPSFPU16" DisplayName="MachineMIPSFPU16">
    </EnumValue>
    <EnumValue Name="MachineSH4" Switch="MACHINE:SH4" DisplayName="MachineSH4">
    </EnumValue>
    <EnumValue Name="MachineTHUMB" Switch="MACHINE:THUMB" DisplayName="MachineTHUMB">
    </EnumValue>
    <EnumValue Name="MachineX64" Switch="MACHINE:X64" DisplayName="MachineX64">
    </EnumValue>
    <EnumValue Name="MachineX86" Switch="MACHINE:X86" DisplayName="MachineX86">
    </EnumValue>
  </EnumProperty>
  <BoolProperty Name="Profile" DisplayName="Profile" Description="Produces an output file that can be used with the Performance Tools profiler. Requires GenerateDebugInformation (/DEBUG) to be set. (/PROFILE)" Category="Advanced" Switch="PROFILE" F1Keyword="VC.Project.VCLinkerTool.Profile">
  </BoolProperty>
  <EnumProperty Name="CLRThreadAttribute" DisplayName="CLR Thread Attribute" Description="Explicitly specify the threading attribute for the entry point of your CLR program." Category="Advanced" F1Keyword="VC.Project.VCLinkerTool.CLRThreadAttribute">
    <EnumValue Name="MTAThreadingAttribute" Switch="CLRTHREADATTRIBUTE:MTA" DisplayName="MTA threading attribute" Description="Applies the MTAThreadAttribute attribute to the entry point of your program.">
    </EnumValue>
    <EnumValue Name="STAThreadingAttribute" Switch="CLRTHREADATTRIBUTE:STA" DisplayName="STA threading attribute" Description="Applies the STAThreadAttribute attribute to the entry point of your program.">
    </EnumValue>
    <EnumValue Name="DefaultThreadingAttribute" Switch="CLRTHREADATTRIBUTE:NONE" DisplayName="Default threading attribute" Description="Same as not specifying /CLRTHREADATTRIBUTE. Lets the Common Language Runtime (CLR) set the default threading attribute.">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="CLRImageType" DisplayName="CLR Image Type" Description="Sets the type (IJW, pure, or safe) of a CLR image." Category="Advanced" F1Keyword="VC.Project.VCLinkerTool.CLRImageType">
    <EnumValue Name="ForceIJWImage" Switch="CLRIMAGETYPE:IJW" DisplayName="Force IJW image">
    </EnumValue>
    <EnumValue Name="ForcePureILImage" Switch="CLRIMAGETYPE:PURE" DisplayName="Force Pure IL Image">
    </EnumValue>
    <EnumValue Name="ForceSafeILImage" Switch="CLRIMAGETYPE:SAFE" DisplayName="Force Safe IL Image">
    </EnumValue>
    <EnumValue Name="Default" Switch="" DisplayName="Default image type">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="file" Name="KeyFile" DisplayName="Key File" Description="Specify key or key pair to sign an assembly. (/KEYFILE:filename)" Category="Advanced" Switch="KEYFILE" Separator=":" F1Keyword="VC.Project.VCLinkerTool.KeyFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="KeyContainer" DisplayName="Key Container" Description="Specify a key container to sign an assembly. (/KEYCONTAINER:name)" Category="Advanced" Switch="KEYCONTAINER" Separator=":" F1Keyword="VC.Project.VCLinkerTool.KeyContainer">
  </StringProperty>
  <BoolProperty ReverseSwitch="DELAYSIGN:NO" Name="DelaySign" DisplayName="Delay Sign" Description="Partially sign an assembly. Use /DELAYSIGN if you only want to place the public key in the assembly. The default is /DELAYSIGN:NO." Category="Advanced" Switch="DELAYSIGN" F1Keyword="VC.Project.VCLinkerTool.DelaySign">
  </BoolProperty>
  <BoolProperty ReverseSwitch="CLRUNMANAGEDCODECHECK:NO" Name="CLRUnmanagedCodeCheck" DisplayName="CLR Unmanaged Code Check" Description="/CLRUNMANAGEDCODECHECK specifies whether the linker will apply SuppressUnmanagedCodeSecurityAttribute to linker-generated PInvoke calls from managed code into native DLLs." Category="Advanced" Switch="CLRUNMANAGEDCODECHECK" F1Keyword="VC.Project.VCLinkerTool.CLRUnmanagedCodeCheck">
  </BoolProperty>
  <EnumProperty Name="LinkErrorReporting" DisplayName="Error Reporting" Description="Allows you to provide internal compiler error (ICE) information directly to the Visual C++ team." Category="Advanced" F1Keyword="VC.Project.VCLinkerTool.ErrorReporting">
    <EnumValue Name="PromptImmediately" Switch="ERRORREPORT:PROMPT" DisplayName="PromptImmediately" Description="Prompt immediately.">
    </EnumValue>
    <EnumValue Name="QueueForNextLogin" Switch="ERRORREPORT:QUEUE" DisplayName="Queue For Next Login" Description="Queue for next login.">
    </EnumValue>
    <EnumValue Name="SendErrorReport" Switch="ERRORREPORT:SEND" DisplayName="Send Error Report" Description="Send error report.">
    </EnumValue>
    <EnumValue Name="NoErrorReport" Switch="ERRORREPORT:NONE" DisplayName="No Error Report" Description="No error report.">
    </EnumValue>
  </EnumProperty>
  <IntProperty Name="SectionAlignment" DisplayName="SectionAlignment" Description="The /ALIGN option specifies the alignment of each section within the linear address space of the program. The number argument is in bytes and must be a power of two." Category="Advanced" Switch="ALIGN" Separator=":" F1Keyword="VC.Project.VCLinkerTool.Alignment">
  </IntProperty>
  <EnumProperty Name="CLRSupportLastError" DisplayName="Preserve Last Error Code for PInvoke Calls" Description="/CLRSUPPORTLASTERROR, which is on by default, preserves the last error code of functions called through the P/Invoke mechanism, which allows you to call native functions in DLLS, from code compiled with /clr." Category="Advanced" F1Keyword="VC.Project.VCLinkerTool.CLRSupportLastError">
    <EnumValue Name="Enabled" Switch="CLRSupportLastError" DisplayName="Enabled" Description="Enable CLRSupportLastError.">
    </EnumValue>
    <EnumValue Name="Disabled" Switch="CLRSupportLastError:NO" DisplayName="Disabled" Description="Disable CLRSupportLastError.">
    </EnumValue>
    <EnumValue Name="SystemDlls" Switch="CLRSupportLastError:SYSTEMDLL" DisplayName="System Dlls Only" Description="Enable CLRSupportLastError for system dlls only.">
    </EnumValue>
  </EnumProperty>
  <BoolProperty ReverseSwitch="SAFESEH:NO" Name="ImageHasSafeExceptionHandlers" DisplayName="Image Has Safe Exception Handlers" Description="When /SAFESEH is specified, the linker will only produce an image if it can also produce a table of the image's safe exception handlers. This table specifies for the operating system which exception handlers are valid for the image." Category="Advanced" Switch="SAFESEH" F1Keyword="VC.Project.VCLinkerTool.ImageHasSafeExceptionHandlers">
  </BoolProperty>
  <BoolProperty Name="LinkDLL" Switch="DLL" Visible="false">
  </BoolProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
  <BoolProperty Name="BuildingInIDE" Visible="false">
  </BoolProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\midl.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="MIDL" PageTemplate="tool" DisplayName="MIDL" SwitchPrefix="/" Order="60" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Output" DisplayName="Output" />
    <Category Name="Advanced" DisplayName="Advanced" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Midl" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <StringListProperty Name="PreprocessorDefinitions" DisplayName="Preprocessor Definitions" Description="Specifies one or more defines, including MIDL macros (/D[macros]" Category="General" Switch="D " F1Keyword="VC.Project.VCMidlTool.PreprocessorDefinitions">
  </StringListProperty>
  <StringListProperty Subtype="folder" Name="AdditionalIncludeDirectories" DisplayName="Additional Include Directories" Description="Specifies one or more directories to add to the include path (/I[path])" Category="General" Switch="I" F1Keyword="VC.Project.VCMidlTool.AdditionalIncludeDirectories">
  </StringListProperty>
  <BoolProperty Name="IgnoreStandardIncludePath" DisplayName="Ignore Standard Include Path" Description="Ignore the current and the INCLUDE directories" Category="General" Switch="no_def_idir" F1Keyword="VC.Project.VCMidlTool.IgnoreStandardIncludePath">
  </BoolProperty>
  <BoolProperty Name="MkTypLibCompatible" DisplayName="MkTypLib Compatible" Description="Forces compatibility with mktyplib.exe version 2.03 (/mktyplib203)" Category="General" Switch="mktyplib203" F1Keyword="VC.Project.VCMidlTool.MkTypLibCompatible">
  </BoolProperty>
  <EnumProperty Name="WarningLevel" DisplayName="Warning Level" Description="Selects the strictness of the MIDL code errors (/Wn)" Category="General" F1Keyword="VC.Project.VCMidlTool.WarningLevel">
    <EnumValue Name="0" Switch="W0" DisplayName="1">
    </EnumValue>
    <EnumValue Name="1" Switch="W1" DisplayName="1">
    </EnumValue>
    <EnumValue Name="2" Switch="W2" DisplayName="2">
    </EnumValue>
    <EnumValue Name="3" Switch="W3" DisplayName="3">
    </EnumValue>
    <EnumValue Name="4" Switch="W4" DisplayName="4">
    </EnumValue>
  </EnumProperty>
  <BoolProperty Name="WarnAsError" DisplayName="Treat Warnings as Errors" Description="Enables MIDL to treat all warnings as errors (/WX)" Category="General" Switch="WX" F1Keyword="VC.Project.VCMidlTool.WarnAsError">
  </BoolProperty>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Suppress the display of the startup banner and information message (/nologo)" Category="General" Switch="nologo" F1Keyword="VC.Project.VCMidlTool.SuppressStartupBanner">
  </BoolProperty>
  <EnumProperty Name="DefaultCharType" DisplayName="C Compiler Char Type" Description="Specifies the default character type of the C compiler that will be used to compile the generated code. (/char signed|unsigned|ascii7)" Category="General" F1Keyword="VC.Project.VCMidlTool.DefaultCharType">
    <EnumValue Name="Signed" Switch="char signed" DisplayName="Signed" Description="Signed">
    </EnumValue>
    <EnumValue Name="Unsigned" Switch="char unsigned" DisplayName="Unsigned" Description="Unsigned">
    </EnumValue>
    <EnumValue Name="Ascii" Switch="char ascii7" DisplayName="Ascii" Description="Ascii">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="TargetEnvironment" DisplayName="Target Environment" Description="Specifies environment to target (/env win32|ia64|x64)" Category="General" F1Keyword="VC.Project.VCMidlTool.TargetEnvironment">
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set" Description="Win32">
    </EnumValue>
    <EnumValue Name="Win32" Switch="env win32" DisplayName="Microsoft Windows 32-bit" Description="Win32">
    </EnumValue>
    <EnumValue Name="Itanium" Switch="env ia64" DisplayName="Microsoft Windows 64-bit on Itanium" Description="IA64">
    </EnumValue>
    <EnumValue Name="X64" Switch="env x64" DisplayName="Microsoft Windows 64-bit on x64" Description="X64">
    </EnumValue>
  </EnumProperty>
  <BoolProperty Name="GenerateStublessProxies" DisplayName="Generate Stubless Proxies" Description="Generate fully interpreted stubs with extensions and stubless proxies for object interfaces (/Oicf, /Oif)" Category="General" Switch="Oicf" F1Keyword="VC.Project.VCMidlTool.GenerateStublessProxies">
  </BoolProperty>
  <BoolProperty Name="SuppressCompilerWarnings" DisplayName="Suppress Compiler Warnings" Description="Supress compiler warning messages (/no_warn)" Category="General" Switch="no_warn" F1Keyword="VC.Project.VCMidlTool.SuppressCompilerWarnings">
  </BoolProperty>
  <BoolProperty Name="ApplicationConfigurationMode" DisplayName="Application Configuration Mode" Description="Allow selected ACF attributes in the IDL file (/app_config)" Category="General" Switch="app_config" F1Keyword="VC.Project.VCMidlTool.ApplicationConfigurationMode">
  </BoolProperty>
  <IntProperty Name="LocaleID" DisplayName="Locale ID" Description="Specifies the LCID for input files, file names and directory paths (/lcid DECIMAL)" Category="General" Switch="lcid" Separator=" " F1Keyword="VC.Project.VCMidlTool.LocaleID">
  </IntProperty>
  <StringProperty Name="OutputDirectory" DisplayName="Output Directory" Description="Output directory (/out [directory])" Category="Output" Switch="out" F1Keyword="VC.Project.VCMidlTool.OutputDirectory">
  </StringProperty>
  <StringProperty Subtype="file" Name="HeaderFileName" DisplayName="Header File" Description="Specifies the name of the generated header file (/h filename)" Category="Output" Switch="h" Separator=" " F1Keyword="VC.Project.VCMidlTool.HeaderFileName">
  </StringProperty>
  <StringProperty Subtype="file" Name="DllDataFileName" DisplayName="DllData File" Description="Specifies the name of the DLLDATA file (/dlldata filename)" Category="Output" Switch="dlldata" Separator=" " F1Keyword="VC.Project.VCMidlTool.DLLDataFileName">
  </StringProperty>
  <StringProperty Subtype="file" Name="InterfaceIdentifierFileName" DisplayName="IID File" Description="Specifies the name for the Interface Identifier file (/iid filename)" Category="Output" Switch="iid" Separator=" " F1Keyword="VC.Project.VCMidlTool.InterfaceIdentifierFileName">
  </StringProperty>
  <StringProperty Subtype="file" Name="ProxyFileName" DisplayName="Proxy File" Description="Specifies the name of the proxy file (/proxy filename)" Category="Output" Switch="proxy" Separator=" " F1Keyword="VC.Project.VCMidlTool.ProxyFileName">
  </StringProperty>
  <BoolProperty ReverseSwitch="notlb" Name="GenerateTypeLibrary" DisplayName="Generate Type Library" Description="Specify not to generate a typelib ([/notlb] for no)" Category="Output" F1Keyword="VC.Project.VCMidlTool.GenerateTypeLibrary">
  </BoolProperty>
  <StringProperty Subtype="file" Name="TypeLibraryName" DisplayName="Type Library" Description="Specifies the name of the type library file (/tlb filename)" Category="Output" Switch="tlb" Separator=" " F1Keyword="VC.Project.VCMidlTool.TypeLibraryName">
  </StringProperty>
  <EnumProperty Name="GenerateClientFiles" DisplayName="Generate Client Stub Files" Description="Generate client stub file only (/client [stub|none])" Category="Output" F1Keyword="VC.Project.VCMidlTool.GenerateClientFiles">
    <EnumValue Name="Stub" Switch="client stub" DisplayName="Stub" Description="Stub">
    </EnumValue>
    <EnumValue Name="None" Switch="client none" DisplayName="None" Description="None">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="GenerateServerFiles" DisplayName="Generate Server Stub Files" Description="Generate server stub file only (/server [stub|none])" Category="Output" F1Keyword="VC.Project.VCMidlTool.GenerateServerFiles">
    <EnumValue Name="Stub" Switch="server stub" DisplayName="Stub" Description="Stub">
    </EnumValue>
    <EnumValue Name="None" Switch="server none" DisplayName="None" Description="None">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="file" Name="ClientStubFile" DisplayName="Client Stub File" Description="Specify the client stub file (/cstub [file])" Category="Output" Switch="cstub" Separator=" " F1Keyword="VC.Project.VCMidlTool.ClientStubFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="ServerStubFile" DisplayName="Server Stub File" Description="Specify the server stub file (/sstub [file])" Category="Output" Switch="sstub" Separator=" " F1Keyword="VC.Project.VCMidlTool.ServerStubFile">
  </StringProperty>
  <EnumProperty Name="TypeLibFormat" DisplayName="Type Library Format" Description="Specifies the type library file format ([/oldtlb|/newtlb])" Category="Output" F1Keyword="VC.Project.VCMidlTool.TypeLibFormat">
    <EnumValue Name="NewFormat" Switch="newtlb" DisplayName="NewFormat" Description="New Format">
    </EnumValue>
    <EnumValue Name="OldFormat" Switch="oldtlb" DisplayName="OldFormat" Description="Old Format">
    </EnumValue>
  </EnumProperty>
  <StringProperty Name="CPreprocessOptions" DisplayName="C Preprocess Options" Description="Specifies switches to pass to C compiler preprocessor (/cpp_opt switches)" Category="Advanced" Switch="cpp_opt" Separator=" " F1Keyword="VC.Project.VCMidlTool.CPreprocessOptions">
  </StringProperty>
  <StringListProperty Name="UndefinePreprocessorDefinitions" DisplayName="Undefine Preprocessor Definitions" Description="Specifies one or more undefines, including MIDL macros (/U[macros])" Category="Advanced" Switch="U" F1Keyword="VC.Project.VCMidlTool.UndefinePreprocessorDefinitions">
  </StringListProperty>
  <EnumProperty Name="EnableErrorChecks" DisplayName="Enable Error Checking" Description="Select error checking option ([/error all|none])" Category="Advanced" F1Keyword="VC.Project.VCMidlTool.EnableErrorChecks">
    <EnumValue Name="EnableCustom" Switch="" DisplayName="EnableCustom" Description="All">
    </EnumValue>
    <EnumValue Name="All" Switch="error all" DisplayName="All" Description="All">
    </EnumValue>
    <EnumValue Name="None" Switch="error none" DisplayName="None" Description="None">
    </EnumValue>
  </EnumProperty>
  <BoolProperty Name="ErrorCheckAllocations" DisplayName="Check Allocations" Description="Check for out of memory errors (/error allocation)" Category="Advanced" Switch="error allocation" F1Keyword="VC.Project.VCMidlTool.ErrorCheckAllocations">
  </BoolProperty>
  <BoolProperty Name="ErrorCheckBounds" DisplayName="Check Bounds" Description="Check size vs transmission length specification (/error bounds_check)" Category="Advanced" Switch="error bounds_check" F1Keyword="VC.Project.VCMidlTool.ErrorCheckBounds">
  </BoolProperty>
  <BoolProperty Name="ErrorCheckEnumRange" DisplayName="Check Enum Range" Description="Check enum values to be in allowable range (/error enum)" Category="Advanced" Switch="error enum" F1Keyword="VC.Project.VCMidlTool.ErrorCheckEnumRange">
  </BoolProperty>
  <BoolProperty Name="ErrorCheckRefPointers" DisplayName="Check Reference Pointers" Description="Check ref pointers to be non-null (/error ref)" Category="Advanced" Switch="error ref" F1Keyword="VC.Project.VCMidlTool.ErrorCheckRefPointers">
  </BoolProperty>
  <BoolProperty Name="ErrorCheckStubData" DisplayName="Check Stub Data" Description="Emit additional check for server side stub data validity (/error stub_data)" Category="Advanced" Switch="error stub_data" F1Keyword="VC.Project.VCMidlTool.ErrorCheckStubData">
  </BoolProperty>
  <BoolProperty ReverseSwitch="no_robust" Name="ValidateAllParameters" DisplayName="Validate Parameters" Description="Generate additonal information to validate parameters (/robust|/no_robust)" Category="Advanced" Switch="robust" F1Keyword="VC.Project.VCMidlTool.ValidateParameters">
  </BoolProperty>
  <EnumProperty Name="StructMemberAlignment" DisplayName="Struct Member Alignment" Description="Specifies the packing level of structures in the target system (/ZpN)" Category="Advanced" F1Keyword="VC.Project.VCMidlTool.StructMemberAlignment">
    <EnumValue Name="NotSet" Switch="" DisplayName="Not Set" Description="Not Set">
    </EnumValue>
    <EnumValue Name="1" Switch="Zp1" DisplayName="1 Byte" Description="Zp1">
    </EnumValue>
    <EnumValue Name="2" Switch="Zp2" DisplayName="2 Byte" Description="Zp2">
    </EnumValue>
    <EnumValue Name="4" Switch="Zp4" DisplayName="4 Byte" Description="Zp4">
    </EnumValue>
    <EnumValue Name="8" Switch="Zp8" DisplayName="8 Byte" Description="Zp8">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="file" Name="RedirectOutputAndErrors" DisplayName="Redirect Output" Description="Redirects output from screen to a file (/o file)" Category="Advanced" Switch="o" Separator=" " F1Keyword="VC.Project.VCMidlTool.RedirectOutputAndErrors">
  </StringProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\mt.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="Mt" PageTemplate="tool" DisplayName="Manifest Tool" SwitchPrefix="/" Order="30" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Input and Output" DisplayName="Input and Output" />
    <Category Name="Isolated COM" DisplayName="Isolated COM" />
    <Category Name="Advanced" DisplayName="Advanced" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Manifest" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Runs without displaying standard Microsoft copyright data. (-nologo)" Category="General" Switch="nologo" F1Keyword="VC.Project.VCManifestTool.SuppressStartupBanner">
  </BoolProperty>
  <BoolProperty Name="VerboseOutput" DisplayName="Verbose Output" Description="Displays additional information during manifest generation. (-verbose)" Category="General" Switch="verbose" F1Keyword="VC.Project.VCManifestTool.VerboseOutput">
  </BoolProperty>
  <StringProperty Name="AssemblyIdentity" DisplayName="Assembly Identity" Description="The identity string contains the attributes of the assemblyIdentity element. (-identity:[identity string])" Category="General" Switch="identity:" F1Keyword="VC.Project.VCManifestTool.AssemblyIdentity">
  </StringProperty>
  <StringListProperty CommandLineValueSeparator=" " Subtype="file" Name="AdditionalManifestFiles" DisplayName="Additional Manifest Files" Description="Used to specify manifests that need to be processed. (-manifest [manifest1] [manifest2] ...)" Category="Input and Output" Switch="manifest" Separator=" " F1Keyword="VC.Project.VCManifestTool.AdditionalManifestFiles">
  </StringListProperty>
  <StringProperty Name="InputResourceManifests" DisplayName="Input Resource Manifests" Description="Input the manifest from a resource of type RT_MANIFEST with the specified id. (-inputresource:[file];#[resource ID])" Category="Input and Output" Switch="inputresource:" F1Keyword="VC.Project.VCManifestTool.InputResourceManifests">
  </StringProperty>
  <BoolProperty Name="EmbedManifest" DisplayName="Embed Manifest" Description="Specifies if the manifest file should be embedded in the assembly or created as a stand-alone file." Category="Input and Output" IncludeInCommandLine="false" F1Keyword="VC.Project.VCManifestTool.EmbedManifest">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <StringProperty Subtype="file" Name="OutputManifestFile" DisplayName="Output Manifest File" Description="Output the manifest to a resource of type RT_MANIFEST with the specified id. (-out:[file];#[resource ID])" Category="Input and Output" Switch="out:" F1Keyword="VC.Project.VCManifestTool.OutputManifestFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="ResourceOutputFileName" DisplayName="Manifest Resource File" Description="Specifies the output resources file used to embed the manifest into the project output." Category="Input and Output" F1Keyword="VC.Project.VCManifestTool.ResourceOutputFileName">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="ManifestResourceCompile" Label="" HasConfigurationCondition="true" />
    </StringProperty.DataSource>
  </StringProperty>
  <BoolProperty Name="GenerateCatalogFiles" DisplayName="Generate Catalog Files" Description="Generates .cdf files to make catalogs. (/makecdfs)" Category="Input and Output" Switch="makecdfs" F1Keyword="VC.Project.VCManifestTool.GenerateCatalogFiles">
  </BoolProperty>
  <StringProperty Subtype="file" Name="DependencyInformationFile" DisplayName="Dependency Information File" Description="Specifies the dependency information file used by Visual Studio to track build dependency information for the manifest tool." Category="Input and Output" Visible="false" F1Keyword="VC.Project.VCManifestTool.DependencyInformationFile">
  </StringProperty>
  <StringProperty Name="OutputResourceManifests" DisplayName="Output Resource Manifests" Description="Output the manifest to a resource of type RT_MANIFEST with the specified id. resource_id is restricted to be a non-negative 16 bit number. (-outputresource:file[;[#]resource_id])" Category="Input and Output" Switch="outputresource:" Visible="false" F1Keyword="VC.Project.VCManifestTool.OutputResourceManifest">
  </StringProperty>
  <StringProperty Subtype="file" Name="ManifestFromManagedAssembly" DisplayName="Generate Manifest From ManagedAssembly" Description="Generates a manifest from a managed assembly. (-managedassemblyname:[file])" Category="Input and Output" Switch="managedassemblyname:" F1Keyword="VC.Project.VCManifestTool.ManifestFromManagedAssembly">
  </StringProperty>
  <BoolProperty Name="SuppressDependencyElement" DisplayName="Suppress Dependency Element" Description="Used with -managedassembly. suppresses the generation of dependency elements in the final manifest. (-nodependency)" Category="Input and Output" Switch="nodependency" F1Keyword="VC.Project.VCManifestTool.SuppressDependencyElement">
  </BoolProperty>
  <BoolProperty Name="GenerateCategoryTags" DisplayName="Generate Category Tags" Description="Used with -managedassembly. -category causes the category tags to be generated. (-category)" Category="Input and Output" Switch="category" F1Keyword="VC.Project.VCManifestTool.GenerateCategoryTags">
  </BoolProperty>
  <BoolProperty Name="EnableDPIAwareness" DisplayName="Enable DPI Awareness" Description="Adds information to the manifest that marks the application as DPI-aware." Category="Input and Output" F1Keyword="VC.Project.VCManifestTool.EnableDPIAwareness">
  </BoolProperty>
  <StringProperty Subtype="file" Name="TypeLibraryFile" DisplayName="Type Library File" Description="Specifies the type library to use for regfree COM manifest support. (-tlb:[file])" Category="Isolated COM" Switch="tlb:" F1Keyword="VC.Project.VCManifestTool.TypeLibraryFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="RegistrarScriptFile" DisplayName="Registrar Script File" Description="Specifies the registrar script file to use for regfree COM manifest support. (-rgs:[file])" Category="Isolated COM" Switch="rgs:" F1Keyword="VC.Project.VCManifestTool.RegistrarScriptFile">
  </StringProperty>
  <StringProperty Subtype="file" Name="ComponentFileName" DisplayName="Component File Name" Description="Specifies the file name of the component that is built from the .tlb or .rgs specified. (-dll:[file])" Category="Isolated COM" Switch="dll:" F1Keyword="VC.Project.VCManifestTool.ComponentFileName">
  </StringProperty>
  <StringProperty Subtype="file" Name="ReplacementsFile" DisplayName="Replacements File" Description="Specifies the file that contains values for replaceable strings in the RGS file. (replacements:[file])" Category="Isolated COM" Switch="replacements:" F1Keyword="VC.Project.VCManifestTool.ReplacementsFile">
  </StringProperty>
  <BoolProperty Name="UpdateFileHashes" DisplayName="Update File Hashes" Description="Computes the hash of files specified in the file elements and updates the hash attribute with this value. (hashupdate:[path])" Category="Advanced" Switch="hashupdate" F1Keyword="VC.Project.VCManifestTool.UpdateFileHashes">
    <Argument Property="UpdateFileHashesSearchPath" IsRequired="false" />
  </BoolProperty>
  <StringProperty Subtype="file" Name="UpdateFileHashesSearchPath" DisplayName="Update File Hashes Search Path" Description="Specifies the search path to use when updating the file hashes." Category="Advanced" Separator=":" F1Keyword="VC.Project.VCManifestTool.UpdateFileHashesSearchPath">
  </StringProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\lib.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="LIB" PageTemplate="tool" DisplayName="Librarian" SwitchPrefix="/" Order="40" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Lib" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <StringProperty Subtype="file" Name="OutputFile" DisplayName="Output File" Description="The /OUT option overrides the default name and location of the program that the lib creates." Category="General" Switch="OUT" Separator=":" F1Keyword="VC.Project.VCLibrarianTool.OutputFile">
  </StringProperty>
  <StringListProperty Subtype="file" Name="AdditionalDependencies" DisplayName="Additional Dependencies" Description="Specifies additional items to add to the link command line [i.e. kernel32.lib] " Category="General" F1Keyword="VC.Project.VCLibrarianTool.AdditionalDependencies">
  </StringListProperty>
  <StringListProperty Subtype="folder" Name="AdditionalLibraryDirectories" DisplayName="Additional Library Directories" Description="Allows the user to override the environmental library path" Category="General" Switch="LIBPATH:" F1Keyword="VC.Project.VCLibrarianTool.AdditionalLibraryDirectories">
  </StringListProperty>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="The /NOLOGO option prevents display of the copyright message and version number. " Category="General" Switch="NOLOGO" F1Keyword="VC.Project.VCLibrarianTool.SuppressStartupBanner">
  </BoolProperty>
  <StringProperty Subtype="file" Name="ModuleDefinitionFile" DisplayName="Module Definition File Name" Description="The /DEF option passes a module-definition file (.def) to LIB. Only one .def file can be specified to LIB." Category="General" Switch="DEF" Separator=":" F1Keyword="VC.Project.VCLibrarianTool.ModuleDefinitionFile">
  </StringProperty>
  <BoolProperty Name="IgnoreAllDefaultLibraries" DisplayName="Ignore All Default Libraries" Description="The /NODEFAULTLIB option tells the lib to remove one or more default libraries from the list of libraries it searches when resolving external references. " Category="General" Switch="NODEFAULTLIB" F1Keyword="VC.Project.VCLibrarianTool.IgnoreAllDefaultLibraries">
  </BoolProperty>
  <StringListProperty Subtype="file" Name="IgnoreSpecificDefaultLibraries" DisplayName="Ignore Specific Default Libraries" Description="A library that you want the lib to ignore when it resolves external references." Category="General" Switch="NODEFAULTLIB:" F1Keyword="VC.Project.VCLibrarianTool.IgnoreDefaultLibraryNames">
  </StringListProperty>
  <StringListProperty Name="ExportNamedFunctions" DisplayName="Export Named Functions" Description="Export one or more specified functions " Category="General" Switch="EXPORT:" F1Keyword="VC.Project.VCLibrarianTool.ExportNamedFunctions">
  </StringListProperty>
  <StringProperty Name="ForceSymbolReferences" DisplayName="Force Symbol References" Description="Force Lib to include a reference to this symbol" Category="General" Switch="INCLUDE" Separator=":" F1Keyword="VC.Project.VCLibrarianTool.ForceSymbolReferences">
  </StringProperty>
  <BoolProperty Name="UseUnicodeResponseFiles" DisplayName="Use Unicode Response Files" Description="Use UNICODE Response Files : Instructs the project system to generate UNICODE response files when spawning the librarian.  Set this property to 'Yes' when files in the project have UNICODE paths." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCLibrarianTool.UseUnicodeResponseFiles">
  </BoolProperty>
  <BoolProperty Name="LinkLibraryDependencies" DisplayName="Link Library Dependencies" Description="Specifies whether or not library outputs from project dependencies are automatically linked in." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCLibrarianTool.LinkLibraryDependencies">
    <BoolProperty.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="ProjectReference" Label="" HasConfigurationCondition="true" />
    </BoolProperty.DataSource>
  </BoolProperty>
  <EnumProperty Name="ErrorReporting" DisplayName="Error Reporting" Description="Allows you to provide internal compiler error (ICE) information directly to Microsoft." Category="General" F1Keyword="VC.Project.VCLibrarianTool.ErrorReporting">
    <EnumValue Name="PromptImmediately" Switch="ERRORREPORT:PROMPT" DisplayName="PromptImmediately" Description="Prompt Immediately.">
    </EnumValue>
    <EnumValue Name="QueueForNextLogin" Switch="ERRORREPORT:QUEUE" DisplayName="Queue For Next Login" Description="Queue for next login.">
    </EnumValue>
    <EnumValue Name="SendErrorReport" Switch="ERRORREPORT:SEND" DisplayName="Send Error Report" Description="Send error report.">
    </EnumValue>
    <EnumValue Name="NoErrorReport" Switch="ERRORREPORT:NONE" DisplayName="No Error Report" Description="No error report.">
    </EnumValue>
  </EnumProperty>
  <StringProperty Name="DisplayLibrary" DisplayName="Display Library to standard output" Description="Displays information about the output library to standard output. The output can be redirected to a file. You can use /LIST to determine the contents of an existing library without modifying it." Category="General" Switch="LIST" Separator=":" Visible="false">
  </StringProperty>
  <BoolProperty ReverseSwitch="WX:NO" Name="TreatLibWarningAsErrors" DisplayName="Treat Lib Warning As Errors" Description="/WX causes no output file to be generated if lib generates a warning." Category="General" Switch="WX" F1Keyword="VC.Project.VCLibrarianTool.TreatLibWarningsAsErrors">
  </BoolProperty>
  <EnumProperty Name="TargetMachine" DisplayName="Target Machine" Description="The /MACHINE option specifies the target platform for the program." Category="General" F1Keyword="VC.Project.VCLibrarianTool.TargetMachine">
    <EnumValue Name="MachineARM" Switch="MACHINE:ARM" DisplayName="MachineARM" Description="MachineARM">
    </EnumValue>
    <EnumValue Name="MachineEBC" Switch="MACHINE:EBC" DisplayName="MachineEBC" Description="MachineEBC">
    </EnumValue>
    <EnumValue Name="MachineIA64" Switch="MACHINE:IA64" DisplayName="MachineIA64" Description="MachineIA64">
    </EnumValue>
    <EnumValue Name="MachineMIPS" Switch="MACHINE:MIPS" DisplayName="MachineMIPS" Description="MachineMIPS">
    </EnumValue>
    <EnumValue Name="MachineMIPS16" Switch="MACHINE:MIPS16" DisplayName="MachineMIPS16" Description="MachineMIPS16">
    </EnumValue>
    <EnumValue Name="MachineMIPSFPU" Switch="MACHINE:MIPSFPU" DisplayName="MachineMIPSFPU" Description="MachineMIPSFPU">
    </EnumValue>
    <EnumValue Name="MachineMIPSFPU16" Switch="MACHINE:MIPSFPU16" DisplayName="MachineMIPSFPU16" Description="MachineMIPSFPU16">
    </EnumValue>
    <EnumValue Name="MachineSH4" Switch="MACHINE:SH4" DisplayName="MachineSH4" Description="MachineSH4">
    </EnumValue>
    <EnumValue Name="MachineTHUMB" Switch="MACHINE:THUMB" DisplayName="MachineTHUMB" Description="MachineTHUMB">
    </EnumValue>
    <EnumValue Name="MachineX64" Switch="MACHINE:X64" DisplayName="MachineX64" Description="MachineX64">
    </EnumValue>
    <EnumValue Name="MachineX86" Switch="MACHINE:X86" DisplayName="MachineX86" Description="MachineX86">
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name="SubSystem" DisplayName="SubSystem" Description="The /SUBSYSTEM option tells the operating system how to run the .exe file.The choice of subsystem affects the entry point symbol (or entry point function) that the linker will choose." Category="General" F1Keyword="VC.Project.VCLibrarianTool.SubSystem">
    <EnumProperty.Arguments>
      <Argument Property="MinimumRequiredVersion" IsRequired="false" />
    </EnumProperty.Arguments>
    <EnumValue Name="Console" Switch="SUBSYSTEM:CONSOLE" DisplayName="Console" Description="Win32 character-mode application. Console applications are given a console by the operating system. If main or wmain is defined, CONSOLE is the default.">
    </EnumValue>
    <EnumValue Name="Windows" Switch="SUBSYSTEM:WINDOWS" DisplayName="Windows" Description="Application does not require a console, probably because it creates its own windows for interaction with the user. If WinMain or wWinMain is defined, WINDOWS is the default.">
    </EnumValue>
    <EnumValue Name="Native" Switch="SUBSYSTEM:NATIVE" DisplayName="Native" Description="Device drivers for Windows NT. If /DRIVER:WDM is specified, NATIVE is the default.">
    </EnumValue>
    <EnumValue Name="EFI Application" Switch="SUBSYSTEM:EFI_APPLICATION" DisplayName="EFI Application" Description="EFI Application.">
    </EnumValue>
    <EnumValue Name="EFI Boot Service Driver" Switch="SUBSYSTEM:EFI_BOOT_SERVICE_DRIVER" DisplayName="EFI Boot Service Driver" Description="EFI boot service driver.">
    </EnumValue>
    <EnumValue Name="EFI ROM" Switch="SUBSYSTEM:EFI_ROM" DisplayName="EFI ROM" Description="EFI ROM.">
    </EnumValue>
    <EnumValue Name="EFI Runtime" Switch="SUBSYSTEM:EFI_RUNTIME_DRIVER" DisplayName="EFI Runtime" Description="EFI runtime.">
    </EnumValue>
    <EnumValue Name="WindowsCE" Switch="SUBSYSTEM:WINDOWSCE" DisplayName="WindowsCE" Description="Application that runs on a Windows CE device.">
    </EnumValue>
    <EnumValue Name="POSIX" Switch="SUBSYSTEM:POSIX" DisplayName="POSIX" Description="Application that runs with the POSIX subsystem in Windows NT.">
    </EnumValue>
  </EnumProperty>
  <StringProperty Name="MinimumRequiredVersion" DisplayName="Minimum Required Version" Description="Specify the minimum required version of the subsystem. The arguments are decimal numbers in the range 0 through 65,535." Category="General" Separator=",">
  </StringProperty>
  <StringListProperty Subtype="file" Name="RemoveObjects" DisplayName="Remove Objects" Description="Omits the specified object from the output library. LIB creates an output library by combining all objects (whether in object files or libraries), and then deleting any objects specified with /REMOVE." Category="General" Switch="REMOVE:" F1Keyword="VC.Project.VCLibrarianTool.RemoveObjects">
  </StringListProperty>
  <BoolProperty Name="Verbose" DisplayName="Verbose" Description="Verbose" Category="General" Switch="VERBOSE" F1Keyword="VC.Project.VCLibrarianTool.Verbose">
  </BoolProperty>
  <StringProperty Subtype="file" Name="Name" DisplayName="Name" Description="When building an import library, specifies the name of the DLL for which the import library is being built." Category="General" Switch="NAME:" F1Keyword="VC.Project.VCLibrarianTool.Name">
  </StringProperty>
  <BoolProperty Name="LinkTimeCodeGeneration" DisplayName="Link Time Code Generation" Description="Specifies link-time code generation" Category="General" Switch="LTCG" F1Keyword="VC.Project.VCLibrarianTool.LinkTimeCodeGeneration">
  </BoolProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker log directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\general_ps.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="ConfigurationGeneral"
      DisplayName="General"
      PageTemplate="generic"
      Description="General"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" Label="Configuration" />
  </Rule.DataSource>
  <StringProperty Name="OutDir" DisplayName="Output Directory"
                  Description="Specifies a relative path to the output file directory; can include environment variables."
                  Category="General" Default="$(SolutionDir)$(Configuration)\"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.OutputDirectory">
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="IntDir" DisplayName="Intermediate Directory"
                  Description="Specifies a relative path to the intermediate file directory; can include environment variables."
                  Category="General" Default="$(Configuration)\"
                  Subtype="folder"
                  F1Keyword="VC.Project.VCConfiguration.IntermediateDirectory">
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="TargetName" DisplayName="Target Name"
                  Description="Specifies a file name that this project will generate."
                  F1Keyword="VC.Project.VCConfiguration.TargetName"
                  Category="General" Default="$(ProjectName)"
                  >
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringProperty Name="TargetExt" DisplayName="Target Extension"
                  Description="Specifies a file extension that this project will generate. (Example: .exe or .dll)"
                  F1Keyword="VC.Project.VCConfiguration.TargetExt"
                  Category="General"
                  >
                  <StringProperty.DataSource>
                     <DataSource Persistence="ProjectFile" Label="" />
                  </StringProperty.DataSource>
  </StringProperty>
  <StringListProperty Name="ExtensionsToDeleteOnClean" DisplayName="Extensions to Delete on Clean"
                      Description="Semi-colon delimited wildcard specification for which files in the intermediate directory to delete on clean or rebuild."
                      Category="General" Separator=";"
                      F1Keyword="VC.Project.VCConfiguration.DeleteExtensionsOnClean">
                      <StringListProperty.DataSource>
                            <DataSource Persistence="ProjectFile" Label="" />
                      </StringListProperty.DataSource>
  </StringListProperty>
  <StringProperty Name="BuildLogFile" DisplayName="Build Log File"
                  Description="Specifies the build log file to write to when build logging is enabled."
                  F1Keyword="VC.Project.VCConfiguration.BuildLogFile"
                  Category="General" Default="$(ProjectDir)\$(MSBuildProjectName).log"
                  Subtype="file"/>
  <!-- There is no InheritProjectPropertySheets in the project file. The property sheets will be expressed as explicit Imports.
  <StringListProperty Name="InheritProjectPropertySheets" DisplayName="Inherit Project Property Sheets"
                      Description="Specifies the project property sheets this configuration or property sheet inherits from."
                      Category="General" Separator=";" Subtype="file" /> -->
  <StringProperty Name="_ProjectFileVersion" DisplayName="Project File Version"
                Description="Specifies the version of the conversion tool used to create this project file."
                Category="General" Visible="false">
    <StringProperty.DataSource>
      <DataSource Persistence="ProjectFile" />
    </StringProperty.DataSource>
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\ProjectItemsSchema.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<ProjectSchemaDefinitions
    xmlns="http://schemas.microsoft.com/build/2009/properties">


    <ContentType
        Name="CppCode"
        DisplayName="C/C++ Code"
        ItemType="ClCompile">
    </ContentType>

    <ContentType
        Name="CppHeader"
        DisplayName="C/C++ Header"
        ItemType="ClInclude">
    </ContentType>

    <ContentType
        Name="CppClass"
        DisplayName="C++ Class"
        ItemType="ClCompile">
    </ContentType>

    <ContentType
        Name="CppForm"
        DisplayName="C++ Form"
        ItemType="ClCompile">
    </ContentType>

    <ContentType
        Name="CppControl"
        DisplayName="C++ Control"
        ItemType="ClCompile">
    </ContentType>


    <ContentType
        Name="Text"
        DisplayName="Text file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="DEF"
        DisplayName="DEF file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="Midl"
        DisplayName="Idl file"
        ItemType="Midl">
    </ContentType>

    <ContentType
        Name="Makefile"
        DisplayName="Makefile"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="RGS"
        DisplayName="RGS file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="RC"
        DisplayName="RC file"
        ItemType="ResourceCompile">
    </ContentType>

    <ContentType
        Name="RC2"
        DisplayName="RC2 file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="RES"
        DisplayName="RES file"
        ItemType="Resource">
    </ContentType>

    <ContentType
        Name="XSD"
        DisplayName="XSD file"
        ItemType="Xsd">
    </ContentType>

    <ContentType
        Name="XML"
        DisplayName="Xml file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="HTML"
        DisplayName="Html file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="CSS"
        DisplayName="Cascading style sheet"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="BMP"
        DisplayName="Bitmap"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="ICO"
        DisplayName="Icon"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="Resx"
        DisplayName="Resx file"
        ItemType="EmbeddedResource">
    </ContentType>

    <ContentType
        Name="Script"
        DisplayName="Script file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="BSC"
        DisplayName="Bsc file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="XSX"
        DisplayName="XSX file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="CppWebService"
        DisplayName="C++ Web service"
        ItemType="ClInclude">
    </ContentType>

    <ContentType
        Name="Asax"
        DisplayName="Asax file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="AspPage"
        DisplayName="ASP page"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="Document"
        DisplayName="Document"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="Discomap"
        DisplayName="Discovery file"
        ItemType="CustomBuild">
    </ContentType>

    <ContentType
        Name="CSharpFile"
        DisplayName="C# file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="ClassDiagram"
        DisplayName="Class Diagram"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="MHT"
        DisplayName="MHT file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="CUR"
        DisplayName="Cursor"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="Manifest"
        DisplayName="Manifest"
        ItemType="Manifest">
    </ContentType>

    <ContentType
        Name="RDLC"
        DisplayName="RDLC file"
        ItemType="None">
    </ContentType>

    <ContentType
        Name="OBJ"
        DisplayName="Object file"
        ItemType="Object">
    </ContentType>

    <ContentType
      Name="LIB"
      DisplayName="Library file"
      ItemType="Library">
    </ContentType>

    <ContentType
      Name="RSC"
      DisplayName="Resource"
      ItemType="Resource">
    </ContentType>

    <ContentType
      Name="Licenses"
      DisplayName="Compiled License"
      ItemType="_EmbedManagedResourceFile">
    </ContentType>

    <ItemType Name="ClCompile" DisplayName="C/C++ compiler"/>
    <ItemType Name="ClInclude" DisplayName="C/C++ header"/>
    <ItemType Name="Midl" DisplayName="MIDL tool"/>
    <ItemType Name="ResourceCompile" DisplayName="Resource compiler"/>
    <ItemType Name="EmbeddedResource" DisplayName="Managed resource compiler"/>
    <ItemType Name="Xsd" DisplayName="XML Data Generator Tool"/>
    <ItemType Name="CustomBuild" DisplayName="Custom Build Tool"/>
    <ItemType Name="None" DisplayName="Does not participate in build"/>
    <ItemType Name="Resource" DisplayName="Resource"/>
    <ItemType Name="Object" DisplayName="Object"/>
    <ItemType Name="Library" DisplayName="Library"/>
    <ItemType Name="Manifest" DisplayName="Manifest Tool"/>
    <ItemType Name="_EmbedManagedResourceFile" DisplayName="Compiled Managed Resource"/>

    <FileExtension Name=".cpp" ContentType="CppCode"/>
    <FileExtension Name=".c" ContentType="CppCode"/>
    <FileExtension Name=".cc" ContentType="CppCode"/>
    <FileExtension Name=".cxx" ContentType="CppCode"/>

    <FileExtension Name=".h" ContentType="CppHeader"/>
    <FileExtension Name=".hpp" ContentType="CppHeader"/>
    <FileExtension Name=".hxx" ContentType="CppHeader"/>

    <FileExtension Name=".idl" ContentType="Midl"/>
    <FileExtension Name=".odl" ContentType="Midl"/>

    <FileExtension Name=".asax" ContentType="Asax"/>
    <FileExtension Name=".asmx" ContentType="HTML"/>
    <FileExtension Name=".asp" ContentType="AspPage"/>
    <FileExtension Name=".def" ContentType="DEF"/>
    <FileExtension Name=".mk" ContentType="MakeFile"/>
    <FileExtension Name=".mak" ContentType="MakeFile"/>
    <FileExtension Name=".txt" ContentType="Text"/>
    <FileExtension Name=".rgs" ContentType="RGS"/>
    <FileExtension Name=".rc" ContentType="RC"/>
    <FileExtension Name=".rc2" ContentType="RC2"/>
    <FileExtension Name=".res" ContentType="RES"/>
    <FileExtension Name=".resx" ContentType="RESX"/>
    <FileExtension Name=".html" ContentType="HTML"/>
    <FileExtension Name=".htm" ContentType="HTML"/>
    <FileExtension Name=".css" ContentType="CSS"/>
    <FileExtension Name=".bmp" ContentType="BMP"/>
    <FileExtension Name=".ico" ContentType="ICO"/>
    <FileExtension Name=".cur" ContentType="CUR"/>
    <FileExtension Name=".vbS" ContentType="Script"/>
    <FileExtension Name=".jS" ContentType="Script"/>
    <FileExtension Name=".xml" ContentType="XML"/>
    <FileExtension Name=".xsd" ContentType="XSD"/>
    <FileExtension Name=".wsdl" ContentType="Discomap"/>
    <FileExtension Name=".disco" ContentType="Discomap"/>
    <FileExtension Name=".discomap" ContentType="Discomap"/>
    <FileExtension Name=".cs" ContentType="CSharpFile"/>
    <FileExtension Name=".bsc" ContentType="BSC"/>
    <FileExtension Name=".mht" ContentType="MHT"/>
    <FileExtension Name=".manifest" ContentType="Manifest"/>
    <FileExtension Name=".rdlc" ContentType="RDLC"/>
    <FileExtension Name=".cd" ContentType="ClassDiagram"/>
    <FileExtension Name=".obj" ContentType="OBJ"/>
    <FileExtension Name=".lib" ContentType="LIB"/>
    <FileExtension Name=".rsc" ContentType="RSC"/>
    <FileExtension Name=".licenses" ContentType="Licenses"/>
</ProjectSchemaDefinitions>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\nmake.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
      Name="ConfigurationNMake"
      DisplayName="NMake"
      PageTemplate="generic"
      Description="NMake"
      SwitchPrefix="/"
      Order="100"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
    <Category Name="IntelliSense" DisplayName="IntelliSense" Description="IntelliSense" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" />
  </Rule.DataSource>
  <StringProperty Name="NMakeBuildCommandLine" DisplayName="Build Command Line"
                  Description="Specifies the command line to run for the 'Build' command."
                  IncludeInCommandLine="false"
                  Category="General" 
                  F1Keyword="VC.Project.VCNMakeTool.BuildCommandLine">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="NMakeReBuildCommandLine" DisplayName="Rebuild All Command Line"
                  Description="Specifies the command line to run for the 'Rebuild All' command."
                  IncludeInCommandLine="false"
                  Category="General"
                  F1Keyword="VC.Project.VCNMakeTool.ReBuildCommandLine">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="NMakeCleanCommandLine" DisplayName="Clean Command Line"
                  Description="Specifies the command line to run for the 'Clean' command."
                  IncludeInCommandLine="false"
                  Category="General" 
                  F1Keyword="VC.Project.VCNMakeTool.CleanCommandLine">
    <StringProperty.ValueEditors>
      <ValueEditor EditorType="DefaultCommandPropertyEditor" DisplayName="&lt;Edit...&gt;"/>
    </StringProperty.ValueEditors>
  </StringProperty>
  <StringProperty Name="NMakeOutput" DisplayName="Output"
                  Description='Specifies the output file to generate.'
                  Category="General" 
                  IncludeInCommandLine="false"
                  F1Keyword="VC.Project.VCNMakeTool.Output"/>
  <StringListProperty Name="NMakePreprocessorDefinitions" DisplayName="Preprocessor Definitions" Category="IntelliSense" Switch="D"
                  Description="Specifies the preprocessor defines used by the source files." 
                  F1Keyword="VC.Project.VCNMakeTool.PreprocessorDefinitions"/>
  <StringListProperty Name="NMakeIncludeSearchPath" DisplayName="Include Search Path" Category="IntelliSense" Switch="I"
                  Description="Specifies the include search path for resolving included files." Subtype="folder" 
                  F1Keyword="VC.Project.VCNMakeTool.IncludeSearchPath"/>
  <StringListProperty Name="NMakeForcedIncludes" DisplayName="Forced Includes" Category="IntelliSense" Switch="FI"
                  Description="Specifies the files that are forced included." Subtype="folder"
                   F1Keyword="VC.Project.VCNMakeTool.ForcedIncludes"/>
  <StringListProperty Name="NMakeAssemblySearchPath" DisplayName="Assembly Search Path" Category="IntelliSense" Switch="AI"
                  Description="Specifies the assembly search path for resolving used .NET assemblies." Subtype="folder"
                  F1Keyword="VC.Project.VCNMakeTool.AssemblySearchPath"/>
  <StringListProperty Name="NMakeForcedUsingAssemblies" DisplayName="Forced Using Assemblies" Category="IntelliSense" Switch="FU"
                  Description="Specifies the assemblies that are forced using in the source files."
                  F1Keyword="VC.Project.VCNMakeTool.ForcedUsingAssemblies" />
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Category="IntelliSense"
                  Description="Specifies additional compiler switches to be used by Intellisense when parsing C++ files" />
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\rc.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="RC" PageTemplate="tool" DisplayName="Resources" SwitchPrefix="/" Order="50" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" Description="General" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="ResourceCompile" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <StringListProperty Name="PreprocessorDefinitions" DisplayName="Preprocessor Definitions" Description="Specifies one or more defines for the resource compiler. (/d[macro])" Category="General" Switch="D " F1Keyword="VC.Project.VCResourceCompilerTool.PreprocessorDefinitions">
  </StringListProperty>
  <StringListProperty Name="UndefinePreprocessorDefinitions" DisplayName="Undefine Preprocessor Definitions" Description="Undefine a symbol. (/u)" Category="General" Switch="u" F1Keyword="VC.Project.VCResourceCompilerTool.UndefineProcessorDefinitions">
  </StringListProperty>
  <DynamicEnumProperty EnumProvider="cultures" Name="Culture" DisplayName="Culture" Description="Lists the culture (such as US English or Italian) used in the resources. (/l [num])" Category="General" Switch="l" F1Keyword="VC.Project.VCResourceCompilerTool.Culture">
    <DynamicEnumProperty.ProviderSettings>
      <NameValuePair Name="DisplayNameFormat" Value="{}{1} (0x{0:x})" />
      <NameValuePair Name="SwitchFormat" Value="{}l 0x{0:x4}" />
    </DynamicEnumProperty.ProviderSettings>
  </DynamicEnumProperty>
  <StringListProperty Subtype="folder" Name="AdditionalIncludeDirectories" DisplayName="Additional Include Directories" Description="Specifies one or more directories to add to the include path; use semi-colon delimiter if more than one. (/I[path])" Category="General" Switch="I" F1Keyword="VC.Project.VCResourceCompilerTool.AdditionalIncludeDirectories">
  </StringListProperty>
  <BoolProperty Name="IgnoreStandardIncludePath" DisplayName="Ignore Standard Include Paths" Description="Prevents the resource compiler from searching for include files in directories specified in the INCLUDE environment variables. (/X)" Category="General" Switch="X" F1Keyword="VC.Project.VCResourceCompilerTool.IgnoreStandardIncludePath">
  </BoolProperty>
  <BoolProperty Name="ShowProgress" DisplayName="Show Progress" Description="Send progress messages to output window. (/v)" Category="General" Switch="v" F1Keyword="VC.Project.VCResourceCompilerTool.ShowProgress">
  </BoolProperty>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Suppress the display of the startup banner and information message (/nologo)" Category="General" Switch="nologo" F1Keyword="VC.Project.VCResourceCompilerTool.SuppressStartupBanner">
  </BoolProperty>
  <StringProperty Name="ResourceOutputFileName" DisplayName="Resource File Name" Description="Specifies the name of the resource file (/fo[file])" Category="General" Switch="fo" F1Keyword="VC.Project.VCResourceCompilerTool.ResourceOutputFileName">
  </StringProperty>
  <BoolProperty Name="NullTerminateStrings" DisplayName="Null Terminate Strings" Description="Append null's to all strings in the string tables. (/n)" Category="General" Switch="n" F1Keyword="VC.Project.VCResourceCompilerTool.NullTerminateStrings">
  </BoolProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\resgen.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="Resgen" 
      DisplayName="Managed Resources" 
      Order="100" 
      PageTemplate="tool"
      xmlns="http://schemas.microsoft.com/build/2009/properties">
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="EmbeddedResource" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <StringProperty Name="LogicalName" DisplayName="Resource Logical Name" Description="Logical name of the resource in the final assembly." F1Keyword="VC.Project.VCManagedResourceCompilerTool.LogicalName" />
  <StringProperty Name="OutputFileName" ReadOnly="true" DisplayName="Output File Name" Description="Name of the final output file this .resx file contributes to." F1Keyword="VC.Project.VCManagedResourceCompilerTool.OutputFileName" />
  <BoolProperty Name="DefaultLocalizedResources" ReadOnly="true" DisplayName="Default Localized Resources" Description="Indicates whether this .resx file contributes to the default resources or to a satellite DLL.  This is controlled by the filename of the resource file." F1Keyword="VC.Project.VCManagedResourceCompilerTool.DefaultLocalizedResources" />
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\usermacros.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule
  xmlns="http://schemas.microsoft.com/build/2009/properties"
  Name="UserMacros" 
  PageTemplate="UserMacros" 
  DisplayName="User Macros" 
  Description="User Macros">
    <Rule.Categories>
      <Category Name="General" DisplayName="General" Description="General" />
    </Rule.Categories>
    <Rule.DataSource>
      <DataSource Persistence="ProjectFile" />
    </Rule.DataSource>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\BuildCustomizations\lc.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<ProjectSchemaDefinitions xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule
    Name="LicxCompiler"
    PageTemplate="tool"
    DisplayName="License Compiler"
    Order="200">
    <Rule.DataSource>
      <DataSource
        Persistence="ProjectFile"
        ItemType="LicxCompiler" />
    </Rule.DataSource>
    <Rule.Categories>
      <Category
        Name="General">
        <Category.DisplayName>
          <sys:String>General</sys:String>
        </Category.DisplayName>
      </Category>
      <Category
        Name="Command Line"
        Subtype="CommandLine">
        <Category.DisplayName>
          <sys:String>Command Line</sys:String>
        </Category.DisplayName>
      </Category>
    </Rule.Categories>
    <StringListProperty
      Name="Inputs"
      Category="Command Line"
      IsRequired="true"
      Switch="/complist:">
     <StringListProperty.DataSource>
       <DataSource
          Persistence="ProjectFile"
          ItemType="LicxCompiler"
          SourceType="Item" />
     </StringListProperty.DataSource>
   </StringListProperty>
    <BoolProperty
      Name="NoLogo"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrflicensecompilerlcexe.asp"
      DisplayName="Suppress Startup Banner"
      Description="Suppress the display of the startup banner and information messages.     (/nologo)"
      Switch="/nologo" />
    <BoolProperty
      Name="VerboseOutput"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrflicensecompilerlcexe.asp"
      DisplayName="Verbose Output"
      Description="Specifies verbose mode; displays compilation progress information.     (/v)"
      Switch="/v" />
    <StringProperty
      Name="TargetAssembly"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrflicensecompilerlcexe.asp"
      DisplayName="Target Assembly"
      Description="Specifies the executable for which the .licenses file is being generated.     (/target:[assembly])"
      Switch="/target:&quot;[value]&quot;" />
    <StringProperty
      Name="OutputDirectory"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrflicensecompilerlcexe.asp"
      DisplayName="Output Directory"
      Description="Specifies the directory in which to place the output .licenses file.     (/outdir:[directory])"
      Switch="/outdir:&quot;[value]&quot;" />
    <StringListProperty
      Name="ComponentModules"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrflicensecompilerlcexe.asp"
      DisplayName="Component Modules"
      Description="Specifies the list of modules that contain the components listed in the /complist file.     (/i:[module])"
      Switch="/i:&quot;[value]&quot;" />
    <BoolProperty
      Name="UseDefaultComponentModules"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrflicensecompilerlcexe.asp"
      DisplayName="Use Default Component Modules"
      Description="Use Default Component Modules." />
    <StringProperty
      Name="CommandLineTemplate"
      DisplayName="Command Line"
      Visible="False"
      IncludeInCommandLine="False" />
    <DynamicEnumProperty
    Name="LicxCompilerBeforeTargets"
    Category="General"
    EnumProvider="Targets"
    IncludeInCommandLine="False">
      <DynamicEnumProperty.DisplayName>
        <sys:String>Execute Before</sys:String>
      </DynamicEnumProperty.DisplayName>
      <DynamicEnumProperty.Description>
        <sys:String>Specifies the targets for the build customization to run before.</sys:String>
      </DynamicEnumProperty.Description>
      <DynamicEnumProperty.ProviderSettings>
        <NameValuePair
          Name="Exclude"
          Value="^LicxCompilerBeforeTargets|^Compute" />
      </DynamicEnumProperty.ProviderSettings>
      <DynamicEnumProperty.DataSource>
        <DataSource
          Persistence="ProjectFile"
          ItemType=""
          HasConfigurationCondition="true" />
      </DynamicEnumProperty.DataSource>
    </DynamicEnumProperty>
    <DynamicEnumProperty
      Name="LicxCompilerAfterTargets"
      Category="General"
      EnumProvider="Targets"
      IncludeInCommandLine="False">
      <DynamicEnumProperty.DisplayName>
        <sys:String>Execute After</sys:String>
      </DynamicEnumProperty.DisplayName>
      <DynamicEnumProperty.Description>
        <sys:String>Specifies the targets for the build customization to run after.</sys:String>
      </DynamicEnumProperty.Description>
      <DynamicEnumProperty.ProviderSettings>
        <NameValuePair
          Name="Exclude"
          Value="^LicxCompilerAfterTargets|^Compute" />
      </DynamicEnumProperty.ProviderSettings>
      <DynamicEnumProperty.DataSource>
        <DataSource
          Persistence="ProjectFile"
          ItemType=""
          HasConfigurationCondition="true" />
      </DynamicEnumProperty.DataSource>
    </DynamicEnumProperty>
    <StringListProperty
      Name="Outputs"
      DisplayName="Outputs"
      IncludeInCommandLine="False"
      Visible="False" />
    <StringProperty
      Name="ExecutionDescription"
      DisplayName="Execution Description"
      IncludeInCommandLine="False"
      Visible="False" />
    <StringListProperty
      Name="AdditionalDependencies"
      DisplayName="Additional Dependencies"
      IncludeInCommandLine="False"
      Visible="False" />
    <StringProperty
      Subtype="AdditionalOptions"
      Name="AdditionalOptions"
      Category="Command Line">
      <StringProperty.DisplayName>
        <sys:String>Additional Options</sys:String>
      </StringProperty.DisplayName>
      <StringProperty.Description>
        <sys:String>Additional Options</sys:String>
      </StringProperty.Description>
    </StringProperty>
  </Rule>
  <ItemType
    Name="LicxCompiler"
    DisplayName="License Compiler" />
  <FileExtension
    Name="*.licx"
    ContentType="LicxCompiler" />
  <ContentType
    Name="LicxCompiler"
    DisplayName="License Compiler"
    ItemType="LicxCompiler" />
</ProjectSchemaDefinitions>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Override\ProjectTypeGuids.txt ===
------------------------------------------------------------------------------------------------------------------------------------

Project Type Name                               Project Type Guid (UPPER CASE)              Project Type Guid (lower case)

------------------------------------------------------------------------------------------------------------------------------------

Windows (C#)                                    {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC} 
Windows (VB.NET)                                {F184B08F-C81C-45F6-A57F-5ABD9991F28F} 
Windows (Visual C++)                            {8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942} 
Web Application                                 {349C5851-65DF-11DA-9384-00065B846F21}      {349c5851-65df-11da-9384-00065b846f21} 
Web Site                                        {E24C65DC-7377-472B-9ABA-BC803B73C61A} 
Distributed System                              {F135691A-BF7E-435D-8960-F99683D2D49C} 
Windows Communication Foundation (WCF)          {3D9AD99F-2412-4246-B90B-4EAA41C64699} 
Windows Presentation Foundation (WPF)           {60DC8134-EBA5-43B8-BCC9-BB4BC16C2548} 
Visual Database Tools                           {C252FEB5-A946-4202-B1D4-9916A0590387} 
Database                                        {A9ACE9BB-CECE-4E62-9AA4-C7E7C5BD2124} 
Database (other project types)                  {4F174C21-8C12-11D0-8340-0000F80270F8} 
Test                                            {3AC096D0-A1C2-E12C-1390-A8335801FDAB}      {3ac096d0-a1c2-e12c-1390-a8335801fdab}
Legacy (2003) Smart Device (C#)                 {20D4826A-C6FA-45DB-90F4-C717570B9F32}      {20d4826a-c6fa-45db-90f4-c717570b9f32}
Legacy (2003) Smart Device (VB.NET)             {CB4CE8C6-1BDB-4DC7-A4D3-65A1999772F8}      {cb4ce8C6-1bdb-4dc7-a4d3-65a1999772f8}
Smart Device (C#)                               {4D628B5B-2FBC-4AA6-8C16-197242AEB884}      {4d628b5b-2fbc-4aa6-8c16-197242aeb884}
Smart Device (VB.NET)                           {68B1623D-7FB9-47D8-8664-7ECEA3297D4F}      {68b1623d-7fb9-47d8-8664-7ecea3297d4f}
Workflow (C#)                                   {14822709-B5A1-4724-98CA-57A101D1B079} 
Workflow (VB.NET)                               {D59BE175-2ED0-4C54-BE3D-CDAA9F3214C8} 
Deployment Merge Module                         {06A35CCD-C46D-44D5-987B-CF40FF872267} 
Deployment Cab                                  {3EA9E505-35AC-4774-B492-AD1749C4943A} 
Deployment Setup                                {978C614F-708E-4E1A-B201-565925725DBA} 
Deployment Smart Device Cab                     {AB322303-2255-48EF-A496-5904EB18DA55} 
Visual Studio Tools for Applications (VSTA)     {A860303F-1F3F-4691-B57E-529FC101A107} 
Visual Studio Tools for Office (VSTO)           {BAA0C2D2-18E2-41B9-852F-F413020CAA33} 
SharePoint Workflow                             {F8810EC1-6754-47FC-A15F-DFABD2E3FA90} 
XNA (Windows)                                   {6D335F3A-9D43-41b4-9D22-F6F17C4BE596} 
XNA (XBox)                                      {2DF5C3F4-5A5F-47a9-8E94-23B4456F55E2} 
XNA (Zune)                                      {D399B71A-8929-442a-A9AC-8BEC78BB2433} 
SharePoint (VB.NET)                             {EC05E597-79D4-47f3-ADA0-324C4F7C7484} 
SharePoint (C#)                                 {593B0543-81F6-4436-BA1E-4747859CAAE2} 
Silverlight                                     {A1591282-1198-4647-A2B1-27E5FF5F6F3B} 
Visual Studio Integration Package (VSIX)        {82B43B9B-A64C-4715-B499-D71E9CA2BD60}      {82b43b9b-a64c-4715-b499-d71e9ca2bd60}
SharePoint Project                              {BB1F664B-9266-4FD6-B973-E1E44974B511}      {bb1f664b-9266-4fd6-b973-e1e44974b511}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\v4.0\.README.txt ===
c:\Windows\Microsoft.NET\Framework\v4.0.30319
-accessibility.dll
-aspnet*
-Microsoft.*
-mscor*
-Service*
-System*.dll
-System*.tlb
-*.sql
-*.log
-*.h
-*.ini
-*chm
-.\ASP.NETWebAdminFiles
-.\Config
-.\en-us
-.\mof
-.\RedistList
-.\MUI
-.\SQL
-.\WPF
-.\Temporary ASP.NET Files
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\xdcmake.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="XDCMake" PageTemplate="tool" DisplayName="XML Document Generator" SwitchPrefix="/" Order="70" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Xdcmake" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <BoolProperty Name="SlashOld" Category="General" Switch="old" Visible="false">
  </BoolProperty>
  <StringProperty Name="ProjectName" SwitchPrefix="" Category="General" Visible="false">
  </StringProperty>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Runs without displaying standard Microsoft copyright data. (/nologo)" Category="General" Switch="nologo" F1Keyword="VC.Project.VCXDCMakeTool.SuppressStartupBanner">
  </BoolProperty>
  <StringListProperty Name="AdditionalDocumentFile" DisplayName="Additional Document File" Description="Additional documentation files (.xdc) to merge. (/Fs:[file])" Category="General" Switch="Fs" F1Keyword="VC.Project.VCXDCMakeTool.AdditionalDocumentFiles">
  </StringListProperty>
  <StringProperty Subtype="file" Name="OutputFile" DisplayName="Output Document File" Description="Overrides the default output file name, the first .xdc file's name is the default name (/Fo:[file])" Category="General" Switch="Fo" F1Keyword="VC.Project.VCXDCMakeTool.OutputDocumentFile">
  </StringProperty>
  <BoolProperty Name="DocumentLibraryDependencies" DisplayName="Document Library Dependencies" Description="If true, project dependencies that output static libraries will have their XML document comment files (.XDC) documented in this project's XML document file." Category="General" IncludeInCommandLine="false" F1Keyword="VC.Project.VCXDCMakeTool.DocumentLibraryDependencies">
  </BoolProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\BuildCustomizations\masm.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<ProjectSchemaDefinitions xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule
    Name="MASM"
    PageTemplate="tool"
    DisplayName="Microsoft Macro Assembler"
    Order="200">
    <Rule.DataSource>
      <DataSource
        Persistence="ProjectFile"
        ItemType="MASM" />
    </Rule.DataSource>
    <Rule.Categories>
      <Category
        Name="General">
        <Category.DisplayName>
          <sys:String>General</sys:String>
        </Category.DisplayName>
      </Category>
      <Category
        Name="Command Line"
        Subtype="CommandLine">
        <Category.DisplayName>
          <sys:String>Command Line</sys:String>
        </Category.DisplayName>
      </Category>
    </Rule.Categories>
    <StringProperty
      Name="Inputs"
      Category="Command Line"
      IsRequired="true">
      <StringProperty.DataSource>
        <DataSource
          Persistence="ProjectFile"
          ItemType="MASM"
          SourceType="Item" />
      </StringProperty.DataSource>
    </StringProperty>
    <BoolProperty
      Name="NoLogo"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Suppress Startup Banner"
      Description="Suppress the display of the startup banner and information messages.     (/nologo)"
      Switch="/nologo" />
    <BoolProperty
      Name="GeneratePreprocessedSourceListing"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Generate Preprocessed Source Listing"
      Description="Generates a preprocessed source listing to the Output Window.     (/EP)"
      Switch="/EP" />
    <BoolProperty
      Name="ListAllAvailableInformation"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="List All Available Information"
      Description="Turns on listing of all available information.     (/Sa)"
      Switch="/Sa" />
    <BoolProperty
      Name="UseSafeExceptionHandlers"
      Category="Advanced"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Use Safe Exception Handlers"
      Description="Marks the object as either containing no exception handlers or containing exception handlers that are all declared with .SAFESEH.     (/safeseh)"
      Switch="/safeseh" />
    <BoolProperty
      Name="AddFirstPassListing"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Add First Pass Listing"
      Description="Adds first-pass listing to listing file.     (/Sf)"
      Switch="/Sf" />
    <BoolProperty
      Name="EnableAssemblyGeneratedCodeListing"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Enable Assembly Generated Code Listing"
      Description="Turns on listing of assembly-generated code.     (/Sg)"
      Switch="/Sg" />
    <BoolProperty
      Name="DisableSymbolTable"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Disable Symbol Table"
      Description="Turns off symbol table when producing a listing.     (/Sn)"
      Switch="/Sn" />
    <BoolProperty
      Name="EnableFalseConditionalsInListing"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Enable False Conditionals In Listing"
      Description="Turns on false conditionals in listing.     (/Sx)"
      Switch="/Sx" />
    <BoolProperty
      Name="TreatWarningsAsErrors"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Treat Warnings As Errors"
      Description="Returns an error code if warnings are generated.     (/WX)"
      Switch="/WX" />
    <BoolProperty
      Name="MakeAllSymbolsPublic"
      Category="Object File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Make All Symbols Public"
      Description="Makes all symbols public.     (/Zf)"
      Switch="/Zf" />
    <BoolProperty
      Name="GenerateDebugInformation"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Generate Debug Information"
      Description="Generates Debug Information.     (/Zi)"
      Switch="/Zi" />
    <BoolProperty
      Name="EnableMASM51Compatibility"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Enable MASM 5.1 Compatibility"
      Description="Enables M510 option for maximum compatibility with MASM 5.1.     (/Zm)"
      Switch="/Zm" />
    <BoolProperty
      Name="PerformSyntaxCheckOnly"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Perform Syntax Check Only"
      Description="Performs a syntax check only.     (/Zs)"
      Switch="/Zs" />
    <StringProperty
      Name="ObjectFileName"
      Category="Object File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Object File Name"
      Description="Specifies the name of the output object file.     (/Fo:[file])"
      Switch="/Fo&quot;[value]&quot;" />
    <StringListProperty
      Name="PreprocessorDefinitions"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Preprocessor Definitions"
      Description="Defines a text macro with the given name.     (/D[symbol])"
      Switch="/D&quot;[value]&quot;" />
    <StringProperty
      Name="AssembledCodeListingFile"
      Category="Listing File"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Assembled Code Listing File"
      Description="Generates an assembled code listing file.     (/Fl[file])"
      Switch="/Fl&quot;[value]&quot;" />
    <StringListProperty
      Name="IncludePaths"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Include Paths"
      Description="Sets path for include file. A maximum of 10 /I options is allowed.     (/I [path])"
      Switch="/I &quot;[value]&quot;" />
    <StringListProperty
      Name="BrowseFile"
      Category="Advanced"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Generate Browse Information File"
      Description="Specifies whether to generate browse information file and its optional name or location of the browse information file.     (/FR[name])"
      Switch="/FR&quot;[value]&quot;" />
    <EnumProperty
      Name="PreserveIdentifierCase"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Preserve Identifier Case"
      Description="Specifies preservation of case of user identifiers.     (/Cp, /Cu, /Cx)">
      <EnumValue
        Name="0"
        DisplayName="Default" />
      <EnumValue
        Name="1"
        DisplayName="Preserves Identifier Case (/Cp)"
        Switch="/Cp" />
      <EnumValue
        Name="2"
        DisplayName="Maps all identifiers to upper case. (/Cu)"
        Switch="/Cu" />
      <EnumValue
        Name="3"
        DisplayName="Preserves case in public and extern symbols. (/Cx)"
        Switch="/Cx" />
    </EnumProperty>
    <EnumProperty
      Name="WarningLevel"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Warning Level"
      Description="Sets the warning level, where level = 0, 1, 2, or 3.    (/W0, /W1, /W2, /W3)">
      <EnumValue
        Name="0"
        DisplayName="Warning Level 0 (/W0)"
        Switch="/W0" />
      <EnumValue
        Name="1"
        DisplayName="Warning Level 1 (/W1)"
        Switch="/W1" />
      <EnumValue
        Name="2"
        DisplayName="Warning Level 2 (/W2)"
        Switch="/W2" />
      <EnumValue
        Name="3"
        DisplayName="Warning Level 3 (/W3)"
        Switch="/W3" />
    </EnumProperty>
    <EnumProperty
      Name="PackAlignmentBoundary"
      Category="Advanced"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Pack Alignment Boundary"
      Description="Packs structures on the specified byte boundary. The alignment can be 1, 2, 4, 8 or 16.     (/Zp1, /Zp2, /Zp4, /Zp8, /Zp16)">
      <EnumValue
        Name="0"
        DisplayName="Default" />
      <EnumValue
        Name="1"
        DisplayName="One Byte Boundary (/Zp1)"
        Switch="/Zp1" />
      <EnumValue
        Name="2"
        DisplayName="Two Byte Boundary (/Zp2)"
        Switch="/Zp2" />
      <EnumValue
        Name="3"
        DisplayName="Four Byte Boundary (/Zp4)"
        Switch="/Zp4" />
      <EnumValue
        Name="4"
        DisplayName="Eight Byte Boundary (/Zp8)"
        Switch="/Zp8" />
      <EnumValue
        Name="5"
        DisplayName="Sixteen Byte Boundary (/Zp16)"
        Switch="/Zp16" />
    </EnumProperty>
    <EnumProperty
      Name="CallingConvention"
      Category="Advanced"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Calling Convention"
      Description="Selects calling convention for your application.     (/Gc, /Gd. /Gz)">
      <EnumValue
        Name="0"
        DisplayName="Default" />
      <EnumValue
        Name="1"
        DisplayName="Use C-style Calling Convention (/Gd)"
        Switch="/Gd" />
      <EnumValue
        Name="2"
        DisplayName="Use stdcall Calling Convention (/Gz)"
        Switch="/Gz" />
      <EnumValue
        Name="3"
        DisplayName="Use Pascal Calling Convention (/Gc)"
        Switch="/Gc" />
    </EnumProperty>
    <EnumProperty
      Name="ErrorReporting"
      Category="Advanced"
      HelpUrl="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmasm/html/vclrfml.asp"
      DisplayName="Error Reporting"
      Description="Reports internal assembler errors to Microsoft.     (/errorReport:[method])">
      <EnumValue
        Name="0"
        DisplayName="Prompt to send report immediately (/errorReport:prompt)"
        Switch="/errorReport:prompt" />
      <EnumValue
        Name="1"
        DisplayName="Prompt to send report at the next logon (/errorReport:queue)"
        Switch="/errorReport:queue" />
      <EnumValue
        Name="2"
        DisplayName="Automatically send report (/errorReport:send)"
        Switch="/errorReport:send" />
      <EnumValue
        Name="3"
        DisplayName="Do not send report (/errorReport:none)"
        Switch="/errorReport:none" />
    </EnumProperty>
    <StringProperty
      Name="CommandLineTemplate"
      DisplayName="Command Line"
      Visible="False"
      IncludeInCommandLine="False" />
    <DynamicEnumProperty
     Name="MASMBeforeTargets"
     Category="General"
     EnumProvider="Targets"
     IncludeInCommandLine="False">
      <DynamicEnumProperty.DisplayName>
        <sys:String>Execute Before</sys:String>
      </DynamicEnumProperty.DisplayName>
      <DynamicEnumProperty.Description>
        <sys:String>Specifies the targets for the build customization to run before.</sys:String>
      </DynamicEnumProperty.Description>
      <DynamicEnumProperty.ProviderSettings>
        <NameValuePair
          Name="Exclude"
          Value="^MASMBeforeTargets|^Compute" />
      </DynamicEnumProperty.ProviderSettings>
      <DynamicEnumProperty.DataSource>
        <DataSource
          Persistence="ProjectFile"
          ItemType=""
          HasConfigurationCondition="true" />
      </DynamicEnumProperty.DataSource>
    </DynamicEnumProperty>
    <DynamicEnumProperty
      Name="MASMAfterTargets"
      Category="General"
      EnumProvider="Targets"
      IncludeInCommandLine="False">
      <DynamicEnumProperty.DisplayName>
        <sys:String>Execute After</sys:String>
      </DynamicEnumProperty.DisplayName>
      <DynamicEnumProperty.Description>
        <sys:String>Specifies the targets for the build customization to run after.</sys:String>
      </DynamicEnumProperty.Description>
      <DynamicEnumProperty.ProviderSettings>
        <NameValuePair
          Name="Exclude"
          Value="^MASMAfterTargets|^Compute" />
      </DynamicEnumProperty.ProviderSettings>
      <DynamicEnumProperty.DataSource>
        <DataSource
          Persistence="ProjectFile"
          ItemType=""
          HasConfigurationCondition="true" />
      </DynamicEnumProperty.DataSource>
    </DynamicEnumProperty>
    <StringProperty
      Name="ExecutionDescription"
      DisplayName="Execution Description"
      IncludeInCommandLine="False"
      Visible="False" />
    <StringListProperty
      Name="AdditionalDependencies"
      DisplayName="Additional Dependencies"
      IncludeInCommandLine="False"
      Visible="False" />
    <StringProperty
      Subtype="AdditionalOptions"
      Name="AdditionalOptions"
      Category="Command Line">
      <StringProperty.DisplayName>
        <sys:String>Additional Options</sys:String>
      </StringProperty.DisplayName>
      <StringProperty.Description>
        <sys:String>Additional Options</sys:String>
      </StringProperty.Description>
    </StringProperty>
  </Rule>
  <ItemType
    Name="MASM"
    DisplayName="Microsoft Macro Assembler" />
  <FileExtension
    Name="*.asm"
    ContentType="MASM" />
  <ContentType
    Name="MASM"
    DisplayName="Microsoft Macro Assembler"
    ItemType="MASM" />
</ProjectSchemaDefinitions>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\Extensions\Microsoft.Cpp\v4.0\1033\xsd.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<!--Copyright, Microsoft Corporation, All rights reserved.-->
<Rule Name="XSD" PageTemplate="tool" DisplayName="XML Data Generator Tool" SwitchPrefix="/" Order="120" xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule.Categories>
    <Category Name="General" DisplayName="General" />
    <Category Name="Command Line" DisplayName="Command Line" Subtype="CommandLine" />
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence="ProjectFile" ItemType="Xsd" Label="" HasConfigurationCondition="true" />
  </Rule.DataSource>
  <BoolProperty Name="SuppressStartupBanner" DisplayName="Suppress Startup Banner" Description="Runs without displaying standard Microsoft copyright data. (/nologo)" Category="General" Switch="nologo" F1Keyword="VC.Project.VCXMLDataGeneratorTool.SupressStartupBanner">
  </BoolProperty>
  <StringProperty Name="Namespace" DisplayName="Namespace" Description="The namespace for generated class files. The default namespace is the global namespace. (/namespace:[string])" Category="General" Switch="namespace:" F1Keyword="VC.Project.VCXMLDataGeneratorTool.Namespace">
  </StringProperty>
  <StringProperty Name="Language" DisplayName="Language" Description="The language to use for the generated code. Choose from 'CS', 'VB', 'JS', 'VJS', 'CPP' or provide a fully-qualified name for a class implementing System.CodeDom.Compiler.CodeDomProvider. The default language is 'CS' (CSharp). (/language:[string])" Category="General" Switch="language:" Visible="false">
  </StringProperty>
  <EnumProperty Name="GenerateFromSchema" DisplayName="Generate From Schema" Description="The types generated from schema" Category="General" F1Keyword="VC.Project.VCXMLDataGeneratorTool.GenerateFromSchema">
    <EnumValue Name="classes" Switch="classes" DisplayName="Classes" Description="Generate classes for this schema. (/classes)">
    </EnumValue>
    <EnumValue Name="dataset" Switch="dataset" DisplayName="DataSet" Description="Generate sub-classed DataSet for this schema. (/dataset)">
    </EnumValue>
  </EnumProperty>
  <StringProperty Subtype="folder" Name="TrackerLogDirectory" DisplayName="Tracker Log Directory" Description="Tracker Log Directory." Category="General" IncludeInCommandLine="false" Visible="false">
  </StringProperty>
  <StringProperty Name="AdditionalOptions" DisplayName="Additional Options" Description="Additional Options" Category="Command Line" F1Keyword="vc.project.AdditionalOptionsPage">
  </StringProperty>
</Rule>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\v4.0\netmemorycache.ini ===
;  <copyright file="netmemorycache.ini" company="Microsoft">
;    Copyright (c) 2009 Microsoft Corporation.  All rights reserved.
;  </copyright>

[info]
drivername=.NET Memory Cache 4.0
symbolfile=netmemorycache.h

[languages]
009=language009

[objects]
OBJECT_1_009_NAME=.NET Memory Cache 4.0

[text]
OBJECT_1_009_NAME=.NET Memory Cache 4.0
OBJECT_1_009_HELP=System.Runtime.Caching.MemoryCache Performance Counters

DEVICE_COUNTER_1_009_NAME=Cache Hits
DEVICE_COUNTER_1_009_HELP=The number of cache hits.

DEVICE_COUNTER_2_009_NAME=Cache Misses
DEVICE_COUNTER_2_009_HELP=The number of cache misses.

DEVICE_COUNTER_3_009_NAME=Cache Hit Ratio
DEVICE_COUNTER_3_009_HELP=The percentage of cache hits in the total number of cache requests.

DEVICE_COUNTER_4_009_NAME=Cache Hit Ratio Base
DEVICE_COUNTER_4_009_HELP=Cache Hit Ratio Base

DEVICE_COUNTER_5_009_NAME=Cache Trims
DEVICE_COUNTER_5_009_HELP=Total number of entries removed from the cache due to memory pressure or Trim invocations.

DEVICE_COUNTER_6_009_NAME=Cache Entries
DEVICE_COUNTER_6_009_HELP=The number of entries within the cache.

DEVICE_COUNTER_7_009_NAME=Cache Turnover Rate
DEVICE_COUNTER_7_009_HELP=The number of entries added to the cache or removed from the cache per second.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\path1st\buildd.log ===
Executing prebuild scripts  *************
1>Performing prebuild steps..  *************
1>'Z:\XONLINE_MAIN\public\ext\tools\build_pre_process.cmd '
1>build_pre_process.cmd: nmake /nologo /f z:\xonline_main\makefil0 versions
Executing post build scripts  *************
Fix Public Change
1>'Z:\XONLINE_MAIN\public\ext\tools\buildpost.cmd '
1>Running scripts in Z:\XONLINE_MAIN\target\debug\AMD64\PostBuildScripts
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\path1st\metadata.config.xml ===
<?xml version="1.0"?>
<root>
  <features preserveAllCustomAttributes="1" /> 
  <features preserveAllSecurityAttributes="1" /> 
  <features respectInternalsVisibleTo="1" />
</root>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\v4.0\Microsoft.VisualBasic.Vsa.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Microsoft.VisualBasic.Vsa</name>
  </assembly>
  <members>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaCodeItem"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaCodeItem.#ctor(Microsoft.Vsa.IVsaCodeItem)">
      <param name="item"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaCodeItem.AddEventSource(System.String,System.String)">
      <param name="EventSourceName"> </param>
      <param name="EventSourceType"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaCodeItem.AppendSourceText(System.String)">
      <param name="Text"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCodeItem.CodeDOM"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaCodeItem.RemoveEventSource(System.String)">
      <param name="EventSourceName"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCodeItem.SourceText"></member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaCompilerError"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.Description"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.EndColumn"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.Line"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.LineText"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.Number"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.Severity"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.SourceItem"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.SourceMoniker"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaCompilerError.StartColumn"></member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaEngine"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.#ctor"></member>
    <member name="F:Microsoft.VisualBasic.Vsa.VsaEngine._baseEngine"></member>
    <member name="F:Microsoft.VisualBasic.Vsa.VsaEngine._engineClosed"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Assembly"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.CheckEngine"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.Close"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.Compile"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.CreateEngine"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.Dispose(System.Boolean)">
      <param name="disposing"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Evidence"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.Finalize"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.GenerateDebugInfo"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.GetExceptionToThrow(System.Exception)">
      <param name="e"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.GetOption(System.String)">
      <param name="Name"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.InitNew"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.IsCompiled"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.IsDirty"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.IsRunning"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.IsValidIdentifier(System.String)">
      <param name="identifier"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Items"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Language"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.LCID"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.LoadSourceState(Microsoft.Vsa.IVsaPersistSite)">
      <param name="Site"> </param>
    </member>
    <member name="F:Microsoft.VisualBasic.Vsa.VsaEngine.m_Items"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Name"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.Reset"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.RevokeCache"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.RootMoniker"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.RootNamespace"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.Run"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.SaveCompiledState(System.Byte[]@,System.Byte[]@)">
      <param name="PE"> </param>
      <param name="PDB"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.SaveSourceState(Microsoft.Vsa.IVsaPersistSite)">
      <param name="Site"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaEngine.SetOption(System.String,System.Object)">
      <param name="Name"> </param>
      <param name="value"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Site"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaEngine.Version"></member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaGlobalItem"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaGlobalItem.ExposeMembers"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaGlobalItem.TypeString"></member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaItem"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItem._item"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItem.GetOption(System.String)">
      <param name="Name"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItem.IsDirty"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItem.ItemType"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItem.Name"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItem.SetOption(System.String,System.Object)">
      <param name="Name"> </param>
      <param name="value"> </param>
    </member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaItems"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.#ctor(Microsoft.Vsa.IVsaItems)">
      <param name="items"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.AddCodeItemWrapper(Microsoft.Vsa.IVsaItem)">
      <param name="item"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItems.Count"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.CreateItem(System.String,Microsoft.Vsa.VsaItemType,Microsoft.Vsa.VsaItemFlag)">
      <param name="Name"> </param>
      <param name="ItemType"> </param>
      <param name="ItemFlag"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.GetEnumerator"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.GetItemWrapper(Microsoft.Vsa.IVsaItem)">
      <param name="item"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItems.Item(System.Int32)">
      <param name="index"> </param>
    </member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItems.Item(System.String)">
      <param name="Name"> </param>
    </member>
    <member name="F:Microsoft.VisualBasic.Vsa.VsaItems.m_ItemCollection"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.Remove(System.Int32)">
      <param name="index"> </param>
    </member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItems.Remove(System.String)">
      <param name="Name"> </param>
    </member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaItemsEnumerator"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaItemsEnumerator.Current"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItemsEnumerator.MoveNext"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItemsEnumerator.Reset"></member>
    <member name="T:Microsoft.VisualBasic.Vsa.VsaReferenceItem"></member>
    <member name="P:Microsoft.VisualBasic.Vsa.VsaReferenceItem.AssemblyName"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaCompilerError.#ctor(Microsoft.Vsa.IVsaError)"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaGlobalItem.#ctor(Microsoft.Vsa.IVsaGlobalItem)"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaItem.#ctor(Microsoft.Vsa.IVsaItem)"></member>
    <member name="M:Microsoft.VisualBasic.Vsa.VsaReferenceItem.#ctor(Microsoft.Vsa.IVsaReferenceItem)"></member>
  </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\v4.0\Microsoft_VsaVb.xml ===
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Microsoft_VsaVb</name>
  </assembly>
  <members>
    <member name="T:Microsoft_VsaVb.VsaDTEngine"></member>
    <member name="T:Microsoft_VsaVb.VsaDTEngineClass"></member>
    <member name="M:Microsoft_VsaVb.VsaDTEngineClass.#ctor"></member>
    <member name="M:Microsoft_VsaVb.VsaDTEngineClass.AttachDebugger(System.Boolean)">
      <param name="isAttach"> </param>
    </member>
    <member name="M:Microsoft_VsaVb.VsaDTEngineClass.GetIDE"></member>
    <member name="M:Microsoft_VsaVb.VsaDTEngineClass.InitCompleted"></member>
    <member name="P:Microsoft_VsaVb.VsaDTEngineClass.TargetURL"></member>
    <member name="T:Microsoft_VsaVb.VsaEngine"></member>
    <member name="T:Microsoft_VsaVb.VsaEngineClass"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.#ctor"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Assembly"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.Close"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.Compile"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Evidence"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.GenerateDebugInfo"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.GetOption(System.String)">
      <param name="Name"> </param>
    </member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.InitNew"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.IsCompiled"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.IsDirty"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.IsRunning"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.IsValidIdentifier(System.String)">
      <param name="identifier"> </param>
    </member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Items"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Language"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.LCID"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.LoadSourceState(Microsoft.Vsa.IVsaPersistSite)">
      <param name="Site"> </param>
    </member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Name"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.Reset"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.RevokeCache"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.RootMoniker"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.RootNamespace"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.Run"></member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.SaveCompiledState(System.Byte[]@,System.Byte[]@)">
      <param name="pe"> </param>
      <param name="pdb"> </param>
    </member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.SaveSourceState(Microsoft.Vsa.IVsaPersistSite)">
      <param name="Site"> </param>
    </member>
    <member name="M:Microsoft_VsaVb.VsaEngineClass.SetOption(System.String,System.Object)">
      <param name="Name"> </param>
      <param name="value"> </param>
    </member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Site"></member>
    <member name="P:Microsoft_VsaVb.VsaEngineClass.Version"></member>
  </members>
</doc>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\tools\msbuild\v4.0\PerfCounters.ini ===
[ i n f o ] 
 
 d r i v e r n a m e = W i n d o w s   W o r k f l o w   F o u n d a t i o n   4 . 0 . 0 . 0 
 
 s y m b o l f i l e = P e r f C o u n t e r s . h 
 
 
 
 [ l a n g u a g e s ] 
 
 0 0 9 = E n g l i s h 
 
 0 0 1 = A r a b i c 
 
 4 0 4 = C h i n e s e   ( T a i w a n ) 
 
 0 0 5 = C z e c h 
 
 0 0 6 = D a n i s h 
 
 0 0 7 = G e r m a n 
 
 0 0 8 = G r e e k 
 
 0 0 B = F i n n i s h 
 
 0 0 C = F r e n c h 
 
 0 0 D = H e b r e w 
 
 0 0 E = H u n g a r i a n 
 
 0 1 0 = I t a l i a n 
 
 0 1 1 = J a p a n e s e 
 
 0 1 2 = K o r e a n 
 
 0 1 3 = D u t c h 
 
 0 1 4 = N o r w e g i a n 
 
 0 1 5 = P o l i s h 
 
 4 1 6 = P o r t u g u e s e   ( B r a z i l ) 
 
 0 1 9 = R u s s i a n 
 
 0 1 D = S w e d i s h 
 
 0 1 F = T u r k i s h 
 
 8 0 4 = C h i n e s e   ( P R C ) 
 
 8 1 6 = P o r t u g u e s e   ( P o r t u g a l ) 
 
 0 0 A = S p a n i s h 
 
 
 
 [ o b j e c t s ] 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 9 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 1 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 4 0 4 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 5 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 6 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 7 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 8 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 B _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 C _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 D _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 E _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 0 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 1 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 2 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 3 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 4 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 5 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 4 1 6 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 9 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 D _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 F _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 8 0 4 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 8 1 6 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 A _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 
 
 [ t e x t ] 
 
 
 
 ; ; 
 
 ; ;     W W S   -   E n g l i s h 
 
 ; ; 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 9 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 9 _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n   P e r f o r m a n c e   C o u n t e r s 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 9 _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   c r e a t e d . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   c r e a t e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 9 _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   u n l o a d e d . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   u n l o a d e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 9 _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   l o a d e d . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   l o a d e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 9 _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   c o m p l e t e d . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   c o m p l e t e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 9 _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   s u s p e n d e d . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   s u s p e n d e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 9 _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   t e r m i n a t e d . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   t e r m i n a t e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 9 _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   i n   m e m o r y . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 9 _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   a b o r t e d . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   a b o r t e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 9 _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   p e r s i s t e d . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   p e r s i s t e d   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 9 _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w   i n s t a n c e s   a c t i v e l y   e x e c u t i n g . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 9 _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 9 _ H E L P = R a t e   o f   w o r k f l o w s   b e c o m i n g   i d l e   p e r   s e c o n d . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 9 _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   r e a d y   t o   e x e c u t e . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 9 _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 9 _ H E L P = T o t a l   n u m b e r   o f   w o r k f l o w s   w a i t i n g   f o r   a   t h r e a d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 1 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 1 _ H E L P = 9/'/'*  #/'!  W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 1 _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *E  %F4'$G'. 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  *E  %F4'$G'  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 1 _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *E  %D:'!  *-EJDG'. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  *E  %D:'!  *-EJDG'  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 1 _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *E  *-EJDG'. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  *E  *-EJDG'  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 1 _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *E  %CE'DG'. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  *E  %CE'DG'  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 1 _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'DE*HBA)  E1-DJ'K. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'DE*HBA)  E1-DJ'K  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 1 _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *E  %FG'$G'. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  *E  %FG'$G'  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 1 _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  AJ  'D0'C1). 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 1 _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *E  %,G'6G'. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  *E  %,G'6G'  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 1 _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'DE3*E1). 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'DE3*E1)  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 1 _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE+JD'*  3J1  'D9ED  'D*J  J*E  *FAJ0G'  (4CD  F47. 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 1 _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 1 _ H E L P = E9/D  E3'1'*  'D9ED  'D*J  #5(-*  .'ED)  AJ  'D+'FJ). 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 1 _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D,'G2  DD*FAJ0. 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 1 _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 1 _ H E L P = 'D9//  'D%,E'DJ  DE3'1'*  'D9ED  'D*J  *F*81  E$41  *1'(7. 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 4 0 4 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 4 0 4 _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n   HexehV
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 4 0 4 _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 4 0 4 _ H E L P = ]^zv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 4 0 4 _ H E L P = ky^z]\OAmzvs0
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 4 0 4 _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 4 0 4 _ H E L P = xS	v]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmzxS	vs0
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 4 0 4 _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 4 0 4 _ H E L P = 	eQv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmz	eQvs0
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 4 0 4 _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 4 0 4 _ H E L P = [bv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmz[bvs0
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 4 0 4 _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 4 0 4 _ H E L P = f\Pv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmzf\Pvs0
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 4 0 4 _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 4 0 4 _ H E L P = P}_gv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmzP}_gvs0
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 4 0 4 _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 4 0 4 _ H E L P = aԚ-Nv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 4 0 4 _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 4 0 4 _ H E L P = -Nbkv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmz-Nbkvs0
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 4 0 4 _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 4 0 4 _ H E L P = c~v]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmzc~vs0
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 4 0 4 _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 4 0 4 _ H E L P = WLv]\OAmzWLPԚ=~xe0
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 4 0 4 _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 4 0 4 _ H E L P = ky]\OAmzbnvs0
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 4 0 4 _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 4 0 4 _ H E L P = nPWLv]\OAmz=~xe0
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 4 0 4 _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 4 0 4 _ H E L P = I{_WL}v]\OAmz=~xe0
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 5 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 5 _ H E L P =  t a 
e   v  k o n u   p r o   p r o g r a m o v a c    m o d e l   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 5 _ N A M E = P o 
e t   v y t v o Ye n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   v y t v o Ye n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   v y t v o Ye n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   v y t v o Ye n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 5 _ N A M E = P o 
e t   u v o l n n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   u v o l n n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   u v o l n n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   u v o l n n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 5 _ N A M E = P o 
e t   n a 
t e n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   n a 
t e n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   n a 
t e n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   n a 
t e n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 5 _ N A M E = P o 
e t   d o k o n 
e n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   d o k o n 
e n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   d o k o n 
e n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   d o k o n 
e n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 5 _ N A M E = P o 
e t   p o z a s t a v e n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   p o z a s t a v e n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   p o z a s t a v e n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   p o z a s t a v e n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 5 _ N A M E = P o 
e t   u k o n 
e n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   u k o n 
e n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   u k o n 
e n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   u k o n 
e n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 5 _ N A M E = P o 
e t   s l e d o  p r a c    v   p a m t i 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   p r a c o v n  c h   p o s t u p o  v   p a m t i 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 5 _ N A M E = P o 
e t   z r u ae n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   z r u ae n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   z r u ae n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   z r u ae n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 5 _ N A M E = P o 
e t   t r v a l  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   t r v a l e   u l o ~e n  c h   p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   t r v a l  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   t r v a l e   u l o ~e n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 5 _ N A M E = P o 
e t   p r o v e d e n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   a k t i v n   p r o v  d n  c h   i n s t a n c    p r a c o v n  c h   p o s t u p o
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 5 _ N A M E = P o 
e t   n e 
i n n  c h   s l e d o  p r a c  / s 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 5 _ H E L P = P o 
e t   n e 
i n n  c h   p r a c o v n  c h   p o s t u p o  z a   s e k u n d u 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 5 _ N A M E = P o 
e t   s p u s t i t e l n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   p r a c o v n  c h   p o s t u p o  p Yi p r a v e n  c h   k   p r o v e d e n  
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 5 _ N A M E = P o 
e t   n e v y Y z e n  c h   s l e d o  p r a c  
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 5 _ H E L P = C e l k o v    p o 
e t   p r a c o v n  c h   p o s t u p o  
e k a j  c  c h   n a   p o d p r o c e s 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 6 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 6 _ H E L P = Y d e l s e s t  l l e r e   t i l   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 6 _ N A M E = O p r e t t e d e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   o p r e t t e d e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 6 _ N A M E = O p r e t t e d e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   o p r e t t e d e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 6 _ N A M E = F j e r n e d e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   f j e r n e d e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 6 _ N A M E = F j e r n e d e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   f j e r n e d e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 6 _ N A M E = I n d l  s t e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   i n d l  s t e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 6 _ N A M E = I n d l  s t e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   i n d l  s t e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 6 _ N A M E = F u l d e n d t e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   f u l d e n d t e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 6 _ N A M E = F u l d e n d t e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   f u l d e n d t e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 6 _ N A M E = A n n u l l e r e d e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   a n n u l l e r e d e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 6 _ N A M E = A n n u l l e r e d e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   a n n u l l e r e d e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 6 _ N A M E = A f s l u t t e d e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   a f s l u t t e d e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 6 _ N A M E = A f s l u t t e d e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   a f s l u t t e d e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 6 _ N A M E = A r b e j d s p r o c e s s e r   i   h u k o m m e l s e n 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 6 _ H E L P = S a m l e t   a n t a l   a r b e j d s p r o c e s s e r   i   h u k o m m e l s e n . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 6 _ N A M E = A f b r u d t e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   a f b r u d t e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 6 _ N A M E = A f b r u d t e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   a f b r u d t e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 6 _ N A M E = V e d v a r e n d e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 6 _ H E L P = S a m l e t   a n t a l   v e d v a r e n d e   a r b e j d s p r o c e s s e r . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 6 _ N A M E = V e d v a r e n d e   a r b e j d s p r o c e s s e r / s e k . 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 6 _ H E L P = F r e k v e n s   a f   v e d v a r e n d e   a r b e j d s p r o c e s s e r   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 6 _ N A M E = A r b e j d s p r o c e s s e r   u n d e r   u d f  r e l s e 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 6 _ H E L P = S a m l e t   a n t a l   a r b e j d s p r o c e s s e r   u n d e r   a k t i v   u d f  r e l s e . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 6 _ N A M E = A r b e j d s p r o c e s s e r ,   s o m   b l i v e r   l e d i g e / s e k . 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 6 _ H E L P = A n t a l   a r b e j d s p r o c e s s e r ,   s o m   b l i v e r   l e d i g e   p r .   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 6 _ N A M E = A r b e j d s p r o c e s s e r   t i l   u d f  r e l s e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 6 _ H E L P = S a m l e t   a n t a l   a r b e j d s p r o c e s s e r   k l a r   t i l   u d f  r e l s e . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 6 _ N A M E = U d e s t  e n d e   a r b e j d s p r o c e s s e r 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 6 _ H E L P = S a m l e d e   a n t a l   a r b e j d s p r o c e s s e r ,   d e r   a f v e n t e r   e n   t r  d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 7 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 7 _ H E L P = L e i s t u n g s i n d i k a t o r e n   v o n   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 7 _ N A M E = E r s t e l l t e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   e r s t e l l t e r   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 7 _ N A M E = E r s t e l l t e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   e r s t e l l t e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 7 _ N A M E = E n t l a d e n e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   e n t l a d e n e r   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 7 _ N A M E = E n t l a d e n e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   e n t l a d e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 7 _ N A M E = G e l a d e n e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   g e l a d e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 7 _ N A M E = G e l a d e n e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   g e l a d e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 7 _ N A M E = A b g e s c h l o s s e n e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   a b g e s c h l o s s e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 7 _ N A M E = A b g e s c h l o s s e n e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   a b g e s c h l o s s e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 7 _ N A M E = A n g e h a l t e n e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   a n g e h a l t e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 7 _ N A M E = A n g e h a l t e n e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   a n g e h a l t e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 7 _ N A M E = B e e n d e t e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   b e e n d e t e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 7 _ N A M E = B e e n d e t e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   b e e n d e t e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 7 _ N A M E = W o r k f l o w s   i m   A r b e i t s s p e i c h e r 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   W o r k f l o w s   i m   A r b e i t s s p e i c h e r . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 7 _ N A M E = A b g e b r o c h e n e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   a b g e b r o c h e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 7 _ N A M E = A b g e b r o c h e n e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   a b g e b r o c h e n e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 7 _ N A M E = P e r s i s t e n t   g e s p e i c h e r t e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   p e r s i s t e n t   g e s p e i c h e r t e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 7 _ N A M E = P e r s i s t e n t   g e s p e i c h e r t e   W o r k f l o w s / S e k u n d e 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   p r o   S e k u n d e   p e r s i s t e n t   g e s p e i c h e r t e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 7 _ N A M E = A u s g e f  h r t e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   W o r k f l o w i n s t a n z e n ,   d i e   a k t i v   a u s g e f  h r t   w e r d e n . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 7 _ N A M E = W o r k f l o w s   i m   L e e r l a u f / S e k u n d e 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 7 _ H E L P = R a t e   d e r   W o r k f l o w s ,   d i e   p r o   S e k u n d e   i n   d e n   L e e r l a u f   g e h e n . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 7 _ N A M E = A u s f  h r b a r e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   a u s f  h r b a r e n   W o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 7 _ N A M E = A u s s t e h e n d e   W o r k f l o w s 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 7 _ H E L P = G e s a m t a n z a h l   d e r   W o r k f l o w s ,   d i e   a u f   e i n e n   T h r e a d   w a r t e n . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 8 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 8 _ H E L P =         P       W i n d o w s   ( W W F ) 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 8 _ N A M E =       
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 8 _ H E L P =                 . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 8 _ N A M E =       / 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 8 _ H E L P =             . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 8 _ N A M E =       
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 8 _ N A M E =     / 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 8 _ N A M E =       
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 8 _ H E L P =               . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 8 _ N A M E =       / 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 8 _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 8 _ N A M E =     
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 8 _ H E L P =                 . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 8 _ N A M E =       
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 8 _ H E L P =                   . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 B _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 B _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n i n   r e s u r s s i l a s k u r i t 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 B _ N A M E = L u o d u t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 B _ H E L P = L u o t u j e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 B _ N A M E = L u o d u t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   l u o n t i m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 B _ N A M E = P o i s t e t u t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 B _ H E L P = P o i s t e t t u j e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 B _ N A M E = P o i s t e t u t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   p o i s t a m i s m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 B _ N A M E = L a d a t u t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 B _ H E L P = L a d a t t u j e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 B _ N A M E = L a d a t u t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   l a t a u s m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 B _ N A M E = V a l m i i t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 B _ H E L P = V a l m i i d e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 B _ N A M E = V a l m i i t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   v a l m i s t u m i s m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 B _ N A M E = P y s  y t e t y t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 B _ H E L P = P y s  y t e t t y j e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 B _ N A M E = P y s  y t e t y t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   k e s k e y t t  m i s m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 B _ N A M E = P   t e t y t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 B _ H E L P = P   t e t t y j e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 B _ N A M E = P   t e t y t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   p   t t  m i s m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 B _ N A M E = M u i s t i s s a   o l e v a t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 B _ H E L P = M u i s t i s s a   o l e v i e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 B _ N A M E = K e s k e y t e t y t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 B _ H E L P = K e s k e y t e t t y j e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 B _ N A M E = K e s k e y t e t y t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   k e s k e y t y s m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 B _ N A M E = P y s y v  t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 B _ H E L P = P y s y v i e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 B _ N A M E = P y s y v  t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   p y s y v  k s i   m u u t t a m i s e n   m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 B _ N A M E = P a r h a i l l a a n   s u o r i t e t t a v a t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 B _ H E L P = P a r h a i l l a a n   s u o r i t e t t a v i e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 B _ N A M E = O d o t t a m a a n   a s e t e t u t   t y  n k u l u t   s e k u n n i s s a 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 B _ H E L P = T y  n k u l k u j e n   o d o t t a m a a n   a s e t t a m i s e n   m   r    s e k u n n i s s a . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 B _ N A M E = S u o r i t e t t a v a k s i   v a l m i i n a   o l e v a t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 B _ H E L P = S u o r i t e t t a v a k s i   v a l m i i n a   o l e v i e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 B _ N A M E = O d o t t a v a t   t y  n k u l u t 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 B _ H E L P = S  i e t t    o d o t t a v i e n   t y  n k u l k u j e n   k o k o n a i s m   r  . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 C _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 C _ H E L P = C o m p t e u r s   d e   p e r f o r m a n c e   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 C _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   c r   s . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   c r   s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 C _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   d  c h a r g  s . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   d  c h a r g  s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 C _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   c h a r g  s . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   c h a r g  s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 C _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   t e r m i n  s . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   t e r m i n  s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 C _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   i n t e r r o m p u s . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   i n t e r r o m p u s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 C _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   a r r  t  s . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   a r r  t  s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 C _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   e n   m  m o i r e . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 C _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   a n n u l  s . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   a n n u l  s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 C _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   c o n s e r v  s . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   c o n s e r v  s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 C _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 C _ H E L P = N o m b r e   t o t a l   d ' i n s t a n c e s   d e   w o r k f l o w s   e n   c o u r s   d ' e x  c u t i o n . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 C _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 C _ H E L P = T a u x   d e   w o r k f l o w s   d e v e n a n t   i n a c t i f s   p a r   s e c o n d e . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 C _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   p r  t s       t r e   e x  c u t  s . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 C _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 C _ H E L P = N o m b r e   t o t a l   d e   w o r k f l o w s   e n   a t t e n t e   d ' u n   t h r e a d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 D _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 D _ H E L P =       W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 D _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 D _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 D _ H E L P =             . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 D _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 D _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 D _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 D _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 D _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 D _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 D _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 D _ H E L P =           . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 D _ H E L P =         . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 D _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 D _ H E L P =                 . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 D _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 D _ H E L P =             . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 D _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 D _ H E L P =             . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 D _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 D _ H E L P =                 ( t h r e a d ) . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 E _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 0 E _ H E L P = A   W i n d o w s   W o r k f l o w   F o u n d a t i o n   t e l j e s  t m  n y s z  m l  l  i 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 E _ N A M E = L  t r e h o z o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 0 E _ H E L P = A z    s s z e s   l  t r e h o z o t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 E _ N A M E = L  t r e h o z o t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   l  t r e h o z o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 E _ N A M E = M e m  r i  b  l   e l t  v o l  t o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 0 E _ H E L P = A   m e m  r i  b  l   e l t  v o l  t o t t    s s z e s   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 E _ N A M E = M e m  r i  b  l   e l t  v o l  t o t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   a   m e m  r i  b  l   e l t  v o l  t o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 E _ N A M E = B e t  l t  t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 0 E _ H E L P = A z    s s z e s   b e t  l t  t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 E _ N A M E = B e t  l t  t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   b e t  l t  t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 E _ N A M E = B e f e j e z e t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 0 E _ H E L P = A z    s s z e s   b e f e j e z e t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 E _ N A M E = B e f e j e z e t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   b e f e j e z e t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 E _ N A M E = F e l f  g g e s z t e t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 0 E _ H E L P = A z    s s z e s   f e l f  g g e s z t e t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 E _ N A M E = F e l f  g g e s z t e t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   f e l f  g g e s z t e t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 E _ N A M E = L e  l l  t o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 0 E _ H E L P = A z    s s z e s   l e  l l  t o t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 E _ N A M E = L e  l l  t o t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   l e  l l  t o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 E _ N A M E = M e m  r i  b a n   l e v Q  m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 0 E _ H E L P = A   m e m  r i  b a n   l e v Q   s s z e s   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 E _ N A M E = M e g s z a k  t o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 0 E _ H E L P = A z    s s z e s   m e g s z a k  t o t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 E _ N A M E = M e g s z a k  t o t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   m e g s z a k  t o t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 E _ N A M E = M e g Qr z  t t   m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 0 E _ H E L P = A z    s s z e s   m e g Qr z  t t   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 E _ N A M E = M e g Qr z  t t   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   m e g Qr z  t t   m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 E _ N A M E = V  g r e h a j t  s   a l a t t    l l    m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 0 E _ H E L P = A   j e l e n l e g   v  g r e h a j t  s   a l a t t    l l     s s z e s   m u n k a f o l y a m a t - p  l d  n y   s z  m a 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 E _ N A M E = T  t l e n   m u n k a f o l y a m a t o k   m  s o d p e r c e n k  n t i   s z  m a 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 0 E _ H E L P = A   m  s o d p e r c e n k  n t   t  t l e n n    v  l    m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 E _ N A M E = F u t t a t h a t    m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 0 E _ H E L P = A   v  g r e h a j t  s r a   k  s z    s s z e s   m u n k a f o l y a m a t   s z  m a 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 E _ N A M E = F  g g Qb e n   l e v Q  m u n k a f o l y a m a t o k   s z  m a 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 0 E _ H E L P = S z  l r a   v  r a k o z    m u n k a f o l y a m a t o k   s z  m a 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 0 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 0 _ H E L P = C o n t a t o r i   d e l l e   p r e s t a z i o n i   d i   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   c r e a t i 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   c r e a t i . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   c r e a t i / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   c r e a t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   s c a r i c a t i 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   s c a r i c a t i . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   s c a r i c a t i / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   s c a r i c a t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   c a r i c a t i 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   c a r i c a t i . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   c a r i c a t i / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   c a r i c a t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   c o m p l e t a t i 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   c o m p l e t a t i . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   c o m p l e t a t i / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   c o m p l e t a t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   s o s p e s i 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   s o s p e s i . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   s o s p e s i / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   s o s p e s i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   t e r m i n a t i 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   t e r m i n a t i . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   t e r m i n a t i / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   t e r m i n a t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   i n   m e m o r i a 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   i n   m e m o r i a . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   i n t e r r o t t i 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   i n t e r r o t t i . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   i n t e r r o t t i / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   i n t e r r o t t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   p e r s i s t e n t i 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   p e r s i s t e n t i . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   p e r s i s t e n t i / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   p e r s i s t e n t i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   i n   e s e c u z i o n e 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   i s t a n z e   d i   f l u s s o   d i   l a v o r o   i n   e s e c u z i o n e . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   i n a t t i v i / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 0 _ H E L P = F r e q u e n z a   d i   f l u s s i   d i   l a v o r o   c h e   d i v e n t a n o   i n a t t i v i   a l   s e c o n d o . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   e s e g u i b i l i 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   p r o n t i   p e r   e s s e r e   e s e g u i t i . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 0 _ N A M E = F l u s s i   d i   l a v o r o   i n   s o s p e s o 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 0 _ H E L P = N u m e r o   t o t a l e   d i   f l u s s i   d i   l a v o r o   i n   a t t e s a   d i   u n   t h r e a d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 1 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 1 _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n   0000000  00000
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 1 _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 1 _ H E L P = \ObW0_0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 1 _ H E L P = \ObW0_0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 1 _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 1 _ H E L P = 00000W0_0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 1 _ H E L P = 00000W0_0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 1 _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 1 _ H E L P = 00`0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 1 _ H E L P = 00`0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 1 _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 1 _ H E L P = [NW0_0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 1 _ H E L P = [NW0_0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 1 _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 1 _ H E L P =  NBf\PbkW0_0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 1 _ H E L P =  NBf\PbkW0_0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 1 _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 1 _ H E L P = B}NW0_0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 1 _ H E L P = B}NW0_0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 1 _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 1 _ H E L P = 000Qn0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 1 _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 1 _ H E L P = -NbkW0_0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 1 _ H E L P = -NbkW0_0000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 1 _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 1 _ H E L P = c}000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 1 _ H E L P = c}000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 1 _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 1 _ H E L P = [L-Nn0000000  000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 1 _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 1 _ H E L P = 0000rKak0j00000000n0ks  ( yXSMO) 0
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 1 _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 1 _ H E L P = [LSj0000000n0Tpe0
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 1 _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 1 _ H E L P = 00000__jW0f0D00000000n0Tpe0
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 2 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 2 _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n   1  tδ0
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 2 _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 2 _ H E L P = 1    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 2 _ H E L P =   1  l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 2 _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 2 _ H E L P = \ܴ    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 2 _ H E L P =   \ܴ  l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 2 _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 2 _ H E L P = \ܴ    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 2 _ H E L P =   \ܴ  l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 2 _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 2 _ H E L P = D̸    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 2 _ H E L P =   D̸  l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 2 _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 2 _ H E L P = |      l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 2 _ H E L P =   |    l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 2 _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 2 _ H E L P = ̸    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 2 _ H E L P =   ̸  l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 2 _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 2 _ H E L P = T  ǔ    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 2 _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 2 _ H E L P =     l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 2 _ H E L P =     l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 2 _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 2 _ H E L P = ɍ    l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 2 _ H E L P =   ɍ  l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 2 _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 2 _ H E L P =   x    l\  xǤ4Ѥ  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 2 _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 2 _ H E L P =    4       l\  D(ǅȲ. 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 2 _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 2 _ H E L P =    D       l\  Ȳ. 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 2 _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 2 _ H E L P = ܴ|  0䲬  ǔ    l\  Ȳ. 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 3 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 3 _ H E L P = P r e s t a t i e m e t e r i t e m s   v o o r   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 3 _ N A M E = G e m a a k t e   w o r k f l o w s 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   g e m a a k t e   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 3 _ N A M E = W o r k f l o w s   g e m a a k t / s e c . 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 3 _ H E L P = F r e q u e n t i e   w a a r m e e   w o r k f l o w s   p e r   s e c o n d e   w o r d e n   g e m a a k t . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 3 _ N A M E = U i t   h e t   g e h e u g e n   v e r w i j d e r d e   w o r k f l o w s 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   v e r w i j d e r d e   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 3 _ N A M E = U i t   h e t   g e h e u g e n   v e r w i j d e r d e   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 3 _ H E L P = A a n t a l   w o r k f l o w s   d a t   p e r   s e c o n d e   w o r d t   v e r w i j d e r d . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 3 _ N A M E = G e l a d e n   w o r k f l o w s 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   g e l a d e n   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 3 _ N A M E = G e l a d e n   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 3 _ H E L P = A a n t a l   w o r k f l o w s   d a t   p e r   s e c o n d e   w o r d t   g e l a d e n . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 3 _ N A M E = V o l t o o i d e   w o r k f l o w s 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   v o l t o o i d e   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 3 _ N A M E = V o l t o o i d e   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 3 _ H E L P = F r e q u e n t i e   w a a r m e e   w o r k f l o w s   p e r   s e c o n d e   w o r d e n   v o l t o o i d . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 3 _ N A M E = O n d e r b r o k e n   w o r k f l o w s 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   o n d e r b r o k e n   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 3 _ N A M E = O n d e r b r o k e n   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 3 _ H E L P = F r e q u e n t i e   w a a r m e e   w o r k f l o w s   p e r   s e c o n d e   w o r d e n   o n d e r b r o k e n . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 3 _ N A M E = B e  i n d i g d e   w o r k f l o w s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   b e  i n d i g d e   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 3 _ N A M E = B e  i n d i g d e   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 3 _ H E L P = F r e q u e n t i e   w a a r m e e   w o r k f l o w s   p e r   s e c o n d e   w o r d e n   b e  i n d i g d . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 3 _ N A M E = W o r k f l o w s   i n   g e h e u g e n 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   w o r k f l o w s   i n   h e t   g e h e u g e n . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 3 _ N A M E = A f g e b r o k e n   w o r k f l o w s 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   a f g e b r o k e n   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 3 _ N A M E = A f g e b r o k e n   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 3 _ H E L P = F r e q u e n t i e   w a a r m e e   w o r k f l o w s   p e r   s e c o n d e   w o r d e n   a f g e b r o k e n . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 3 _ N A M E = O p g e s l a g e n   w o r k f l o w s 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 3 _ H E L P = H e t   t o t a l e   a a n t a l   s t a n d h o u d e n d e   w o r k f l o w s . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 3 _ N A M E = O p g e s l a g e n   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 3 _ H E L P = A a n t a l   w o r k f l o w s   d a t   p e r   s e c o n d e   s t a n d h o u d t . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 3 _ N A M E = W o r k f l o w s   d i e   w o r d e n   u i t g e v o e r d 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 3 _ H E L P = H e t   t o t a l e   a a n t a l   w o r k f l o w - e x e m p l a r e n   d a t   a c t i e f   w o r d t   u i t g e v o e r d . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 3 _ N A M E = I n a c t i e v e   w o r k f l o w s / s e c . 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 3 _ H E L P = A a n t a l   w o r k f l o w s   d a t   p e r   s e c o n d e   w o r d t   g e d e a c t i v e e r d . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 3 _ N A M E = U i t v o e r b a r e   w o r k f l o w s 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   w o r k f l o w s   d a t   k a n   w o r d e n   u i t g e v o e r d . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 3 _ N A M E = W o r k f l o w s   i n   b e h a n d e l i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 3 _ H E L P = T o t a l e   a a n t a l   w o r k f l o w s   i n   a f w a c h t i n g   v a n   e e n   t h r e a d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 4 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 4 _ H E L P = Y t e l s e s t e l l e r e   f o r   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   e r   o p p r e t t e t 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   o p p r e t t e d e   a r b e i d s f l y t o p e r a s j o n e r . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   o p p r e t t e t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   o p p r e t t e t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   e r   l a s t e t   u t 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   e r   l a s t e t   u t . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   l a s t e t   u t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   l a s t e t   u t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   l a s t e t 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   l a s t e d e   a r b e i d s f l y t o p e r a s j o n e r . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   l a s t e t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   l a s t e s   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   f u l l f  r t 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   f u l l f  r t e   a r b e i d s f l y t o p e r a s j o n e r . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   f u l l f  r t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   f u l l f  r t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   s t a n s e t 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   e r   s t a n s e t . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   s t a n s e t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   e r   s t a n s e t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   a v s l u t t e t 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a v s l u t t e d e   a r b e i d s f l y t o p e r a s j o n e r . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   a v s l u t t e t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   a v s l u t t e t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   i   m i n n e t 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t o p e r a s j o n e r   i   m i n n e . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   a v b r u t t 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a v b r u t t e   a r b e i d s f l y t o p e r a s j o n e r . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   a v b r u t t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   a v b r u t t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   e r   b e h o l d t 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t o p e r a s j o n e r   b e h o l d t . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 4 _ N A M E = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   b e h o l d t   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   b e h o l d t   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   u n d e r   u t f  r i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t f o r e k o m s t e r   s o m   e r   u n d e r   u t f  r i n g . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 4 _ N A M E = L e d i g e   a r b e i d s f l y t o p e r a s j o n e r   p e r   s e k u n d 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 4 _ H E L P = A n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   b l i r   i n a k t i v e   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 4 _ N A M E = A r b e i d s f l y t o p e r a s j o n e r   s o m   k a n   k j  r e s 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   e r   k l a r e   t i l   u t f  r i n g . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 4 _ N A M E = V e n t e n d e   a r b e i d s f l y t o p e r a s j o n e r 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 4 _ H E L P = T o t a l t   a n t a l l   a r b e i d s f l y t o p e r a s j o n e r   s o m   v e n t e r   p    e n   t r  d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 5 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 5 _ H E L P = L i c z n i k i   w y d a j n o [c i   u s Bu g   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 5 _ N A M E = U t w o r z o n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   u t w o r z o n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 5 _ N A M E = U t w o r z o n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   t w o r z o n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 5 _ N A M E = Z w o l n i o n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   z w o l n i o n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 5 _ N A M E = Z w o l n i o n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   z w a l n i a n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 5 _ N A M E = Z a Ba d o w a n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   z a Ba d o w a n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 5 _ N A M E = Z a Ba d o w a n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   Ba d o w a n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 5 _ N A M E = U k o Dc z o n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   u k o Dc z o n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 5 _ N A M E = U k o Dc z o n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   k o Dc z o n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 5 _ N A M E = W s t r z y m a n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   w s t r z y m a n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 5 _ N A M E = W s t r z y m a n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   w s t r z y m y w a n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 5 _ N A M E = Z a k o Dc z o n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   z a k o Dc z o n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 5 _ N A M E = Z a k o Dc z o n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   z a k a Dc z a n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 5 _ N A M E = P r z e p By w y   p r a c y   w   p a m i c i 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   p r z e p By w  w   p r a c y   w   p a m i c i . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 5 _ N A M E = P r z e r w a n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   p r z e r w a n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 5 _ N A M E = P r z e r w a n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   p r z e r y w a n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 5 _ N A M E = U t r w a l o n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   u t r w a l o n y c h   p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 5 _ N A M E = U t r w a l o n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   u t r w a l a n y c h   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 5 _ N A M E = W y k o n y w a n e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   a k t y w n i e   w y k o n y w a n y c h   w y s t p i e D  p r z e p By w  w   p r a c y . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 5 _ N A M E = B e z c z y n n e   p r z e p By w y   p r a c y / s 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 5 _ H E L P = L i c z b a   p r z e p By w  w   p r a c y   p r z e c h o d z c y c h   d o   s t a n u   b e z c z y n n o [c i   w   c i g u   s e k u n d y . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 5 _ N A M E = P r z e p By w y   p r a c y ,   k t  r e   m o |n a   u r u c h o m i 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   p r z e p By w  w   p r a c y   g o t o w y c h   d o   w y k o n a n i a . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 5 _ N A M E = O c z e k u j c e   p r z e p By w y   p r a c y 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 5 _ H E L P = C a Bk o w i t a   l i c z b a   p r z e p By w  w   p r a c y   o c z e k u j c y c h   n a   w t e k . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 4 1 6 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 4 1 6 _ H E L P = C o n t a d o r e s   d e   D e s e m p e n h o   d o   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C r i a d o s 
 
 W W S _ W O R K F L O W S C R E A T E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   c r i a d o s . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C r i a d o s / s 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c r i a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   D e s c a r r e g a d o s 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   d e s c a r r e g a d o s . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   D e s c a r r e g a d o s / s 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   d e s c a r r e g a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 4 1 6 _ N A M E = F L u x o s   d e   T r a b a l h o   C a r r e g a d o s 
 
 W W S _ W O R K F L O W S L O A D E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   c a r r e g a d o s . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C a r r e g a d o s / s 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c a r r e g a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C o n c l u  d o s 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   c o n c l u  d o s . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C o n c l u  d o s / s 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c o n c l u  d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   S u s p e n s o s 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   s u s p e n s o s . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   S u s p e n s o s / s 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   s u s p e n s o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   T e r m i n a d o s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   t e r m i n a d o s . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   T e r m i n a d o s / s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   t e r m i n a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   n a   M e m  r i a 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   n a   m e m  r i a . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   A n u l a d o s 
 
 W W S _ W O R K F L O W S A B O R T E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   a n u l a d o s . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   A n u l a d o s / s 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   a n u l a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   P e r s i s t e n t e s 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   c o n s e r v a d o s . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   P e r s i s t e n t e s / s 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c o n s e r v a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   e m   E x e c u   o 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 4 1 6 _ H E L P = T o t a l   d e   i n s t  n c i a s   d e   f l u x o   d e   t r a b a l h o   e m   e x e c u   o . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   O c i o s o s / s 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 4 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   q u e   s e   t o r n a m   o c i o s o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   E x e c u t  v e i s 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   p r o n t o s   p a r a   e x e c u   o . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 4 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   P e n d e n t e s 
 
 W W S _ W O R K F L O W S P E N D I N G _ 4 1 6 _ H E L P = T o t a l   d e   f l u x o s   d e   t r a b a l h o   a g u a r d a n d o   p o r   u m   s e g m e n t o . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 9 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 9 _ H E L P = !G5BG8:8  ?@>872>48B5;L=>AB8  W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 9 _ N A M E = !>740=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  A>740==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 9 _ N A M E = !>740=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   A>740205<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 9 _ N A M E = K3@C65=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  2K3@C65==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 9 _ N A M E = K3@C65=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   2K3@C605<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 9 _ N A M E = 03@C65=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  703@C65==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 9 _ N A M E = 03@C65=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   703@C605<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 9 _ N A M E = 025@H5=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  7025@H5==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 9 _ N A M E = 025@H5=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   7025@H05<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 9 _ N A M E = @8>AB0=>2;5=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  ?@8>AB0=>2;5==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 9 _ N A M E = @8>AB0=>2;5=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   ?@8>AB0=02;8205<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 9 _ N A M E = 025@H5=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  ?@5:@0I5==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 9 _ N A M E = 025@H5=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   ?@5:@0I05<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 9 _ N A M E = >B>:>2  >?5@0F89  2  ?0<OB8
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  ?>B>:>2  @01>B  2  ?0<OB8. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 9 _ N A M E = @5@20=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  ?@5@20==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 9 _ N A M E = @5@20=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   ?@5@K205<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 9 _ N A M E = !>E@0=5=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  A>E@0=5==KE  ?>B>:>2  @01>B. 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 9 _ N A M E = !>E@0=5=>  ?>B>:>2  >?5@0F89  70  A5:C=4C
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   A>E@0=O5<KE  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 9 _ N A M E = K?>;=5=>  ?>B>:>2  >?5@0F89
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  M:75<?;O@>2  ?>B>:>2  @01>B,   2K?>;=O5<KE  2  =0AB>OI55  2@5<O. 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 9 _ N A M E = >B>:>2  >?5@0F89  157459AB2C5B  70  A5:C=4C
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 9 _ H E L P = >;8G5AB2>  ?>B>:>2  @01>B,   ?5@5E>4OI8E  2  A>AB>O=85  ?@>AB>O  2  A5:C=4C. 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 9 _ N A M E = >B>:>2  >?5@0F89  3>B>2>  :  70?CA:C
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  ?>B>:>2  @01>B,   3>B>2KE  :  2K?>;=5=8N. 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 9 _ N A M E = >B>:>2  >?5@0F89  >B;>65=>
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 9 _ H E L P = 1I55  :>;8G5AB2>  ?>B>:>2  @01>B,   >6840NI8E  ?>B>:0. 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 D _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 D _ H E L P = P r e s t a n d a r  k n a r e   f  r   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 D _ N A M E = S k a p a d e   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   s k a p a d e   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 D _ N A M E = S k a p a d e   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   s k a p a d e   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 D _ N A M E = I n a k t i v e r a d e   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   i n a k t i v e r a d e   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 D _ N A M E = I n a k t i v e r a d e   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   i n a k t i v e r a d e   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 D _ N A M E = I n l  s t a   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   i n l  s t a   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 D _ N A M E = I n l  s t a   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   i n l  s t a   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 D _ N A M E = S l u t f  r d a   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   s l u t f  r d a   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 D _ N A M E = S l u t f  r d a   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   s l u t f  r d a   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 D _ N A M E = P a u s a d e   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   p a u s a d e   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 D _ N A M E = P a u s a d e   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   p a u s a d e   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 D _ N A M E = A v s l u t a d e   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   a v s l u t a d e   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 D _ N A M E = A v s l u t a d e   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   a v s l u t a d e   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 D _ N A M E = A r b e t s f l  d e n   i   m i n n e t 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 D _ H E L P = T o t a l t   a n t a l   a r b e t s f l  d e n   i   m i n n e t . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 D _ N A M E = A v b r u t n a   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   a v b r u t n a   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 D _ N A M E = A v b r u t n a   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   a v b r u t n a   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 D _ N A M E = B e s t  n d i g a   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 D _ H E L P = T o t a l t   a n t a l   b e s t  n d i g a   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 D _ N A M E = B e s t  n d i g a   a r b e t s f l  d e n / s e k 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   b e s t  n d i g a   a r b e t s f l  d e n   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 D _ N A M E = A r b e t s f l  d e n   s o m   k  r s 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 D _ H E L P = T o t a l t   a n t a l   a r b e t s f l  d e s i n s t a n s e r   s o m   k  r s   a k t i v t . 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 D _ N A M E = A r b e t s f l  d e n   i   v i l o l  g e / s e k 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 D _ H E L P = A n t a l   a r b e t s f l  d e n   s o m   f  r   v i l o l  g e   p e r   s e k u n d . 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 D _ N A M E = K  r b a r a   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 D _ H E L P = T o t a l t   a n t a l   k  r b a r a   a r b e t s f l  d e n . 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 D _ N A M E = V  n t a n d e   a r b e t s f l  d e n 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 D _ H E L P = A n t a l   a r b e t s f l  d e n   s o m   v  n t a r   p    e n   t r  d . 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 F _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 0 1 F _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n   P e r f o r m a n s   S a y a  l a r 1
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 F _ N A M E = O l u _t u r u l a n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S C R E A T E D _ 0 1 F _ H E L P = O l u _t u r u l a n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 F _ N A M E = O l u _t u r u l a n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   o l u _t u r u l a n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 F _ N A M E = K a l d 1r 1l a n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S U N L O A D E D _ 0 1 F _ H E L P = B e l l e k t e n   k a l d 1r 1l a n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 F _ N A M E = K a l d 1r 1l a n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   b e l l e k t e n   k a l d 1r 1l a n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 F _ N A M E = Y  k l e n e n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S L O A D E D _ 0 1 F _ H E L P = B e l l e e   y  k l e n e n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 F _ N A M E = Y  k l e n e n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   b e l l e e   y  k l e n e n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 F _ N A M E = T a m a m l a n a n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 0 1 F _ H E L P = T a m a m l a n a n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 F _ N A M E = T a m a m l a n a n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   t a m a m l a n a n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 F _ N A M E = A s k 1y a   A l 1n a n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 0 1 F _ H E L P = A s k 1y a   a l 1n a n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 F _ N A M E = A s k 1y a   A l 1n a n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   a s k 1y a   a l 1n a n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 F _ N A M E = S o n l a n d 1r 1l a n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 0 1 F _ H E L P = S o n l a n d 1r 1l a n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 F _ N A M E = S o n l a n d 1r 1l a n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   s o n l a n d 1r 1l a n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 F _ N A M E = B e l l e k t e k i   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 0 1 F _ H E L P = B e l l e k t e k i   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 F _ N A M E = D u r d u r u l a n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S A B O R T E D _ 0 1 F _ H E L P = D u r d u r u l a n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 F _ N A M E = D u r d u r u l a n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   d u r d u r u l a n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 F _ N A M E = S  r d  r  l e n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 0 1 F _ H E L P = S  r d  r  l e n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 F _ N A M E = S  r d  r  l e n   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   s  r d  r  l e n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 F _ N A M E = Y  r  t  l e n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 0 1 F _ H E L P = E t k i n   o l a r a k   y  r  t  l e n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 F _ N A M E = B o _t a k i   0_  A k 1_l a r 1/ s a n 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 0 1 F _ H E L P = S a n i y e d e   b o _  d u r u m a   g e  e n   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 F _ N A M E =  a l 1_t 1r 1l a b i l i r   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S R U N N A B L E _ 0 1 F _ H E L P = Y  r  t  l m e y e   h a z 1r   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 F _ N A M E = B e k l e y e n   0_  A k 1_l a r 1
 
 W W S _ W O R K F L O W S P E N D I N G _ 0 1 F _ H E L P = 0_  p a r  a c 11  b e k l e y e n   t o p l a m   i _  a k 1_1  s a y 1s 1. 
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 8 0 4 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 8 0 4 _ H E L P = W i n d o w s   W o r k f l o w   F o u n d a t i o n   '`pehV
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 8 0 4 _ N A M E = W o r k f l o w s   C r e a t e d 
 
 W W S _ W O R K F L O W S C R E A T E D _ 8 0 4 _ H E L P = ]R^v]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   C r e a t e d / s e c 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 8 0 4 _ H E L P = kyR^]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 8 0 4 _ N A M E = W o r k f l o w s   U n l o a d e d 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 8 0 4 _ H E L P = ]xS}v]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   U n l o a d e d / s e c 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 8 0 4 _ H E L P = kyxS}]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 8 0 4 _ N A M E = W o r k f l o w s   L o a d e d 
 
 W W S _ W O R K F L O W S L O A D E D _ 8 0 4 _ H E L P = ]R}v]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   L o a d e d / s e c 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 8 0 4 _ H E L P = kyR}]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 8 0 4 _ N A M E = W o r k f l o w s   C o m p l e t e d 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 8 0 4 _ H E L P = ][bv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   C o m p l e t e d / s e c 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 8 0 4 _ H E L P = ky[b]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 8 0 4 _ N A M E = W o r k f l o w s   S u s p e n d e d 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 8 0 4 _ H E L P = ]cwv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   S u s p e n d e d / s e c 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 8 0 4 _ H E L P = kycw]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 8 0 4 _ N A M E = W o r k f l o w s   T e r m i n a t e d 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 8 0 4 _ H E L P = ]~bkv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   T e r m i n a t e d / s e c 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 8 0 4 _ H E L P = ky~bk]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 8 0 4 _ N A M E = W o r k f l o w s   I n   M e m o r y 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 8 0 4 _ H E L P = QX[-Nv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 8 0 4 _ N A M E = W o r k f l o w s   A b o r t e d 
 
 W W S _ W O R K F L O W S A B O R T E D _ 8 0 4 _ H E L P = ]-Nbkv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   A b o r t e d / s e c 
 
 W W S _ W O R K F L O W S A B O R T E D P E R S E C O N D _ 8 0 4 _ H E L P = ky-Nbk]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 8 0 4 _ N A M E = W o r k f l o w s   P e r s i s t e d 
 
 W W S _ W O R K F L O W S P E R S I S T E D _ 8 0 4 _ H E L P = cENSv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   P e r s i s t e d / s e c 
 
 W W S _ W O R K F L O W S P E R S I S T E D P E R S E C O N D _ 8 0 4 _ H E L P = kycENS]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 8 0 4 _ N A M E = W o r k f l o w s   E x e c u t i n g 
 
 W W S _ W O R K F L O W S E X E C U T I N G _ 8 0 4 _ H E L P = ;NRgbLv]\OAm[Ov;`pe0
 
 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 8 0 4 _ N A M E = W o r k f l o w s   I d l e / s e c 
 
 W W S _ W O R K F L O W S I D L E P E R S E C O N D _ 8 0 4 _ H E L P = kyS:Nzz]\OAmvs0
 
 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 8 0 4 _ N A M E = W o r k f l o w s   R u n n a b l e 
 
 W W S _ W O R K F L O W S R U N N A B L E _ 8 0 4 _ H E L P = QYgbLv]\OAm;`pe0
 
 
 
 W W S _ W O R K F L O W S P E N D I N G _ 8 0 4 _ N A M E = W o r k f l o w s   P e n d i n g 
 
 W W S _ W O R K F L O W S P E N D I N G _ 8 0 4 _ H E L P = ck(WI{_~zv]\OAm;`pe0
 
 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 8 1 6 _ N A M E = W F   ( S y s t e m . W o r k f l o w )   4 . 0 . 0 . 0 
 
 W W S _ W W S V 1 P E R F C O U N T E R S _ 8 1 6 _ H E L P = C o n t a d o r e s   d e   D e s e m p e n h o   d o   W i n d o w s   W o r k f l o w   F o u n d a t i o n 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C r i a d o s 
 
 W W S _ W O R K F L O W S C R E A T E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   c r i a d o s . 
 
 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C r i a d o s / s e g 
 
 W W S _ W O R K F L O W S C R E A T E D P E R S E C O N D _ 8 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c r i a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   D e s c a r r e g a d o s 
 
 W W S _ W O R K F L O W S U N L O A D E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   t r a n s f e r i d o s . 
 
 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   D e s c a r r e g a d o s / s e g 
 
 W W S _ W O R K F L O W S U N L O A D E D P E R S E C O N D _ 8 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   t r a n s f e r i d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C a r r e g a d o s 
 
 W W S _ W O R K F L O W S L O A D E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   c a r r e g a d o s . 
 
 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C a r r e g a d o s / s e g 
 
 W W S _ W O R K F L O W S L O A D E D P E R S E C O N D _ 8 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c a r r e g a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C o n c l u  d o s 
 
 W W S _ W O R K F L O W S C O M P L E T E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   c o n c l u  d o s . 
 
 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   C o n c l u  d o s / s e g 
 
 W W S _ W O R K F L O W S C O M P L E T E D P E R S E C O N D _ 8 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   c o n c l u  d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   S u s p e n s o s 
 
 W W S _ W O R K F L O W S S U S P E N D E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   s u s p e n s o s . 
 
 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   S u s p e n s o s / s e g 
 
 W W S _ W O R K F L O W S S U S P E N D E D P E R S E C O N D _ 8 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   s u s p e n s o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   T e r m i n a d o s 
 
 W W S _ W O R K F L O W S T E R M I N A T E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   t e r m i n a d o s . 
 
 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   T e r m i n a d o s / s e g 
 
 W W S _ W O R K F L O W S T E R M I N A T E D P E R S E C O N D _ 8 1 6 _ H E L P = T a x a   d e   f l u x o s   d e   t r a b a l h o   t e r m i n a d o s   p o r   s e g u n d o . 
 
 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   N a   M e m  r i a 
 
 W W S _ W O R K F L O W S I N M E M O R Y _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x o s   d e   t r a b a l h o   n a   m e m  r i a . 
 
 
 
 W W S _ W O R K F L O W S A B O R T E D _ 8 1 6 _ N A M E = F l u x o s   d e   T r a b a l h o   A b o r t a d o s 
 
 W W S _ W O R K F L O W S A B O R T E D _ 8 1 6 _ H E L P = N  m e r o   t o t a l   d e   f l u x 