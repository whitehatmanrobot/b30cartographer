ools\common\win32sdk\include\poppack.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winbase.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\winerror.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\wingdi.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack1.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winuser.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\tvout.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winnls.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\wincon.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winver.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winreg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\reason.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winnetwk.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\cderr.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\dde.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\ddeml.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\dlgs.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\lzexpand.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mmsystem.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack1.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\nb30.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\rpc.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\rpcdce.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\rpcdcep.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\rpcnsi.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\rpcnterr.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\rpcasync.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\shellapi.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack1.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winperf.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack8.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winsock.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\wincrypt.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winefs.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winscard.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\wtypes.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\rpcndr.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\pshpack8.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\rpcnsip.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\guiddef.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\winioctl.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\winsmcrd.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winspool.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\prsht.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\ole2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack8.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\objbase.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\pshpack8.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\stdlib.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\unknwn.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\objidl.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\guiddef.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\urlmon.h
Note: including file:       e:\vs70\devtools\common\win32sdk\include\oleidl.h
Note: including file:       e:\vs70\devtools\common\win32sdk\include\servprov.h
Note: including file:       e:\vs70\devtools\common\win32sdk\include\msxml.h
Note: including file:        e:\vs70\devtools\common\win32sdk\include\oaidl.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\propidl.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\oleauto.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\pshpack8.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\commdlg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\prsht.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\pshpack1.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\stralign.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\winsvc.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mcx.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\imm.h
Note: including file:  e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:  e:\vs70\devtools\common\win32sdk\include\ocidl.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\mdmsg.h
e:\VS70\devtools\x86\vcLKG\bin\cl -nologo -Ii386\ -I. -Ie:\VS70\VS\src\vc\ide\include -Ie:\VS70\VS\src\vc\ide\pkgs\include -Ie:\VS70\VS\external\inc -Ie:\VS70\vsbuilt\debug\bin\i386 -Ie:\VS70\VS\src\common\idl\vs -Ie:\VS70\VS\src\common\win95 -Ie:\VS70\VS\src\common\inc -Ie:\VS70\vsbuilt\debug\inc\i386 -Ie:\VS70\devtools\common\win32sdk\include -Ie:\VS70\devtools\common\win32sdk\include\nonship -Ie:\VS70\vsbuilt\debug\bin\i386\complus -Ie:\VS70\devtools\common\win32sdk\include -Ie:\VS70\devtools\common\vcLKG\inc\atlmfc -Ie:\VS70\devtools\common\vcLKG\inc\atlmfc -Ie:\VS70\devtools\common\vcLKG\inc\stl -Ie:\VS70\devtools\common\vcLKG\inc -Ie:\VS70\VS\src\vc\langapi\include -Ie:\VS70\VS\src\vc\langapi\ncb -D_X86_=1 -Di386=1       -DWIN32 -DWINNT=1     -DCC_CVTYPE32 -DCC_LAZYTYPES   -D_DEBUG -D_DLL=1 -D_MT=1  -DDEBUG -D_NEW_SDK=1  -D_WINDOWS -D_DBCS=1 -D_NTWIN -D_SUSHI -DCC_MULTIPLE_STORES=1 -D_TEST -DADDR_MIXED  -DCODEVIEW -DCONDITION_HANDLING -DCROSS_PLATFORM -DHOST32 -DHOST_i386 -Dx86 -D_MBCS -D_WINDLL  -D_ATL_STATIC_REGISTRY -DNEW_PROJBLD_TURNED_ON -D_DEBUG -DDEBUG=1 -DVC_PROXY -DSTRICT -DVS_PACKAGE -DUNICODE   /c /Zel /Zp8 /Gy  -W3 -WX /Gd    /Gi /Gm    /GF  /D_ATL_STATIC_REGISTRY /D_ATL_DISABLE_DEPRECATED /DATL_NO_LEAN_AND_MEAN /Zi -Od /Oy- /GZ /FdE:\VS70\vs\src\vc\ide\pkgs\projbld\vcpb\objd\i386\VCProjectEngine_COMP.pdb   /GS /RTC1  -Zm400 /showIncludes /FIwarning.h /Yustdafx.h /Fpobjd\i386\stdafx.pch .\bldactions.cpp .\bldeventtool.cpp .\bldhelpers.cpp .\bldspawner.cpp .\bldthread.cpp .\bldtool.cpp .\bsctool.cpp .\buildengine.cpp .\buildlogging.cpp .\cltool.cpp .\cmdlines.cpp .\configrecords.cpp .\configuration.cpp .\custombuildtool.cpp .\debugsettings.cpp .\dependencygraph.cpp .\deploytool.cpp .\envdaemon.cpp .\encbldthrd.cpp .\file.cpp .\fileconfiguration.cpp .\fileregistry.cpp .\filter.cpp .\globals.cpp .\libtool.cpp .\linklibhelp.cpp .\linktool.cpp .\midltoolbase.cpp .\mrdependencies.cpp .\nmaketool.cpp .\platform.cpp .\project.cpp .\projectoptions.cpp .\projevaluator.cpp .\projwriter.cpp .\propcontainer.cpp .\rctool.cpp .\regscan.cpp .\scanner.cpp .\sdltool.cpp .\settingspage.cpp .\stylesheet.cpp .\util2.cpp .\vcnodefactory.cpp .\vcpb.cpp .\vcprojectengine.cpp .\vctool.cpp .\xmlfile.cpp 
bldactions.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
bldeventtool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldEventTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
bldhelpers.cpp
Note: including file: e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldThread.h
Note: including file:  e:\VS70\VS\src\vc\ide\pkgs\include\bldmarshal.h
bldspawner.cpp
Note: including file: e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file: e:\VS70\VS\src\vc\ide\include\dllapi.h
Note: including file: e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:  e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:  e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
bldthread.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldthread.h
Note: including file:  e:\VS70\VS\src\vc\ide\pkgs\include\bldmarshal.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldHelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
bldtool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
bsctool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BscTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
buildengine.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldThread.h
Note: including file:  e:\VS70\VS\src\vc\ide\pkgs\include\bldmarshal.h
Note: including file: e:\VS70\devtools\common\vcLKG\inc\mbctype.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\EnvDaemon.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldEventTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MRDependencies.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\xmlfile.h
buildlogging.cpp
Note: including file: e:\VS70\devtools\common\vcLKG\inc\locale.h
Note: including file: e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:     e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:    e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\xmlfile.h
cltool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CLTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CLToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:    e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldHelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MRDependencies.h
Note: including file: e:\VS70\vsbuilt\debug\inc\i386\vsappid.h
cmdlines.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
configrecords.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
configuration.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\Configuration.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\configrecords.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\StyleSheet.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldtool.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\debugsettings.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\toolhrt.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file: e:\VS70\devtools\common\vcLKG\inc\atlmfc\atltime.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\linktool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\cltool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CLToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
custombuildtool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CustomBuildTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldHelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\VS70\VS\src\common\idl\vs\DTE.h
debugsettings.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DebugSettings.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:     e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:    e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\toolhrt.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file: e:\VS70\vsbuilt\debug\inc\i386\msdbg.h
Note: including file:  e:\vs70\vsbuilt\debug\inc\i386\enc.h
Note: including file:   e:\vs70\vsbuilt\debug\inc\i386\sh.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\regscan.h
Note: including file: e:\VS70\vsbuilt\debug\inc\i386\vsappid.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
dependencygraph.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MRDependencies.h
deploytool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DeployTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\XMLFile.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\stylesheet.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\linktool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
envdaemon.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\envdaemon.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:   e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
encbldthrd.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:   e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\devtools\common\vcLKG\inc\fcntl.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\EnvDaemon.h
file.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\File.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:     e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:    e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\fileconfiguration.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\projwriter.h
Generating Code...
Compiling...
fileconfiguration.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileConfiguration.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccoll.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:       e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:       e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:       e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:       e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:        e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:       e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:        e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:        e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\projwriter.h
fileregistry.cpp
Note: including file: e:\VS70\devtools\common\vcLKG\inc\sys\utime.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
filter.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\Filter.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:       e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:       e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:        e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\file.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\projwriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\project.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\globals.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\webref.h
globals.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\projwriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\globals.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
libtool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LibTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldHelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
linklibhelp.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldactions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\linklibhelp.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\linktool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:    e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
linktool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:    e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldHelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\stylesheet.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
midltoolbase.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MidlTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MidlToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:    e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
mrdependencies.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\mrdependencies.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\fileregistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\VS70\devtools\common\win32sdk\include\winver.h
Note: including file: e:\VS70\VS\src\vc\langapi\include\mrengine.h
Note: including file:  e:\VS70\VS\src\vc\langapi\include\pdb.h
Note: including file:   e:\vs70\vs\src\vc\langapi\include\..\include\vcver.h
Note: including file: e:\VS70\VS\src\common\inc\utf.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
nmaketool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\NMakeTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldHelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
platform.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\Platform.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:       e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:       e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:        e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\projwriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\regscan.h
Note: including file: e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bsctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldeventtool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\cltool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CLToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\custombuildtool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DeployTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\libtool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\linktool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkLibHelp.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\LinkToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\midltool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MidlToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\nmaketool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\rctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\RCToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\sdltool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
project.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\Project.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\globals.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\webref.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\file.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\configuration.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\configrecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\StyleSheet.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldtool.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\filter.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\xmlfile.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
projectoptions.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
projevaluator.cpp
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:  e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\fileregistry.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
projwriter.cpp
propcontainer.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\propcontainer.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccoll.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:  e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:  e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
rctool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\RCTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\RCToolBase.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:    e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
regscan.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\RegScan.h
Note: including file: e:\VS70\VS\src\common\inc\uniapi.h
scanner.cpp
Note: including file: e:\VS70\devtools\common\win32sdk\include\shlobj.h
Note: including file: e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\mrdependencies.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
sdltool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SdlTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:      e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:      e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:     e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Generating Code...
Compiling...
settingspage.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:     e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:       e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:    e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:  e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:  e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
stylesheet.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\StyleSheet.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldtool.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\propcontainer.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:    e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
util2.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
vcnodefactory.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCNodeFactory.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\vcprojectengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:   e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
vcpb.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:   e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\configuration.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\configrecords.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:   e:\VS70\VS\src\common\idl\vs\DTE.h
Note: including file:    e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\projbld2.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\ocdesign.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\DirControl.h
Note: including file:   e:\VS70\VS\src\vc\ide\pkgs\include\vcdlg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\StyleSheet.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldtool.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\fileconfiguration.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\platform.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PlatformXbox.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\debugsettings.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\toolhrt.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\pshpack4.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\poppack.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCNodeFactory.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\XMLFile.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
vcprojectengine.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:   e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\collection.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\project.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\globals.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\webref.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\regscan.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\VS70\VS\src\vc\ide\include\msgboxes2.h
Note: including file:  e:\vs70\vs\src\vc\ide\include\msgboxes2.inl
Note: including file: e:\VS70\VS\src\vc\ide\include\profile.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\StyleSheet.h
Note: including file: e:\VS70\VS\src\vc\ide\include\register.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCNodeFactory.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\xmlfile.h
Note: including file: e:\VS70\vsbuilt\debug\inc\i386\vsappid.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\MRDependencies.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\platform.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file: e:\VS70\devtools\common\vcLKG\inc\fcntl.h
Note: including file: e:\VS70\devtools\common\win32sdk\include\iads.h
Note: including file: e:\VS70\VS\src\common\idl\vs\dte.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\dteinternal.h
Note: including file: e:\VS70\vsbuilt\debug\inc\i386\uilocale.h
Note: including file: e:\VS70\vsbuilt\debug\inc\i386\helpsys.h
vctool.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjectOptions.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:     e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys\stat.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:    e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:   e:\VS70\VS\src\vc\ide\include\VCMap.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\FileRegistry.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\CmdLines.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldActions.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildLogging.h
Note: including file:    e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:      e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:     e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:      e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:       e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:     e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:      e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:       e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:      e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:     e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ConfigRecords.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BldTool.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\DependencyGraph.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\BuildEngine.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcbuild.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\stylesheet.h
xmlfile.cpp
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\XMLFile.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\VcpbengCP.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\scriptexecutor.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\time.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/types.h
Note: including file:   e:\VS70\devtools\common\vcLKG\inc\sys/stat.h
Note: including file:   e:\VS70\vsbuilt\debug\inc\i386\activscp.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:  e:\VS70\VS\src\vc\ide\include\vccolls.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vccoll.h
Note: including file:    e:\vs70\vs\src\vc\ide\include\plex.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\vccoll.inl
Note: including file:   e:\VS70\VS\src\vc\ide\include\vccolls.inl
Note: including file:  e:\VS70\VS\src\vc\ide\include\vcmap.h
Note: including file:   e:\vs70\vs\src\vc\ide\include\vcmap.inl
Note: including file:  e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\PropContainer.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h
Note: including file:   e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h
Note: including file:    e:\VS70\VS\src\vc\ide\pkgs\include\vcids.h
Note: including file:    e:\VS70\VS\src\vc\ide\include\path2.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\direct.h
Note: including file:     e:\VS70\devtools\common\vcLKG\inc\io.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\VCFileClasses.h
Note: including file:      e:\VS70\VS\src\vc\ide\include\vctimeclasses.h
Note: including file:     e:\VS70\VS\src\vc\ide\include\OsUtil.h
Note: including file:  e:\VS70\vsbuilt\debug\inc\i386\vcprojcnvt2.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iadmw.h
Note: including file:   e:\vs70\devtools\common\win32sdk\include\mddefw.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:    e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdcommsg.h
Note: including file:   e:\VS70\devtools\common\win32sdk\include\mdmsg.h
Note: including file:  e:\VS70\devtools\common\win32sdk\include\iiscnfg.h
Note: including file: e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h
Generating Code...
	e:\VS70\devtools\x86\vcLKG\bin\lib -out:e:\VS70\vsbuilt\debug\lib\i386\VCProjectEngine.lib @C:\DOCUME~1\jpalevic\LOCALS~1\Temp\nm56.tmp
Microsoft (R) Library Manager Version 7.00.9351
Copyright (C) Microsoft Corporation.  All rights reserved.

-debugtype:cv 
-name:VCProjectEngine 
-IGNORE:4075,4099 
-ignore:4013,4078,4089,4099 
-nodefaultlib 
-machine:ix86 
-def:vcpb.def 
objd\i386\vcpb.res 
objd\i386\guid.obj 
objd\i386\bldactions.obj 
objd\i386\bldeventtool.obj 
objd\i386\bldhelpers.obj 
objd\i386\bldspawner.obj 
objd\i386\bldthread.obj 
objd\i386\bldtool.obj 
objd\i386\bsctool.obj 
objd\i386\buildengine.obj 
objd\i386\buildlogging.obj 
objd\i386\cltool.obj 
objd\i386\cmdlines.obj 
objd\i386\configrecords.obj 
objd\i386\configuration.obj 
objd\i386\custombuildtool.obj 
objd\i386\debugsettings.obj 
objd\i386\dependencygraph.obj 
objd\i386\deploytool.obj 
objd\i386\envdaemon.obj 
objd\i386\encbldthrd.obj 
objd\i386\file.obj 
objd\i386\fileconfiguration.obj 
objd\i386\fileregistry.obj 
objd\i386\filter.obj 
objd\i386\globals.obj 
objd\i386\libtool.obj 
objd\i386\linklibhelp.obj 
objd\i386\linktool.obj 
objd\i386\midltoolbase.obj 
objd\i386\mrdependencies.obj 
objd\i386\nmaketool.obj 
objd\i386\platform.obj 
objd\i386\project.obj 
objd\i386\projectoptions.obj 
objd\i386\projevaluator.obj 
objd\i386\projwriter.obj 
objd\i386\propcontainer.obj 
objd\i386\rctool.obj 
objd\i386\regscan.obj 
objd\i386\scanner.obj 
objd\i386\sdltool.obj 
objd\i386\settingspage.obj 
objd\i386\stylesheet.obj 
objd\i386\util2.obj 
objd\i386\vcnodefactory.obj 
objd\i386\vcpb.obj 
objd\i386\vcprojectengine.obj 
objd\i386\vctool.obj 
objd\i386\xmlfile.obj 
objd\i386\stdafx.obj 
   Creating library e:\VS70\vsbuilt\debug\lib\i386\VCProjectEngine.lib and object e:\VS70\vsbuilt\debug\lib\i386\VCProjectEngine.exp
	echo ***  Pass 1 complete. ***
*** Pass 1 complete. ***

Stop.
Linking e:\vs70\vs\src\vc\ide\pkgs\projbld\vcpb directory ********************
'e:\VS70\devtools\x86\vcLKG\bin\nmake.exe /c BUILDMSG=Stop. -i LINKONLY=1 NOPASS0=1 NTTEST= UMTEST= MAKEDLL=1 386=1'
34 MIDL_OPTIMIZATION is -Oicf -no_format_opt -error all
	e:\VS70\devtools\x86\vcLKG\bin\link -out:e:\VS70\vsbuilt\debug\bin\i386\VC7\VCPackages\VCProjectEngine.dll -machine:ix86 @C:\DOCUME~1\jpalevic\LOCALS~1\Temp\nm57.tmp
Microsoft (R) Incremental Linker Version 7.00.9351
Copyright (C) Microsoft Corporation.  All rights reserved.

-opt:noref 
-IGNORE:4075,4099 
-ignore:4013,4078,4089,4099 
-nodefaultlib 
-debug 
-debugtype:cv 
-opt:win98 
-merge:.rdata=.text 
-ignore:4199 
-delayload:shell32.dll 
-delayload:comdlg32.dll 
-delayload:vsansi.dll 
-delayload:wininet.dll 
-delayload:UrlMon.dll 
-version:7.00 
-dll 
-base:@e:\VS70\VS\public\dllbase.txt,VCProjectEngine 
-subsystem:windows 
-entry:_DllMainCRTStartup@12 
objd\i386\stdafx.obj 
e:\VS70\vsbuilt\debug\lib\i386\VCProjectEngine.exp 
objd\i386\vcpb.res 
objd\i386\guid.obj 
objd\i386\bldactions.obj 
objd\i386\bldeventtool.obj 
objd\i386\bldhelpers.obj 
objd\i386\bldspawner.obj 
objd\i386\bldthread.obj 
objd\i386\bldtool.obj 
objd\i386\bsctool.obj 
objd\i386\buildengine.obj 
objd\i386\buildlogging.obj 
objd\i386\cltool.obj 
objd\i386\cmdlines.obj 
objd\i386\configrecords.obj 
objd\i386\configuration.obj 
objd\i386\custombuildtool.obj 
objd\i386\debugsettings.obj 
objd\i386\dependencygraph.obj 
objd\i386\deploytool.obj 
objd\i386\envdaemon.obj 
objd\i386\encbldthrd.obj 
objd\i386\file.obj 
objd\i386\fileconfiguration.obj 
objd\i386\fileregistry.obj 
objd\i386\filter.obj 
objd\i386\globals.obj 
objd\i386\libtool.obj 
objd\i386\linklibhelp.obj 
objd\i386\linktool.obj 
objd\i386\midltoolbase.obj 
objd\i386\mrdependencies.obj 
objd\i386\nmaketool.obj 
objd\i386\platform.obj 
objd\i386\project.obj 
objd\i386\projectoptions.obj 
objd\i386\projevaluator.obj 
objd\i386\projwriter.obj 
objd\i386\propcontainer.obj 
objd\i386\rctool.obj 
objd\i386\regscan.obj 
objd\i386\scanner.obj 
objd\i386\sdltool.obj 
objd\i386\settingspage.obj 
objd\i386\stylesheet.obj 
objd\i386\util2.obj 
objd\i386\vcnodefactory.obj 
objd\i386\vcpb.obj 
objd\i386\vcprojectengine.obj 
objd\i386\vctool.obj 
objd\i386\xmlfile.obj 
e:\VS70\vsbuilt\debug\lib\i386\vcutillibd.lib 
e:\VS70\vsbuilt\debug\lib\i386\vcidl.lib 
e:\VS70\vsbuilt\debug\lib\i386\vsguids.lib 
e:\VS70\vsbuilt\debug\lib\i386\vseeguids.lib 
e:\VS70\vsbuilt\debug\lib\i386\envguids.lib 
e:\VS70\vsbuilt\debug\lib\i386\ad2ide.lib 
e:\VS70\vsbuilt\debug\lib\i386\utild.lib 
e:\VS70\vsbuilt\debug\lib\i386\vsassert.lib 
e:\VS70\vsbuilt\debug\lib\i386\unilibd.lib 
e:\VS70\vsbuilt\debug\lib\i386\dpclstub.lib 
e:\VS70\vsbuilt\debug\lib\i386\toolhrtd.lib 
e:\VS70\vsbuilt\debug\lib\i386\vsansidelayimp.lib 
e:\VS70\devtools\x86\win32sdk\lib\rpcrt4.lib 
e:\VS70\devtools\x86\win32sdk\lib\msxml2.lib 
e:\VS70\devtools\x86\win32sdk\lib\uuid.lib 
e:\VS70\devtools\x86\win32sdk\lib\oleaut32.lib 
e:\VS70\devtools\x86\win32sdk\lib\ole32.lib 
e:\VS70\devtools\x86\win32sdk\lib\kernel32.lib 
e:\VS70\devtools\x86\win32sdk\lib\gdi32.lib 
e:\VS70\devtools\x86\win32sdk\lib\user32.lib 
e:\VS70\devtools\x86\win32sdk\lib\shell32.lib 
e:\VS70\devtools\x86\win32sdk\lib\comdlg32.lib 
e:\VS70\devtools\x86\win32sdk\lib\comctl32.lib 
e:\VS70\devtools\x86\win32sdk\lib\advapi32.lib 
e:\VS70\devtools\x86\win32sdk\lib\wininet.lib 
e:\VS70\devtools\x86\win32sdk\lib\urlmon.lib 
e:\VS70\devtools\x86\win32sdk\lib\Ws2_32.lib 
e:\VS70\devtools\x86\vcLKG\lib\oldnames.lib 
e:\VS70\devtools\x86\win32sdk\lib\shlwapi.lib 
e:\VS70\devtools\x86\vcLKG\lib\msvcrtd.lib 
e:\VS70\devtools\x86\vcLKG\lib\msvcirtd.lib 
e:\VS70\devtools\x86\vcLKG\atlmfc\lib\atlsd.lib 
vcpb.obj : error LNK2001: unresolved external symbol "public: virtual long __stdcall CPlatformXbox::IsToolInToolset(enum toolSetType,struct IVCToolImpl *,short *)" (?IsToolInToolset@CPlatformXbox@@UAGJW4toolSetType@@PAUIVCToolImpl@@PAF@Z)
vcpb.obj : error LNK2001: unresolved external symbol "public: virtual long __stdcall CPlatformXbox::Initialize(void)" (?Initialize@CPlatformXbox@@UAGJXZ)
vcpb.obj : error LNK2001: unresolved external symbol "public: virtual long __stdcall CPlatformXbox::SaveObject(struct IStream *,struct IVCPropertyContainer *,long)" (?SaveObject@CPlatformXbox@@UAGJPAUIStream@@PAUIVCPropertyContainer@@J@Z)
vcpb.obj : error LNK2001: unresolved external symbol "public: virtual long __stdcall CPlatformXbox::MatchName(unsigned short *,short,short *)" (?MatchName@CPlatformXbox@@UAGJPAGFPAF@Z)
vcpb.obj : error LNK2001: unresolved external symbol "public: virtual long __stdcall CPlatformXbox::get_Name(unsigned short * *)" (?get_Name@CPlatformXbox@@UAGJPAPAG@Z)
e:\VS70\vsbuilt\debug\bin\i386\VC7\VCPackages\VCProjectEngine.dll : fatal error LNK1120: 5 unresolved externals
	copy /y AssemblyAttributes.vb objd\i386\AssemblyAttributes.vb
The system cannot find the file specified.
	cscript //nologo e:\VS70\VS\public\tools\vbverinfo.js e:\VS70\VS\src\common\inc\version.h  >>objd\i386\AssemblyAttributes.vb
	echo ***  Pass 2 complete. ***
*** Pass 2 complete. ***

Stop.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\wizards\xboxwiz\templates\1033\readme.txt ===
[!if LIB_APP]
========================================================================
    STATIC LIBRARY : [!output PROJECT_NAME] Project Overview
========================================================================

AppWizard has created this [!output PROJECT_NAME] library project for you. 
[!endif]
[!if XBOX_APP]
========================================================================
    Xbox APPLICATION : [!output PROJECT_NAME] Project Overview
========================================================================

AppWizard has created this [!output PROJECT_NAME] application for you.  
[!endif]

[!if !LIB_APP]
This file contains a summary of what you will find in each of the files that
make up your [!output PROJECT_NAME] application.
[!else]
[!if PRE_COMPILED_HEADER]
This file contains a summary of what you will find in each of the files that
make up your [!output PROJECT_NAME] application.
[!else]
No source files were created as part of your project.
[!endif]
[!endif]


[!output PROJECT_NAME].vcproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

[!if !EMPTY_PROJECT && !LIB_APP]
[!output PROJECT_NAME].cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named [!output PROJECT_NAME].pch and a precompiled types file named StdAfx.obj.

[!endif]
[!if LIB_APP]
[!if PRE_COMPILED_HEADER]

/////////////////////////////////////////////////////////////////////////////

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named [!output PROJECT_NAME].pch and a precompiled types file named StdAfx.obj.

[!endif]
[!endif]
/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\ReadMe.txt ===
This directory tree contains files that are copied
from a real Visual Stuidio 7 build tree, are checked
in to our build tree.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\win2000\drivers\sctrsz\readme.txt ===
Sector Size Converter:

This code builds with the Windows 2000 DDK.  It produces the driver Sctrsize.sys.  At this time there is no inf
file for this driver and had been tested by manually changed the registry.

The intent of this driver is to enable the use of mass storage devices with block sizes greater than 512 bytes by
converting the block size to 512 bytes.  The code is intended for fixed-media devices and may have difficulty
with removal media.  Particularly, if different configurations of removal media are allowed.

The driver should be installed as a lower-filter driver for disk.sys.  

For simplicity of development the driver is based off of the generic filter.sys sample in the Windows 2000 DDK.

The filter does all filtering in a worker thread which is created during IRP_MN_START_DEVICE. IRPs with SRB requests
SCSIOP_READ_CAPACITY, SCSIOP_READ,and SCSIOP_WRITE are queued to a single queue and pulled off in FIFO order
by the worker thread which handles IRPs synchronously.

The first time a SCSIOP_READ_CAPACITY is encountered it is forward down the stack.  On the way back up,
the driver records the block size of the device and allocates a buffer of the same size for use during
SCSIOP_READ and SCSIOP_WRITE.  The block size is changed to 512 bytes increasing the number of blocks
appriopriately before completing the IRP.  Subsequent SCSIOP_READ_CAPACITY IRPs are completed without forwarding
first.

SCSIOP_READ and SCSIOP_WRITE prior to the first SCSIOP_READ_CAPACITY are failed with a device not ready error.

All SCSIOP_READ and SCSIOP_WRITE requests are broken into three areaa:  An intial number of sectors that
do not begin on a block alignment, a contiguous middle number of sectors that begin and end on a block
alignment, and a final number of sectors that do not end on a block alignment.

For SCSIOP_READ the first group of sectors is read and the copied into the caller's buffer.  The middle
sectors are read straight into the caller's buffers, and the final group of sectors is read and copied
into the caller's buffer.

For SCSIOP_WRITE the first and last group of sectors must first read the whole block containing the target sectors.
Copy over the sectors to be modified and then write out the whole block.  The middle group of sectors is
written directly from the caller's buffer.

TESTING STATUS:

The driver was tested and works in transparent mode (i.e. where the block size is 512 bytes).
I did not have working hardware to test the filter with the intended 8k blocks.  I verified through CATC and
stepping through the code with a debugger that the remaining problems appear to have been with the firmware
I had.  It was not properly updating the sections of blocks beyond the first 512 bytes.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmscript\notes.txt ===
Consider
	Abandon using IActiveScriptParse in favor of IPersist* (doesn't appear to be an options for VBS).
	Do we really need protection from multithreaded access?  Am I doing it right?
	Am I defining/returning proper errors?  What about the facility of errors from WinError.h that I return?
	In IDirectMusicScript, etc. pass variants by ref (pointer) instead of value for efficiency?
	If a null performance or loader is passed to IDirectMusicScript::Init then just create and initialize one.
	Should scripts be able to do all the initialization things traditionally done to prepare for playing?
	How do we handle CloseDown?  Must be called by engine?
	Handle error hr's from calling DirectMusic objects better.  Objects set rich error info that we save in exception?
	Multiply times by somthing like 1000 due to lost capacity.  Similar to VB OM.
	Any way to turn off library functions such as Stop?
	Use properties.  "MasterVolume = 100" instead of "SetMasterVolume(100)".

Automation model
	We don't support type info.
	We don't support named parameters.
	We don't pass parameters by reference.

International
	We have no support for scripts with international character sets or locale-dependant programming languages.  In fact, we hard code English so that we assure consistent playback of scripts no matter whether they are running on English or on foreign-language OS's.
	The script source is read from disk with the ANSI code page.
	The script is interpreted/executed with respect to the US English locale.

Scripting Engines
	The scripting engine must support the IActiveScriptParse interface.
	The scripting engine must change to the Started state immediately -- it cannot return OLESCRIPT_S_PENDING from SetScriptState.

Restrictions for simplicity of script API / DirectMusicScript implementation
	Routines take no parameters and don't return values (use global variables instead)

VBS
	No constant for OLESCRIPT_S_PENDING.
	IActiveScript::Close docs inconsistent about return if already closed.

Script Event Track
	Mutes have no effect on whether script events fire.

Implementing new IDispatch object
	New aut*.h from autperformance.h
		Replace CAutDirectMusicPerformance with CAutDirectMusic*
		Replace BaseImpPerf with BaseImp*
		Replace IDirectMusicPerformance with IDirectMusic*
		Replace automation methods (Delete GetIDs/Invoke overrides, delete or replace helpers)
	New aut*.cpp from autperformance.cpp
		#include "autperformance.h" -> "aut*.h", remove unnecessary includes
		Replace BaseImpPerf with BaseImp*
		Replace CAutDirectMusicPerformance with CAutDirectMusic*
		Change ms_wszClassName to the name of your object instead of "Performance"
		Replace method info
		Replace P in DMPDISP_* IDs with your own letter or couple of letters (DMLDISP_* for loader)
		Delete from private functions section onward
		Implement automation methods
	COM hookup
		define new guid in dmscriptautguids.h
		dll.cpp: #include "aut*.h", define g_szDMScript*FriendlyName etc
		dll.cpp: DllGetClassObject, DLLUnregisterServer, DLLRegisterServer

Adding aggregated IDispatch to main objects
	place #include "dmscriptautguids.h" in initguid file and in object .cpp file
	Add IUnknown pointer for controlling unknown to object decl, init to NULL in constructor
	Add IID_IDispatch to query interface
		See an example such as performance.
		Be sure it returns NULL if it fails. (Change structure of if to clear *ppv at top and return E_NOTIMPL if still null instead of else.)
		Be sure to change performance type/GUID.
	Release on destruction, protect destruction with artificially increased ref count (read release and destruction code to make sure this works right with the object)
	Simple test
		Place breakpoint in a method and run into it
		Place breakpoint in real object's destructor and quit
		Step into release of Aut object to ensure it is destroyed as well

Making a new track
	Add new CLSID to dmusici.h
	Create header from track.h
		Replace CDirectMusicScriptTrack
		Change EventInfo to contain the appropriate stuff
	Create source from track.cpp
		Replace CDirectMusicScriptTrack
		Eliminate or modify begin a tool and posting back to self
			IDirectMusicTool interface
			DMUS_PMSG_ScriptTrack structure
		Load ...
			Make new error to replace DMUS_E_INVALID_SCRIPTTRACK.
		InitPlay ...
		EndPlay ...
		Clone
	COM goo (ugh!)
		Duplicate class factory in dmprfdll.cpp and dmprfdll.h.  Change new statement if necessary.
		#include track header in dmprfdll.cpp
		Add case to DllGetClassObject
		Add case to DllUnregisterServer and DllRegisterServer

Segment trigger track
	SetParam (such as GUID_Download) with index 0 won't work.  Only goes to band or trigger track
	but not both.  Must use DMUS_SEG_ALLTRACKS with trigger track.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\ddkreadme.txt ===
The ddksynth sample in the DDK is created from the live sources in dmsynth.
The sample is generated by removing text between the special BEGIN and END
@@DDKSPLIT tags (such as this paragraph).

This can get a bit cryptic when one line must be used in the real dmsynth code
and a different line must appear in the sample ddksynth code.  Example from umsynth.cpp:
    // @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
        pCaps->guidPort = CLSID_DirectMusicSynth;
    #if 0 // The following section will only take affect in the DDK sample.
    // @@END_DDKSPLIT
        pCaps->guidPort = CLSID_DDKSynth;
    // @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
    #endif
    // @@END_DDKSPLIT

In this example, just the line with CLSID_DDKSynth will appear in the ddksynth
sample.  In the real dmsynth code, CLSID_DDKSynth is surrounded by an #if 0 conditional so it
has no effect.  Thus only CLSID_DirectMusicSynth takes effect in the real code.

The point here is to ship real functioning code for a synthesizer in the DDK, but to replace
its name and CLSID and also to strip out any Microsoft proprietary or licensed technology.  For
example, we can't ship our reverb capability in the DDK since it is licensed from another company.

You can build the cab containing this sample by running "genddkcab dmusiccab.ini" from the
\nt\private\ddk\cabs directory.  See http://devkits/ddk for more information about the DDK.

There are two files that are used only for the DDK sample:
ddksynth.htm:  A descriptive overview that will appear in the DDK sample.
ddksources:    The sources file that will be used in the DDK sample.
               (It would have been too difficult to generate it from the dmsynth sources.inc file.
                Please keep these two files in sync.)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\readme.txt ===
I created this simple MFC application is to test my new MXF concept in user mode.  
The files and objects in the Kernel Code section will be moved to kernel mode when 
they are robust.

    -MartinP 5/5/98

========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : DMCoreTest
========================================================================


AppWizard has created this DMCoreTest application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your DMCoreTest application.

DMCoreTest.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CDMCoreTestApp application class.

DMCoreTest.cpp
    This is the main application source file that contains the application
    class CDMCoreTestApp.

DMCoreTest.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\DMCoreTest.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file DMCoreTest.rc.

res\DMCoreTest.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

DMCoreTest.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

DMCoreTestDlg.h, DMCoreTestDlg.cpp - the dialog
    These files contain your CDMCoreTestDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in DMCoreTest.rc, which can be edited in Microsoft
	Developer Studio.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named DMCoreTest.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04041115.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 46 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\search.out	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\bilink.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\common.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dndbg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dneterrors.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\fpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\guidutil.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\map.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\osind.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\packbuff.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\queue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\rcbuffer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\appdesc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\async.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\caps.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\client.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\common.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connection.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\disconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dnet.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\enum_sp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupcon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupmem.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\memoryfpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\message.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\migration.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\msghandler.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\nametable.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntentry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntoplist.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\paramval.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\peer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\protocol.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\request.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\server.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\servprov.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\spmessages.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\user.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\voice.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\worker.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addbase.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addcore.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addparse.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addtcp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dnadd.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dplegacy.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strcache.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvrq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpsvr8.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\proctbl.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplapp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplclient.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplcommon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplmsgq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplobby.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplproc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplreg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\backend.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\command.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\endpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\enum.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\initialize.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\lower_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\protocol.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\send.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\stub_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\timer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\cmddata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\debugutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dnwsock.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dwinsock.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\endpoint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\iodata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipendpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipui.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\jobqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\locals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\rsip.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\sendqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\socketport.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spdata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\threadpool.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\unk.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\utils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\wsocksp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 233 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
223a224,243
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38c38
< //#include "CReg.h"
---
> #include "CReg.h"
73,77d72
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
238d232
< */	return(E_FAIL);
252,256d245
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
405d393
< */	return(E_FAIL);
623d610
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpsvr8.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
300d299
<     DWORD dwProvider = 0;
342c341
<     for( dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
---
>     for( DWORD dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
76,77d75
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
111a110,112
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
244c245
<     DWORD   dwMaxDatagramLength;
---
>     DWORD	dwMaxDatagramLength;
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36c36
< //#include "CReg.h"
---
> #include "CReg.h"
92,97c92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
<     HRESULT			hResultCode;
---
> 	HRESULT			hResultCode;
381d375
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
567d555
< */	return(E_FAIL);
1303d1290
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
41a43
> #include	"IPXAddress.h"
76c78,79
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
94a98,99
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
110c115,117
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
176a184,189
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
197a211,217
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
200a221,266
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
223a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
242a311,312
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
269a340,345
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
387a464,470
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
390a474,518
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
422a551,552
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
442a573,574
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
115a116,118
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
145a149
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
146a151
> 
166a172,174
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1372a1374,1379
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1373a1381,1399
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1376a1403,1405
> 		case 2:
> 		default:
> 		{
1377a1407,1409
> 			break;
> 		}
> 	}
1451a1484,1489
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1491,1509
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1455a1513,1515
> 		case 2:
> 		default:
> 		{
1456a1517,1519
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
59a61
> #include	"IPXAddress.h"
63a66
> #include	"IPXEndpt.h"
93a97
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
94a99
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
185a191,197
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
195a208,214
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
314a334,339
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
323a349,354
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
431a463,476
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
432a478
> 
434a481,497
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
464a528,559
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
248a250,251
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
249a253,270
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
251a273,275
> 		case 2:
> 		default:
> 		{
252a277,279
> 			break;
> 		}
> 	}
382a410,432
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
739a790,802
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
741a805,911
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
742a913,915
> 
> 
> //**********************************************************************
743a917,1065
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
771,772c1093,1094
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
783a1106,1108
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
836a1162,1164
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
914c1242,1243
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
928a1258,1260
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
993a1326,1327
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1041a1376,1377
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1297a1634,1640
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1331a1675,1676
> 			break;
> 		}
1332a1678,1757
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
1829a2255,2266
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
1830a2268,2271
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
1831a2273,2417
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			DEBUG_ONLY( pReadData->m_pReceiveBuffer = NULL );
> 
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// One of our previous sends blew chunks for some unknown reason,
> 				// and Winsock is being a pain and telling us on our completely
> 				// unreleated receive thread.  Ignore this and continue  because
> 				// another read was submitted.
> 				//
> 				case WSAECONNRESET:
> 				{
> 					DPF( 8, "Winsock indicated an earlier send failed....." );
> 					break;
> 				}
> 
> 				//
> 				// other error, report it (we've already submitted another read)
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock2 Win9x read: " );
> 					DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
1832a2419,2421
> 
> 
> //**********************************************************************
2098a2688,2746
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
225a226
> 
270a272,273
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
274a278,280
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
308a315
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
313a321,322
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,94
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100c100
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
118c118,119
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
153c154,155
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
238a241
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
239a243
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
242c246
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
249c253
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
268a273
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
285d353
< 
488a557,562
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
541a616,621
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
678a759,764
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
711a798,803
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
89c91
< 		void		SetThreadPool( CThreadPool *const pThreadPool )
---
> 		void	SetThreadPool( CThreadPool *const pThreadPool )
93a96
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
132a134,157
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
169a195
> 		m_iWinsockVersion( 0 ),
198a225
> 	DNASSERT( m_iWinsockVersion == 0 );
223c250
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
235a263
> 	m_iWinsockVersion = iWinsockVersion;
254c282,292
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
255a294,301
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
262c308,318
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
263a320,325
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
264a327
> 
362a426,432
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
368a439,465
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
464a562,721
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
563a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
584a844
> 	}
662a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
678a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
839a1108,1109
> 
> 	m_iWinsockVersion = 0;
1272a1543,1549
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, submit new I/O completion item
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1289a1567,1600
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1385a1697,1698
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1392a1706
> 	}
1645a1960,1976
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
> 		// WinNT has many potential threads
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1647a1979,1980
> 			break;
> 		}
1648a1982,1991
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1677a2021,2022
> 	switch ( DNGetOSType() )
> 	{
1678a2024,2031
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1681a2035,2036
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1691a2047,2059
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2132a2501,2513
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
2134a2516,2517
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
2135a2519,2528
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
2137a2531,2535
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
2138a2537,2614
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
2139a2616,2618
> 
> 
> //**********************************************************************
2140a2620,3298
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process enums on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an enum submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the enum time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2491a3650,3660
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
2492a3662,3788
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> }
2493a3790,3792
> 
> 
> //**********************************************************************
2738a4038,4039
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
101c102
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
106c107,108
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
152a155
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
157a161
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
189a194
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
229,231c234,236
< 		UINT_PTR	m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
< 		FD_SET		m_SocketSet;					// set of all sockets in use
< 		CSocketPort	*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
---
> 		UINT_PTR			m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
> 		FD_SET				m_SocketSet;					// set of all sockets in use
> 		CSocketPort 		*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
273a279
> 		HRESULT	Win9xInit( void );
290a297,298
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
291a300
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
298a308
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
69a71
> 
71a74
> 
73c76
< static	CRsip		*g_pRsipObject = NULL;
---
> static	CRsip			*g_pRsipObject = NULL;
74a78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
76,77d79
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
< 
102a105
> 	INT		iVersion;
130c133,134
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a142,143
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c156
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
192,193c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
204a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
205a223
> 
303a322
> 	INT_PTR iWinsockVersion;
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
245a247
> 		case TYPE_IPX:
479,480c481,483
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2660a2664,2675
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2873a2889,2900
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
3036d3062
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04061145.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 46 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\search.out	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\bilink.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\common.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dndbg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dneterrors.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\fpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\guidutil.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\map.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\osind.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\packbuff.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\queue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\rcbuffer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\appdesc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\async.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\caps.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\client.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\common.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connection.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\disconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dnet.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\enum_sp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupcon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupmem.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\memoryfpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\message.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\migration.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\msghandler.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\nametable.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntentry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntoplist.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\paramval.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\peer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\protocol.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\request.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\server.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\servprov.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\spmessages.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\user.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\voice.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\worker.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addbase.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addcore.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addparse.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addtcp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dnadd.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dplegacy.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strcache.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvrq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpsvr8.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\proctbl.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplapp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplclient.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplcommon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplmsgq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplobby.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplproc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplreg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\backend.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\command.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\endpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\enum.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\initialize.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\lower_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\protocol.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\send.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\stub_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\timer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\cmddata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\debugutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dnwsock.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dwinsock.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\endpoint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\iodata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipendpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipui.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\jobqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\locals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\rsip.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\sendqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\socketport.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spdata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\threadpool.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\unk.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\utils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\wsocksp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 236 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
223a224,244
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38c38
< //#include "CReg.h"
---
> #include "CReg.h"
73,77d72
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
236d230
< */	return(E_FAIL);
250,254d243
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
403d391
< */	return(E_FAIL);
621d608
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpsvr8.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
300d299
<     DWORD dwProvider = 0;
342c341
<     for( dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
---
>     for( DWORD dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
82,83d81
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
116a115,117
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37c37
< //#include "CReg.h"
---
> #include "CReg.h"
93,97d92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
389d383
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
41a43
> #include	"IPXAddress.h"
76c78,79
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
94a98,99
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
110c115,117
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
176a184,189
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
197a211,217
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
200a221,266
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
223a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
242a311,312
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
269a340,345
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
387a464,470
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
390a474,518
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
422a551,552
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
442a573,574
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
115a116,118
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
145a149
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
146a151
> 
166a172,174
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1446a1448,1453
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1447a1455,1473
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1450a1477,1479
> 		case 2:
> 		default:
> 		{
1451a1481,1483
> 			break;
> 		}
> 	}
1525a1558,1563
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1526a1565,1583
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1529a1587,1589
> 		case 2:
> 		default:
> 		{
1530a1591,1593
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
59a61
> #include	"IPXAddress.h"
63a66
> #include	"IPXEndpt.h"
93a97
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
94a99
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
185a191,197
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
195a208,214
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
314a334,339
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
323a349,354
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
431a463,476
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
432a478
> 
434a481,497
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
464a528,559
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
768a819,831
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
770a834,940
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
771a942,944
> 
> 
> //**********************************************************************
772a946,1094
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
800,801c1122,1123
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
812a1135,1137
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
865a1191,1193
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
943c1271,1272
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
957a1287,1289
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1022a1355,1356
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1070a1405,1406
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1425a1762,1768
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1459a1803,1804
> 			break;
> 		}
1460a1806,1885
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2042a2468,2479
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2043a2481,2484
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2044a2486,2630
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			DEBUG_ONLY( pReadData->m_pReceiveBuffer = NULL );
> 
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// One of our previous sends blew chunks for some unknown reason,
> 				// and Winsock is being a pain and telling us on our completely
> 				// unreleated receive thread.  Ignore this and continue  because
> 				// another read was submitted.
> 				//
> 				case WSAECONNRESET:
> 				{
> 					DPF( 8, "Winsock indicated an earlier send failed....." );
> 					break;
> 				}
> 
> 				//
> 				// other error, report it (we've already submitted another read)
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock2 Win9x read: " );
> 					DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2045a2632,2634
> 
> 
> //**********************************************************************
2311a2901,2959
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
273a274
> 
283a285,286
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
287a291,293
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
326a333
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
331a339,340
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,94
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100c100
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
118c118,119
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
153c154,155
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
238a241
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
239a243
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
242c246
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
249c253
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
268a273
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
490a560,565
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
543a619,624
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
680a762,767
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
713a801,806
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
132a134,157
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
169a195
> 		m_iWinsockVersion( 0 ),
198a225
> 	DNASSERT( m_iWinsockVersion == 0 );
223c250
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
235a263
> 	m_iWinsockVersion = iWinsockVersion;
254c282,292
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
255a294,301
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
262c308,318
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
263a320,325
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
264a327
> 
362a426,432
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
368a439,465
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
464a562,721
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
563a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
584a844
> 	}
662a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
678a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
839a1108,1109
> 
> 	m_iWinsockVersion = 0;
1272a1543,1549
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, submit new I/O completion item
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1289a1567,1600
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1385a1697,1698
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1392a1706
> 	}
1645a1960,1976
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
> 		// WinNT has many potential threads
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1647a1979,1980
> 			break;
> 		}
1648a1982,1991
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1677a2021,2022
> 	switch ( DNGetOSType() )
> 	{
1678a2024,2031
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1681a2035,2036
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1691a2047,2059
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2132a2501,2513
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
2134a2516,2517
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
2135a2519,2528
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
2137a2531,2535
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
2138a2537,2614
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
2139a2616,2618
> 
> 
> //**********************************************************************
2140a2620,3298
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process enums on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an enum submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the enum time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2491a3650,3660
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
2492a3662,3788
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> }
2493a3790,3792
> 
> 
> //**********************************************************************
2738a4038,4039
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
101c102
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
106c107,108
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
152a155
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
157a161
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
189a194
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
229,231c234,236
< 		UINT_PTR	m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
< 		FD_SET		m_SocketSet;					// set of all sockets in use
< 		CSocketPort	*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
---
> 		UINT_PTR			m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
> 		FD_SET				m_SocketSet;					// set of all sockets in use
> 		CSocketPort 		*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
273a279
> 		HRESULT	Win9xInit( void );
290a297,298
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
291a300
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
298a308
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
69a71
> 
71a74
> 
73c76
< static	CRsip		*g_pRsipObject = NULL;
---
> static	CRsip			*g_pRsipObject = NULL;
74a78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
76,77d79
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
< 
102a105
> 	INT		iVersion;
130c133,134
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a142,143
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c156
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
192,193c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
204a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
205a223
> 
303a322
> 	INT_PTR iWinsockVersion;
313a333
> 	iWinsockVersion = GetWinsockVersion();
329c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
245a247
> 		case TYPE_IPX:
479,480c481,483
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2661a2665,2676
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2873a2889,2900
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04181430.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 52 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\search.out	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.bsc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.ilk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.sbr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\vc60.idb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\vc60.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.map	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.sym	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.bsc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.ilk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.sbr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\vc60.idb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\vc60.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 135 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
59a60
> #include "DVoice.h"
90a92
> #include "Voice.h"
95d96
< #include <mmsystem.h>
547a549,568
> 				case DN_MSG_INTERNAL_VOICE_SEND:
> 					{
> 						DPF(9,"DN_MSG_INTERNAL_VOICE_SEND");
> 
> 						PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 						if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 						{
>     						DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     						dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 							dvSendComplete.hrSendResult = pdnAsyncOp->hResultCode;
> 
>     						Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 						}
> 
> 						break;
> 					}
> 
2116a2138,2146
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
> 
> 				break;
> 			}
> 
2546a2577,2599
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF( 5, "DN_MSG_INTERNAL_VOICE_SEND" );
> 
> 				if( !(pdnAsyncOp->dwFlags & DN_ASYNC_OP_FLAG_MULTI_OP) )
> 				{
> 					PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 					if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 					{
>     					DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     					dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 						dvSendComplete.hrSendResult = hr;
> 
>     					Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 					}
> 				}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include "DVoice.h"
65a67,68
> #include "dvoice.h"
> #include "voice.h"
113a117
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
565a601,603
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
796a835,839
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
79a80
> #include "DVoice.h"
112a114
> #include "Voice.h"
1352a1355,1359
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
> //#include "dvoice.h"
143a145
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x20 | DN_MSG_INTERNAL)
166a169
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
213a217,222
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
285a295,299
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23
> #include "DVoice.h"
45a47
> #include "voice.h"
48a51,52
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2141a2146
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
109a110
>          voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
35a36
> #include "DVoice.h"
45a47
> #include "voice.h"
161a164,165
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
195a200,201
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
227a234,235
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
262a271,272
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
296a307,308
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
332a345,346
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
600a615,616
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89,90d88
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
123a122,124
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37c37
< //#include "CReg.h"
---
> #include "CReg.h"
93,97d92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
389d383
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1433a1435,1440
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1434a1442,1460
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1437a1464,1466
> 		case 2:
> 		default:
> 		{
1438a1468,1470
> 			break;
> 		}
> 	}
1512a1545,1550
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1513a1552,1570
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1516a1574,1576
> 		case 2:
> 		default:
> 		{
1517a1578,1580
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
80a84
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
81a86
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
172a178,184
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
182a195,201
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
307a327,332
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
316a342,347
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
424a456,469
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
425a471
> 
427a474,490
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
457a521,552
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX endpoint
> //
> // Entry:		Pointer to IPX endpoint
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
262a264,265
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
263a267,284
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
265a287,289
> 		case 2:
> 		default:
> 		{
266a291,293
> 			break;
> 		}
> 	}
410a438,460
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
838a889,901
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
840a904,1010
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
841a1012,1014
> 
> 
> //**********************************************************************
842a1016,1164
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
870,871c1192,1193
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
882a1205,1207
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
935a1261,1263
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1013c1341,1342
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1027a1357,1359
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1092a1425,1426
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1140a1475,1476
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1708a2045,2051
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1742a2086,2087
> 			break;
> 		}
1743a2089,2168
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2316a2742,2753
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2317a2755,2758
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2318a2760,2912
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2319a2914,2916
> 
> 
> //**********************************************************************
2592a3190,3250
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
237a238,239
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
241a244,246
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
285a291
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
290a297,298
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61,72
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
> 
> #
85a98,99
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
105,106d118
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103c103
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
121c121,122
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
156c157,158
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
277a282
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
490a560,565
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
543a619,624
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
680a762,767
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
713a801,806
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
113a115,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
150a176
> 		m_iWinsockVersion( 0 ),
178a205
> 	DNASSERT( m_iWinsockVersion == 0 );
201c228
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
209a237
> 	m_iWinsockVersion = iWinsockVersion;
228c256,266
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
229a268,275
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
236c282,292
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
237a294,301
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
271a336,342
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
325a397,401
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
328a405,406
> 		case VER_PLATFORM_WIN32_NT:
> 		{
334a413,439
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
430a536,695
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
528a794,795
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
549a817
> 	}
627a896,901
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
643a918,919
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
792a1069
> 	m_IPXReadIODataPool.Deinitialize();
803a1081,1082
> 
> 	m_iWinsockVersion = 0;
851a1131,1145
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
946a1241,1249
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1201a1505,1506
> 	switch ( DNGetOSType() )
> 	{
1204a1510,1511
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1221a1529,1562
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1332a1674,1675
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1339a1683
> 	}
1538a1883,1884
> 	switch ( DNGetOSType() )
> 	{
1539a1886,1895
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1541a1898,1899
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1543a1902,1903
> 			break;
> 		}
1544a1905,1914
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1573a1944,1945
> 	switch ( DNGetOSType() )
> 	{
1574a1947,1954
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1577a1958,1959
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1587a1970,1982
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1980a2376,3171
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2325a3517,3658
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
92c93
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
97c98,99
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
143a146
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
148a152
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
188a193
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
200a206
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
265a272
> 		HRESULT	Win9xInit( void );
275a283,284
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
276a286
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
283a294
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
76c77
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
102a104
> 	INT		iVersion;
130c132,133
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c155
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
244a246
> 		case TYPE_IPX:
478,479c480,482
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2664a2668,2679
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2876a2892,2903
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04101330.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 45 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\search.out	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\bilink.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\common.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dndbg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dneterrors.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\fpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\guidutil.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\map.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\osind.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\packbuff.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\queue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\rcbuffer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\appdesc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\async.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\caps.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\client.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\common.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connection.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\disconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dnet.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dpnet.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\enum_sp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupcon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupmem.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\memoryfpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\message.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\migration.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\msghandler.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\nametable.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntentry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntoplist.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\paramval.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\peer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\protocol.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\request.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\server.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\servprov.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\spmessages.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\user.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\voice.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\worker.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addbase.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addcore.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addparse.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addtcp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dnadd.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dplegacy.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strcache.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvrq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpsvr8.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\proctbl.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplapp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplclient.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplcommon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplmsgq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplobby.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplproc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplreg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\backend.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\command.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\endpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\enum.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\initialize.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\lower_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\protocol.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\send.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\stub_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\timer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\bchecker\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\cmddata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\debugutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dnwsock.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dwinsock.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\endpoint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\iodata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipendpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipui.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\jobqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\locals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\rsip.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\sendqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\socketport.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spdata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\threadpool.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\unk.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\utils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\wsocksp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\directx.ico	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\resource.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.rc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 253 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
223a224,244
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39c39
< //#include "CReg.h"
---
> #include "CReg.h"
74,78d73
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
265d259
< */	return(E_FAIL);
279,283d272
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
432d420
< */	return(E_FAIL);
650d637
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
85,86d84
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
119a118,120
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37c37
< //#include "CReg.h"
---
> #include "CReg.h"
93,97d92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
389d383
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
41a43
> #include	"IPXAddress.h"
76c78,79
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
94a98,99
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
110c115,117
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
176a184,189
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
197a211,217
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
200a221,266
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
223a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
242a311,312
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
269a340,345
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
387a464,470
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
390a474,518
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
422a551,552
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
442a573,574
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
115a116,118
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
145a149
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
146a151
> 
166a172,174
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1438a1440,1445
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1439a1447,1465
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1442a1469,1471
> 		case 2:
> 		default:
> 		{
1443a1473,1475
> 			break;
> 		}
> 	}
1517a1550,1555
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1518a1557,1575
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1521a1579,1581
> 		case 2:
> 		default:
> 		{
1522a1583,1585
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
59a61
> #include	"IPXAddress.h"
63a66
> #include	"IPXEndpt.h"
93a97
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
94a99
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
185a191,197
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
195a208,214
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
314a334,339
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
323a349,354
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
431a463,476
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
432a478
> 
434a481,497
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
464a528,559
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
256a258,259
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
257a261,278
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
259a281,283
> 		case 2:
> 		default:
> 		{
260a285,287
> 			break;
> 		}
> 	}
404a432,454
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
761a812,824
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
763a827,933
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
764a935,937
> 
> 
> //**********************************************************************
765a939,1087
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
793,794c1115,1116
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
805a1128,1130
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
858a1184,1186
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
936c1264,1265
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
950a1280,1282
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1015a1348,1349
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1063a1398,1399
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1428a1765,1771
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1462a1806,1807
> 			break;
> 		}
1463a1809,1888
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2045a2471,2482
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2046a2484,2487
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2047a2489,2633
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			DEBUG_ONLY( pReadData->m_pReceiveBuffer = NULL );
> 
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// One of our previous sends blew chunks for some unknown reason,
> 				// and Winsock is being a pain and telling us on our completely
> 				// unreleated receive thread.  Ignore this and continue  because
> 				// another read was submitted.
> 				//
> 				case WSAECONNRESET:
> 				{
> 					DPF( 8, "Winsock indicated an earlier send failed....." );
> 					break;
> 				}
> 
> 				//
> 				// other error, report it (we've already submitted another read)
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock2 Win9x read: " );
> 					DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			ReturnReceiveBuffer( pReadData->m_pReceiveBuffer );
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2048a2635,2637
> 
> 
> //**********************************************************************
2314a2904,2962
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
273a274
> 
283a285,286
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
287a291,293
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
326a333
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
331a339,340
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,94
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
99c99
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
117c117,118
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
152c153,154
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
237a240
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
238a242
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
241c245
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
248c252
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
267a272
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
490a560,565
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
543a619,624
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
680a762,767
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
713a801,806
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
132a134,157
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
169a195
> 		m_iWinsockVersion( 0 ),
198a225
> 	DNASSERT( m_iWinsockVersion == 0 );
223c250
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
235a263
> 	m_iWinsockVersion = iWinsockVersion;
254c282,292
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
255a294,301
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
262c308,318
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
263a320,325
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
264a327
> 
362a426,432
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
368a439,465
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
464a562,721
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
563a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
584a844
> 	}
662a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
678a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
839a1108,1109
> 
> 	m_iWinsockVersion = 0;
1272a1543,1549
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, submit new I/O completion item
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1289a1567,1600
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1385a1697,1698
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1392a1706
> 	}
1645a1960,1976
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
> 		// WinNT has many potential threads
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1647a1979,1980
> 			break;
> 		}
1648a1982,1991
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1677a2021,2022
> 	switch ( DNGetOSType() )
> 	{
1678a2024,2031
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1681a2035,2036
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1691a2047,2059
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2132a2501,2513
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
2134a2516,2517
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
2135a2519,2528
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
2137a2531,2535
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
2138a2537,2614
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
2139a2616,2618
> 
> 
> //**********************************************************************
2140a2620,3298
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process enums on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an enum submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the enum time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2491a3650,3660
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
2492a3662,3788
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> }
2493a3790,3792
> 
> 
> //**********************************************************************
2738a4038,4039
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
101c102
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
106c107,108
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
152a155
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
157a161
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
189a194
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
229,231c234,236
< 		UINT_PTR	m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
< 		FD_SET		m_SocketSet;					// set of all sockets in use
< 		CSocketPort	*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
---
> 		UINT_PTR			m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
> 		FD_SET				m_SocketSet;					// set of all sockets in use
> 		CSocketPort 		*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports
273a279
> 		HRESULT	Win9xInit( void );
290a297,298
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
291a300
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
298a308
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
77c78
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
103a105
> 	INT		iVersion;
131c133,134
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
138a142,143
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
151,152c156
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
245a247
> 		case TYPE_IPX:
479,480c481,483
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2661a2665,2676
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2873a2889,2900
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04121430.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\search.out	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 46 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dplay.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dplay.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\bilink.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\common.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dndbg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\dneterrors.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\fpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\guidutil.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\map.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\osind.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\packbuff.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\queue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\obj\i386\rcbuffer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\appdesc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\cancel.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\caps.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\client.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\connection.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\disconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\dnet.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\enum_sp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupcon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\groupmem.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\memoryfpm.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\message.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\migration.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\msghandler.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\nametable.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntentry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\ntoplist.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\peer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\protocol.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\request.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\server.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\servprov.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\spmessages.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\obj\i386\worker.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addbase.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addcore.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addparse.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\addtcp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dnadd.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dplegacy.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\dpnaddr.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strcache.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\obj\i386\strutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvlib.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\obj\i386\dpnsvrq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpnsvr.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\dpsvr8.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\obj\i386\proctbl.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dllmain.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplapp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplclient.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplcommon.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplconnect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplmsgq.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplobby.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplproc.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dplreg.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\dpnlobby.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\globals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\obj\i386\handles.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\backend.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\command.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\connect.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\endpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\enum.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\initialize.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\lower_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\protocol.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\receive.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\send.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\stub_mn.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\obj\i386\timer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\directx.ico	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\dxutil.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\dxutil.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\resource.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\simplepeer.rc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\vc50.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\classfac.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\cmddata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\debugutils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dnwsock.res	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.dll	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.exp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dpnwsock.lib	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\dwinsock.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\endpoint.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\iodata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipendpt.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\ipui.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\jobqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\locals.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\pools.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\registry.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\rsip.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\sendqueue.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\socketport.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spaddress.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\spdata.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\threadpool.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\unk.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\utils.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\obj\i386\wsocksp.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\search.out	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\back\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.bsc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.ilk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\simplepeer.sbr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\vc60.idb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\debug\vc60.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.map	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\i386\simplepeer.sym	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.bsc	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.exe	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.ilk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.obj	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.pch	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\simplepeer.sbr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\vc60.idb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer___win32_debug\vc60.pdb	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 277 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\search.out)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,151c1,16
< ---- Registry Matches (150) ----
< Dneterrors.cpp (common):		case ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND:
< Dneterrors.cpp (common):			pString = "ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND";
< Dneterrors.cpp (common):		case ERROR_INTERNET_BAD_REGISTRY_PARAMETER:
< Dneterrors.cpp (common):			pString = "ERROR_INTERNET_BAD_REGISTRY_PARAMETER";
< Dneterrors.cpp (common):		// The permanent card identifier specified in dwCard could not be found in any entry in the [Cards] section in the registry.
< Dneterrors.cpp (common):		// The permanent location identifier specified in dwLocation could not be found in any entry in the [Locations] section in the registry.
< Dneterrors.cpp (common):		// A telephony service provider which does not support multiple instances is listed more than once in the [Providers] section in the registry. The application should advise the user to use the Telephony Control Panel to remove the duplicated driver.
< Dneterrors.cpp (common):			// 1009 The configuration registry database is corrupt.  ERROR_BADDB
< Dneterrors.cpp (common):			// 1010 The configuration registry key is invalid.  ERROR_BADKEY
< Dneterrors.cpp (common):			// 1011 The configuration registry key could not be opened.  ERROR_CANTOPEN
< Dneterrors.cpp (common):			// 1012 The configuration registry key could not be read.  ERROR_CANTREAD
< Dneterrors.cpp (common):			// 1013 The configuration registry key could not be written.  ERROR_CANTWRITE
< Dneterrors.cpp (common):		case ERROR_REGISTRY_RECOVERED:
< Dneterrors.cpp (common):			// 1014 One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.  ERROR_REGISTRY_RECOVERED
< Dneterrors.cpp (common):			pString = "ERROR_REGISTRY_RECOVERED";
< Dneterrors.cpp (common):		case ERROR_REGISTRY_CORRUPT:
< Dneterrors.cpp (common):			// 1015 The registry is corrupted. The structure of one of the files that contains registry data is corrupted, or the system's image of the file in memory is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.  ERROR_REGISTRY_CORRUPT
< Dneterrors.cpp (common):			pString = "ERROR_REGISTRY_CORRUPT";
< Dneterrors.cpp (common):		case ERROR_REGISTRY_IO_FAILED:
< Dneterrors.cpp (common):			// 1016 An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.  ERROR_REGISTRY_IO_FAILED
< Dneterrors.cpp (common):			pString = "ERROR_REGISTRY_IO_FAILED";
< Dneterrors.cpp (common):		case ERROR_NOT_REGISTRY_FILE:
< Dneterrors.cpp (common):			// 1017 The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.  ERROR_NOT_REGISTRY_FILE
< Dneterrors.cpp (common):			pString = "ERROR_NOT_REGISTRY_FILE";
< Dneterrors.cpp (common):			// 1018 Illegal operation attempted on a registry key that has been marked for deletion.  ERROR_KEY_DELETED
< Dneterrors.cpp (common):			// 1019 System could not allocate the required space in a registry log.  ERROR_NO_LOG_SPACE
< Dneterrors.cpp (common):			// 1020 Cannot create a symbolic link in a registry key that already has subkeys or values.  ERROR_KEY_HAS_CHILDREN
< Dneterrors.cpp (common):			// 1369 The transaction state of a registry subtree is incompatible with the requested operation.  ERROR_RXACT_INVALID_STATE
< Dplapp.cpp (lobby)://		Register program creates and fills in a registry entry for the program
< Dplapp.cpp (lobby)://		described in lpProgramDesc.  If the registry key already exists, it updates the
< Dplapp.cpp (lobby)://		TODO - maybe this should be kept as Unicode (binary in registry) ?
< Dplclient.cpp (lobby):// MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< Dplclient.cpp (lobby)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Dplclient.cpp (lobby):	CRegistry		RegistryEntry;
< Dplclient.cpp (lobby):	CRegistry		SubEntry;
< Dplclient.cpp (lobby):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPL_REG_LOCAL_APPL_SUBKEY,FALSE))
< Dplclient.cpp (lobby):		DPFERR("RegistryEntry.Open() failed");
< Dplclient.cpp (lobby):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Dplclient.cpp (lobby):		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
< Dplclient.cpp (lobby):	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
< Dplclient.cpp (lobby):		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
< Dplclient.cpp (lobby):				RegistryEntry.Close();
< Dplclient.cpp (lobby):				// grow buffer (noting that all strings from the registry are WCHAR) and try again
< Dplclient.cpp (lobby):					RegistryEntry.Close();
< Dplclient.cpp (lobby):					RegistryEntry.Close();
< Dplclient.cpp (lobby):				RegistryEntry.Close();
< Dplclient.cpp (lobby):	RegistryEntry.Close();
< Dplclient.cpp (lobby)://		DPNERR_DOESNOTEXIST		If there was a problem opening reading a registry key
< Dplclient.cpp (lobby)://		WinNT registry is kept in Unicode, whereas Win9x is in ANSI.  Application root key
< Dplclient.cpp (lobby):	//	Get program description from registry
< Dplreg.cpp (lobby): *  Content:    DirectPlay Lobby Registry Functions
< Dplreg.cpp (lobby):// MGERE:  Removed this whole function.  It uses registry to write app description
< Dplreg.cpp (lobby)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Dplreg.cpp (lobby):	CRegistry	RegistryEntry;
< Dplreg.cpp (lobby):	CRegistry	SubEntry;
< Dplreg.cpp (lobby):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPL_REG_LOCAL_APPL_SUBKEY,FALSE))
< Dplreg.cpp (lobby):		DPFERR("RegistryEntry.Open() failed");
< Dplreg.cpp (lobby):	if (!SubEntry.Open(RegistryEntry,pdplProgramDesc->pwszApplicationName,TRUE))
< Dplreg.cpp (lobby):		DPFERR("Could not create new registry entry");
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):		RegistryEntry.Close();
< Dplreg.cpp (lobby):	RegistryEntry.Close();
< Dplreg.cpp (lobby):// MGERE:  Removed this whole function.  It uses registry to read app description
< Dplreg.cpp (lobby)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Dplreg.cpp (lobby):	CRegistry		RegistryEntry;
< Dplreg.cpp (lobby):	CRegistry		SubEntry;
< Dplreg.cpp (lobby):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPL_REG_LOCAL_APPL_SUBKEY,FALSE))
< Dplreg.cpp (lobby):		DPFERR("RegistryEntry.Open() failed");
< Dplreg.cpp (lobby):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Dplreg.cpp (lobby):		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
< Dplreg.cpp (lobby):	while (!bFound && RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
< Dplreg.cpp (lobby):		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
< Dplreg.cpp (lobby):	RegistryEntry.Close();
< Dplreg.cpp (lobby)://		registry tree staring from the open key, hBase, creating keys as required.
< Dplreg.cpp (lobby)://		This function reads the program description entry from the registry at hKey into the
< Dplreg.cpp (lobby)://		This function deletes a GUID specified application registry entry.
< Dplreg.cpp (lobby)://		function will search for the program description entry in the registry, and the
< Dplreg.h (lobby): *  Content:    DirectPlay Lobby Registry Header File
< Enum_sp.cpp (core): *	01/18/00	mjn		Converted EnumAdapters registry interface to use CRegistry
< Enum_sp.cpp (core): *	01/24/00	mjn		Converted EnumSP registry interface to use CRegistry
< Enum_sp.cpp (core)://	Examine the "All Applications" value of the SP's registry key.  Only if this value exists and is 'N'
< Enum_sp.cpp (core)://		hSPKey				- handle to SP's registry key
< Enum_sp.cpp (core):// MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< Enum_sp.cpp (core)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Enum_sp.cpp (core):	CRegistry	RegistryEntry;
< Enum_sp.cpp (core):	CRegistry	SubEntry;
< Enum_sp.cpp (core):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
< Enum_sp.cpp (core):		DPFERR("RegistryEntry.Open() failed");
< Enum_sp.cpp (core):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Enum_sp.cpp (core):		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
< Enum_sp.cpp (core):	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
< Enum_sp.cpp (core):		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
< Enum_sp.cpp (core):			// grow buffer (noting that the registry functions always return WCHAR) and try again
< Enum_sp.cpp (core):	RegistryEntry.Close();
< Enum_sp.cpp (core):	if (RegistryEntry.IsOpen())
< Enum_sp.cpp (core):		RegistryEntry.Close();
< Enum_sp.cpp (core):// MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< Enum_sp.cpp (core)://         and XBox doesn't have a registry.  Need to figure out some other way to
< Enum_sp.cpp (core):	CRegistry	RegistryEntry;
< Enum_sp.cpp (core):	CRegistry	SubEntry;
< Enum_sp.cpp (core):	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
< Enum_sp.cpp (core):	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
< Enum_sp.cpp (core):	while (RegistryEntry.EnumKeys(lpwszKeyName,&dwKeyLen,dwEnumIndex))
< Enum_sp.cpp (core):		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,FALSE))
< Registry.cpp (sp\wsock): *  File:       Registry.cpp
< Registry.cpp (sp\wsock):#define	DPF_MODNAME	"Registry"
< Registry.cpp (sp\wsock):#include	"Registry.h"
< Registry.cpp (sp\wsock):static const DWORD	g_dwRegistryNameLength = 512;
< Registry.cpp (sp\wsock):// registry key strings
< Registry.cpp (sp\wsock):BOOL FindSPInRegistry( const GUID *const lpguid, char *const lpszSPName, const DWORD dwNameSize, HKEY *const lphkey )
< Registry.cpp (sp\wsock):	DPF(7, "Entering FindSPInRegistry");
< Registry.cpp (sp\wsock):		DPF( 0, "Unable to open DPlay service provider registry key!" );
< Registry.cpp (sp\wsock):	// Walk the list of sps in the registry, looking for
< Registry.cpp (sp\wsock):} // FindSPInRegistry
< Registry.cpp (sp\wsock):HRESULT GetFlagsFromRegistry( const GUID *const lpguidSP, DWORD *const lpdwFlags )
< Registry.cpp (sp\wsock):	DPF(7, "Entering GetFlagsFromRegistry");
< Registry.cpp (sp\wsock):	lpszSPName = static_cast<char*>( DNMalloc( g_dwRegistryNameLength ) );
< Registry.cpp (sp\wsock):	// Open the registry key for the App
< Registry.cpp (sp\wsock):	if(!FindSPInRegistry(lpguidSP, lpszSPName, g_dwRegistryNameLength, &hkeySP))
< Registry.cpp (sp\wsock):		DPF(0,"Unable to find sp in registry!");
< Registry.cpp (sp\wsock):		DPF(0,"Unable to get flags value from registry!");
< Registry.cpp (sp\wsock):} // GetFlagsFromRegistry
< Registry.cpp (sp\wsock):HRESULT GetGatewayFromRegistry( BYTE *const lpszGateway, const DWORD cbszGateway )
< Registry.cpp (sp\wsock):	DPF(7, "Entering GetGatewayFromRegistry");
< Registry.cpp (sp\wsock):	lpszSPName = static_cast<char*>( DNMalloc( g_dwRegistryNameLength ) );
< Registry.cpp (sp\wsock):	// Open the registry key for the SP
< Registry.cpp (sp\wsock):	if(!FindSPInRegistry( &OldDPlayTCPGuid, lpszSPName, g_dwRegistryNameLength, &hkeySP ) )
< Registry.cpp (sp\wsock):		DPF(0,"Unable to find sp in registry!");
< Registry.cpp (sp\wsock):		DPF(0,"Unable to get flags value from registry, using default ICS gateway!");
< Registry.cpp (sp\wsock):} // GetGatewayFromRegistry
< Registry.h (sp\wsock): *  File:       Registry.h
< Registry.h (sp\wsock):#ifndef	__REGISTRY_H__
< Registry.h (sp\wsock):#define	__REGISTRY_H__
< Registry.h (sp\wsock):BOOL	FindSPInRegistry( const GUID *const lpguid, char *const lpszSPName, const DWORD dwNameSize, HKEY *const lphkey );
< Registry.h (sp\wsock):HRESULT	GetFlagsFromRegistry( const GUID *const lpguidSP, DWORD *const lpdwFlags);
< Registry.h (sp\wsock):HRESULT	GetGatewayFromRegistry( BYTE *const lpszGateway, const DWORD cbszGateway );
< Registry.h (sp\wsock):#endif	// __REGISTRY_H__
< Rfc1738.txt (doc):   registry of URL schemes. Any submission of a new URL scheme must
< Rsip.cpp (sp\wsock):#include	"Registry.h"
< Rsip.cpp (sp\wsock):		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
< Rsip.cpp (sp\wsock):		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
< Simplepeer.cpp (test\simplepeer):            // Write information to the registry
---
> ---- 03/24 Matches (15) ----
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9413 edit on 2000/03/24 18:03:53 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added items to the PREPEND_BUFF'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9414 edit on 2000/03/24 18:05:07 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added code to handle proxied en'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9377 edit on 2000/03/24 13:14:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified SP to compile under Wi'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9399 edit on 2000/03/24 15:25:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added stubs for SPGetCaps() and'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9399 edit on 2000/03/24 15:25:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added stubs for SPGetCaps() and'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #4 change 9416 edit on 2000/03/24 18:08:19 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Modified code to have proper so'
> Temp.txt (d:\nt\multimedia\directx\dplay\dnet\sp\wsock):... #3 change 9399 edit on 2000/03/24 15:25:05 by REDMOND\johnkan@JOHNKAN1-1 (text) 'Added stubs for SPGetCaps() and'
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
226a227,246
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,79d74
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate service providers
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
266d260
< */	return(E_FAIL);
280,284d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
433d421
< */	return(E_FAIL);
728d715
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
85,86d84
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
119a118,120
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
187a188,206
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37c37
< //#include "CReg.h"
---
> #include "CReg.h"
93,97d92
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
389d383
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
388a465,471
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
391a475,519
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
423a552,553
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
443a574,575
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
116a117,119
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
146a150
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
147a152
> 
167a173,175
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1433a1435,1440
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1434a1442,1460
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1437a1464,1466
> 		case 2:
> 		default:
> 		{
1438a1468,1470
> 			break;
> 		}
> 	}
1512a1545,1550
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1513a1552,1570
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1516a1574,1576
> 		case 2:
> 		default:
> 		{
1517a1578,1580
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
80a84
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
81a86
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
172a178,184
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
182a195,201
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
307a327,332
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
316a342,347
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
424a456,469
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
425a471
> 
427a474,490
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
457a521,552
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
768a819,831
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
770a834,940
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
771a942,944
> 
> 
> //**********************************************************************
772a946,1094
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
800,801c1122,1123
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
812a1135,1137
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
865a1191,1193
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
943c1271,1272
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
957a1287,1289
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1022a1355,1356
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1070a1405,1406
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1590a1927,1933
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1624a1968,1969
> 			break;
> 		}
1625a1971,2050
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2198a2624,2635
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2199a2637,2640
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2200a2642,2794
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2201a2796,2798
> 
> 
> //**********************************************************************
2474a3072,3132
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
287a288,289
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
291a294,296
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
335a341
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
340a347,348
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
97a98,99
> 	 IPXAddress.cpp \
> 	 IPXEndpt.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103c103
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
121c121,122
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
156c157,158
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
274a279
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
491a561,566
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
544a620,625
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
681a763,768
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
714a802,807
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
133a135,158
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
170a196
> 		m_iWinsockVersion( 0 ),
199a226
> 	DNASSERT( m_iWinsockVersion == 0 );
224c251
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
236a264
> 	m_iWinsockVersion = iWinsockVersion;
255c283,293
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
256a295,302
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
263c309,319
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
264a321,326
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
265a328
> 
306a370,376
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
363a434,440
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
369a447,473
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
465a570,729
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	//
> 	// note that we've started a thread
> 	//
> 	m_iTotalThreadCount++;
> 	DNASSERT( m_iNTCompletionThreadCount == 0 );
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
564a829,830
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
585a852
> 	}
663a931,936
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
679a953,954
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
828a1104
> 	m_IPXReadIODataPool.Deinitialize();
840a1117,1118
> 
> 	m_iWinsockVersion = 0;
888a1167,1181
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
983a1277,1285
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1316a1619,1625
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, submit new I/O completion item
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1333a1643,1676
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1429a1773,1774
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1436a1782
> 	}
1689a2036,2052
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
> 		// WinNT has many potential threads
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1691a2055,2056
> 			break;
> 		}
1692a2058,2067
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1721a2097,2098
> 	switch ( DNGetOSType() )
> 	{
1722a2100,2107
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1725a2111,2112
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1735a2123,2135
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2176a2577,2589
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
2178a2592,2593
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
2179a2595,2604
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
2181a2607,2611
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
2182a2613,2690
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
2183a2692,2694
> 
> 
> //**********************************************************************
2184a2696,3374
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process enums on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an enum submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the enum time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active enums left when enuming with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2535a3726,3736
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
2536a3738,3864
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> }
2537a3866,3868
> 
> 
> //**********************************************************************
2782a4114,4115
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
101c102
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
106c107,108
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
152a155
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
157a161
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
189a194
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
201a207
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
273a280
> 		HRESULT	Win9xInit( void );
290a298,299
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
291a301
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
298a309
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
77c78
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
103a105
> 	INT		iVersion;
131c133,134
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
138a142,143
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
151,152c156
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
245a247
> 		case TYPE_IPX:
479,480c481,483
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2661a2665,2676
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2873a2889,2900
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04241015.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\build.log	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\build.log	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 129 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64
> #include "DVoice.h"
94a96
> #include "Voice.h"
99d100
< #include <mmsystem.h>
551a553,572
> 				case DN_MSG_INTERNAL_VOICE_SEND:
> 					{
> 						DPF(9,"DN_MSG_INTERNAL_VOICE_SEND");
> 
> 						PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 						if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 						{
>     						DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     						dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 							dvSendComplete.hrSendResult = pdnAsyncOp->hResultCode;
> 
>     						Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 						}
> 
> 						break;
> 					}
> 
2242a2264,2272
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
> 
> 				break;
> 			}
> 
2691a2722,2744
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF( 5, "DN_MSG_INTERNAL_VOICE_SEND" );
> 
> 				if( !(pdnAsyncOp->dwFlags & DN_ASYNC_OP_FLAG_MULTI_OP) )
> 				{
> 					PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 					if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 					{
>     					DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     					dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 						dvSendComplete.hrSendResult = hr;
> 
>     					Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 					}
> 				}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include "DVoice.h"
65a67,68
> #include "dvoice.h"
> #include "voice.h"
113a117
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
565a601,603
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
796a835,839
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88
> #include "DVoice.h"
120a122
> #include "Voice.h"
127d128
< #include <mmsystem.h>
1380a1382,1386
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
143a144
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
163a165
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
203a206,211
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
275a284,288
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23
> #include "DVoice.h"
45a47
> #include "voice.h"
48a51,52
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2161a2166
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
110a111
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
93,94d92
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
127a126,128
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38c38
< //#include "CReg.h"
---
> #include "CReg.h"
95,99d94
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
404d398
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1433a1435,1440
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1434a1442,1460
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1437a1464,1466
> 		case 2:
> 		default:
> 		{
1438a1468,1470
> 			break;
> 		}
> 	}
1512a1545,1550
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1513a1552,1570
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1516a1574,1576
> 		case 2:
> 		default:
> 		{
1517a1578,1580
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
132,134d132
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
142,145d139
< */
< 
< 	SetTempHostName( "", 0 );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
80a84
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
81a86
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
172a178,184
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
182a195,201
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
307a327,332
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
316a342,347
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
424a456,469
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
425a471
> 
427a474,490
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
457a521,552
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX endpoint
> //
> // Entry:		Pointer to IPX endpoint
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
262a264,265
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
263a267,284
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
265a287,289
> 		case 2:
> 		default:
> 		{
266a291,293
> 			break;
> 		}
> 	}
410a438,460
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
838a889,901
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
840a904,1010
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
841a1012,1014
> 
> 
> //**********************************************************************
842a1016,1164
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
870,871c1192,1193
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
882a1205,1207
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
935a1261,1263
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1013c1341,1342
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1027a1357,1359
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1092a1425,1426
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1140a1475,1476
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1708a2045,2051
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1742a2086,2087
> 			break;
> 		}
1743a2089,2168
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2364a2790,2801
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2365a2803,2806
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2366a2808,2960
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2367a2962,2964
> 
> 
> //**********************************************************************
2640a3238,3298
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
291a298,299
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
157c158,159
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
242a245
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
243a247
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
246c250
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
253c257
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
280a285
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
490a560,565
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
543a619,624
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
680a762,767
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
713a801,806
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
113a115,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
161a187
> 		m_iWinsockVersion( 0 ),
189a216
> 	DNASSERT( m_iWinsockVersion == 0 );
212c239
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
220a248
> 	m_iWinsockVersion = iWinsockVersion;
239c267,277
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
240a279,286
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
247c293,303
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
248a305,312
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
282a347,353
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
336a408,412
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
339a416,417
> 		case VER_PLATFORM_WIN32_NT:
> 		{
345a424,450
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
441a547,711
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
550a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
571a844
> 	}
649a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
665a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
814a1096
> 	m_IPXReadIODataPool.Deinitialize();
825a1108,1109
> 
> 	m_iWinsockVersion = 0;
873a1158,1172
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
968a1268,1276
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1223a1532,1533
> 	switch ( DNGetOSType() )
> 	{
1226a1537,1538
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1243a1556,1589
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1354a1701,1702
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1361a1710
> 	}
1661a2011,2012
> 	switch ( DNGetOSType() )
> 	{
1662a2014,2023
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1664a2026,2027
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1666a2030,2031
> 			break;
> 		}
1667a2033,2042
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1696a2072,2073
> 	switch ( DNGetOSType() )
> 	{
1697a2075,2082
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1700a2086,2087
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1710a2098,2110
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2103a2504,3299
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2503a3700,3841
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
76c77
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
102a104
> 	INT		iVersion;
130c132,133
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c155
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
176a178,181
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
177a183,197
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
271a292
> 		case TYPE_IPX:
505,506c526,528
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2691a2714,2725
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2903a2938,2949
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04201700.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 52 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 122 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61
> #include "DVoice.h"
91a93
> #include "Voice.h"
96d97
< #include <mmsystem.h>
548a550,569
> 				case DN_MSG_INTERNAL_VOICE_SEND:
> 					{
> 						DPF(9,"DN_MSG_INTERNAL_VOICE_SEND");
> 
> 						PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 						if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 						{
>     						DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     						dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 							dvSendComplete.hrSendResult = pdnAsyncOp->hResultCode;
> 
>     						Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 						}
> 
> 						break;
> 					}
> 
2117a2139,2147
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
> 
> 				break;
> 			}
> 
2547a2578,2600
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF( 5, "DN_MSG_INTERNAL_VOICE_SEND" );
> 
> 				if( !(pdnAsyncOp->dwFlags & DN_ASYNC_OP_FLAG_MULTI_OP) )
> 				{
> 					PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 					if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 					{
>     					DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     					dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 						dvSendComplete.hrSendResult = hr;
> 
>     					Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 					}
> 				}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include "DVoice.h"
65a67,68
> #include "dvoice.h"
> #include "voice.h"
113a117
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
565a601,603
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
796a835,839
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
83a84
> #include "DVoice.h"
116a118
> #include "Voice.h"
123d124
< #include <mmsystem.h>
1372a1374,1378
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
> //#include "dvoice.h"
143a145
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x20 | DN_MSG_INTERNAL)
166a169
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
213a217,222
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
285a295,299
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23
> #include "DVoice.h"
45a47
> #include "voice.h"
48a51,52
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2161a2166
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
110a111
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
156c161
<     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;    
---
>     STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
242c247
< #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)              
---
> #define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
93,94d92
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
127a126,128
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38c38
< //#include "CReg.h"
---
> #include "CReg.h"
95,99d94
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
404d398
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1433a1435,1440
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1434a1442,1460
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1437a1464,1466
> 		case 2:
> 		default:
> 		{
1438a1468,1470
> 			break;
> 		}
> 	}
1512a1545,1550
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1513a1552,1570
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1516a1574,1576
> 		case 2:
> 		default:
> 		{
1517a1578,1580
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
80a84
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
81a86
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
172a178,184
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
182a195,201
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
307a327,332
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
316a342,347
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
424a456,469
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
425a471
> 
427a474,490
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
457a521,552
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX endpoint
> //
> // Entry:		Pointer to IPX endpoint
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
262a264,265
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
263a267,284
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
265a287,289
> 		case 2:
> 		default:
> 		{
266a291,293
> 			break;
> 		}
> 	}
410a438,460
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
838a889,901
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
840a904,1010
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
841a1012,1014
> 
> 
> //**********************************************************************
842a1016,1164
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
870,871c1192,1193
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
882a1205,1207
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
935a1261,1263
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1013c1341,1342
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1027a1357,1359
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1092a1425,1426
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1140a1475,1476
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1708a2045,2051
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1742a2086,2087
> 			break;
> 		}
1743a2089,2168
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2317a2743,2754
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2318a2756,2759
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2319a2761,2913
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2320a2915,2917
> 
> 
> //**********************************************************************
2593a3191,3251
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
237a238,239
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
241a244,246
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
285a291
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
290a297,298
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103c103
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
121c121,122
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
156c157,158
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
277a282
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
490a560,565
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
543a619,624
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
680a762,767
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
713a801,806
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
113a115,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
161a187
> 		m_iWinsockVersion( 0 ),
189a216
> 	DNASSERT( m_iWinsockVersion == 0 );
212c239
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
220a248
> 	m_iWinsockVersion = iWinsockVersion;
239c267,277
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
240a279,286
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
247c293,303
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
248a305,312
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
282a347,353
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
336a408,412
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
339a416,417
> 		case VER_PLATFORM_WIN32_NT:
> 		{
345a424,450
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
441a547,711
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
550a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
571a844
> 	}
649a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
665a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
814a1096
> 	m_IPXReadIODataPool.Deinitialize();
825a1108,1109
> 
> 	m_iWinsockVersion = 0;
873a1158,1172
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
968a1268,1276
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1223a1532,1533
> 	switch ( DNGetOSType() )
> 	{
1226a1537,1538
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1243a1556,1589
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1354a1701,1702
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1361a1710
> 	}
1661a2011,2012
> 	switch ( DNGetOSType() )
> 	{
1662a2014,2023
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1664a2026,2027
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1666a2030,2031
> 			break;
> 		}
1667a2033,2042
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1696a2072,2073
> 	switch ( DNGetOSType() )
> 	{
1697a2075,2082
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1700a2086,2087
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1710a2098,2110
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2103a2504,3299
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2503a3700,3841
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
76c77
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
102a104
> 	INT		iVersion;
130c132,133
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c155
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
175a177,180
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
176a182,196
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
270a291
> 		case TYPE_IPX:
504,505c525,527
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2690a2713,2724
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2902a2937,2948
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04211500.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 126 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62
> #include "DVoice.h"
92a94
> #include "Voice.h"
97d98
< #include <mmsystem.h>
549a551,570
> 				case DN_MSG_INTERNAL_VOICE_SEND:
> 					{
> 						DPF(9,"DN_MSG_INTERNAL_VOICE_SEND");
> 
> 						PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 						if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 						{
>     						DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     						dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 							dvSendComplete.hrSendResult = pdnAsyncOp->hResultCode;
> 
>     						Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 						}
> 
> 						break;
> 					}
> 
2186a2208,2216
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
> 
> 				break;
> 			}
> 
2616a2647,2669
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF( 5, "DN_MSG_INTERNAL_VOICE_SEND" );
> 
> 				if( !(pdnAsyncOp->dwFlags & DN_ASYNC_OP_FLAG_MULTI_OP) )
> 				{
> 					PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 					if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 					{
>     					DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     					dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 						dvSendComplete.hrSendResult = hr;
> 
>     					Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 					}
> 				}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include "DVoice.h"
65a67,68
> #include "dvoice.h"
> #include "voice.h"
113a117
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
565a601,603
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
796a835,839
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
85a86
> #include "DVoice.h"
118a120
> #include "Voice.h"
125d126
< #include <mmsystem.h>
1378a1380,1384
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69
> //#include "dvoice.h"
143a145
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x20 | DN_MSG_INTERNAL)
166a169
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
213a217,222
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
285a295,299
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23
> #include "DVoice.h"
45a47
> #include "voice.h"
48a51,52
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2161a2166
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
110a111
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
93,94d92
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
127a126,128
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38c38
< //#include "CReg.h"
---
> #include "CReg.h"
95,99d94
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
404d398
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25c25
< //#include "CReg.h"
---
> #include "CReg.h"
67,71d66
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
254d248
< */ return(E_FAIL);
275,279d268
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
573d561
< */	return(E_FAIL);
1309d1296
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1433a1435,1440
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1434a1442,1460
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1437a1464,1466
> 		case 2:
> 		default:
> 		{
1438a1468,1470
> 			break;
> 		}
> 	}
1512a1545,1550
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1513a1552,1570
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1516a1574,1576
> 		case 2:
> 		default:
> 		{
1517a1578,1580
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
80a84
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
81a86
> static	CFixedPool< CIPXEndpoint >	*g_pIPXEndpointPool = NULL;
172a178,184
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
182a195,201
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CFixedPool< CIPXEndpoint >;
> 	if ( g_pIPXEndpointPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
307a327,332
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
316a342,347
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
424a456,469
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
425a471
> 
427a474,490
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
457a521,552
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( void )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXEndpoint - return an IPX endpoint
> //
> // Entry:		Pointer to IPX endpoint
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint )
> {
> 	DNASSERT( pIPXEndpoint != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXEndpointPool->Release( pIPXEndpoint );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
57a60,62
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
59a65,67
> 
> CIPXEndpoint	*CreateIPXEndpoint( void );
> void	ReturnIPXEndpoint( CIPXEndpoint *const pIPXEndpoint );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
262a264,265
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
263a267,284
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
265a287,289
> 		case 2:
> 		default:
> 		{
266a291,293
> 			break;
> 		}
> 	}
410a438,460
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
838a889,901
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
840a904,1010
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
841a1012,1014
> 
> 
> //**********************************************************************
842a1016,1164
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
870,871c1192,1193
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
882a1205,1207
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
935a1261,1263
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1013c1341,1342
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1027a1357,1359
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1092a1425,1426
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1140a1475,1476
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1708a2045,2051
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1742a2086,2087
> 			break;
> 		}
1743a2089,2168
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2364a2790,2801
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2365a2803,2806
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2366a2808,2960
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2367a2962,2964
> 
> 
> //**********************************************************************
2640a3238,3298
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
291a298,299
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
157c158,159
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
242a245
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
243a247
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
246c250
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
253c257
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
280a285
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
46a48
> #include	"IPXAddress.h"
52a55
> #include	"IPXEndpt.h"
182a186,251
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
490a560,565
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint();
>     		break;
>     	}
> 
543a619,624
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXEndpoint( static_cast<CIPXEndpoint*>( pEndpoint ) );
>     		break;
>     	}
> 
680a762,767
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
713a801,806
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
113a115,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
161a187
> 		m_iWinsockVersion( 0 ),
189a216
> 	DNASSERT( m_iWinsockVersion == 0 );
212c239
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
220a248
> 	m_iWinsockVersion = iWinsockVersion;
239c267,277
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
240a279,286
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
247c293,303
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
248a305,312
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
282a347,353
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
336a408,412
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
339a416,417
> 		case VER_PLATFORM_WIN32_NT:
> 		{
345a424,450
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
441a547,711
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
550a821,822
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
571a844
> 	}
649a923,928
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
665a945,946
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
814a1096
> 	m_IPXReadIODataPool.Deinitialize();
825a1108,1109
> 
> 	m_iWinsockVersion = 0;
873a1158,1172
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
968a1268,1276
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1223a1532,1533
> 	switch ( DNGetOSType() )
> 	{
1226a1537,1538
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1243a1556,1589
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1354a1701,1702
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1361a1710
> 	}
1661a2011,2012
> 	switch ( DNGetOSType() )
> 	{
1662a2014,2023
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1664a2026,2027
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1666a2030,2031
> 			break;
> 		}
1667a2033,2042
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1696a2072,2073
> 	switch ( DNGetOSType() )
> 	{
1697a2075,2082
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1700a2086,2087
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1710a2098,2110
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2103a2504,3299
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2503a3700,3841
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65c65,94
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
126a156,245
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
228a348
> //	we can either create an IPX instance or an IP instance
234a355,358
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
265c389,390
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
76c77
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
102a104
> 	INT		iVersion;
130c132,133
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c155
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
175a177,180
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
176a182,196
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
270a291
> 		case TYPE_IPX:
504,505c525,527
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
2690a2713,2724
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2902a2937,2948
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\04261045.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\build.log	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\build.log	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.err	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\build.log	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 133 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64a65
> #include "DVoice.h"
95a97
> #include "Voice.h"
100d101
< #include <mmsystem.h>
552a554,573
> 				case DN_MSG_INTERNAL_VOICE_SEND:
> 					{
> 						DPF(9,"DN_MSG_INTERNAL_VOICE_SEND");
> 
> 						PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 						if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 						{
>     						DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     						dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 							dvSendComplete.hrSendResult = pdnAsyncOp->hResultCode;
> 
>     						Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 						}
> 
> 						break;
> 					}
> 
2296a2318,2326
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
> 
> 				break;
> 			}
> 
2745a2776,2798
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF( 5, "DN_MSG_INTERNAL_VOICE_SEND" );
> 
> 				if( !(pdnAsyncOp->dwFlags & DN_ASYNC_OP_FLAG_MULTI_OP) )
> 				{
> 					PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pdnAsyncOp->pvUserContext;
> 
> 					if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
> 					{
>     					DVEVENTMSG_SENDCOMPLETE dvSendComplete;
> 
>     					dvSendComplete.pvUserContext = pdnAsyncOp->pvUserContext;
> 						dvSendComplete.hrSendResult = hr;
> 
>     					Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
> 
> 					}
> 				}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include "DVoice.h"
65a67,68
> #include "dvoice.h"
> #include "voice.h"
113a117
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
565a601,603
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
796a835,839
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90
> #include "DVoice.h"
122a124
> #include "Voice.h"
129d130
< #include <mmsystem.h>
1392a1394,1398
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
143a144
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
163a165
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
203a206,211
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
275a284,288
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25
> #include "DVoice.h"
47a49
> #include "voice.h"
50a53,54
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2181a2186
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
109a110
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
93,94d92
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
127a126,128
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39c39
< //#include "CReg.h"
---
> #include "CReg.h"
97,101d96
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
404d398
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26c26
< //#include "CReg.h"
---
> #include "CReg.h"
68,72d67
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
255d249
< */ return(E_FAIL);
276,280d269
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
574d562
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1451a1453,1458
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1455a1482,1484
> 		case 2:
> 		default:
> 		{
1456a1486,1488
> 			break;
> 		}
> 	}
1530a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1531a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1534a1592,1594
> 		case 2:
> 		default:
> 		{
1535a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
136,138d136
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
146,150d143
< */
< 
< 	SetTempHostName( "", 0 );
<         SettingsDialogComplete( hr );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
840a891,903
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
842a906,1012
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
843a1014,1016
> 
> 
> //**********************************************************************
844a1018,1166
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
872,873c1194,1195
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
884a1207,1209
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
937a1263,1265
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1015c1343,1344
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1029a1359,1361
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1094a1427,1428
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1142a1477,1478
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1710a2047,2053
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1744a2088,2089
> 			break;
> 		}
1745a2091,2170
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2366a2792,2803
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2367a2805,2808
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2368a2810,2962
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2369a2964,2966
> 
> 
> //**********************************************************************
2655a3253,3313
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
291a298,299
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
243a246
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
244a248
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
247c251
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
254c258
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
281a286
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
496a566,571
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint( &EndpointPoolContext );
>     		break;
>     	}
> 
635a711,716
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
668a750,755
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,139
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
162a188
> 		m_iWinsockVersion( 0 ),
190a217
> 	DNASSERT( m_iWinsockVersion == 0 );
213c240
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
221a249
> 	m_iWinsockVersion = iWinsockVersion;
240c268,278
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
241a280,287
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
248c294,304
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
249a306,313
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
283a348,354
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a409,413
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
340a417,418
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a425,451
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
442a548,712
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
551a822,823
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
572a845
> 	}
650a924,929
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
666a946,947
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
815a1097
> 	m_IPXReadIODataPool.Deinitialize();
826a1109,1110
> 
> 	m_iWinsockVersion = 0;
874a1159,1173
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
969a1269,1277
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1224a1533,1534
> 	switch ( DNGetOSType() )
> 	{
1227a1538,1539
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1244a1557,1590
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1355a1702,1703
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1362a1711
> 	}
1683a2033,2034
> 	switch ( DNGetOSType() )
> 	{
1684a2036,2045
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1686a2048,2049
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1688a2052,2053
> 			break;
> 		}
1689a2055,2064
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1718a2094,2095
> 	switch ( DNGetOSType() )
> 	{
1719a2097,2104
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1722a2108,2109
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1732a2120,2132
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2125a2526,3321
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2525a3722,3863
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67c67,96
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
128a158,247
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
230a350
> //	we can either create an IPX instance or an IP instance
236a357,360
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
267c391,392
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
76c77
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
102a104
> 	INT		iVersion;
130c132,133
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c155
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
330c349
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
177a179,182
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
178a184,198
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
272a293
> 		case TYPE_IPX:
506,507c527,529
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
691c713,714
< 			if ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 )
---
> 			if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( IsEqualCLSID( DNSPInterface.pDataInterface->ClassID, CLSID_DP8SP_IPX ) == FALSE ) )
2675a2699,2710
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2887a2923,2934
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\05010945.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwinsock.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwinsock.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 138 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
66a67
> #include "DVoice.h"
97a99
> #include "Voice.h"
102d103
< #include <mmsystem.h>
1459a1461,1469
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include "DVoice.h"
67a69,70
> #include "dvoice.h"
> #include "voice.h"
115a119
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
224a229,233
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
225a235,249
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
257a282,285
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
286a315,321
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
546a582,584
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
771a810,814
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
95a96
> #include "DVoice.h"
128a130
> #include "Voice.h"
135d136
< #include <mmsystem.h>
1408a1410,1414
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
159a161
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
199a202,207
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
267a276,280
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25a26
> #include "DVoice.h"
48a50
> #include "voice.h"
51a54,55
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2187a2192
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
93,94d92
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
127a126,128
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
98,102d97
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
405d399
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26c26
< //#include "CReg.h"
---
> #include "CReg.h"
68,72d67
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
255d249
< */ return(E_FAIL);
276,280d269
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
574d562
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15
> #include <wsipx.h>
18a20,23
> //
> // comment out the follwing #define to prevent loading Winsock2
> //
> #define	LOAD_WINSOCK2
30c35,41
< static BOOL MapFunctionPointers(HINSTANCE hndlWinSock);
---
> static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
> static int  FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 							  LPDWORD pdwBufLen);
> static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
34c45
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock)
---
> int DWSInitWinSock(LPDWSSTATE lpState)
36a48
> 	BOOL f2Loaded = TRUE;
39a52,53
> 	if (lpState == NULL)
> 		return 0;
43,44c57,59
< 	*lphndlWinSock = LoadLibrary("WS2_32.DLL");
< 	if (*lphndlWinSock == NULL)
---
> #ifdef	LOAD_WINSOCK2
> 	lpState->hndlWinSock = LoadLibrary("WS2_32.DLL");
> 	if (lpState->hndlWinSock == NULL)
45a61
> #endif	// LOAD_WINSOCK2
47c63
< 		// Couldn't load WinSock 2
---
> 		// Couldn't load WinSock 2, try 1.1
49c65,69
< 			return FALSE;
---
> 		f2Loaded = FALSE;
> 		lpState->hndlWinSock = LoadLibrary("WSOCK32.DLL");
> 		if (lpState->hndlWinSock == NULL)
> 			return 0;
> #ifdef	LOAD_WINSOCK2
50a71
> #endif	// LOAD_WINSOCK2
56,57c77,78
< 	if (!MapFunctionPointers(*lphndlWinSock))
< 		return FALSE;
---
> 	if (!MapFunctionPointers(lpState, f2Loaded))
> 		return 0;
60c81
< 	// Ask for 2.2
---
> 	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
61a83
> 	if (f2Loaded)
62a85,86
> 	else
> 		wVersionRequested = MAKEWORD(1,1);
70,71c94,95
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
76,77c100,101
< 		FreeLibrary(*lphndlWinSock);
< 		return FALSE;
---
> 		FreeLibrary(lpState->hndlWinSock);
> 		return 0;
80c104,111
< 	return(TRUE);
---
> 	// Save Max UDP for use with 1.1
> 	lpState->nMaxUdp = wsaData.iMaxUdpDg;
> 
> 	//
> 	// Return 1 or 2
> 	//
> 	lpState->nVersion = f2Loaded ? 2 : 1;
> 	return(lpState->nVersion);
85c116
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock)
---
> BOOL DWSFreeWinSock(LPDWSSTATE lpState)
86a118,120
> 	if (lpState == NULL)
> 		return FALSE;
> 
89c123,124
< 	return(FreeLibrary(hndlWinSock));
---
> 	lpState->nVersion = 0;
> 	return(FreeLibrary(lpState->hndlWinSock));
94c129
< BOOL MapFunctionPointers(HINSTANCE hndlWinSock)
---
> BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
95a131,133
> 	// we set the local lib handle for use with the
> 	//	macros
> 	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
115c153
< 	if (fOK)
---
> 	if (fOK && fMapVersion2)
121a160,710
> ////////////////////////////////////////////////////////////
> 
> int DWSVersion(LPDWSSTATE lpState)
> {
> 	return lpState->nVersion;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket)
> {
> 	int nOptVal;
> 	int nOptLen;
> 	int nRet;
> 
> 	//
> 	// If WinSock isn't loaded
> 	// return 0
> 	//
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// If we're using WinSock 1.1
> 	// return the previously saved
> 	// info from WSADATA
> 	//
> 	if (lpState->nVersion == 1)
> 		return lpState->nMaxUdp;
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 
> 	//
> 	// Use getsockopt() to find
> 	// the max message size for
> 	// this socket
> 	//
> 	nOptLen = sizeof(int);
> 	nRet = p_getsockopt(socket,
> 					  SOL_SOCKET,
> 					  SO_MAX_MSG_SIZE,
> 					  (char *)&nOptVal,
> 					  &nOptLen);
> 	if (nRet == SOCKET_ERROR)
> 		return SOCKET_ERROR;
> 	return nOptVal;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr, LPDWORD pdwStrLen)
> {
> 	LPTSTR			lpStr;
> 	LPSOCKADDR_IN	pInAddr;
> 	int				nRet = 0;
> 
> 	lpAddrStr[0] = '\0';
> 
> 	//
> 	// If WinSock isn't loaded, return 1
> 	//
> 	if (lpState->nVersion == 0)
> 		return 1;
> 
> 	//
> 	// If using WinSock 1.1 then assume IP
> 	//
> 	if (lpState->nVersion == 1)
> 	{
> 		//
> 		// Convert address with inet_ntoa
> 		//
> 		pInAddr = (LPSOCKADDR_IN)pAddr;
> 		lpStr = p_inet_ntoa(pInAddr->sin_addr);
> 		if (lpStr == NULL)
> 		{
> 			p_WSASetLastError(WSAEINVAL);
> 			*pdwStrLen = 0;
> 			return SOCKET_ERROR;	
> 		}
> 		#ifdef UNICODE
> 			//
> 			// Convert inet_ntoa string to wide char
> 			//
> 			nRet = MultiByteToWideChar(CP_ACP,
> 										0,
> 										lpStr,
> 										-1,
> 										lpAddrStr,
> 										*pdwStrLen);
> 			if (nRet == 0)
> 			{
> 				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
> 					p_WSASetLastError(WSAEFAULT);
> 				else
> 					p_WSASetLastError(WSAEINVALID);
> 				return SOCKET_ERROR;
> 			}
> 		#else
> 			//
> 			// ANSI -- Check the string length
> 			//
> 			if (strlen(lpStr) > *pdwStrLen)
> 			{
> 				p_WSASetLastError(WSAEFAULT);
> 				*pdwStrLen = strlen(lpStr);
> 				return SOCKET_ERROR;
> 			}
> 			strcpy(lpAddrStr, lpStr);
> 			*pdwStrLen = strlen(lpStr);
> 			return 0;
> 		#endif
> 	}
> 
> 	//
> 	// Must be WinSock 2
> 	//
> 	nRet = p_WSAAddressToString(pAddr,
> 							    dwAddrLen,
> 							    NULL,
> 							    lpAddrStr,
> 							    pdwStrLen);
> 	//
> 	// Check for "unsupported" families
> 	//
> 	if (nRet == SOCKET_ERROR && p_WSAGetLastError() == WSAEOPNOTSUPP)
> 	{
> 		if (pAddr->sa_family == AF_IPX)
> 		{
> 			nRet = IPXAddressToString((LPSOCKADDR_IPX) pAddr,
> 									  dwAddrLen,
> 									  lpAddrStr,
> 									  pdwStrLen);
> 		}
> 	}
> 	return nRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					 LPDWORD pdwBufLen)
> {
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	if (lpState->nVersion == 1)
> 		return(FakeEnumProtocols(lpState, lpProtocolBuffer,
> 								 pdwBufLen));
> 	//
> 	// Must be WinSock 2
> 	//
> 	return(p_WSAEnumProtocols(NULL,
> 							 lpProtocolBuffer,
> 							 pdwBufLen));
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int FakeEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					  LPDWORD pdwBufLen)
> {
> 	WSAPROTOCOL_INFO FakeTcp;
> 	WSAPROTOCOL_INFO FakeUdp;
> 	LPWSAPROTOCOL_INFO lpInfo;
> 
> 	//
> 	// Assume WinSock 1.1, we're returning
> 	// 2 WSAPROTOCOL_INFO structures.
> 	// 1 for TCP, 1 for UDP
> 	//
> 
> 	//
> 	// Check the buffer size
> 	//
> 	if (*pdwBufLen < (sizeof(WSAPROTOCOL_INFO)*2))
> 	{
> 		*pdwBufLen = (sizeof(WSAPROTOCOL_INFO)*2);
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Build fake TCP entry
> 	//
> 	memset(&FakeTcp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeTcp.dwServiceFlags1 = XP1_GUARANTEED_DELIVERY	|
> 							  XP1_GUARANTEED_ORDER		|
> 							  XP1_GRACEFUL_CLOSE		|
> 							  XP1_EXPEDITED_DATA;
> 	FakeTcp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeTcp.dwCatalogEntryId= 1;;
> 	FakeTcp.iVersion		= 1;
> 	FakeTcp.iAddressFamily  = AF_INET;
> 	FakeTcp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeTcp.iSocketType		= SOCK_STREAM;
> 	FakeTcp.iProtocol		= IPPROTO_TCP;
> 	FakeTcp.iNetworkByteOrder = BIGENDIAN;
> 	FakeTcp.dwMessageSize	= 0;
> 	_tcscpy(FakeTcp.szProtocol, _TEXT("tcp"));
> 
> 	//
> 	// Build fake UDP entry
> 	//
> 	memset(&FakeUdp, 0, sizeof(WSAPROTOCOL_INFO));
> 	FakeUdp.dwServiceFlags1 = XP1_CONNECTIONLESS		|
> 							  XP1_MESSAGE_ORIENTED		|
> 							  XP1_SUPPORT_BROADCAST;		
> 							  // Might want to add multipoint
> 	FakeUdp.dwProviderFlags = PFL_MATCHES_PROTOCOL_ZERO;
> 	FakeUdp.ProtocolChain.ChainLen = 1;	// Base protocol
> 	FakeUdp.dwCatalogEntryId= 2;;
> 	FakeUdp.iVersion		= 1;
> 	FakeUdp.iAddressFamily  = AF_INET;
> 	FakeUdp.iMaxSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iMinSockAddr	= sizeof(SOCKADDR_IN);
> 	FakeUdp.iSocketType		= SOCK_DGRAM;
> 	FakeUdp.iProtocol		= IPPROTO_UDP;
> 	FakeUdp.iNetworkByteOrder = BIGENDIAN;
> 	FakeUdp.dwMessageSize	= lpState->nMaxUdp;	// The reason this can't be static
> 	_tcscpy(FakeUdp.szProtocol, _TEXT("udp"));
> 
> 	//
> 	// Copy the fake entries to the supplied buffer
> 	lpInfo = lpProtocolBuffer;
> 	memcpy(lpInfo, &FakeTcp, sizeof(WSAPROTOCOL_INFO));
> 	lpInfo++;
> 	memcpy(lpInfo, &FakeUdp, sizeof(WSAPROTOCOL_INFO));
> 
> 	//
> 	// Returning 2 protocols
> 	//	
> 	return 2;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> int DWSSelectProtocols( LPDWSSTATE lpState,
> 					DWORD dwSetFlags,
> 					DWORD dwNotSetFlags,
> 					LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					LPDWORD lpdwBufferLength
> 					)
> {
> 	LPBYTE				pBuf;
> 	LPWSAPROTOCOL_INFO	pInfo;
> 	DWORD				dwNeededLen;
> 	LPWSAPROTOCOL_INFO	pRetInfo;
> 	DWORD				dwRetLen;
> 	int					nCount;
> 	int					nMatchCount;
> 	int					nRet;
> 
> 	if (lpState->nVersion == 0)
> 		return 0;
> 
> 	//
> 	// Determine needed buffer size
> 	//
> 	dwNeededLen = 0;
> 	nRet = DWSEnumProtocols(lpState, NULL, &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAENOBUFS)
> 			return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Allocate the buffer
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwNeededLen) );
> 	if (pBuf == NULL)
> 	{
> 		p_WSASetLastError(WSAENOBUFS);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Make the "real" call
> 	//
> 	nRet = DWSEnumProtocols(lpState, (LPWSAPROTOCOL_INFO)pBuf,
> 							 &dwNeededLen);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Helper macros for selecting protocols
> 	//
> 	#define REJECTSET(f) \
> 	    ((dwSetFlags & f) && !(pInfo->dwServiceFlags1 & f))
> 	#define REJECTNOTSET(f) \
> 	    ((dwNotSetFlags &f) && (pInfo->dwServiceFlags1 & f))
> 	#define REJECTEDBY(f) (REJECTSET(f) || REJECTNOTSET(f))
> 
> 	//
> 	// Loop through the protocols making selections
> 	//
> 	pInfo = (LPWSAPROTOCOL_INFO)pBuf;	
> 	pRetInfo = lpProtocolBuffer;
> 	dwRetLen = 0;
> 	nMatchCount = 0;
> 	for(nCount = 0; nCount < nRet; nCount++)
> 	{
> 		//
> 		// Check all of the requested flags
> 		//
> 		while(1)
> 		{
> 			if (REJECTEDBY(XP1_CONNECTIONLESS))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_DELIVERY))
> 				break;
> 			if (REJECTEDBY(XP1_GUARANTEED_ORDER))
> 				break;
> 			if (REJECTEDBY(XP1_MESSAGE_ORIENTED))
> 				break;
> 			if (REJECTEDBY(XP1_PSEUDO_STREAM))
> 				break;
> 			if (REJECTEDBY(XP1_GRACEFUL_CLOSE))
> 				break;
> 			if (REJECTEDBY(XP1_EXPEDITED_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_CONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_DISCONNECT_DATA))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_BROADCAST))
> 				break;
> 			if (REJECTEDBY(XP1_SUPPORT_MULTIPOINT))
> 				break;
> 			if (REJECTEDBY(XP1_MULTIPOINT_DATA_PLANE))
> 				break;
> 			if (REJECTEDBY(XP1_QOS_SUPPORTED))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_SEND))
> 				break;
> 			if (REJECTEDBY(XP1_UNI_RECV))
> 				break;
> 			if (REJECTEDBY(XP1_IFS_HANDLES))
> 				break;
> 			if (REJECTEDBY(XP1_PARTIAL_MESSAGE))
> 				break;
> 			//
> 			// If we made it here,
> 			//the protocol meets all requirements
> 			//
> 			dwRetLen += sizeof(WSAPROTOCOL_INFO);
> 			if (dwRetLen > *lpdwBufferLength)
> 			{
> 				// The supplied buffer is too small
> 				p_WSASetLastError(WSAENOBUFS);
> 				*lpdwBufferLength = dwNeededLen;
> 				DNFree(pBuf);
> 				return SOCKET_ERROR;
> 			}
> 			nMatchCount++;
> 			// Copy this protocol to the caller's buffer
> 			memcpy(pRetInfo, pInfo, sizeof(WSAPROTOCOL_INFO));
> 			pRetInfo++;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	*lpdwBufferLength = dwRetLen;
> 	return(nMatchCount);
> }
> 
> ////////////////////////////////////////////////////////////
> 
> BOOL DWSDnsOnly(LPDWSSTATE lpState)
> {
> 	//
> 	// Return TRUE if DNS is the only name space provider
> 	//
> 
> 	LPWSANAMESPACE_INFO pInfo;
> 	DWORD				dwBufLen;
> 	PBYTE				pBuf;
> 	int					nCount;
> 	BOOL				fRet = TRUE;
> 	int					nRet;
> 
> 	//
> 	// If we're running on WinSock 1.1 return TRUE
> 	//
> 	if (lpState->nVersion == 1)
> 		return fRet;
> 
> 	// WinSock 2
> 
> 	//
> 	// Intentionally generate an error
> 	// to get the required buffer size
> 	//
> 	dwBufLen = 0;
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen, NULL);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		if (p_WSAGetLastError() != WSAEFAULT)
> 			return fRet;
> 	}
> 
> 	//
> 	// dwBufLen now equals needed size
> 	//
> 	pBuf = static_cast<BYTE*>( DNMalloc(dwBufLen+1) );
> 	if (pBuf == NULL)
> 		return fRet;
> 
> 	//
> 	// Now, make the "real" call
> 	//
> 	nRet = p_WSAEnumNameSpaceProviders(&dwBufLen,
> 									   (LPWSANAMESPACE_INFO)pBuf);
> 	if (nRet == SOCKET_ERROR)
> 	{
> 		DNFree(pBuf);
> 		return fRet;
> 	}
> 
> 	pInfo = (LPWSANAMESPACE_INFO)pBuf;
> 	for (nCount = 0; nCount < nRet; nCount++)
> 	{
> 		if (pInfo->dwNameSpace != NS_DNS)
> 		{
> 			fRet = FALSE;
> 			break;
> 		}
> 		pInfo++;
> 	}
> 	DNFree(pBuf);
> 	return fRet;
> }
> 
> ////////////////////////////////////////////////////////////
> 
> char NibbleToHex(BYTE b)
> {
>     if (b < 10)
> 		return (b + '0');
> 
>     return (b - 10 + 'A');
> }
> 
> void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
> {
> 	BYTE b;
>     while(nNbrBytes--)
>     {
> 		// High order nibble first
> 		b = (*pBytes >> 4);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		// Then low order nibble
> 		b = (*pBytes & 0x0F);
> 		*lpStr = NibbleToHex(b);
> 		lpStr++;
> 		pBytes++;
>     }
>     *lpStr = '\0';
> }
> 
> ////////////////////////////////////////////////////////////
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToString(LPSOCKADDR_IPX pAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
>     strcat(szAddr, ":");
> 
> 	// IPX Address Socket number
>     BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
> 
> 
> //
> // Workaround for WSAAddressToString()/IPX bug
> //
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen)
> {
> 	char szAddr[32];
> 	char szTmp[20];
> 	char *cp = szAddr;
> 	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
> 	//
> 	// Check destination length
> 	//
> 	if (*pdwStrLen < 27)
> 	{
> 		p_WSASetLastError(WSAEINVAL);
> 		return SOCKET_ERROR;
> 	}
> 
> 	//
> 	// Convert network number
> 	//
>     BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
> 	strcpy(szAddr, szTmp);
>     strcat(szAddr, ",");
> 
> 	// Node Number
>     BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
>     strcat(szAddr, szTmp);
> 
> 	strcpy(lpAddrStr, szAddr);
> 
> 	return 0;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwinsock.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17,18c17,42
< BOOL DWSInitWinSock(HINSTANCE *lphndlWinSock);
< BOOL DWSFreeWinSock(HINSTANCE hndlWinSock);
---
> // added to support multiple instantiation/initialization
> typedef struct _DWSSTATE
> {
> 	HINSTANCE	hndlWinSock;
> 	int			nVersion;
> 	int			nMaxUdp	;
> } DWSSTATE, *LPDWSSTATE;
> 
> 
> int  DWSInitWinSock(LPDWSSTATE lpState);
> BOOL DWSFreeWinSock(LPDWSSTATE lpState);
> int  DWSVersion(LPDWSSTATE lpState);
> int  DWSMaxMsgSize(LPDWSSTATE lpState, SOCKET socket);
> int  DWSAddressToString(LPDWSSTATE lpState, LPSOCKADDR pAddr, DWORD dwAddrLen,
> 						LPSTR lpAddrStr, LPDWORD pdwStrLen);
> int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
> 					   DWORD dwAddrLen,
> 					   LPTSTR lpAddrStr,
> 					   LPDWORD pdwStrLen);
> int  DWSEnumProtocols(LPDWSSTATE lpState, LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 		   			  LPDWORD pdwBufLen);
> int  DWSSelectProtocols(LPDWSSTATE lpState, DWORD dwSetFlags,
> 					    DWORD dwNotSetFlags,
> 					    LPWSAPROTOCOL_INFO lpProtocolBuffer,
> 					    LPDWORD lpdwBufferLength);
> BOOL DWSDnsOnly(LPDWSSTATE lpState);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1451a1453,1458
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1455a1482,1484
> 		case 2:
> 		default:
> 		{
1456a1486,1488
> 			break;
> 		}
> 	}
1530a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1531a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1534a1592,1594
> 		case 2:
> 		default:
> 		{
1535a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
136,138d136
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
146,150d143
< */
< 
< 	SetTempHostName( "", 0 );
<         SettingsDialogComplete( hr );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
840a891,903
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
842a906,1012
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
843a1014,1016
> 
> 
> //**********************************************************************
844a1018,1166
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
872,873c1194,1195
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
884a1207,1209
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
937a1263,1265
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1015c1343,1344
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1029a1359,1361
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1094a1427,1428
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1142a1477,1478
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1710a2047,2053
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1744a2088,2089
> 			break;
> 		}
1745a2091,2170
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2366a2792,2803
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2367a2805,2808
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2368a2810,2962
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2369a2964,2966
> 
> 
> //**********************************************************************
2655a3253,3313
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
291a298,299
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
60a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
243a246
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
244a248
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
247c251
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
254c258
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
281a286
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
496a566,571
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint( &EndpointPoolContext );
>     		break;
>     	}
> 
635a711,716
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
668a750,755
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,139
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
162a188
> 		m_iWinsockVersion( 0 ),
190a217
> 	DNASSERT( m_iWinsockVersion == 0 );
213c240
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
221a249
> 	m_iWinsockVersion = iWinsockVersion;
240c268,278
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
241a280,287
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
248c294,304
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
249a306,313
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
283a348,354
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a409,413
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
340a417,418
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a425,451
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
442a548,712
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
551a822,823
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
572a845
> 	}
650a924,929
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
666a946,947
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
815a1097
> 	m_IPXReadIODataPool.Deinitialize();
826a1109,1110
> 
> 	m_iWinsockVersion = 0;
874a1159,1173
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
969a1269,1277
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1224a1533,1534
> 	switch ( DNGetOSType() )
> 	{
1227a1538,1539
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1244a1557,1590
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1355a1702,1703
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1362a1711
> 	}
1683a2033,2034
> 	switch ( DNGetOSType() )
> 	{
1684a2036,2045
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1686a2048,2049
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1688a2052,2053
> 			break;
> 		}
1689a2055,2064
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1718a2094,2095
> 	switch ( DNGetOSType() )
> 	{
1719a2097,2104
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1722a2108,2109
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1732a2120,2132
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2125a2526,3321
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2522a3719,3860
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67c67,96
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
128a158,247
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
230a350
> //	we can either create an IPX instance or an IP instance
236a357,360
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
267c391,392
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
76c77
< static	HINSTANCE g_hndlWinSock;		// state info for the WS1/2 glue lib
---
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
102a104
> 	INT		iVersion;
130c132,133
< 	if ( FALSE == DWSInitWinSock( &g_hndlWinSock ) )	// failure
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
137a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
150,151c155
< 		fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 		g_hndlWinSock = NULL;
---
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
193,194c197
< 	fFreeReturn = DWSFreeWinSock( g_hndlWinSock );
< 	g_hndlWinSock = NULL;
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
205a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
206a223
> 
304a322
> 	INT_PTR iWinsockVersion;
314a333
> 	iWinsockVersion = GetWinsockVersion();
327c346
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
177a179,182
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
178a184,198
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
272a293
> 		case TYPE_IPX:
506,507c527,529
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
691c713,714
< 			if ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 )
---
> 			if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( IsEqualCLSID( DNSPInterface.pDataInterface->ClassID, CLSID_DP8SP_IPX ) == FALSE ) )
2675a2699,2710
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2887a2923,2934
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\05021600.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 140 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
66a67
> #include "DVoice.h"
97a99
> #include "Voice.h"
102d103
< #include <mmsystem.h>
1459a1461,1469
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include "DVoice.h"
67a69,70
> #include "dvoice.h"
> #include "voice.h"
115a119
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
224a229,233
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
225a235,249
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
257a282,285
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
286a315,321
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
546a582,584
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
771a810,814
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
95a96
> #include "DVoice.h"
128a130
> #include "Voice.h"
135d136
< #include <mmsystem.h>
1408a1410,1414
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
159a161
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
199a202,207
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
267a276,280
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
75,76c75
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c77,87
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,83c89,91
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
85,86c93,94
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
---
> 	DPF(3,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%lx], pSPInfoBuffer [0x%lx], pcbEnumData [0x%lx], pcReturned [0x%lx]",
> 		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
87a96,101
> 	DNASSERT(pcbEnumData != NULL);
> 	DNASSERT(pcReturned != NULL);
> 
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> 
91,92c105,110
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
94,95c112,137
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	// Set up to enumerate
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
97,98c139,143
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	// Enumerate !
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
99a145,215
> 		// Get friendly name and GUID from each sub key
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(7,"skipping %S",pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(7,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(7,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		DPF(7,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPFERR("SubEntry.ReadGUID failed - skipping entry");
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
106c222
< 		goto Exit;
---
> 		goto Failure;
110c226
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
115c231,232
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
117a235,236
> 
> Exit:
119a239,260
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
133,137d273
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
287d422
< */	return(E_FAIL);
582d716
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25a26
> #include "DVoice.h"
48a50
> #include "voice.h"
51a54,55
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
> 
2187a2192
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
93,94d92
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
127a126,128
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40c40
< //#include "CReg.h"
---
> #include "CReg.h"
98,102d97
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
405d399
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26c26
< //#include "CReg.h"
---
> #include "CReg.h"
68,72d67
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
255d249
< */ return(E_FAIL);
276,280d269
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
574d562
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< #define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< #define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< #define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< #define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< #define p_WSAAsyncGetServByName WSAAsyncGetServByName
< #define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< #define p_WSAAsyncSelect WSAAsyncSelect
< #define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< 	#define p_WSAAddressToString				WSAAddressToStringW
< 	#define p_WSADuplicateSocket				WSADuplicateSocketW
< 	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< 	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< 	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< 	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< 	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< 	#define p_WSALookupServiceNext				WSALookupServiceNextW
< 	#define p_WSASetService						WSASetServiceW
< 	#define p_WSASocket							WSASocketW
< 	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< 	#define p_WSAAddressToString				WSAAddressToStringA
< 	#define p_WSADuplicateSocket				WSADuplicateSocketA
< 	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< 	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< 	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< 	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< 	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< 	#define p_WSALookupServiceNext				WSALookupServiceNextA
< 	#define p_WSASetService						WSASetServiceA
< 	#define p_WSASocket							WSASocketA
< 	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< #define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< #define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< #define p_WSAGetQOSByName WSAGetQOSByName
< #define p_WSAHtonl WSAHtonl
< #define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< #define p_WSAJoinLeaf WSAJoinLeaf
< #define p_WSALookupServiceEnd WSALookupServiceEnd
< #define p_WSANtohl WSANtohl
< #define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< #define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< #define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< #define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1451a1453,1458
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1455a1482,1484
> 		case 2:
> 		default:
> 		{
1456a1486,1488
> 			break;
> 		}
> 	}
1530a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1531a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1534a1592,1594
> 		case 2:
> 		default:
> 		{
1535a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
136,138d136
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
146,150d143
< */
< 
< 	SetTempHostName( "", 0 );
<         SettingsDialogComplete( hr );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
840a891,903
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
842a906,1012
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
843a1014,1016
> 
> 
> //**********************************************************************
844a1018,1166
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
872,873c1194,1195
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
884a1207,1209
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
937a1263,1265
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1015c1343,1344
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1029a1359,1361
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1094a1427,1428
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1142a1477,1478
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1710a2047,2053
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1744a2088,2089
> 			break;
> 		}
1745a2091,2170
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2366a2792,2803
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2367a2805,2808
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2368a2810,2962
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2369a2964,2966
> 
> 
> //**********************************************************************
2655a3253,3313
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
291a298,299
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
51,52c51
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\ws2_32.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
61a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
82a93
> 	 ..\DWinsock.cpp \
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
243a246
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
244a248
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
247c251
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
254c258
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
281a286
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
496a566,571
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint( &EndpointPoolContext );
>     		break;
>     	}
> 
635a711,716
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
668a750,755
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,139
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
162a188
> 		m_iWinsockVersion( 0 ),
190a217
> 	DNASSERT( m_iWinsockVersion == 0 );
213c240
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
221a249
> 	m_iWinsockVersion = iWinsockVersion;
240c268,278
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
241a280,287
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
248c294,304
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
249a306,313
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
283a348,354
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a409,413
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
340a417,418
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a425,451
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
442a548,712
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
551a822,823
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
572a845
> 	}
650a924,929
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
666a946,947
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
815a1097
> 	m_IPXReadIODataPool.Deinitialize();
826a1109,1110
> 
> 	m_iWinsockVersion = 0;
874a1159,1173
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
969a1269,1277
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1224a1533,1534
> 	switch ( DNGetOSType() )
> 	{
1227a1538,1539
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1244a1557,1590
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1355a1702,1703
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1362a1711
> 	}
1683a2033,2034
> 	switch ( DNGetOSType() )
> 	{
1684a2036,2045
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1686a2048,2049
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1688a2052,2053
> 			break;
> 		}
1689a2055,2064
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1718a2094,2095
> 	switch ( DNGetOSType() )
> 	{
1719a2097,2104
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1722a2108,2109
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1732a2120,2132
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2125a2526,3321
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2522a3719,3860
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67c67,96
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
128a158,247
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
230a350
> //	we can either create an IPX instance or an IP instance
236a357,360
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
267c391,392
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
48,51d49
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
78a77,78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
103a104
> 	INT		iVersion;
129c130
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
131,137c132,133
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
139,141c135,137
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
143d138
< 
145a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
155c152,160
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
185a191,193
> 	BOOL	fFreeReturn;
> 
> 
189c197,201
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
196a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
197a223
> 
295a322
> 	INT_PTR iWinsockVersion;
305a333
> 	iWinsockVersion = GetWinsockVersion();
318c346
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
177a179,182
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
178a184,198
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
272a293
> 		case TYPE_IPX:
506,507c527,529
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
691c713,714
< 			if ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 )
---
> 			if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( IsEqualCLSID( DNSPInterface.pDataInterface->ClassID, CLSID_DP8SP_IPX ) == FALSE ) )
2675a2699,2710
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2887a2923,2934
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\05091400.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 161 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
107a108,111
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
140a145
> 	OSVERSIONINFO	OSVersionInfo;
141a147
> 
149a156,166
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
162a180,183
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
262a284,285
> 		switch ( DNGetOSType() )
> 		{
265a289,290
> 			case VER_PLATFORM_WIN32_NT:
> 			{
289a315,325
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
316a353,368
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,100
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
69a70
> #include "DVoice.h"
100a102
> #include "Voice.h"
105d106
< #include <mmsystem.h>
1461a1463,1471
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39a40
> #include "DVoice.h"
68a70,71
> #include "dvoice.h"
> #include "voice.h"
116a120
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
578a614,616
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
844a883,887
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
101a102
> #include "DVoice.h"
134a136
> #include "Voice.h"
141d142
< #include <mmsystem.h>
1418a1420,1424
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
159a161
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
199a202,207
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
267a276,280
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43c43
< //#include "CReg.h"
---
> #include "CReg.h"
79,80c79
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
82c81,91
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
84,87c93,95
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
97,99c105,106
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
< 
---
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
105,106c112,117
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
108,109c119,146
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
111,112c148,161
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
113a163,254
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> 				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
117c258
< 		DPF(7,"Buffer too small");
---
> 		DPF(5,"Buffer too small");
120c261
< 		goto Exit;
---
> 		goto Failure;
124c265,266
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
129c271,272
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
132c275,277
< 	DPF(3,"Returning: [0x%lx]",hResultCode);
---
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
133a279,300
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
147,151d313
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
301d462
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26a27
> #include "DVoice.h"
49a51
> #include "voice.h"
52a55
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
2189a2193
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
396a397,400
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,66
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
78a83
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
389,390c394,396
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
452a459
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
96,97d95
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
130a129,131
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42c42
< //#include "CReg.h"
---
> #include "CReg.h"
101,105d100
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
408d402
< */	return(E_FAIL);
791a786,787
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
809a806,845
> 	}
> 	else
> 	{
>     	// More setup
>     	siA.cb = sizeof(STARTUPINFO);
>     	siA.lpReserved = NULL;
>     	siA.lpDesktop = NULL;
>     	siA.lpTitle = NULL;
>     	siA.dwFlags = 0;
>     	siA.cbReserved2 = 0;
>     	siA.lpReserved2 = NULL;	    
>     	
> 	    DPF( 1, "Detected 9x, Doing Unicode launch" );
> 	    
>     	if( FAILED( hResultCode = DPL_AllocAndConvertToAnsi( &pszUnExpanded, pwszUnexpanded ) ) )
>     	{
>     	    dwError = GetLastError();
>     	    DPF( 0, "String conversion failed dwError = [0x%lx]", dwError );
>     	    hResultCode = DPNERR_CONVERSION;
>     	    goto CLEANUP_DPLLaunch;
>     	}
> 
>     	if( FAILED( hResultCode = DPL_AllocAndConvertToAnsi( &pszDefaultDir, pdplProgramDesc->pwszCurrentDirectory ) ) )
>     	{
>     	    dwError = GetLastError();
>     	    DPF( 0, "String conversion failed dwError = [0x%lx]", dwError );
>     	    hResultCode = DPNERR_CONVERSION;
>     	    goto CLEANUP_DPLLaunch;
>     	}
> 
>     	// Launch !
>     	if (CreateProcessA(NULL,pszUnExpanded,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
>     			pszDefaultDir,&siA,&pi) == 0)
>     	{
>     		dwError = GetLastError();
>     		DPF( 0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
>     		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
>     		goto CLEANUP_DPLLaunch;
>     	}	    
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< //#include "CReg.h"
---
> #include "CReg.h"
58,62d57
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
154d148
< */ return(E_FAIL);
171,175d164
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
344d332
< */ return(E_FAIL);
365,369d352
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
659d641
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,245
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a269,270
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a319,324
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a445,451
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a455,478
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a511,512
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a533,534
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1451a1453,1458
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1455a1482,1484
> 		case 2:
> 		default:
> 		{
1456a1486,1488
> 			break;
> 		}
> 	}
1530a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1531a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1534a1592,1594
> 		case 2:
> 		default:
> 		{
1535a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
136,138d136
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
146,150d143
< */
< 
< 	SetTempHostName( "", 0 );
<         SettingsDialogComplete( hr );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,272
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
264a274,278
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
408a423,448
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> ////			HRESULT	hTempResult;
> //			THREAD_POOL_JOB	*pTemp;
> //
> //
> //			pTemp = m_pRemoveSocketPortData;
> //			m_pRemoveSocketPortData = NULL;
> //			INT3;
> ////			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> ////			if ( hTempResult != DPN_OK )
> ////			{
> ////			    DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> ////			    DisplayDNError( 0, hTempResult );
> ////			}
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 
> 		}
> 
837a878,890
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
839a893,999
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
840a1001,1003
> 
> 
> //**********************************************************************
841a1005,1155
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> //	TempBuffer = static_cast<char*>( DNMalloc( MAX_MESSAGE_SIZE ) );
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
869,870c1183,1184
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
881a1196,1198
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
934a1252,1254
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1012c1332,1333
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1026a1348,1350
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1091a1416,1417
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1139a1466,1467
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1707a2036,2042
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1741a2077,2078
> 			break;
> 		}
1742a2080,2152
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 					DPF( 0, "Problem issuing initial read in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> //				//
> //				// Winsock 1.x
> //				//
> //				case 1:
> //				{
> //				    //
> //				    // we're handing this I/O request off to another thread, up reference count
> //				    //
> //				    AddRef();
> //				    fReferenceAdded = TRUE;
> //				    DNASSERT( m_pRemoveSocketPortData == NULL );
> //				    INT3;
> ////				    hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> ////				    if ( hr != DPN_OK )
> ////				    {
> ////				    	DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> ////				    	DisplayDNError( 0, hr );
> ////				    	goto Failure;
> ////				    }
> //				    DNASSERT( m_pRemoveSocketPortData != NULL );
> //
> //				    break;
> //				}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2382a2793,2964
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
51,52c51
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\ws2_32.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
61a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
82a93
> 	 ..\DWinsock.cpp \
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
243a246
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
244a248
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
247c251
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
254c258
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
281a286
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
496a566,571
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint( &EndpointPoolContext );
>     		break;
>     	}
> 
635a711,716
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
668a750,755
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
235c259,266
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
237c268,269
< 	)
---
> 						break;
> 					}
238a271,278
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
245c285,292
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
247c294,295
< 	)
---
> 						break;
> 					}
248a297,304
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
282a339,345
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
336a400,404
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
339a408,409
> 		case VER_PLATFORM_WIN32_NT:
> 		{
345a416,442
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
441a539,708
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> //	switch ( LOWORD( GetWinsockVersion() ) )
> //	{
> //		//
> //		// Winsock2, use events to signal I/O completion
> //		//
> //		case 2:
> //		{
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the events
> 	// even though the they might not be used because the network layer might
> 	// only support Winsock1.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> //		    break;
> //		}
> //
> //		//
> //		// Winsock1, nothing special to do
> //		//
> //		case 1:
> //		{
> //		    break;
> //		}
> //
> //		default:
> //		{
> //		    INT3;
> //		}
> //	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
550a818,819
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
571a841
> 	}
649a920,925
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
665a942,943
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
814a1093
> 	m_IPXReadIODataPool.Deinitialize();
873a1153,1167
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
968a1263,1271
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1223a1527,1528
> 	switch ( DNGetOSType() )
> 	{
1226a1532,1533
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1243a1551,1579
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1354a1691,1692
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1361a1700
> 	}
1682a2022,2023
> 	switch ( DNGetOSType() )
> 	{
1683a2025,2034
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1685a2037,2038
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1687a2041,2042
> 			break;
> 		}
1688a2044,2053
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1717a2083,2084
> 	switch ( DNGetOSType() )
> 	{
1718a2086,2093
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1721a2097,2098
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1731a2109,2121
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1975a2366
> 
1977a2369,2625
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	
> 
> //	DNASSERT( pSocketPort != NULL );
> //	DNASSERT( pCancelFunction != NULL );
> //	DNASSERT( ppRemoveSocketPortData != NULL );
> //	DNASSERT( *ppRemoveSocketPortData == NULL );
> //
> //	//
> //	// initialize
> //	//
> //	hr = DPN_OK;
> //	pJobData = NULL;
> //	pRemoveSocketPortData = NULL;
> //
> //	LockJobData();
> //
> //	//
> //	// always reserve a space for this socket and clean it up on a failure
> //	//
> //	m_uReservedSocketCount++;
> //
> //	//
> //	// We're capped by the number of sockets we can use for Winsock1.  Make
> //	// sure we don't allocate too many sockets.
> //	//
> //	if ( m_uReservedSocketCount == ( FD_SETSIZE + 1 ) )
> //	{
> //		hr = DPNERR_OUTOFMEMORY;
> //		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> //		goto Failure;
> //	}
> //
> //	//
> //	// Allocate memory for job data.  Preallocate the remove socket port job so
> //	// we don't need to worry about being out of memory when we want to remove
> //	// the socket port.
> //	//
> //	pJobData = static_cast<WORK_THREAD_JOB*>( m_JobPool.Get( &m_JobPool ) );
> //	if ( pJobData == NULL )
> //	{
> //		hr = DPNERR_OUTOFMEMORY;
> //		DPF( 0, "Cannot allocate memory for SubmitAddSocketPort job!" );
> //		goto Failure;
> //	}
> //
> //	pRemoveSocketPortData = static_cast<WORK_THREAD_JOB*>( m_JobPool.Get( &m_JobPool ) );
> //	if ( pRemoveSocketPortData == NULL )
> //	{
> //		hr = DPNERR_OUTOFMEMORY;
> //		DPF( 0, "Cannot allocate memory for SubmitRemoveSocketPort job!" );
> //	}
> //
> //	//
> //	// set information
> //	//
> //	pJobData->JobType = JOB_ADD_WIN9X_SOCKET;
> //	pJobData->JobData.JobAddSocket.pSocketPort = pSocketPort;
> //	pJobData->pCancelFunction = pCancelFunction;
> //
> //	pRemoveSocketPortData->JobType = JOB_REMOVE_WIN9X_SOCKET;
> //	pRemoveSocketPortData->JobData.JobRemoveSocket.pSocketPort = pSocketPort;
> //
> //	hr = SubmitWorkItem( pJobData );
> //	if ( hr != DPN_OK )
> //	{
> //		DPF( 0, "Problem submitting AddSocketPort job!" );
> //		DisplayDNError( 0, hr );
> //		goto Failure;
> //	}
> //
> Exit:
> 	Unlock();
> //	*ppRemoveSocketPortData = pRemoveSocketPortData;
> //	UnlockJobData();
> //
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> //	if ( pJobData != NULL )
> //	{
> //		m_JobPool.Release( &m_JobPool, pJobData );
> //		pJobData = NULL;
> //	}
> //
> //	if ( pRemoveSocketPortData != NULL )
> //	{
> //		m_JobPool.Release( &m_JobPool, pRemoveSocketPortData );
> //		pRemoveSocketPortData = NULL;
> //	}
> //
> //	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> 
> //	//
> //	// set information
> //	//
> //	DNASSERT( pRemoveSocketPortData->JobType == JOB_REMOVE_WIN9X_SOCKET );
> //	DNASSERT( pRemoveSocketPortData->JobData.JobRemoveSocket.pSocketPort == pSocketPort );
> //	pRemoveSocketPortData->pCancelFunction = pCancelFunction;
> //
> //	hr = SubmitWorkItem( pRemoveSocketPortData );
> //	if ( hr != DPN_OK )
> //	{
> //		DPF( 0, "Problem submitting RemoveSocketPort job!" );
> //		DisplayDNError( 0, hr );
> //		goto Failure;
> //	}
> //
> //Exit:
> //	UnlockJobData();
> //
> //	return	hr;
> //
> //Failure:
> //	DNASSERT( pRemoveSocketPortData != NULL );
> //	m_JobPool.Release( &m_JobPool, pRemoveSocketPortData );
> //
> //	goto Exit;
> }
> //**********************************************************************
> 
> 
> 
> //**********************************************************************
> // ------------------------------
2124a2773,3749
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = SelectTimeslice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> //	while ( fLooping != FALSE )
> //	{
> 		//
> 		// check for Winsock1 sockets.  If there are some around, we need to
> 		// use the 'select' call to perform the timing
> 		//
> //
> //		pThisThreadPool->Lock();
> //		if ( pSocketSet->fd_count == 0 )
> //		{
> //			DWORD	dwWaitReturn;
> //
> //
> //			pThisThreadPool->Unlock();
> //			//
> //			// There are no sockets active.  Wait for the SP to close, a job
> //			// to be submitted, or a timeout for enumeration.
> //			//
> //			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> ////			dwElapsedTime = GetTickCount();
> //
> //			DNTimeGet( &CurrentTime );
> //			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> //			{
> //				pThisThreadPool->LockTimerData();
> //				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> //																			   &CoreData.NextTimerJobTime );
> //				if ( CoreData.fTimerJobsActive != FALSE )
> //				{
> //					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> //				}
> //				pThisThreadPool->UnlockTimerData();
> //			}
> //
> //			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> //			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> //
> //#pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> //			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> //
> //			dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> //													 CoreData.hWaitHandles,					// handles to wait on
> //													 FALSE,									// don't wait for all to be signalled
> //													 dwMaxWaitTime,							// wait timeout
> //													 TRUE									// we're alertable for APCs
> //													 );
> //			switch ( dwWaitReturn )
> //			{
> //				//
> //				// timeout, don't do anything, we'll probably process jobs on the next loop
> //				//
> //				case WAIT_TIMEOUT:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// New job.  Account for the time spent in the wait.  Don't
> //				// account for time after the job is complete because it's
> //				// possible that the job was an job submission which will want
> //				// to reset the wait time.
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> //				{
> //					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> //
> //					pThisThreadPool->ProcessWin9xJob( &CoreData );
> //
> //					break;
> //				}
> //
> //				//
> //				// SP closing
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> //				{
> //					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> //					fLooping = FALSE;
> //
> //					break;
> //				}
> //
> //				//
> //				// Winsock2 send complete
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> //				{
> //					//
> //					// reset the event so it will be signalled again if anything
> //					// completes while we're scanning the pending write list
> //					//
> //					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> //					{
> //						DWORD	dwError;
> //
> //
> //						dwError = GetLastError();
> //						DPF( 0, "Failed to reset Winsock2 send event!" );
> //						DisplayErrorCode( 0, dwError );
> //					}
> //
> //					pThisThreadPool->CompleteOutstandingSends();
> //					break;
> //				}
> //
> //				//
> //				// Winsock2 receive complete
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> //				{
> //					//
> //					// reset the event so it will be signalled again if anything
> //					// completes while we're scanning the pending read list
> //					//
> //					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> //					{
> //						DWORD	dwError;
> //
> //
> //						dwError = GetLastError();
> //						DPF( 0, "Failed to reset Winsock2 receive event!" );
> //						DisplayErrorCode( 0, dwError );
> //					}
> //
> //					pThisThreadPool->CompleteOutstandingReceives();
> //					break;
> //				}
> //
> //				//
> //				// There are I/O completion routines scheduled on this thread,
> //				// no problem.
> //				//
> //				case WAIT_IO_COMPLETION:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// wait failed
> //				//
> //				case WAIT_FAILED:
> //				{
> //					DWORD	dwError;
> //
> //
> //					dwError = GetLastError();
> //					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> //					DisplayDNError( 0, dwError );
> //					break;
> //				}
> //
> //				//
> //				// problem
> //				//
> //				default:
> //				{
> //					DWORD	dwError;
> //
> //
> //					dwError = GetLastError();
> //					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> //					DisplayDNError( 0, dwError );
> //					DNASSERT( FALSE );
> //					break;
> //				}
> //			}
> //		} // if ( CoreData.dwActiveSocketCount == 0 )
> //		else
> //		{
> //			INT				iSelectReturn;
> //			DWORD			dwWaitReturn;
> //			FD_SET			ReadSocketSet;
> //			FD_SET			WriteSocketSet;
> //			FD_SET			ErrorSocketSet;
> //
> //
> //			pThisThreadPool->Unlock();
> //
> //			//
> //			// Update the job time so we know how long to wait.  We can
> //			// only get here if a socket was just added to the socket list, or
> //			// we've been servicing sockets.
> //			//
> //
> //			DNTimeGet( &CurrentTime );
> //
> //			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> //			{
> //				pThisThreadPool->LockTimerData();
> //				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> //																			   &CoreData.NextTimerJobTime );
> //				if ( CoreData.fTimerJobsActive != FALSE )
> //				{
> //					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> //				}
> //				pThisThreadPool->UnlockTimerData();
> //			}
> //
> //			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> //#pragma	BUGBUG( johnkan, "Busted Win64!" )
> //			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> //
> //			//
> //			// Wait for something to happen on a socket or wait for next enum
> //			// service.  We're supposed to pass select times in microseconds,
> //			// but multiplying by 1000 is slower than letting the compiler
> //			// get fancy with multiplying by 1024, and the relative error
> //			// is negligible.
> //			//
> //			//
> //			if ( SelectTimeslice < dwMaxWaitTime )
> //			{
> //				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> //			}
> //			else
> //			{
> //				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> //			}
> //
> //			//
> //			// Make a local copy of all of the sockets.  This isn't totally
> //			// efficient, but it works.  Multiplying by active socket count will
> //			// spend half the time in the integer multiply.
> //			//
> //			pThisThreadPool->Lock();
> //			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> //			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> //			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> //			pThisThreadPool->Unlock();
> //
> //			DNASSERT( SelectTimeout.tv_sec == 0 );
> //			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> //									  &ReadSocketSet,	// sockets to check for read
> //									  NULL,				// sockets to check for write (don't check writes)
> //									  &ErrorSocketSet,	// sockets to check for error
> //									  &SelectTimeout	// wait timeout
> //									  );
> //			switch ( iSelectReturn )
> //			{
> //				//
> //				// timeout
> //				//
> //				case 0:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// select got pissed
> //				//
> //				case SOCKET_ERROR:
> //				{
> //					DWORD	dwWSAError;
> //
> //
> //					dwWSAError = p_WSAGetLastError();
> //					switch ( dwWSAError )
> //					{
> //						//
> //						// This socket was probably closed
> //						//
> //						case WSAENOTSOCK:
> //						{
> //							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> //							break;
> //						}
> //
> //						//
> //						// other
> //						//
> //						default:
> //						{
> //							DPF( 0, "Problem selecting all sockets for service!" );
> //							DisplayWinsockError( 0, dwWSAError );
> //							INT3;
> //							break;
> //						}
> //					}
> //
> //					break;
> //				}
> //
> //				//
> //				// Check for sockets needing read service and error service.
> //				//
> //				default:
> //				{
> //					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> //					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> //
> //					break;
> //				}
> //			}
> //
> //			//
> //			// check for writes only
> //			//
> //			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> //									  NULL,				// sockets to check for read (don't check reads)
> //									  &WriteSocketSet,	// sockets to check for write
> //									  NULL,				// sockets to check for error (don't check errors)
> //									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> //									  );
> //			switch ( iSelectReturn )
> //			{
> //				//
> //				// timeout
> //				//
> //				case 0:
> //				{
> //					INT3;
> //					break;
> //				}
> //
> //				//
> //				// select got pissed
> //				//
> //				case SOCKET_ERROR:
> //				{
> //					DWORD	dwWSAError;
> //
> //
> //					dwWSAError = p_WSAGetLastError();
> //					switch ( dwWSAError )
> //					{
> //						//
> //						// this socket was probably closed
> //						//
> //						case WSAENOTSOCK:
> //						{
> //							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> //							break;
> //						}
> //
> //						//
> //						// other
> //						//
> //						default:
> //						{
> //							DPF( 0, "Problem selecting write sockets for service!" );
> //							DisplayWinsockError( 0, dwWSAError );
> //							INT3;
> //
> //							break;
> //						}
> //					}
> //
> //					break;
> //				}
> //
> //				//
> //				// Check for sockets needing write service
> //				//
> //				default:
> //				{
> //					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> //
> //					break;
> //				}
> //			}
> //
> //			//
> //			// since we just serviced sockets, make a quick check for pending
> //			// events
> //			//
> //			dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),	// count of handles
> //													 CoreData.hWaitHandles,				// handles to wait on
> //													 FALSE,								// don't wait for all to be signalled
> //													 0,									// make a quick check
> //													 TRUE								// we're alertable for APCs
> //													 );
> //			switch ( dwWaitReturn )
> //			{
> //				//
> //				// nothing was signalled, keep looping
> //				//
> //				case WAIT_TIMEOUT:
> //				{
> //					break;
> //				}
> //
> //				//
> //				// SP closing
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> //				{
> //					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> //					fLooping = FALSE;
> //
> //					break;
> //				}
> //
> //				//
> //				// pending job
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> //				{
> //					pThisThreadPool->ProcessWin9xJob( &CoreData );
> //
> //					break;
> //				}
> //
> //				//
> //				// Winsock 2 I/O complete, we should not be getting this if
> //				// we're using Winsock1 support!!!
> //				//
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> //				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> //				{
> //					DNASSERT( FALSE );
> //					break;
> //				}
> //
> //				//
> //				// problem
> //				//
> //				default:
> //				{
> //					DWORD	dwError;
> //
> //
> //					dwError = GetLastError();
> //					DPF( 0, "Win9x wait for events with sockets active failed!" );
> //					DisplayErrorCode( 0, dwError );
> //					DNASSERT( FALSE );
> //					break;
> //				}
> //			}
> //		}
> //	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2521a4147,4501
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> //		//
> //		// start monitoring a port for I/O
> //		//
> //		case JOB_ADD_WIN9X_SOCKET:
> //		{
> //			DPF( 8, "WorkThread job ADD_SOCKET" );
> //
> //			//
> //			// add this port to the ends of the lists
> //			//
> //			LockJobData();
> //
> //			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> //			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> //			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> //			m_SocketSet.fd_count++;
> //
> //			UnlockJobData();
> //
> //			break;
> //		}
> //
> //		//
> //		// stop monitoring a port for I/O
> //		//
> //		case JOB_REMOVE_WIN9X_SOCKET:
> //		{
> //			UINT_PTR	uIdx;
> //
> //
> //			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> //
> //			//
> //			// remove this port from the lists
> //			//
> //			LockJobData();
> //
> //			DNASSERT( m_uReservedSocketCount != 0 );
> //			uIdx = m_SocketSet.fd_count;
> //			DNASSERT( uIdx != 0 );
> //			do
> //			{
> //				uIdx--;
> //
> //				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> //				{
> //					m_uReservedSocketCount--;
> //					m_SocketSet.fd_count--;
> //
> //					//
> //					// release our I/O reference to this item and shift all other entries down in
> //					// the socket array
> //					//
> //					m_pSocketPorts[ uIdx ]->DecRef();
> //					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> //					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> //
> //					//
> //					// clear last entry (which is now unused) in the debug build
> //					//
> //					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> //					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> //
> //					//
> //					// end the loop.
> //					//
> //					uIdx = 0;
> //				}
> //			} while ( uIdx != 0 );
> //
> //			UnlockJobData();
> //
> //			break;
> //		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting all sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uSocketCount;
> 
> 
> 	uSocketCount = pSocketSet->fd_count;
> 	while ( uSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		DNASSERT( uIdx != 0 );
> 		do
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// call the service function and stop the loop
> 				//
> 				(m_pSocketPorts[ uIdx ]->*pServiceFunction)();
> 				uIdx = 0;
> 			}
> 
> 		} while ( uIdx > 0 );
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
156a161,163
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
203a211
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a277
> 		HRESULT	Win9xInit( void );
278a288,289
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a291
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
288c300,303
< 		void	ServiceSockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
---
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67c67,96
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
128a158,247
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
230a350
> //	we can either create an IPX instance or an IP instance
236a357,360
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
267c391,392
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
48,51d49
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
78a77,78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
103a104
> 	INT		iVersion;
129c130
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
131,137c132,133
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
139,141c135,137
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
143d138
< 
145a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
155c152,160
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
185a191,193
> 	BOOL	fFreeReturn;
> 
> 
189c197,201
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
196a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
197a223
> 
295a322
> 	INT_PTR iWinsockVersion;
305a333
> 	iWinsockVersion = GetWinsockVersion();
318c346
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize();
549a578,579
> 	WCHAR	cMillenniumHack;
> 	WCHAR*	pMillenniumHack = pWCHARString;
555a586,589
> 
> 	if ( pMillenniumHack < (WCHAR*) 0x0000FFFF )
> 		pMillenniumHack = &cMillenniumHack;
> 
561c595
< 								   pWCHARString,			// pointer to destination wide-char string
---
> 								   pMillenniumHack,			// pointer to destination wide-char string
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
177a179,182
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
179a185,200
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
274a296
> 		case TYPE_IPX:
508,509c530,532
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
693c716,717
< 			if ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 )
---
> 			if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( IsEqualCLSID( DNSPInterface.pDataInterface->ClassID, CLSID_DP8SP_IPX ) == FALSE ) )
2677a2702,2713
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2889a2926,2937
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\05031030.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipui.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 57 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\search.out	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 143 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,104
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
133a138
> 	OSVERSIONINFO	OSVersionInfo;
134a140
> 
142a149,159
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
155a173,176
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
255a277,278
> 		switch ( DNGetOSType() )
> 		{
258a282,283
> 			case VER_PLATFORM_WIN32_NT:
> 			{
282a308,318
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
309a346,361
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
89a90,97
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67a68
> #include "DVoice.h"
98a100
> #include "Voice.h"
103d104
< #include <mmsystem.h>
1462a1464,1472
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include "DVoice.h"
67a69,70
> #include "dvoice.h"
> #include "voice.h"
115a119
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
224a229,233
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
225a235,249
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
257a282,285
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
286a315,321
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
546a582,584
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
771a810,814
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(5,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
97a98
> #include "DVoice.h"
130a132
> #include "Voice.h"
137d138
< #include <mmsystem.h>
1410a1412,1416
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
159a161
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
199a202,207
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
267a276,280
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42c42
< //#include "CReg.h"
---
> #include "CReg.h"
78,79c78
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
81c80,90
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
83,86c92,94
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
96,98c104,105
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
< 
---
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
104,105c111,116
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
107,108c118,145
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
110,111c147,160
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
112a162,250
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 		if (hResultCode != DPN_OK)
> 		{
> 			DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			hResultCode = DPN_OK; // override return code
> 			continue;
> 		}
> 		else
> 		{
> 			DN_SPRelease(pdnObject,&guid);
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
116c254
< 		DPF(7,"Buffer too small");
---
> 		DPF(5,"Buffer too small");
119c257
< 		goto Exit;
---
> 		goto Failure;
123c261,262
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
128c267,268
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
131c271,273
< 	DPF(3,"Returning: [0x%lx]",hResultCode);
---
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
132a275,296
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
146,150d309
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
300d458
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
25a26
> #include "DVoice.h"
48a50
> #include "voice.h"
51a54
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
2188a2192
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
375a376,379
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61a62,65
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
77a82
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388,389c393,395
< #define DPNA_VALUE_MODEMPROVIDER                    L"MODEM"
< #define DPNA_VALUE_SERIALPROVIDER                   L"SERIAL"
---
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
447a454
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
94,95d93
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
128a127,129
> 
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42c42
< //#include "CReg.h"
---
> #include "CReg.h"
100,104d99
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
407d401
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< //#include "CReg.h"
---
> #include "CReg.h"
58,62d57
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
154d148
< */ return(E_FAIL);
171,175d164
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
344d332
< */ return(E_FAIL);
365,369d352
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
659d641
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
97c97,98
< STYLE 
---
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
100a102,106
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,267
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown state
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.x, or higher
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a291,292
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a341,346
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a467,473
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a477,521
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// unknown
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// winsock 1, 2.X or greater
> 				//
> 				case 1:
> 				case 2:
> 				default:
> 				{
> 					DNASSERT( NTCompletionFunction() == NULL );
> 					DNASSERT( OverlapEvent() == NULL );
> 					break;
> 				}
> 			}
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a554,555
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a576,577
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
1451a1453,1458
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1452a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1455a1482,1484
> 		case 2:
> 		default:
> 		{
1456a1486,1488
> 			break;
> 		}
> 	}
1530a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1531a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1534a1592,1594
> 		case 2:
> 		default:
> 		{
1535a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
136,138d136
< 
< /* BUGBUG: [mgere] Removed UI.  Find cleaner way of doing this.
< 
146,150d143
< */
< 
< 	SetTempHostName( "", 0 );
<         SettingsDialogComplete( hr );
< 	hr = S_OK;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipui.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,266
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
264a268,285
> 		// something's not right!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// winsock 1.x
> 		//
> 		case 1:
> 		{
> 			m_pSendFunction = Winsock1Send;
> 			break;
> 		}
> 
> 		//
266a288,290
> 		case 2:
> 		default:
> 		{
267a292,294
> 			break;
> 		}
> 	}
411a439,461
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( LOWORD( GetWinsockVersion() ) == 1 )
> 		{
> //			HRESULT	hTempResult;
> 			THREAD_POOL_JOB	*pTemp;
> 
> 
> 			pTemp = m_pRemoveSocketPortData;
> 			m_pRemoveSocketPortData = NULL;
> 			INT3;
> //			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> //			if ( hTempResult != DPN_OK )
> //			{
> //				DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> //				DisplayDNError( 0, hTempResult );
> //			}
> 		}
> 
840a891,903
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
842a906,1012
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
843a1014,1016
> 
> 
> //**********************************************************************
844a1018,1166
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
872,873c1194,1195
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
884a1207,1209
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
937a1263,1265
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1015c1343,1344
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1029a1359,1361
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1094a1427,1428
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1142a1477,1478
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1710a2047,2053
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1744a2088,2089
> 			break;
> 		}
1745a2091,2170
> 		//
> 		// we're on Win9x, ask work thread to submit a read
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 			switch ( LOWORD( GetWinsockVersion() ) )
> 			{
> 				//
> 				// invalid version
> 				//
> 				case 0:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// Winsock 1.x
> 				//
> 				case 1:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					DNASSERT( m_pRemoveSocketPortData == NULL );
> 					INT3;
> //					hr = g_pThreadPool->SubmitAddSocketPort( this, CancelAddSocketPort, &m_pRemoveSocketPortData );
> //					if ( hr != DPN_OK )
> //					{
> //						DPF( 0, "Failed to submit initial Win9x Winsock1 read for SocketPort!" );
> //						DisplayDNError( 0, hr );
> //						goto Failure;
> //					}
> 					DNASSERT( m_pRemoveSocketPortData != NULL );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2.x or greater
> 				//
> 				case 2:
> 				default:
> 				{
> 					//
> 					// we're handing this I/O request off to another thread, up reference count
> 					//
> 					AddRef();
> 					fReferenceAdded = TRUE;
> 					hr = m_pThreadPool->SubmitDelayedCommand( InitialWin9xWinsock2Read, CancelInitialWin9xWinsock2Read, this );
> 					if ( hr != DPN_OK )
> 					{
> 						DPF( 0, "Failed to submit initial Win9x Winsock2 read for SocketPort!" );
> 						DisplayDNError( 0, hr );
> 						goto Failure;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2366a2792,2803
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
2367a2805,2808
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
2368a2810,2962
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			goto Exit;
> 			
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					DNASSERT(pReadData->m_pReceiveBuffer == NULL);
> 
> 					goto SkipReturningBuffer;
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return receive buffer before returning read data to the pool
> 			//
> 			
> 			DNASSERT(pReadData->m_pReceiveBuffer != NULL);
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 			
> SkipReturningBuffer:
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	m_pThreadPool->ReturnReadIOData( pReadData );
> 	DecRef();
> 
> 	return;
> }
2369a2964,2966
> 
> 
> //**********************************************************************
2655a3253,3313
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::InitialWin9xWinsock2Read - perform initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	HRESULT			hr;
> 	CSocketPort		*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	hr = pThisSocketPort->Winsock2Receive();
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Problem with initial read on socket port!" );
> 		DisplayDNError( 0, hr );
> 	}
> 
> 	//
> 	// release the reference for the pending command
> 	//
> 	pThisSocketPort->DecRef();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::CancelInitialWin9xWinsock2Read - cancel initial read for Winsock2
> //
> // Entry:		Pointer to job header
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pDelayedCommand )
> {
> 	CSocketPort	*pThisSocketPort;
> 
> 
> 	DNASSERT( pDelayedCommand != NULL );
> 
> 	INT3;
> 	//
> 	// Since this command was for the worker thread and won't be processed,
> 	// remove the socket port reference created for this action.
> 	//
> 	pThisSocketPort = static_cast<CSocketPort*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
> 	DNASSERT( pThisSocketPort != NULL );
> 
> 	pThisSocketPort->DecRef();
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239,240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
> 
242a245,247
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
286a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
291a298,299
> 		static	void	InitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
> 		static	void	CancelInitialWin9xWinsock2Read( THREAD_POOL_JOB *const pJob );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
51,52c51
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\ws2_32.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
61a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
82a93
> 	 ..\DWinsock.cpp \
87a99,100
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
107,108d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
243a246
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
244a248
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
247c251
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
254c258
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
281a286
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
183a187,252
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 	    // Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 	    {
> 	    	break;
> 	    }
> 
> 		//
> 	    // Windows 95, 98
> 		//
> 	    case VER_PLATFORM_WIN32_WINDOWS:
> 	    {
> 			DPF( 8, "Win9x detected!" );
> 
> 
> //			DNASSERT( m_hWinsock2SendEvent == NULL );
> //			DNASSERT( m_hWinsock2ReceiveEvent == NULL );
> //
> //			//
> //			// if we're using Winsock 2 or later, use an event to signal send
> //			// completion.
> //			//
> //			INT3;
> //			if ( LOWORD( GetWinsockVersion() ) >= 2 )
> //			{
> //				m_hWinsock2SendEvent = CreateEvent( NULL,		// pointer to security (none)
> //													TRUE,		// manual-reset
> //													FALSE,		// start unsignalled
> //													NULL		// pointer to name (none)
> //													);
> //				if ( m_hWinsock2SendEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 send event!" );
> //					goto Failure;
> //				}
> //
> //				m_hWinsock2ReceiveEvent = CreateEvent( NULL,	// pointer to security (none)
> //													   TRUE,	// manual reset
> //													   FALSE,	// start unsignalled
> //													   NULL		// pointer to name (none)
> //													   );
> //				if ( m_hWinsock2ReceiveEvent == NULL )
> //				{
> //					hr = DPNERR_OUTOFMEMORY;
> //					DPF( 0, "Could not create Winsock2 receive event!" );
> //					goto Failure;
> //				}
> //			}
> 
> 			break;
> 	    }
> 
> 	    // other version (unsupported!)
> //	    case VER_PLATFORM_WIN32_CE:
> 	    case VER_PLATFORM_WIN32s:
> 	    default:
> 	    {
> 	    	DNASSERT( FALSE );
> 	    	break;
> 	    }
> 	}
> 
496a566,571
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXEndpoint( &EndpointPoolContext );
>     		break;
>     	}
> 
635a711,716
>     	case TYPE_IPX:
>     	{
>     		pReturn = CreateIPXAddress();
>     		break;
>     	}
> 
668a750,755
>     		break;
>     	}
> 
>     	case TYPE_IPX:
>     	{
>     		ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,139
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwWaitHandleCount;					// count of handles to wait on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
162a188
> 		m_iWinsockVersion( 0 ),
190a217
> 	DNASSERT( m_iWinsockVersion == 0 );
213c240
< HRESULT	CThreadPool::Initialize( void )
---
> HRESULT	CThreadPool::Initialize( const INT_PTR iWinsockVersion )
221a249
> 	m_iWinsockVersion = iWinsockVersion;
240c268,278
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
241a280,287
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
248c294,304
< 	DEBUG_ONLY( DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 ); )
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
249a306,313
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
283a348,354
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a409,413
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
340a417,418
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a425,451
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
442a548,712
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	switch ( LOWORD( GetWinsockVersion() ) )
> 	{
> 		//
> 		// Winsock2, use events to signal I/O completion
> 		//
> 		case 2:
> 		{
> 			DNASSERT( m_hWinsock2SendComplete == NULL );
> 			m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 												   TRUE,	// manual reset
> 												   FALSE,	// start unsignalled
> 												   NULL		// pointer to name (none)
> 												   );
> 			if ( m_hWinsock2SendComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Send!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 			m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 													  TRUE,		// manual reset
> 													  FALSE,	// start unsignalled
> 													  NULL		// pointer to name (none)
> 													  );
> 			if ( m_hWinsock2ReceiveComplete == NULL )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to create event for Winsock2Receive!" );
> 				DisplayErrorCode( 0, dwError );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, nothing special to do
> 		//
> 		case 1:
> 		{
> 			break;
> 		}
> 
> 		default:
> 		{
> 			INT3;
> 		}
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
551a822,823
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
572a845
> 	}
650a924,929
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
> 		pReadData->SocketPort()->Win9xWinsock2ReceiveComplete( pReadData );
666a946,947
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
815a1097
> 	m_IPXReadIODataPool.Deinitialize();
826a1109,1110
> 
> 	m_iWinsockVersion = 0;
874a1159,1173
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			if ( pTempReadData == NULL )
> 			{
> 				DPF( 0, "Failed to get new IPX ReadIOData from pool!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
969a1269,1277
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1224a1533,1534
> 	switch ( DNGetOSType() )
> 	{
1227a1538,1539
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1244a1557,1590
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				hr = DPNERR_GENERIC;
> 				dwError = GetLastError();
> 				DPF( 0, "Cannot set event for pending job!" );
> 				DisplayErrorCode( 0, dwError );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1355a1702,1703
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1362a1711
> 	}
1683a2033,2034
> 	switch ( DNGetOSType() )
> 	{
1684a2036,2045
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1686a2048,2049
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1688a2052,2053
> 			break;
> 		}
1689a2055,2064
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1718a2094,2095
> 	switch ( DNGetOSType() )
> 	{
1719a2097,2104
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1722a2108,2109
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1732a2120,2132
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
2125a2526,3321
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 	TIMEVAL				SelectTimeout = { 0 };
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> 	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> 	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	CoreData.dwWaitHandleCount = 2;
> 
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) &&
> 		 ( LOWORD( GetWinsockVersion() ) >= 2 ) )
> 	{
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 		CoreData.dwWaitHandleCount++;
> 
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 		DNASSERT( CoreData.dwWaitHandleCount >= ( EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE + 1 ) );
> 	}
> 
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		//
> 		// Since only this thread can modify m_SocketSet.fd_count, there's no
> 		// need to take a critical section to read it!
> 		//
> 		if ( pSocketSet->fd_count == 0 )
> 		{
> 			DWORD	dwWaitReturn;
> 
> 
> 			//
> 			// There are no sockets active.  Wait for the SP to close, a job
> 			// to be submitted, or a timeout for enumeration.
> 			//
> 			DPF( 8, "Entering Win9x wait without active Winsock1 sockets!" );
> //			dwElapsedTime = GetTickCount();
> 
> 			DNTimeGet( &CurrentTime );
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left on timer with no Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNASSERT( DNTimeCompare( &CoreData.NextTimerJobTime, &CurrentTime ) >= 0 );
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> 
> #pragma	BUGBUG( johnkan, "Busted on 64-bit!" )
> 			dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );
> 
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,		// count of handles
> 													 CoreData.hWaitHandles,				// handles to wait on
> 													 FALSE,								// don't wait for all to be signalled
> 													 dwMaxWaitTime,						// wait timeout
> 													 TRUE								// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// timeout, don't do anything, we'll probably process jobs on the next loop
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// New job.  Account for the time spent in the wait.  Don't
> 				// account for time after the job is complete because it's
> 				// possible that the job was an job submission which will want
> 				// to reset the wait time.
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 send complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending write list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 send event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingSends();
> 					break;
> 				}
> 
> 				//
> 				// Winsock2 receive complete
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				{
> 					//
> 					// reset the event so it will be signalled again if anything
> 					// completes while we're scanning the pending read list
> 					//
> 					if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 					{
> 						DWORD	dwError;
> 
> 
> 						dwError = GetLastError();
> 						DPF( 0, "Failed to reset Winsock2 receive event!" );
> 						DisplayErrorCode( 0, dwError );
> 					}
> 
> 					pThisThreadPool->CompleteOutstandingReceives();
> 					break;
> 				}
> 
> 				//
> 				// There are I/O completion routines scheduled on this thread,
> 				// no problem.
> 				//
> 				case WAIT_IO_COMPLETION:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// wait failed
> 				//
> 				case WAIT_FAILED:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Wait with no active Winsock1 sockets failed!" );
> 					DisplayDNError( 0, dwError );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Unknown problem in wait with no active Winsock1 sockets!" );
> 					DisplayDNError( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		} // if ( CoreData.dwActiveSocketCount == 0 )
> 		else
> 		{
> 			INT				iSelectReturn;
> 			DWORD			dwWaitReturn;
> 			FD_SET			ReadSocketSet;
> 			FD_SET			WriteSocketSet;
> 			FD_SET			ErrorSocketSet;
> 
> 
> 			//
> 			// Update the job time so we know how long to wait.  We can
> 			// only get here if a socket was just added to the socket list, or
> 			// we've been servicing sockets.
> 			//
> 
> 			DNTimeGet( &CurrentTime );
> 
> 			if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 			{
> 				pThisThreadPool->LockTimerData();
> 				CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																			   &CoreData.NextTimerJobTime );
> 				if ( CoreData.fTimerJobsActive != FALSE )
> 				{
> 					DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 				}
> 				pThisThreadPool->UnlockTimerData();
> 			}
> 
> 			DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 			dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 			//
> 			// Wait for something to happen on a socket or wait for next enum
> 			// service.  We're supposed to pass select times in microseconds,
> 			// but multiplying by 1000 is slower than letting the compiler
> 			// get fancy with multiplying by 1024, and the relative error
> 			// is negligible.
> 			//
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				SelectTimeout.tv_usec = ( SelectTimeslice * 1024 );
> 			}
> 			else
> 			{
> 				SelectTimeout.tv_usec = ( dwMaxWaitTime * 1024 );
> 			}
> 
> 			//
> 			// Make a local copy of all of the sockets.  This isn't totally
> 			// efficient, but it works.  Multiplying by active socket count will
> 			// spend half the time in the integer multiply.
> 			//
> 			memcpy( &ReadSocketSet, pSocketSet, sizeof( ReadSocketSet ) );
> 			memcpy( &WriteSocketSet, pSocketSet, sizeof( WriteSocketSet ) );
> 			memcpy( &ErrorSocketSet, pSocketSet, sizeof( ErrorSocketSet ) );
> 
> 			DNASSERT( SelectTimeout.tv_sec == 0 );
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  &ReadSocketSet,	// sockets to check for read
> 									  NULL,				// sockets to check for write (don't check writes)
> 									  &ErrorSocketSet,	// sockets to check for error
> 									  &SelectTimeout	// wait timeout
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// This socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting all sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing read service and error service.
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 					pThisThreadPool->ServiceSockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// check for writes only
> 			//
> 			iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 									  NULL,				// sockets to check for read (don't check reads)
> 									  &WriteSocketSet,	// sockets to check for write
> 									  NULL,				// sockets to check for error (don't check errors)
> 									  &g_SelectNoTime	// wait timeout (zero, do an instant check)
> 									  );
> 			switch ( iSelectReturn )
> 			{
> 				//
> 				// timeout
> 				//
> 				case 0:
> 				{
> 					INT3;
> 					break;
> 				}
> 
> 				//
> 				// select got pissed
> 				//
> 				case SOCKET_ERROR:
> 				{
> 					DWORD	dwWSAError;
> 
> 
> 					dwWSAError = p_WSAGetLastError();
> 					switch ( dwWSAError )
> 					{
> 						//
> 						// this socket was probably closed
> 						//
> 						case WSAENOTSOCK:
> 						{
> 							DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 							break;
> 						}
> 
> 						//
> 						// other
> 						//
> 						default:
> 						{
> 							DPF( 0, "Problem selecting write sockets for service!" );
> 							DisplayWinsockError( 0, dwWSAError );
> 							INT3;
> 
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 
> 				//
> 				// Check for sockets needing write service
> 				//
> 				default:
> 				{
> 					pThisThreadPool->ServiceSockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// since we just serviced sockets, make a quick check for pending
> 			// events
> 			//
> 			dwWaitReturn = WaitForMultipleObjectsEx( CoreData.dwWaitHandleCount,	// count of handles
> 													 CoreData.hWaitHandles,			// handles to wait on
> 													 FALSE,							// don't wait for all to be signalled
> 													 0,								// make a quick check
> 													 TRUE							// we're alertable for APCs
> 													 );
> 			switch ( dwWaitReturn )
> 			{
> 				//
> 				// nothing was signalled, keep looping
> 				//
> 				case WAIT_TIMEOUT:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// SP closing
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 				{
> 					DPF( 8, "WorkThread exit because SP closing with sockets active!" );
> 					fLooping = FALSE;
> 
> 					break;
> 				}
> 
> 				//
> 				// pending job
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 				{
> 					pThisThreadPool->ProcessWin9xJob( &CoreData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Winsock 2 I/O complete, we should not be getting this if
> 				// we're using Winsock1 support!!!
> 				//
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 				case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				//
> 				// problem
> 				//
> 				default:
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Win9x wait for events with sockets active failed!" );
> 					DisplayErrorCode( 0, dwError );
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2522a3719,3860
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// remove and process a single job from the list
> 	//
> 	pJobInfo = GetWorkItem();
> 	DNASSERT( pJobInfo != NULL );
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// start monitoring a port for I/O
> 		//
> 		case JOB_ADD_WIN9X_SOCKET:
> 		{
> 			DPF( 8, "WorkThread job ADD_SOCKET" );
> 
> 			//
> 			// add this port to the ends of the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 			m_pSocketPorts[ m_SocketSet.fd_count ] = pJobInfo->JobData.JobAddSocket.pSocketPort;
> 			m_SocketSet.fd_array[ m_SocketSet.fd_count ] = m_pSocketPorts[ m_SocketSet.fd_count ]->GetSocket();
> 			m_SocketSet.fd_count++;
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// stop monitoring a port for I/O
> 		//
> 		case JOB_REMOVE_WIN9X_SOCKET:
> 		{
> 			UINT_PTR	uIdx;
> 
> 
> 			DPF( 8, "WorkThread job REMOVE_SOCKET" );
> 
> 			//
> 			// remove this port from the lists
> 			//
> 			LockJobData();
> 
> 			DNASSERT( m_uReservedSocketCount != 0 );
> 			uIdx = m_SocketSet.fd_count;
> 			DNASSERT( uIdx != 0 );
> 			do
> 			{
> 				uIdx--;
> 
> 				if ( m_pSocketPorts[ uIdx ] == pJobInfo->JobData.JobRemoveSocket.pSocketPort )
> 				{
> 					m_uReservedSocketCount--;
> 					m_SocketSet.fd_count--;
> 
> 					//
> 					// release our I/O reference to this item and shift all other entries down in
> 					// the socket array
> 					//
> 					m_pSocketPorts[ uIdx ]->DecRef();
> 					memmove( &m_pSocketPorts[ uIdx ], &m_pSocketPorts[ uIdx + 1 ], ( sizeof( m_pSocketPorts[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 					memmove( &m_SocketSet.fd_array[ uIdx ], &m_SocketSet.fd_array[ uIdx + 1 ], ( sizeof( m_SocketSet.fd_array[ uIdx ] ) * ( m_SocketSet.fd_count - uIdx ) ) );
> 
> 					//
> 					// clear last entry (which is now unused) in the debug build
> 					//
> 					DEBUG_ONLY( memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) ) );
> 					DEBUG_ONLY( memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) ) );
> 
> 					//
> 					// end the loop.
> 					//
> 					uIdx = 0;
> 				}
> 			} while ( uIdx != 0 );
> 
> 			UnlockJobData();
> 
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
93c94
< 		HRESULT	Initialize( void );
---
> 		HRESULT	Initialize( const INT_PTR iWinsockVersion );
98c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
144a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
149a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
191a196
> 		INT_PTR	m_iWinsockVersion;				// version of available Winsock
203a209
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
268a275
> 		HRESULT	Win9xInit( void );
278a286,287
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
279a289
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
287a298
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
67c67,96
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
>     DNSP_QueryInterface,
>     DNSP_AddRef,
>     DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_Close,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
128a158,247
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to DirectNet
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP )
> {
> 	HRESULT 		hr;
> 	DNSPINTERFACE	Interface;
> 	BOOL			fCriticalSectionInitialized;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	Interface.pDataInterface = NULL;
> 	fCriticalSectionInitialized = FALSE;
> 
> 	//
> 	// this is the interface, with a vtble, a size, and a pointer to the object
> 	//
> 	Interface.pDataInterface = static_cast<DNSPI_DNSP_INT*>( DNMalloc( sizeof( *Interface.pDataInterface ) ) );
> 	if ( Interface.pDataInterface == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// be sure we start with a clean slate
> 	//
> 	memset( Interface.pDataInterface, 0x00, sizeof( *Interface.pDataInterface ) );
> 
> 	//
> 	// initialize objects in turn
> 	//
> 	Interface.pDataInterface->lpVtbl = &ipxInterface;
> 	Interface.pDataInterface->RefCount = 0;
> 	Interface.pDataInterface->ClassID = CLSID_DP8SP_IPX;
> 	Interface.pDataInterface->SPType = TYPE_IPX;
> 
> 	if ( DNInitializeCriticalSection( &Interface.pDataInterface->Lock ) == FALSE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to initialize critical section for WSockSP IPX interface!" );
> 		goto Failure;
> 	}
> 	fCriticalSectionInitialized = TRUE;
>     DebugSetCriticalSectionRecursionCount( &Interface.pDataInterface->Lock, 0 );
> 
> 	//
> 	// create main data class
> 	//
> 	if ( ( hr = CreateSPData( Interface.pDataInterface ) ) != DPN_OK )
> 	{
> 		DNASSERT( Interface.pDataInterface->pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( Interface.pCOMInterface != NULL );
> 	*ppiDNSP = Interface.pCOMInterface;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( fCriticalSectionInitialized != FALSE )
> 	{
> 		DNDeleteCriticalSection( &Interface.pDataInterface->Lock );
> 		fCriticalSectionInitialized = FALSE;
> 	}
> 
> 	if ( Interface.pDataInterface != NULL )
> 	{
> 		DNFree( Interface.pDataInterface );
> 		Interface.pDataInterface = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
230a350
> //	we can either create an IPX instance or an IP instance
236a357,360
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP );
> 	}
267c391,392
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP) ||
> 		IsEqualCLSID(rclsid, CLSID_DP8SP_IPX));
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
48,51d49
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
78a77,78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
103a104
> 	INT		iVersion;
129c130
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
131,137c132,133
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
139,141c135,137
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
143d138
< 
145a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
155c152,160
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
185a191,193
> 	BOOL	fFreeReturn;
> 
> 
189c197,201
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
196a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
197a223
> 
295a322
> 	INT_PTR iWinsockVersion;
305a333
> 	iWinsockVersion = GetWinsockVersion();
318c346
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize( iWinsockVersion );
549a578,579
> 	WCHAR	cMillenniumHack;
> 	WCHAR*	pMillenniumHack = pWCHARString;
555a586,589
> 
> 	if ( pMillenniumHack < (WCHAR*) 0x0000FFFF )
> 		pMillenniumHack = &cMillenniumHack;
> 
561c595
< 								   pWCHARString,			// pointer to destination wide-char string
---
> 								   pMillenniumHack,			// pointer to destination wide-char string
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58,59
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
177a179,182
>  	switch ( DNSPInterface.pDataInterface->SPType )
> 	{
> 		case TYPE_IP:
> 		{
179a185,200
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
274a296
> 		case TYPE_IPX:
508,509c530,532
< 		if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
< 			     ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) )
---
> 		if ( ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
693c716,717
< 			if ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 )
---
> 			if ( ( ( pEnumQueryData->dwFlags & DNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( IsEqualCLSID( DNSPInterface.pDataInterface->ClassID, CLSID_DP8SP_IPX ) == FALSE ) )
2677a2702,2713
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2889a2926,2937
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\05111530.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\caps.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\servprov.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dnet.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dnsp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplclient.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\lobby\dplobby.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\lobby\dplreg.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 71 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\dnet.pi	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.pr	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.ps	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnet.wk	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvlib\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dpnsvr\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\temp.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.dif\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.dsw	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.ncb	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.opt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.pi	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.plg	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.pr	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.ps	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\simplepeer.wk	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer2\obj\_objects.mac	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 164 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
107a108,111
> //
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
140a145
> 	OSVERSIONINFO	OSVersionInfo;
141a147
> 
149a156,166
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
162a180,183
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
262a284,285
> 		switch ( DNGetOSType() )
> 		{
265a289,290
> 			case VER_PLATFORM_WIN32_NT:
> 			{
289a315,325
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
316a353,368
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
92a93,100
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
71a72
>         creg.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
69a70
> #include "DVoice.h"
100a102
> #include "Voice.h"
105d106
< #include <mmsystem.h>
1461a1463,1471
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\caps.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
54,55d53
< extern HRESULT WINAPI DirectPlay8SPCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
567c565,566
<     	hr = DirectPlay8SPCreate( &IID_IDP8ServiceProvider, reinterpret_cast<void**>(&pSP), NULL );
---
>     	hr = CoCreateInstance(*pguidSP, NULL, CLSCTX_INPROC_SERVER, IID_IDP8ServiceProvider, 
>     		                  reinterpret_cast<void**>(&pSP) );
644c643,644
<     	hr = DirectPlay8SPCreate( &IID_IDP8ServiceProvider, reinterpret_cast<void**>(&pSP), NULL );
---
>     	hr = CoCreateInstance(*pguidSP, NULL, CLSCTX_INPROC_SERVER, IID_IDP8ServiceProvider, 
>     		                  reinterpret_cast<void**>(&pSP) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39a40
> #include "DVoice.h"
68a70,71
> #include "dvoice.h"
> #include "voice.h"
116a120
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
222a227,231
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
223a233,247
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
255a280,283
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
284a313,319
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
578a614,616
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
844a883,887
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
101a102
> #include "DVoice.h"
134a136
> #include "Voice.h"
141d142
< #include <mmsystem.h>
171d171
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
173d172
< 
796,798c795,799
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pIDevice),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pIDevice))) != S_OK)
873a875,878
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1415a1421,1425
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
> 
3372,3374c3382,3386
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pIHost),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pIHost))) != DPN_OK)
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
82,84d81
< 
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
201,203c198,202
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pAddress),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pAddress))) != S_OK)
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141
> #define	DN_MSG_INTERNAL_VOICE_SEND						(0x1e | DN_MSG_INTERNAL)
159a161
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
199a202,207
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> #define MAX_VOICE_CLIENTS	32	
> 
267a276,280
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43c43
< //#include "CReg.h"
---
> #include "CReg.h"
79,80c79
< // BUGBUG:  [mgere] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
82c81,91
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
84,87c93,95
< 	DWORD dwStrLen;
< 	TCHAR szFriendlyName[] = "DirectPlay8 TCP/IP Service Provider";
< 	LPWSTR pwszFriendlyName = NULL;
<     GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
97,99c105,106
< 	pwszFriendlyName = static_cast<WCHAR*>(DNMalloc((strlen(szFriendlyName)+1)*sizeof(WCHAR)));
< 	dwStrLen = MultiByteToWideChar(CP_ACP,0,szFriendlyName,-1,pwszFriendlyName,strlen(szFriendlyName)+1);
< 
---
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
105,106c112,117
< 	hResultCode = packedBuffer.AddToBack(pwszFriendlyName,(strlen(szFriendlyName)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
108,109c119,146
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
111,112c148,161
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
113a163,254
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> 				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = (LPWSTR)(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = (LPGUID)(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
117c258
< 		DPF(7,"Buffer too small");
---
> 		DPF(5,"Buffer too small");
120c261
< 		goto Exit;
---
> 		goto Failure;
124c265,266
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
129c271,272
< Exit:
---
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
132c275,277
< 	DPF(3,"Returning: [0x%lx]",hResultCode);
---
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
133a279,300
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
147,151d313
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
233,235c395,399
< 		if ((hResultCode = DirectPlay8SPCreate( IID_IDP8ServiceProvider,
<                                                 (LPVOID*)&pDNSP,
<                                                 NULL)) != DPN_OK)
---
> 		if ((hResultCode = CoCreateInstance(*lpguidSP,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDP8ServiceProvider,
> 											(LPVOID*)&pDNSP)) != DPN_OK)
299d462
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
496a497,498
> 		BOOL	fCoUninitialize = FALSE;
> 
498a501,505
> 		if (CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
499a507,511
> 
> 		if (fCoUninitialize)
> 		{
> 			CoUninitialize();
> 		}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
54,55d53
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
472c470,474
< 		hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<PVOID*>( &pAddress ), NULL);
---
> 		hResultCode = CoCreateInstance(	CLSID_DirectPlay8Address,
> 										NULL,
> 										CLSCTX_INPROC_SERVER,
> 										IID_IDirectPlay8Address,
> 										reinterpret_cast<PVOID*>(&pAddress));
580d581
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26a27
> #include "DVoice.h"
49a51
> #include "voice.h"
52a55
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
891c894,896
< 			DPF( 0, "Cannot specify NULL Host address" );
---
> 		if ( !(dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING) )
> 		{
> 			DPF( 0, "Cannot specify NULL Host address without specifying DPNENUMHOSTS_OKTOQUERYFORADDRESSING" );
892a898
> 		}
936c942
<     if( dwFlags & ~(DPNOP_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNOP_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1636c1642
<     if( dwFlags & ~(DPNOP_SYNC) )
---
>     if( dwFlags & ~(DPNOP_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
2186a2193
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\servprov.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56,57d55
< extern HRESULT WINAPI DirectPlay8SPCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
74,76c72,76
< 	if ((hResultCode = DirectPlay8SPCreate( &IID_IDP8ServiceProvider,
<                                             reinterpret_cast<void**>(&m_pDNSP),
<                                             NULL)) != DPN_OK)
---
> 	if ((hResultCode = CoCreateInstance(*pguid,
> 										NULL,
> 										CLSCTX_INPROC_SERVER,
> 										IID_IDP8ServiceProvider,
> 										reinterpret_cast<void**>(&m_pDNSP))) != DPN_OK)
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
45,46d44
<            ..\..\dnaddress\daytona\obj$(BUILD_ALT_DIR)\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
110a109
>          ..\voice.cpp \
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37d36
< #include "classfac.h"
448c447
<     hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, (void **) &lpdp8Address, NULL);
---
>     hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectPlay8Address, (void **) &lpdp8Address );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
396a397,408
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     return SetSP( &CLSID_DP8SP_SERIAL );
>                 }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
65,66d64
< HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dpnsvr\dpnsvr\dpnsvr.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnet.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53,55
> #define	CLSID_DNSP_IPX			CLSID_DP8SP_IPX
> #define	CLSID_DNSP_MODEM		CLSID_DP8SP_MODEM
> #define	CLSID_DNSP_SERIAL		CLSID_DP8SP_SERIAL
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dnsp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> #define DNSPF_OKTOQUERY				0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,66
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
78a83
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
388a394,396
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
450a459,461
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
96,97d95
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
131a130,138
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
618a626
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
622a631
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
188a189,207
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplclient.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42c42
< //#include "CReg.h"
---
> #include "CReg.h"
101,105d100
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to enumerate local apps
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
408d402
< */	return(E_FAIL);
791a786,787
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
809a806,845
> 	}
> 	else
> 	{
>     	// More setup
>     	siA.cb = sizeof(STARTUPINFO);
>     	siA.lpReserved = NULL;
>     	siA.lpDesktop = NULL;
>     	siA.lpTitle = NULL;
>     	siA.dwFlags = 0;
>     	siA.cbReserved2 = 0;
>     	siA.lpReserved2 = NULL;	    
>     	
> 	    DPF( 1, "Detected 9x, Doing Unicode launch" );
> 	    
>     	if( FAILED( hResultCode = DPL_AllocAndConvertToAnsi( &pszUnExpanded, pwszUnexpanded ) ) )
>     	{
>     	    dwError = GetLastError();
>     	    DPF( 0, "String conversion failed dwError = [0x%lx]", dwError );
>     	    hResultCode = DPNERR_CONVERSION;
>     	    goto CLEANUP_DPLLaunch;
>     	}
> 
>     	if( FAILED( hResultCode = DPL_AllocAndConvertToAnsi( &pszDefaultDir, pdplProgramDesc->pwszCurrentDirectory ) ) )
>     	{
>     	    dwError = GetLastError();
>     	    DPF( 0, "String conversion failed dwError = [0x%lx]", dwError );
>     	    hResultCode = DPNERR_CONVERSION;
>     	    goto CLEANUP_DPLLaunch;
>     	}
> 
>     	// Launch !
>     	if (CreateProcessA(NULL,pszUnExpanded,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
>     			pszDefaultDir,&siA,&pi) == 0)
>     	{
>     		dwError = GetLastError();
>     		DPF( 0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
>     		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
>     		goto CLEANUP_DPLLaunch;
>     	}	    
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplobby.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20c20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
.  
.  
()---()---()---()---()---()---()---()---()---(.\lobby\dplreg.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< //#include "CReg.h"
---
> #include "CReg.h"
58,62d57
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
154d148
< */ return(E_FAIL);
171,175d164
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to write app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
344d332
< */ return(E_FAIL);
365,369d352
< // BUGBUG
< // MGERE:  Removed this whole function.  It uses registry to read app description
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
659d641
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
107c107
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
108a109,113
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
149c149,154
< 	DNASSERT( ( dwFlags & ~( DPNENUMHOSTS_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( dwFlags & ~( DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_NOBROADCASTFALLBACK ) ) == 0 );
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
194,195c194,224
< // MGERE:  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
113a115,134
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( 8, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
2a3
> #include "resource.h"
11a13
> #include "resource.h"
18a21
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
20c23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
60a64,141
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
101a103
> 	m_hActiveSettingsDialog( NULL ),
134a137
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
385a389,397
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
> 
386a399,405
> 	}
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
298a299,305
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
320a328,329
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
42a44
> #include	"IPXAddress.h"
77c79,80
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
95a99,100
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
111c116,118
<     m_pSourceSocketAddress( NULL )
---
>     m_pSourceSocketAddress( NULL ),
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 )
177a185,190
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
198a212,218
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
201a222,245
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
224a269,270
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
243a290,291
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
270a319,324
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
390a445,451
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
393a455,478
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
425a511,512
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
445a533,534
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
180a185,186
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
80a82
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
100,102d101
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
< 
589c588
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
739c738
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
804c803
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
869c868
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
1453a1453,1458
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1454a1460,1478
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1457a1482,1484
> 		case 2:
> 		default:
> 		{
1458a1486,1488
> 			break;
> 		}
> 	}
1532a1563,1568
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1533a1570,1588
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1536a1592,1594
> 		case 2:
> 		default:
> 		{
1537a1596,1598
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> extern const DWORD	g_dwIPBroadcastAddressSize;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
51a53
> #include	"IPUI.h"
92a95
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
114a118,340
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	INT3;
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
216a443
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
178a184,190
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
197a210,225
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
342a371,377
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
352a388,393
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
442a484,497
> //**********************************************************************
> // ------------------------------
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
443a499
> 
445a502,518
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
458a532,546
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
> }
> //**********************************************************************
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
60a63,65
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
> 
61a67
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
263a265,272
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
264a274,278
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
408a423,448
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> ////			HRESULT	hTempResult;
> //			THREAD_POOL_JOB	*pTemp;
> //
> //
> //			pTemp = m_pRemoveSocketPortData;
> //			m_pRemoveSocketPortData = NULL;
> //			INT3;
> ////			hTempResult = g_pThreadPool->SubmitRemoveSocketPort( this, CancelRemoveSocketPort, pTemp );
> ////			if ( hTempResult != DPN_OK )
> ////			{
> ////			    DPF( 0, "Problem submitting job to remove socket port from work thread!" );
> ////			    DisplayDNError( 0, hTempResult );
> ////			}
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 
> 		}
> 
837a878,890
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
839a893,999
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->m_pReceiveBuffer->GetBufferDesc()->pBufferData ),	// pointer to receive buffer
> 								pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize,	// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// return the receive buffer to act like the data
> 			// was processed
> 			//
> 			pReadData->m_pReceiveBuffer->DecRef();
> 			pReadData->m_pReceiveBuffer = NULL;
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->m_pReceiveBuffer->GetBufferDesc()->dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pReadData != NULL )
> 	{
> 		m_pThreadPool->ReturnReadIOData( pReadData );
> 		DEBUG_ONLY( pReadData = NULL );
> 	}
> 
> 	return;
> }
840a1001,1003
> 
> 
> //**********************************************************************
841a1005,1155
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		INT3;
> 
> 		SendFromWriteQueue();
> 	}
> 
> 	