R,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 *H2 %%C3 -Q1 S46=138"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 *H2 %%C3 -Q1""
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -SEC=1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 -K1 -Q1 *H1 :E0 &Q5"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 -K1 -Q1 *H1 :E0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 -K1 :E0 @M18 *H1 S48=7 S36=0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 *H0 -K1 -Q1 :E1 @M0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 *H1 -K1 -Q1 @M0 :E1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 *H2 -K2 -Q1 @M18 :E0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2&Q5)M1-K1*H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2)M1-K1-Q1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2S48=128S36=4-K1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2S48=128S36=4 -K1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4-K1)M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 -K1 )M1 -Q2 *H1 ""M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 $M1 W1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 &Q5 -K1 *H1 )M1 -C1 -Q0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 W1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4)M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 -K1 -C0 -J1 -K1 -Q1 *H2"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 &F6 S0=0 &D2 E0 V1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 )M1 *H1 -K1 -Q1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 )M1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6&J2S7=90S10=60"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6)M1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "+MS=10, 1, 4800, 14400 S10=10"
HKR,Settings, ErrorControl_Cellular_Forced, , "F6 S10=10"
HKR,Settings, ErrorControl_Cellular_Forced, , "S43.3=0S57.5=1&K3*E1"
HKR,Settings, ErrorControl_Cellular_Forced, , "S48=0 \N4 &F5 &I14"
HKR,Settings, ErrorControl_Cellular_Forced, , "S48=128 S36=4 -K1"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , "-K1"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , "-K1)M1"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , "-K1)M1*H0"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , ")M1"
HKR,Settings, ErrorControl_Cellular_Off, , "-K0"
HKR,Settings, ErrorControl_Cellular_Off, , "-K0)M0"
HKR,Settings, ErrorControl_Cellular_Off, , "M0"
HKR,Settings, ErrorControl_Cellular_ON, , "-K1"
HKR,Settings, ErrorControl_Cellular_ON, , "-K1)M1"
HKR,Settings, ErrorControl_Cellular_ON, , "-K1)M1*H0"
HKR,Settings, ErrorControl_Cellular_ON, , ")M1"
HKR,Settings, ErrorControl_Forced, , ""
HKR,Settings, ErrorControl_Forced, , "$E4"
HKR,Settings, ErrorControl_Forced, , "&B49\N6"
HKR,Settings, ErrorControl_Forced, , "&E2"
HKR,Settings, ErrorControl_Forced, , "&E3"
HKR,Settings, ErrorControl_Forced, , "&K3*E1"
HKR,Settings, ErrorControl_Forced, , "&K4*E1"
HKR,Settings, ErrorControl_Forced, , "&M5"
HKR,Settings, ErrorControl_Forced, , "&Q0"
HKR,Settings, ErrorControl_Forced, , "&Q5 S36=4 S48=7"
HKR,Settings, ErrorControl_Forced, , "&Q5\N2"
HKR,Settings, ErrorControl_Forced, , "&Q5\N4"
HKR,Settings, ErrorControl_Forced, , "&Q5S36=4S48=128"
HKR,Settings, ErrorControl_Forced, , "&Q5S36=4S48=7"
HKR,Settings, ErrorControl_Forced, , "&Q5S36=4S48=7\N2"
HKR,Settings, ErrorControl_Forced, , "&Q6 S36=0"
HKR,Settings, ErrorControl_Forced, , "*E5"
HKR,Settings, ErrorControl_Forced, , "*E6"
HKR,Settings, ErrorControl_Forced, , "*SM2"
HKR,Settings, ErrorControl_Forced, , "\E1\P2\N2"
HKR,Settings, ErrorControl_Forced, , "\J0\N4"
HKR,Settings, ErrorControl_Forced, , "\N1"
HKR,Settings, ErrorControl_Forced, , "\N1\P2"
HKR,Settings, ErrorControl_Forced, , "\N10"
HKR,Settings, ErrorControl_Forced, , "\N11"
HKR,Settings, ErrorControl_Forced, , "\N2-J1"
HKR,Settings, ErrorControl_Forced, , "\N2-K0S36=4S48=7"
HKR,Settings, ErrorControl_Forced, , "\N2 S48=7 S36=4"
HKR,Settings, ErrorControl_Forced, , "\N2"
HKR,Settings, ErrorControl_Forced, , "\N2*Y0"
HKR,Settings, ErrorControl_Forced, , "\N2S48=128S36=4"
HKR,Settings, ErrorControl_Forced, , "\N3"
HKR,Settings, ErrorControl_Forced, , "\N4-J1"
HKR,Settings, ErrorControl_Forced, , "\N4"
HKR,Settings, ErrorControl_Forced, , "\N5"
HKR,Settings, ErrorControl_Forced, , "\N6"
HKR,Settings, ErrorControl_Forced, , "\N6S48=128S36=4"
HKR,Settings, ErrorControl_Forced, , "L4"
HKR,Settings, ErrorControl_Forced, , "S106=0S97=1S95=1S66=1"
HKR,Settings, ErrorControl_Forced, , "S180=1 S181=2"
HKR,Settings, ErrorControl_Forced, , "S180=2 S181=2"
HKR,Settings, ErrorControl_Forced, , "S180=2S181=2"
HKR,Settings, ErrorControl_Forced, , "S48=0 \N4"
HKR,Settings, ErrorControl_Forced, , "S48=128 S36=4"
HKR,Settings, ErrorControl_Forced, , "S95=1"
HKR,Settings, ErrorControl_Off, , ""
HKR,Settings, ErrorControl_Off, , "$E"
HKR,Settings, ErrorControl_Off, , "$E0"
HKR,Settings, ErrorControl_Off, , "%%A2=1"
HKR,Settings, ErrorControl_Off, , "&B34\N0"
HKR,Settings, ErrorControl_Off, , "&E0"
HKR,Settings, ErrorControl_Off, , "&K0"
HKR,Settings, ErrorControl_Off, , "&M0"
HKR,Settings, ErrorControl_Off, , "&Q0"
HKR,Settings, ErrorControl_Off, , "&Q0\N0"
HKR,Settings, ErrorControl_Off, , "&Q0\N1"
HKR,Settings, ErrorControl_Off, , "&Q5S36=3S48=7"
HKR,Settings, ErrorControl_Off, , "&Q5S46=136"
HKR,Settings, ErrorControl_Off, , "&Q5S48=128"
HKR,Settings, ErrorControl_Off, , "&Q6 S36=3 S48=128"
HKR,Settings, ErrorControl_Off, , "&Q6"
HKR,Settings, ErrorControl_Off, , "&Q6\N"
HKR,Settings, ErrorControl_Off, , "&Q6S36=3S48=128"
HKR,Settings, ErrorControl_Off, , "&Q6S36=3S48=128\N0"
HKR,Settings, ErrorControl_Off, , "*E0"
HKR,Settings, ErrorControl_Off, , "*SM0"
HKR,Settings, ErrorControl_Off, , "*SM1"
HKR,Settings, ErrorControl_Off, , "\J1\N1"
HKR,Settings, ErrorControl_Off, , "\N"
HKR,Settings, ErrorControl_Off, , "\N0-J0"
HKR,Settings, ErrorControl_Off, , "\N0-K0S36=3S48=128"
HKR,Settings, ErrorControl_Off, , "\N0 S48=128 S36=3"
HKR,Settings, ErrorControl_Off, , "\N0"
HKR,Settings, ErrorControl_Off, , "\N0S48=128"
HKR,Settings, ErrorControl_Off, , "\N0S48=128S36=3"
HKR,Settings, ErrorControl_Off, , "\N1"
HKR,Settings, ErrorControl_Off, , "\P0"
HKR,Settings, ErrorControl_Off, , "L0"
HKR,Settings, ErrorControl_Off, , "S106=0S97=0S95=0"
HKR,Settings, ErrorControl_Off, , "S180=0 S181=1"
HKR,Settings, ErrorControl_Off, , "S180=0"
HKR,Settings, ErrorControl_Off, , "S180=0S181=1"
HKR,Settings, ErrorControl_Off, , "S48=128 S36=3"
HKR,Settings, ErrorControl_Off, , "S95=0 S66=1 S97=0"
HKR,Settings, ErrorControl_On, , ""
HKR,Settings, ErrorControl_On, , "$E3"
HKR,Settings, ErrorControl_On, , "%%A2=2"
HKR,Settings, ErrorControl_On, , "&B49\N3"
HKR,Settings, ErrorControl_On, , "&E1"
HKR,Settings, ErrorControl_On, , "&K3*E0"
HKR,Settings, ErrorControl_On, , "&K4"
HKR,Settings, ErrorControl_On, , "&K5S36=7S46=136S48=138"
HKR,Settings, ErrorControl_On, , "&M4"
HKR,Settings, ErrorControl_On, , "&Q5 S36=7 S48=7"
HKR,Settings, ErrorControl_On, , "&Q5"
HKR,Settings, ErrorControl_On, , "&Q5\N3"
HKR,Settings, ErrorControl_On, , "&Q5S36=7S46=136S48=128"
HKR,Settings, ErrorControl_On, , "&Q5S36=7S48=7"
HKR,Settings, ErrorControl_On, , "&Q5S36=7S48=7\N3"
HKR,Settings, ErrorControl_On, , "&Q6"
HKR,Settings, ErrorControl_On, , "&Q9"
HKR,Settings, ErrorControl_On, , "*E5"
HKR,Settings, ErrorControl_On, , "*E9"
HKR,Settings, ErrorControl_On, , "*SM3"
HKR,Settings, ErrorControl_On, , "\E1\P2\N3"
HKR,Settings, ErrorControl_On, , "\J0\N3"
HKR,Settings, ErrorControl_On, , "\N0"
HKR,Settings, ErrorControl_On, , "\N11"
HKR,Settings, ErrorControl_On, , "\N2"
HKR,Settings, ErrorControl_On, , "\N3-J1"
HKR,Settings, ErrorControl_On, , "\N3-K0S36=7S48=7"
HKR,Settings, ErrorControl_On, , "\N3 -J1"
HKR,Settings, ErrorControl_On, , "\N3 S48=7 S36=7"
HKR,Settings, ErrorControl_On, , "\N3"
HKR,Settings, ErrorControl_On, , "\N3*Y0"
HKR,Settings, ErrorControl_On, , "\N3\P2"
HKR,Settings, ErrorControl_On, , "\N3S48=7S36=7"
HKR,Settings, ErrorControl_On, , "\N4"
HKR,Settings, ErrorControl_On, , "\N5"
HKR,Settings, ErrorControl_On, , "\N6"
HKR,Settings, ErrorControl_On, , "\N7"
HKR,Settings, ErrorControl_On, , "\N7S48=7S36=7"
HKR,Settings, ErrorControl_On, , "L4"
HKR,Settings, ErrorControl_On, , "S106=1 S97=1 S66=2 S95=2"
HKR,Settings, ErrorControl_On, , "S106=1S95=2S97=0S66=2"
HKR,Settings, ErrorControl_On, , "S180=1 S181=1"
HKR,Settings, ErrorControl_On, , "S180=2 S181=1"
HKR,Settings, ErrorControl_On, , "S180=2S181=1"
HKR,Settings, ErrorControl_On, , "S180=3S181=1"
HKR,Settings, ErrorControl_On, , "S48=7 S36=7"
HKR,Settings, ErrorControl_On, , "S48=7"
HKR,Settings, FlowControl_Hard, ,
HKR,Settings, FlowControl_Hard, , ""
HKR,Settings, FlowControl_Hard, , "$F4"
HKR,Settings, FlowControl_Hard, , "$F5"
HKR,Settings, FlowControl_Hard, , "&E4"
HKR,Settings, FlowControl_Hard, , "&E6"
HKR,Settings, FlowControl_Hard, , "&H1&I0&R2"
HKR,Settings, FlowControl_Hard, , "&H1&R2&B1&I0"
HKR,Settings, FlowControl_Hard, , "&H1&R2&I0"
HKR,Settings, FlowControl_Hard, , "&H3"
HKR,Settings, FlowControl_Hard, , "&K1"
HKR,Settings, FlowControl_Hard, , "&K3"
HKR,Settings, FlowControl_Hard, , "*F3"
HKR,Settings, FlowControl_Hard, , "*FL3"
HKR,Settings, FlowControl_Hard, , "\Q0"
HKR,Settings, FlowControl_Hard, , "\Q1"
HKR,Settings, FlowControl_Hard, , "\Q10"
HKR,Settings, FlowControl_Hard, , "\Q2"
HKR,Settings, FlowControl_Hard, , "\Q3"
HKR,Settings, FlowControl_Hard, , "\Q3\Q6"
HKR,Settings, FlowControl_Hard, , "S34=2"
HKR,Settings, FlowControl_Hard, , "S58=2 S68=255"
HKR,Settings, FlowControl_Hard, , "S58=2"
HKR,Settings, FlowControl_Off, ,
HKR,Settings, FlowControl_Off, , ""
HKR,Settings, FlowControl_Off, , "$F0"
HKR,Settings, FlowControl_Off, , "$F5"
HKR,Settings, FlowControl_Off, , "&E0"
HKR,Settings, FlowControl_Off, , "&E3"
HKR,Settings, FlowControl_Off, , "&E6"
HKR,Settings, FlowControl_Off, , "&H0"
HKR,Settings, FlowControl_Off, , "&H0&B0&R1"
HKR,Settings, FlowControl_Off, , "&H0&I0&R1"
HKR,Settings, FlowControl_Off, , "&H0&R1&I0"
HKR,Settings, FlowControl_Off, , "&K"
HKR,Settings, FlowControl_Off, , "&K0"
HKR,Settings, FlowControl_Off, , "&K2"
HKR,Settings, FlowControl_Off, , "*F0"
HKR,Settings, FlowControl_Off, , "*FL0"
HKR,Settings, FlowControl_Off, , "\Q"
HKR,Settings, FlowControl_Off, , "\Q0"
HKR,Settings, FlowControl_Off, , "S34=0"
HKR,Settings, FlowControl_Off, , "S58=0 S68=255"
HKR,Settings, FlowControl_Off, , "S58=0"
HKR,Settings, FlowControl_Soft, ,
HKR,Settings, FlowControl_Soft, , ""
HKR,Settings, FlowControl_Soft, , "$F"
HKR,Settings, FlowControl_Soft, , "$F0"
HKR,Settings, FlowControl_Soft, , "$F5"
HKR,Settings, FlowControl_Soft, , "&E4"
HKR,Settings, FlowControl_Soft, , "&E5"
HKR,Settings, FlowControl_Soft, , "&H2&B1&I2&R1"
HKR,Settings, FlowControl_Soft, , "&H2&I2&R1"
HKR,Settings, FlowControl_Soft, , "&H4"
HKR,Settings, FlowControl_Soft, , "&K1"
HKR,Settings, FlowControl_Soft, , "&K2"
HKR,Settings, FlowControl_Soft, , "&K4"
HKR,Settings, FlowControl_Soft, , "*F2"
HKR,Settings, FlowControl_Soft, , "*FL1"
HKR,Settings, FlowControl_Soft, , "\Q1"
HKR,Settings, FlowControl_Soft, , "\Q1\Q5"
HKR,Settings, FlowControl_Soft, , "\Q2"
HKR,Settings, FlowControl_Soft, , "\Q3"
HKR,Settings, FlowControl_Soft, , "\Q4"
HKR,Settings, FlowControl_Soft, , "\Q5"
HKR,Settings, FlowControl_Soft, , "S34=1"
HKR,Settings, FlowControl_Soft, , "S58=3 S68=255"
HKR,Settings, FlowControl_Soft, , "S58=3"
HKR,Settings, InactivityTimeout, ,
HKR,Settings, InactivityTimeout, , " "
HKR,Settings, InactivityTimeout, , ""
HKR,Settings, InactivityTimeout, , "*SI5S30=<#>"
HKR,Settings, InactivityTimeout, , "\t<#>"
HKR,Settings, InactivityTimeout, , "\T<#>"
HKR,Settings, InactivityTimeout, , "\T=<#>"
HKR,Settings, InactivityTimeout, , "+S8=<#>"
HKR,Settings, InactivityTimeout, , "S19=<#>"
HKR,Settings, InactivityTimeout, , "S30=<#>"
HKR,Settings, InactivityTimeout, , "S30=60"
HKR,Settings, InactivityTimeout, , "S36=<#>"
HKR,Settings, InactivityTimeout, , "S37=<#>"
HKR,Settings, InactivityTimeout, , "S40=<#>"
HKR,Settings, InactivityTimeout, , "S41=<#>"
HKR,Settings, InactivityTimeout, , "S50=<#>"
HKR,Settings, InactivityTimeout, , "S58=<#>"
HKR,Settings, InactivityTimeout, , "S9=<#>"
HKR,Settings, Modulation_Bell, ,
HKR,Settings, Modulation_Bell, , ""
HKR,Settings, Modulation_Bell, , "B0"
HKR,Settings, Modulation_Bell, , "B1 "
HKR,Settings, Modulation_Bell, , "B1 +MS=11, 1, 300, 28800"
HKR,Settings, Modulation_Bell, , "B1 B1"
HKR,Settings, Modulation_Bell, , "B1 B16"
HKR,Settings, Modulation_Bell, , "B1 F0"
HKR,Settings, Modulation_BELL, , "B1"
HKR,Settings, Modulation_Bell, , "B1"
HKR,Settings, Modulation_Bell, , "B1B16"
HKR,Settings, Modulation_Bell, , "B1F(i4)"
HKR,Settings, Modulation_Bell, , "B1F0"
HKR,Settings, Modulation_Bell, , "B1F1 B1F4"
HKR,Settings, Modulation_Bell, , "B1S37=5"
HKR,Settings, Modulation_Bell, , "B2"
HKR,Settings, Modulation_Bell, , "B90"
HKR,Settings, Modulation_CCITT, ,
HKR,Settings, Modulation_CCITT, , ""
HKR,Settings, Modulation_CCITT, , "B"
HKR,Settings, Modulation_CCITT, , "B0 "
HKR,Settings, Modulation_CCITT, , "B0 +MS=11, 1, 300, 28800"
HKR,Settings, Modulation_CCITT, , "B0 B0"
HKR,Settings, Modulation_CCITT, , "B0 B15"
HKR,Settings, Modulation_CCITT, , "B0 F0"
HKR,Settings, Modulation_CCITT, , "B0 S27=1"
HKR,Settings, Modulation_CCITT, , "B0"
HKR,Settings, Modulation_CCITT, , "B0B15"
HKR,Settings, Modulation_CCITT, , "B0F(I4)"
HKR,Settings, Modulation_CCITT, , "B0F0"
HKR,Settings, Modulation_CCITT, , "B99"
HKR,Settings, Modulation_CCITT, , "F0"
HKR,Settings, Modulation_CCITT, , "F1 F4"
HKR,Settings, Modulation_CCITT_V23, , "$MB75 "
HKR,Settings, Modulation_CCITT_V23, , "B0 +MS=3, 0, 1200, 1200"
HKR,Settings, Modulation_CCITT_V23, , "B0 B2 "
HKR,Settings, Modulation_CCITT_V23, , "B0 F3"
HKR,Settings, Modulation_CCITT_V23, , "B0"
HKR,Settings, Modulation_CCITT_V23, , "B18"
HKR,Settings, Modulation_CCITT_V23, , "F3"
HKR,Settings, Modulation_CCITT_V23, , "L2"
HKR,Settings, Modulation_CCITT_V23, , "S34=8"
HKR,Settings, Prefix, , "AT"
HKR,Settings, Pulse, ,
HKR,Settings, Pulse, , ""
HKR,Settings, Pulse, , "I"
HKR,Settings, Pulse, , "P"
HKR,Settings, Pulse, , "T"
HKR,Settings, SpeakerMode_Dial, ,
HKR,Settings, SpeakerMode_Dial, , "M1"
HKR,Settings, SpeakerMode_Off, ,
HKR,Settings, SpeakerMode_Off, , "M"
HKR,Settings, SpeakerMode_Off, , "M0"
HKR,Settings, SpeakerMode_On, ,
HKR,Settings, SpeakerMode_On, , "M2"
HKR,Settings, SpeakerMode_Setup, ,
HKR,Settings, SpeakerMode_Setup, , "M0"
HKR,Settings, SpeakerMode_Setup, , "M3"
HKR,Settings, SpeakerVolume_High, ,
HKR,Settings, SpeakerVolume_High, , ""
HKR,Settings, SpeakerVolume_High, , "L1"
HKR,Settings, SpeakerVolume_High, , "L2"
HKR,Settings, SpeakerVolume_High, , "L3"
HKR,Settings, SpeakerVolume_High, , "L7"
HKR,Settings, SpeakerVolume_High, , "S61=250"
HKR,Settings, SpeakerVolume_Low, ,
HKR,Settings, SpeakerVolume_Low, , ""
HKR,Settings, SpeakerVolume_Low, , "L"
HKR,Settings, SpeakerVolume_Low, , "L0"
HKR,Settings, SpeakerVolume_Low, , "L1"
HKR,Settings, SpeakerVolume_Low, , "S61=50"
HKR,Settings, SpeakerVolume_Med, ,
HKR,Settings, SpeakerVolume_Med, , ""
HKR,Settings, SpeakerVolume_Med, , "L1"
HKR,Settings, SpeakerVolume_Med, , "L2"
HKR,Settings, SpeakerVolume_Med, , "L4"
HKR,Settings, SpeakerVolume_Med, , "S61=150"
HKR,Settings, SpeedNegotiation_Off, ,
HKR,Settings, SpeedNegotiation_Off, , "-R1"
HKR,Settings, SpeedNegotiation_Off, , "!N0"
HKR,Settings, SpeedNegotiation_Off, , ""
HKR,Settings, SpeedNegotiation_Off, , "$M1"
HKR,Settings, SpeedNegotiation_Off, , "%%F0"
HKR,Settings, SpeedNegotiation_Off, , "%%N6"
HKR,Settings, SpeedNegotiation_Off, , "%%R"
HKR,Settings, SpeedNegotiation_Off, , "%G"
HKR,Settings, SpeedNegotiation_Off, , "&A0"
HKR,Settings, SpeedNegotiation_Off, , "&A1"
HKR,Settings, SpeedNegotiation_Off, , "&E0"
HKR,Settings, SpeedNegotiation_Off, , "&N1"
HKR,Settings, SpeedNegotiation_Off, , "*G0"
HKR,Settings, SpeedNegotiation_Off, , "*S0"
HKR,Settings, SpeedNegotiation_Off, , "\J0"
HKR,Settings, SpeedNegotiation_Off, , "+M0"
HKR,Settings, SpeedNegotiation_Off, , "+MS=11, 0, 300, 28800"
HKR,Settings, SpeedNegotiation_Off, , "+MS=74, 0, 300, 28800"
HKR,Settings, SpeedNegotiation_Off, , "B2"
HKR,Settings, SpeedNegotiation_Off, , "N"
HKR,Settings, SpeedNegotiation_Off, , "N0"
HKR,Settings, SpeedNegotiation_Off, , "N0S37=0"
HKR,Settings, SpeedNegotiation_Off, , "N1"
HKR,Settings, SpeedNegotiation_Off, , "S15=2"
HKR,Settings, SpeedNegotiation_Off, , "S50=254S94=0"
HKR,Settings, SpeedNegotiation_Off, , "S94=0"
HKR,Settings, SpeedNegotiation_On, ,
HKR,Settings, SpeedNegotiation_On, , "-R0"
HKR,Settings, SpeedNegotiation_On, , "!N2"
HKR,Settings, SpeedNegotiation_On, , ""
HKR,Settings, SpeedNegotiation_On, , "$M0"
HKR,Settings, SpeedNegotiation_On, , "%%F4%%R1"
HKR,Settings, SpeedNegotiation_On, , "%%N0"
HKR,Settings, SpeedNegotiation_On, , "%%R2"
HKR,Settings, SpeedNegotiation_On, , "%G1"
HKR,Settings, SpeedNegotiation_On, , "&A0"
HKR,Settings, SpeedNegotiation_On, , "&A1"
HKR,Settings, SpeedNegotiation_On, , "&E1"
HKR,Settings, SpeedNegotiation_On, , "&N0"
HKR,Settings, SpeedNegotiation_On, , "*G1"
HKR,Settings, SpeedNegotiation_On, , "*S1"
HKR,Settings, SpeedNegotiation_On, , "\J1"
HKR,Settings, SpeedNegotiation_On, , "+M2"
HKR,Settings, SpeedNegotiation_On, , "+M3"
HKR,Settings, SpeedNegotiation_On, , "+MS=11, 1, 300, 28800"
HKR,Settings, SpeedNegotiation_On, , "B0"
HKR,Settings, SpeedNegotiation_On, , "F0"
HKR,Settings, SpeedNegotiation_On, , "N0"
HKR,Settings, SpeedNegotiation_On, , "N1"
HKR,Settings, SpeedNegotiation_On, , "N1S37=0"
HKR,Settings, SpeedNegotiation_On, , "S15=0"
HKR,Settings, SpeedNegotiation_On, , "S35=7"
HKR,Settings, SpeedNegotiation_On, , "S50=0S94=1"
HKR,Settings, SpeedNegotiation_On, , "S50=6S94=1"
HKR,Settings, Terminator, , "<cr>"
HKR,Settings, Tone, ,
HKR,Settings, Tone, , ""
HKR,Settings, Tone, , "M"
HKR,Settings, Tone, , "T"
HKR,SpeakerPhoneDisable, 1, , "at#spk=0<cr>"
HKR,SpeakerPhoneDisable, 1, , "at#vls=0<cr>"
HKR,SpeakerPhoneDisable, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneDisable, 2, , "at#spk=0, 15, , <cr>"
HKR,SpeakerPhoneDisable, 3, , "at#vls=0<cr>"
HKR,SpeakerPhoneEnable, 1, , "at#spk=1<cr>"
HKR,SpeakerPhoneEnable, 1, , "at#vls=5<cr>"
HKR,SpeakerPhoneEnable, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneEnable, 2, , "ata<cr>"
HKR,SpeakerPhoneEnable, 3, , "at#vdx=0<cr>"
HKR,SpeakerPhoneMute, 1, , "at#vgm=1<cr>"
HKR,SpeakerPhoneMute, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneMute, 1, , "at<cr>"
HKR,SpeakerPhoneMute, 2, , "at#spk=0, , , <cr>"
HKR,SpeakerPhoneSetVolumeGain, 1, , "at#vgs=<Vol><cr>"
HKR,SpeakerPhoneSetVolumeGain, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneSetVolumeGain, 1, , "at<cr>"
HKR,SpeakerPhoneSetVolumeGain, 2, , "at#spk=, <Vol>, <Gain><cr>"
HKR,SpeakerPhoneUnMute, 1, , "at#vgm=128<cr>"
HKR,SpeakerPhoneUnMute, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneUnMute, 1, , "at<cr>"
HKR,SpeakerPhoneUnMute, 2, , "at#spk=1, , , <cr>"
HKR,StartPlay, 1, , "at#spk=0<cr>"
HKR,StartPlay, 1, , "at#vpy<cr>"
HKR,StartPlay, 1, , "at#vtx<cr>"
HKR,StartPlay, 2, , "ata<cr>"
HKR,StartPlay, 3, , "at+vgt=134<cr>"
HKR,StartPlay, 4, , "at#vtx<cr>"
HKR,StartRecord, 1, , "at#spk=0<cr>"
HKR,StartRecord, 1, , "at#vrd<cr>"
HKR,StartRecord, 1, , "at#vrx<cr>"
HKR,StartRecord, 2, , "ata<cr>"
HKR,StartRecord, 3, , "at+vgr=134<cr>"
HKR,StartRecord, 4, , "at#vrx<cr>"
HKR,StopPlay, 1, , "None"
HKR,StopPlay, 2, , "NoResponse"
HKR,StopRecord, 1, , "None"
HKR,StopRecord, 2, , "NoResponse"
HKR,VoiceAnswer, 1, , "at#cls=8<cr>"
HKR,VoiceAnswer, 1, , "at#vcl=1<cr>"
HKR,VoiceAnswer, 2, , "at#vln=1<cr>"
HKR,VoiceAnswer, 2, , "at#vls=0<cr>"
HKR,VoiceAnswer, 3, , "at#vbt=1<cr>"
HKR,VoiceAnswer, 3, , "at#vsr=7200<cr>"
HKR,VoiceAnswer, 4, , "at#vbs=4<cr>"
HKR,VoiceAnswer, 4, , "at#vsr=7200<cr>"
HKR,VoiceAnswer, 5, , "at#vbs=4<cr>"
HKR,VoiceAnswer, 5, , "ats30=60<cr>"
HKR,VoiceAnswer, 6, , "ata<cr>"
HKR,VoiceAnswer, 6, , "ats30=60<cr>"
HKR,VoiceAnswer, 7, , "ata<cr>"
HKR,VoiceDialNumberSetup, 1, , "at#cls=8<cr>"
HKR,VoiceDialNumberSetup, 1, , "at#vcl=1<cr>"
HKR,VoiceDialNumberSetup, 2, , "at#vln=17<cr>"
HKR,VoiceDialNumberSetup, 2, , "at#vls=0<cr>"
HKR,VoiceDialNumberSetup, 2, , "at#vls=4<cr>"
HKR,VoiceDialNumberSetup, 3, , "at#vrn=0<cr>"
HKR,VoiceDialNumberSetup, 3, , "atdt, ;<cr>"
HKR,VoiceDialNumberSetup, 4, , "at#vbt=1<cr>"
HKR,VoiceDialNumberSetup, 4, , "at#vsr=7200<cr>"
HKR,VoiceDialNumberSetup, 5, , "at#vbs=4<cr>"
HKR,VoiceDialNumberSetup, 5, , "at#vsr=7200<cr>"
HKR,VoiceDialNumberSetup, 6, , "at#vbs=4<cr>"
HKR,VoiceDialNumberSetup, 6, , "ats30=60<cr>"
HKR,VoiceDialNumberSetup, 7, , "ats30=60<cr>"
HKR,VoiceToDataAnswer, 1, , "at#cls=0<cr>"
HKR,VoiceToDataAnswer, 1, , "at#vcl=0<cr>"
HKR,VoiceToDataAnswer, 2, , "ata<cr>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\inf\mdmplace.txt ===
# placefil.txt prototype for modem INF's
# Last update 10/20/98 JimSp
# Keep everything alphabetized for easy maintenance.
# Copy complete below and insert/replace the proper chunk in placefil.txt

#Drivers
# Verify placfil.txt has these entries in proper placement.

3cisaadi.sys	 retail
3cpxiadi.sys	 retail
3cwmcru.sys	 retail
hcf_msft.sys     retail
ltcpq5.sys	 retail
ltmdmnt.sys	 retail
ltmdmntt.sys	 retail
ltmodem5.sys	 retail
winacisa.sys	 retail
winmodem.sys	 retail

#INFs
# Copy complete below and insert/replace the proper chunk in placefil.txt

mdm3cisa.inf     retail
mdm3com.inf      retail
mdm3cpcm.inf     retail
mdm3cusb.inf     retail
mdm3x.inf        retail
mdm_rint.inf     retail ;JPN
mdmaceex.inf     retail
mdmadc.inf       retail
mdmairte.inf     retail
mdmaiwa.inf      retail ;JPN
mdmaiwa2.inf     retail ;JPN
mdmaiwa3.inf     retail ;JPN
mdmaiwat.inf     retail ;JPN
mdmalex.inf      retail ;JPN
mdmar1.inf       retail
mdmarch.inf      retail
mdmarcht.inf     retail
mdmarn.inf       retail
mdmati.inf       retail
mdmatkk.inf      retail ;JPN
mdmatt.inf       retail
mdmaus.inf       retail
mdmblatz.inf     retail
mdmboca.inf      retail
mdmbsb.inf       retail
mdmbsch.inf      retail
mdmbug.inf       retail ;JPN
mdmbug3.inf      retail ;JPN
mdmcm28.inf      retail
mdmcmcm.inf      retail
mdmcodex.inf     retail
mdmcom1.inf      retail
mdmcomm1.inf     retail
mdmcommu.inf     retail
mdmcomz.inf      retail ;JPN
mdmcpi.inf       retail
mdmcpq.inf       retail
mdmcpv.inf       retail
mdmcrtix.inf     retail
mdmctm1.inf      retail
mdmdcm2.inf      retail ;JPN
mdmdcm5.inf      retail ;JPN
mdmdefd.inf      retail
mdmdgitn.inf     retail
mdmdicom.inf     retail
mdmdigi.inf      retail
mdmdisco.inf     retail
mdmdp2.inf       retail ;JPN
mdmdsi.inf       retail
mdmdyna.inf      retail
mdmeiger.inf     retail
mdmelink.inf     retail
mdmelpro.inf     retail
mdmelsa.inf      retail
mdmeric.inf      retail
mdmeric2.inf     retail
mdmetech.inf     retail
mdmexp.inf       retail
mdmeyp.inf       retail
mdmfj.inf        retail ;JPN
mdmfj1.inf       retail ;JPN
mdmfj2.inf       retail ;JPN
mdmfjta1.inf     retail ;JPN
mdmgal.inf       retail
mdmgatew.inf     retail
mdmgcs.inf       retail
mdmgen.inf       retail
mdmgl001.inf     retail
mdmgl002.inf     retail
mdmgl003.inf     retail
mdmgl004.inf     retail
mdmgl005.inf     retail
mdmgl006.inf     retail
mdmgl007.inf     retail
mdmgl008.inf     retail
mdmgsm.inf       retail
mdmgv.inf        retail
mdmgvc.inf       retail
mdmhaeu.inf      retail
mdmhaeus.inf     retail
mdmhandy.inf     retail
mdmhay2.inf      retail
mdmhayes.inf     retail
mdmhcom1.inf     retail ;JPN
mdmhucom.inf     retail ;JPN
mdmibmj.inf      retail ;JPN
mdmico.inf       retail
mdminfot.inf     retail
mdminst.dll      retail
mdminsys.inf     retail
mdmintel.inf     retail
mdmintpc.inf     retail
mdmiodat.inf     retail ;JPN
mdmiodt2.inf     retail ;JPN
mdmisdn.inf      retail
mdmitex.inf      retail
mdmke.inf        retail
mdmkortx.inf     retail
mdmlasat.inf     retail
mdmlasno.inf     retail
mdmlce.inf       retail
mdmlight.inf     retail
mdmlngsh.inf     retail
mdmlt3.inf       retail
mdmmart.inf      retail
mdmmc144.inf     retail ;JPN
mdmmc24.inf      retail ;JPN
mdmmcom.inf      retail
mdmmega.inf      retail ;JPN
mdmmega2.inf     retail ;JPN
mdmmetri.inf     retail
mdmmhrtz.inf     retail
mdmmhza.inf      retail
mdmmhzel.inf     retail
mdmmhzk1.inf     retail
mdmmid.inf       retail ;JPN
mdmmix.inf       retail
mdmmn128.inf     retail ;JPN
mdmmod.inf       retail
mdmmoto.inf      retail
mdmmoto1.inf     retail
mdmmoton.inf     retail
mdmmotou.inf     retail
mdmmrit.inf      retail ;JPN
mdmmrl.inf       retail ;JPN
mdmmsint.inf     retail ;JPN
mdmmsoki.inf     retail ;JPN
mdmmspan.inf     retail ;JPN
mdmmtd.inf       retail
mdmmts.inf       retail
mdmmulog.inf     retail
mdmnec.inf       retail ;JPN
mdmnec98.inf     retail ;JPN
mdmnecom.inf     retail ;JPN
mdmnect2.inf     retail ;JPN
mdmnecta.inf     retail ;JPN
mdmneuhs.inf     retail
mdmnis.inf       retail ;JPN
mdmnj15.inf      retail ;JPN
mdmnj16.inf      retail ;JPN
mdmnokia.inf     retail
mdmnokno.inf     retail
mdmnova.inf      retail
mdmnovfx.inf     retail
mdmnttp.inf      retail ;JPN
mdmnttte.inf     retail ;JPN
mdmoki.inf       retail ;JPN
mdmoki2.inf      retail ;JPN
mdmokipl.inf     retail ;JPN
mdmokita.inf     retail ;JPN
mdmolic.inf      retail
mdmolive.inf     retail
mdmomrn2.inf     retail ;JPN
mdmomron.inf     retail ;JPN
mdmopt1.inf      retail
mdmoptn.inf      retail
mdmosi.inf       retail
mdmpace.inf      retail
mdmpana.inf      retail ;JPN
mdmpbit.inf      retail
mdmpenr.inf      retail
mdmphils.inf     retail
mdmpn1.inf       retail
mdmpnb.inf       retail
mdmpp.inf        retail
mdmprodm.inf     retail
mdmpsion.inf     retail
mdmracal.inf     retail
mdmrex.inf       retail ;JPN
mdmrfi.inf       retail
mdmrisa.inf      retail
mdmrock.inf      retail
mdmrock2.inf     retail
mdmrock3.inf     retail
mdmrock4.inf     retail
mdmrock5.inf     retail
mdmrpci.inf      retail
mdmsecdy.inf     retail
mdmsetup.inf     retail
mdmshrup.dll     winnt32\winntupg\ms\modemshr
mdmsier.inf      retail
mdmsimpl.inf     retail
mdmsmart.inf     retail
mdmsnit1.inf     retail
mdmsnitn.inf     retail
mdmsonix.inf     retail
mdmsony.inf      retail ;JPN
mdmsonyu.inf     retail ;JPN
mdmspec.inf      retail
mdmspq28.inf     retail
mdmsrt.inf       retail
mdmsun.inf       retail ;JPN
mdmsun1.inf      retail ;JPN
mdmsupr3.inf     retail
mdmsupra.inf     retail
mdmsuprv.inf     retail
mdmtaicm.inf     retail
mdmtdk.inf       retail
mdmtdkj.inf      retail ;JPN
mdmtdkj2.inf     retail ;JPN
mdmte2.inf       retail ;JPN
mdmtelbt.inf     retail
mdmtelin.inf     retail
mdmtelnk.inf     retail
mdmtexas.inf     retail
mdmtger.inf      retail
mdmti.inf        retail
mdmtkr.inf       retail
mdmtorn.inf      retail
mdmtosh.inf      retail
mdmtoshi.inf     retail ;JPN
mdmtripl.inf     retail
mdmtron.inf      retail
mdmtrust.inf     retail
mdmucom.inf      retail
mdmusrcr.inf     retail
mdmusrf.inf      retail
mdmusrg.inf      retail
mdmusrk1.inf     retail
mdmusrsp.inf     retail
mdmusrwp.inf     retail
mdmvayrs.inf     retail
mdmvdot.inf      retail
mdmvict.inf      retail
mdmvsa1.inf      retail
mdmvv.inf        retail
mdmwell.inf      retail
mdmwhql0.inf     retail
mdmwoer.inf      retail
mdmx5560.inf     retail
mdmyorik.inf     retail
mdmzoom.inf      retail
mdmzyp.inf       retail
mdmzyxel.inf     retail
mdmzyxld.inf     retail
mdmzyxlg.inf     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\notes.txt ===
10/25/1997 JosephJ
    Notes on the reorganization of modemui.

    The UI has been split into two: CPL and CFG.
    Files to do with CPL UI are named cpl*.*, and
    those to do with CFG UI are named cfg*.*.

    modemui.c still contains all the exported apis.



----------------------------------------
Settings (visible from control panel)

General: IDD_GENERAL
    Speaker Volume: IDC_VOLUME
    Maximum Port Speed: IDC_CB_SPEED
    Blind Dial: IDC_WAITFORDIALTONE

----------------------------------------

Diagnostics: IDD_DIAGNOSTICS
    IDC_MOREINFOV  -- commands
    IDC_MOREINFOV2 -- "static info"
    IDC_LOGGING
    IDC_VIEWLOG

----------------------------------------

Advanced: IDD_ADV_MODEM
    Extra Settings: IDC_AM_EXTRA_ED
    Default Properties: button that launches property pages to set
        IDC_BN_DEFAULTS
     Enable extensions checkbox:  IDC_CB_ENABLE_EXTENSIONS 

----------------------------------------

Properties: Called through lineConfigDialog or lineConfigDialogEdit ....
IDD_MDMSETTINGS
    IDC_CH_DIALTIMER; IDC_ED_DIALTIMER
    IDC_CH_IDLETIMER  IDC_ED_IDLETIMER
    IDC_TERMINAL_PRE  IDC_TERMINAL_POST
    IDC_MANUAL_DIAL 
    IDC_WAIT_SEC

----------------------------------------

IDD_DATAMODEM
    IDC_CB_EC
    IDC_CB_COMP
    IDC_CB_MOD
    IDC_CB_SPEED
    IDC_CB_FC
    IDC_CB_DATABITS
    IDC_CB_PARITY
    IDC_CB_STOPBITS

----------------------------------------
from util.c:
RegQueryModemSettings(
    HKEY hkey,
    LPMODEMSETTINGS pms,
    LPDWORD pdwSize)        // Size of modem settings struct
{

    // 10/26/1997 JosephJ:
    //      Only the following 4 contiguous fields of MODEMSETTINGS are saved
    //      in the registry:
    //        DWORD   dwCallSetupFailTimer;       // seconds
    //        DWORD   dwInactivityTimeout;        // seconds
    //        DWORD   dwSpeakerVolume;            // level
    //        DWORD   dwSpeakerMode;              // mode
    //        DWORD   dwPreferredModemOptions;    // bitmap
    //
    //      The following code reads in just those fields, and then
    //      munges the dwInactivityTimeout by multiplying by the
    //      separate InactivityScale registry entry.
    //
    //      On NT4.0 we just blindly read the above 4 fields
    //      Here we validate the size before reading.
----------------------------------------

4/29/1998 JosephJ
	cfgisdn.c
		in RegSetGlobalModemInfo(), call  ValidateISDNStaticConfig(),
		Implement all checks in ValidateISDNStaticConfig.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\notes.txt ===
ISSUES
* Must avoid lots of switch statements everywhere.
----------------------------------------------------
IMPORTANT OBJECTS

CTspDevice -- the object which handle all TSP calls for a particular device
CTspDeviceEnumerator - responsible for enumerating and creating device objects

CTspDeviceTable -- the object keeping the array of devices and mapping handles
	to device objects.
CTspTask -- generic TSP "irp" object. TSP functioncalls and MiniDriver
			function calls are the two primary subtypes.
----------------------------------------------------
IMPORTANT CONCEPTS
*Diagnostic annotations can be tacked on to a bunch of things -- eg. call
or device -- these things build up and get cleared periodically on a successful
call.
*TSP tasks are the IRPs of the TSP. They are allocated by each device, and
 context can be added to the IRP as it progresses along. The two main types of
 TSP  tasks are those representing TSPI function and those representing
 MiniDriver functions.
* TspTaskHandlers are the objects (pieces of code) that actually perform  
  TspTasks -- they may do some stuff and hand over the task to other handlers.
* TspTask-related resources, including handler-specific context,
  are managed by the device object. How? We'll see...
----------------------------------------------------
IMPORTANT SCALARS
TSPRETURN  -- Return code for all TSP-internal functions
TSPOBJID   -- Object type ID  
TSPSTATE   -- Object state -- object-specific state.
TSPTASKID  -- TSP Task ID
----------------------------------------------------
Common methods
Load/Unload -- lazy unload semantics
Lock/Unlock

-------------------------------------
class CTspDeviceEnumerator
{
	DeviceEnumerator(void);
	~DeviceEnumerator();

	TSPRETURN Load(...);
	HANDLE	  Unload();

	<way to notify DeviceTable of new/removed devices>
};

class CTspDevice
{
	Device(void);
	~Device();

	TSPRETURN Load(...);
	HANDLE	  Unload();

	TSPRETURN AllocTspMem(pTspTask);
	TSPRETURN DoTask(pTspTask);
};

class CTspTask
{
	GetID()
	GetCurrentHandler()
	GetCurrentState()
};

class CTspTaskHandler
{
	HandleTask(pTspTask);
};

class CTspDeviceTable
{
	TSPRETURN GetTSPDeviceFromHDRVCALL(HDRVCALL, pTSPDevice);
	TSPRETURN GetTSPDeviceFromHDRVLINE(HDRVLINE, pTSPDevice);
	TSPRETURN GetTSPDeviceFromHDRVPHONE(HDRVPHONE, pTSPDevice);
	TSPRETURN RegisterNewDevices(TSPDEVICE rgTspDev[], UINT cDevices);
			- resize internal table, making space for new ones.
			- fill out table, querying each for it's permanent ID, and its
			name. Make sure status is embryonic.
			- send up LINE_CREATE message for each, and wait for
			  lineCreate to be called on each.
			- when done, return.
	TSPRETURN RegisterPnPStatusChange(DWORD rgdwPermID, UINT cIDs, PNPSTATUS);
			- for each, look rgdwPermID, notify device of status change,
			  update local status and send up REMOVED/OUTOFSERVICE.
		    - when done, return.
};

TSPI_lineMakeCall(...)
{
 TSPPARAM_TSPI_lineMakeCall param;
 param.dwSize = sizeof(TSPPARAM_TSPI_lineMakeCall);
 param.flags = TSPIFLAGS;
 param.funccode = TASKID_TSPI_lineMakeCall;

 param.xxxx = xxx;
 ....

 return DoTSPCallForHDRVCALL(hdCall, pParam);
}

LONG DoTSPCallForHDRVCALL(HDRVCALL hdCall, pParam)
{
	tspRet = gDevTab.GetTSPDeviceFromHDRVCALL(hdCall, &pDevice);
	if (TSPSUCCESS(tspRet))
	{
		tspRet = pDevice->AcceptTSPCall(&param, &lRet);
		pDevice->Release();
	}

	if (TSPSUCCESS(tspRet))
	{
		return lRet;
	}
	else
	{
		return MapTSPRETURNtoTSPIRet(tspRet);
	}
}

TSPRETURN gDevTab.GetTSPDeviceFromHDRVCALL(hdCall, &pDevice)
{
	enter_crit;
	LOWORD(hdCall
	exit_crit;
}

TSPI_lineMakeCall(...)
{
	*Find associated device
		tspRet = pDevTab->GetTSPDeviceFromTapiCallHandle(hCall, &pDev);
	*Determine how much memory is required for task
		dwSize = (TASKPARAM_TSPI_lineMakeCall);
	*Create empty task
		pEmptyTask = pDev->GetTask(dwSize)
	*Fill in parameters
		xxx.hLine =
		xxx.hCall =
		xxx.hBlah.=Blah
	*SubmitTask
		dwRet = pDev->SubmitTask(pTask);
}

CTspTask::SubmitTask
{
	Handler->SubmitTask(pTask);
}



CTspTaskHandler:
type
---------------------------------------------------
CTspDev           cdev.h     cdev.cpp
CTspDevMgr    	  cmgr.h     cmgr.cpp
CTspDevFactory    cfact.h    cfact.cpp
CTspTask          ctask.h    ctask.cpp

tspi0.cpp   ProviderInit, etc....
tspi1.cpp   All the rest.
tspirec.h   TSPI func record..
mdrec.h     Mini-driver records.

tspcomm.h       common header file.


1/3/97 Changes from LINEDEV structure
* divided into static-info, settings, and device-state
* DEVCFG is created on the fly, not saved as-is. Instead, we keep
  
1/4/97
* I am *not* going to enumerate modems at the drop of the hat, in particular
  not going to do so just to find the driver key name (which we do only 
  because we want to pass it up to fax via the devspecific hack). So we have
  to figure out another way to get the driver key name.

1/4/97
  Thought of how to encode *both* RFR information and error codes in the DWORD
  return value of a function. Decided to enforce RFR LUIDS to have the LSB
  byte set to 0x00. RFR values can then be combined with a byte worth of error
  codes. Defined macros FL_GEN_RETVAL, FL_BYTERR_FROM_RETVAL, and
  FL_RFR_FROM_RETVAL to construct and break-apart these hybrid return values.
  To enforce having the RFR value LSB byte be 0x00, I did two things:
  (1) FL_SET_RFR now masks off the LSB byte, so the compiled-in value will
	  have the LSB byte zeroed -- this is important because otherwise it will
	  modify the byte error return value, which could cause undefined 
	  behaviour and may be hard to track down.
  (2) flhash.bat perl script will embed a "#error" macro in the generated
	  .cpp file when it processes a FL_SET_RFR with a non-zero LSB RFR:
	  #error "RFR LUID 0x833c923e (from globals.cpp): LSB byte should be 0"

  Now, if the function decides to return because of some error, it
  can have the following code:
		FL_SET_RFR(0x528e2a00, "Driver Key too large");
		tspRet = FL_GEN_RETVAL(IDERR_INTERNAL_OBJECT_TOO_SMALL);
		goto end:
  which translates to...
    	dwLUID_RFR = 0x528e2a00;
		tspRet = 0x528e2a08; // 8 is IDERR_INTERNAL_OBJECT_TOO_SMALL
		goto end;
  NOTE: we can't do away with the dwLUID_RFR variable altogother because
  stacklogging uses it independently. I want to keep the use of the return
  value in this way optional because it may
  not be possible or desirable to have this
  form of return value always (especially if retrofitting this logging scheme
  (FASTLOGGING) into existing code).
  The GREAT thing is that the compiler will strip out any
  reference to dwLUID_RFR if it is not actually used, so if  the function
  does not have stacklogging (no FL_LOG_EXIT(...)), the following macros
  will translate to
		tspRet = 0x528e2a08;
		goto end;
  CAN'T GET MUCH MORE EFFICIENT THAN THAT!!!!!!

1/4/97 JosephJ
    Modified fastlogs hashing algorithm by adding munging the luid as follows:
      luid ^= luid>>16
    This xors the hsb bits over to the lsb bits.
    This was done because the RFR luids have 00 as the lsb, screwing up the
    hashing distribution especially since the size of the hash table is
    a power of two!

1/4/97 JosephJ
    Putting in assert information into the stacklog:
    * need to define stacklogrec for assert
    * need to mark "fatal-error" flag in the stacklog main structure
	typedef struct
	{
		GENERIC_SMALL_OBJECT_HEADER hdr;
		DWORD dwLUID_ASSERT;

	} STACKLOGREC_ASSERT;

	FL_ASSERT(x>y)

	#define FL_ASSERT(_cond)\
		if (_cond) 
		{
			OutputDebutString(....);
			if (psl)
			{
				psl->LogAssert(dwLUID_CurrentLoc);
			}
		}

	FL_ASSERTEX(0x900000, cond, "this is bonkers");

	#define FL_ASSERTEX(_luid, _cond, _reason) \
		if (_cond)
		{
			OutputDebugString(....);
			if (psl)
			{
				psl->LogAssert(_luid);
			}
		}

    Sample output:
	*func1
	  |
	  | !!!! ASSERTFAIL !!!! (x>y) "this is bonkers" 0xf09900 (blah.cpp)
	  |
	  |


1/5/1997 JosephJ
	Created umdmrtl.cpp to keep functions that interact with external
	components. I decided for now to steal the UnimodemGetDefaultCommConfig
	code from modemui.dll -- a temporary solution -- basically I don't want to
	hassle with loading and unloading modemui.dll just for this measly api.
	See comments/todo's before the definition of UmRtlGetDefaultCommConfig
	in umdmrtl.cpp for detail.

1/7/1997 JosephJ
    * set up in place to implement open/close line.
		 - when does UmOpen/CloseModem get called?
			-- It could happen completely implicitly -- ppDev decides when
			   to open/close device? Nah -- will need to preserve state.
			-- It will be opened based by the relevant tasks on hand -- their
			   state diagrams can deal with the case that the modem is not
			   opened and hence open it.
		- What is llDev->Load() ? May as well be UmOpenModem, why have a 
			   different api? Can change this later if required.
		- What happens on lineOpen?
			-- nothing much, just set state to opened. Later, we may start the
			   async. thread on lineOpen -- else the whole async thread thing
			   could be completely on-demand.
	* Implement it properly in CDevMgr as well.
	* Get this to work with TB20 -- lineOpen(no privilidges)/Close should work.
	* Implement lineDial
		- Concept of a task with its own state
		- APC support
		- ASync callback
		- Open/Close modem 

1/8/1997 JosephJ
    * If passing a stacklog in function arguments is deemed to be too much
      of an overhead, another way of propogating it is to place a pointer
    to it in the current object soon after claiming that objects critical
   section. m_pslCurrent stores the pointer and is set to NULL just before
   releasing the crit sect. Member functions that assume that the crit.
  sect. is held can then use m_pslCurrent. This is useful in fairly
 common cases where one of the public methods of an object is called,
  which results in the crit. sect. being claimed and lots of activity
  happens while this crit. sect is claimed. Any time one of the private
  functions wants to log something, it can use m_pslCurrent. These functions
  can even log function entry and exit. I've used this concept in some
  places in CFact, just to demonstrate the idea.

1/8/1997 JosephJ
    UNICODE issues
    * To keep things simple, UNICODE is assumed. TCHAR is not used -- strings
      are either explicitly char or WCHAR. Most of the logging stuff is
      char.
1/8/1997 JosephJ Blatant Bug in NT4.0 TSP in lineGetAddressCaps
		(unimdm.c, line 3239)

    lpAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS);
    lpAddressCaps->dwNeededSize = lpAddressCaps->dwUsedSize +
                                  sizeof(LINEADDRESSCAPS); <<<<<BUG

    if (lpAddressCaps->dwTotalSize >= lpAddressCaps->dwNeededSize)
    {
	....

	Above should be dwNeededSize = UsedSize+sizeof(g_szzClassList);

	Fixed in NT5.0.

1/9/1997 JosephJ: Following are the times for providerInit plus doing basic
        operations on 10,000 stubbed-out devices:
                [X:\NT\private\unimodem\nt50\tsp]ttsp
                
                tTSPI0: 20570 ms after providerEnumDevices.
                tTSPI0: 21080 ms after providerInit.
                
                tTSPI0: Testing 10000 devices.
                
                tTSPI0: SUCCESS!
                tTSPI0: 23694 ms after completion of test.
                tTSPI0: 23704 ms after process detach.

       The operations done per device (in ttspi.cpp) are:
            lineGetDevCaps
            lineOpen
            lineClose

       From the times above...
        21 seconds to to load the devices (basically read stuff from the
                registry). (2 ms per device).
        1  second to do providerInit (which causes the CDevMgr to ask
                CDevFactory for all the devices and to set up the internal
                array of devices. (0.1 ms per device).
        3  seconds to do the per-device tests (lineGetID,open,close).
                (0.3 ms per device).

        This timing was obtained with logging enabled but logging output        
        disabled (specifically, CStackLog::Dump and ConsolePrintf stubbed
        out).

1/9/1997 JosephJ UNICODE (again) I decided to do the traditional TCHAR so that
        the tsp can potentially be compiled with normal BYTE-sized chars -- it's
        easy enough to do and will ease the Pegasus team's job stealing the code
        for their product (assuming it doesn't do unicode). I wrote
        the ConsolePrintfW function to emulate UNICODE-enabled printf and things
        work dandy.

1/9/1997 JosephJ Thougts on adding diagnostics to the modem control panel
       - diagnostics/troubleshooter page of modem cpl should have:
            - examine and clean up registry
            - enhanced logging (Note: some amount of logging should always
              be enabled)
            - view log(default should include install history, plus components
               and their timestamps, versions) -- the viewing mechanism can
               be to generate and then view html, so you have a nice table
               of contents for the different sub-logs.
            - both of the above selectible on a per modem basis, or combined
              (all modems) basis.
            - Tests:
                -- test comm port: bring up little terminal to type stuff...
                -- test modem0: try the Init commands, etc, view result.
                -- test modem1: try checking for dial tone.
                -- test modem2: try dialing out.
                In all of the above, log copious details. The main log should
                include pointers to the test logs.
            - SendLogTo: be able to encapsulate and send the combined log 
              via (a) email (b) save to disk (c) print.

1/9/1997 JosephJ 1/9 plan of action:
        * finish up lineOpen/Close (comm config stuff).
            - comm. config strategy:
                - fAppRequestedChange
                - ccCurrentDefault
                - ccCall (kept in CDevCall)
        * implement lineConditionalMediaDetection (line open w/ owner)
            - open modem on demand
            - init modem
            - make modem wait for answer
            - handle callbacks
            * get above to work with stubbed out minidriver, with console app.
            * get above to work with stubbed out minidriver, with TB20.
            * test scaleibility with console app.
            * get above to work with real at minidriver, with console version of
              tsp.
            * get above to work with tb20.
        * implement lineMakeCall, lineDrop
            - maintain call state
            - orderly drop on lineClose
            - handle callstates
-------------------
1/11/1997 JosephJ Notes on task handling
	* We want to simulate a synchronous call tree asynchronously -- what can be
	  done by, say fibres, but I don't want to use fibers or any funky external
	  API.
	* The NT4.0 unimodem approach is to have a single large state machine in the
	  upper-level TSP -- we definitely don't want that. We want lots of little
	  state machines, each focused on some coherent thing, like dialing,
	  initing the device, making a call, etc.

	Properties of a task
	--------------------
	1. A task is tied to a particular device and uses the devices' critical
	   section for synchronization. Allocation is managed by the device, and
	   typically doesn't use any global resources -- so tasks can be allocated
	   and freed without touching any global resources.
	2. A task is similar to a windowless window, in that it has a message
	   handler function which is used to receive messages. All calls into
	   this message handle are serialized using the containing devices' critical
	   section.
	3. The task  when it is complete.
	4. Tasks may create subtasks, there is no special parent/child relationship
	   however (or should there be?).

	Task message handler
	--------------------
	TSPRETURN
	MsgProc(DWORD dwMsg, DWORD dwParam1, DWORD dwParam2)
	{
	}
	Sample:

	MsgProcMakeDataCall(....)
	{
		switch(dwMsg)
		{
		case START:
			if (!loaded) load;
			if (!inited) dwRet = llDev->InitModem(this, INIT_COMLETE);
			if (dwRet == pending)
				return;
			// fall through

		case INIT_COMPLETE:
			// handle error

			// start dial
			DoDial();

			// if (dwRet == pending)	
				return;

		case DIAL_COMPLETE:
			// handle errors
			// finish task, signal completion to upper-level task.

		case ABORT:
			if (pending op)
			abort pending opp
			goto end;
		}
	}

--------------------------
class CTask;


typedef TSPRETURN (CTspDev::*PFNTASKHANDLER) (
					CTask *pTask,
					DWORD dwMsg,
					DWORD dwParam1,
					DWORD dwParam2
					);

// Special messages:
START
ABORT
SUBTASK_COMPLETE

#define fLOADED 	(0x1<<0)
#define fCOMPLETED 	(0x1<<1)
#define fABORTING 	(0x1<<2)

// MAKE_SigAndSize(_size)

#define MAX_CONTEXT_SIZE 16

#define MSG_ABORT 0x1

class CTspTask
{

private:

	friend class CTspTaskMgr;

	BOOL is_loaded(void)
	{
		return m_hdr.dwFlags & fLOADED;
	}

	BOOL is_completed(void)
	{
		return m_hdr.dwFlags & fCOMPLETED;
	}

	void Alloc (
			CTspDev *pDevParent
		 	)
	{
		ZeroMemory(this, sizeof(this));
		m_hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(this));
		m_pDevParent = pDevParent;
	}

	TSPRETURN
	Load(
		CTask *pParentTask,
		PFNTASKHANDLER pfnTaskHandler,
		DWORD dwCompletionID
		void *pvContext,
		UINT cbContext,
		)
	{
		ASSERT(!(m_hdr.dwFlags));

		if (cbContext>sizeof(m_rgbContext))
		{
			return IDERR_INTERNAL_OBJECT_TOO_SMALL;
		}
		m_pParentTask = pParentTask;
		m_pCurrentSubTask =  pCurrentSubTask;
		m_pfnTaskHandler = pfnTaskHandler;
		CopyMemory(m_rgbContext, pvContext, cbContext);
		m_hdr.dwFlags = fLOADED;
	}

	void Unload(void)
	{
		ASSERT(is_loaded());
		ASSERT(is_completed());
		ASSERT(!m_pCurrentSubTask);
		ZeroMemory(this, sizeof(*this));
	}

	void Abort(CTspDev *pDevParent)
	{
		ASSERT(is_loaded());
		m_hdr.dwFlags |= fABORTING;
		// TODO: Maybe don't do the following if we're already in aborting state
		(pDevParent->*m_pfnTaskHandler)(this, MSG_ABORT, 0, 0);
	}

	void Start(CTspDev *pDevParent)
	{
		ASSERT(is_loaded());
		// TODO: Maybe don't do the following if we're already in aborting state
		(pDevParent->*m_pfnTaskHandler)(this, MSG_START, 0, 0);
	}

	void Complete(CTspDev *pDevParent, HANDLE  hThreadAPC)
	{
		ASSERT(is_loaded());
		ASSERT(!is_completed());
		ASSERT(!m_pfnCurrentSubTask);

		// TODO handle hThreadAPC (deferred completion)

		// Notify parent we are comlete.
		(pDevParent->*m_pfnTaskHandler)(
				m_pParentTask,
				MSG_SUBTASK_COMPETE,
				m_dwContextID,
				(DWORD) m_pContext
				);

		// Nuke pointer to ourself in our parent.
		ASSERT(m_pParentTask->pCurrentSubTask==this);
		m_pParentTask->pCurrentSubTask=NULL;
		m_hdr.dwFlags |= fCOMPLETED;
	}

	
	GENERIC_SMALL_OBJECT_HEADER m_hdr;
	CTask *m_pParentTask;
	CTask *m_pCurrentSubTask;
	PFNTASKHANDLER m_pfnTaskHandler;
	BYTE m_rgbContext[MAX_CONTEXT_SIZE];
	UINT m_cbContext;
}


TSPRETURN 
CTspDev::TSPICompletionHandler (
		CTask *pTask,
		DWORD dwMsg,
		DWORD dwParam1,
		DWORD dwParam2
		)
{
	switch (dwMsg)
	{
	case TSPI_CALL_COMPLETE:
		pTask->GetState();
		m_pfnCompletionProc(dwID, dwParam1);
		pTask->Complete();
	}
}

TSPRETURN 
CTspDev::MakeCallHandler (
		CTask *pTask,
		DWORD dwMsg,
		DWORD dwParam1,
		DWORD dwParam2
		)
{
	switch (dwMsg)
	{
	case ABORT:
		pTask->AbortSubTask();
		goto end_pending;

	case START:
		if (!device-inited)
		{
			pTask->StartSubTask (
				&(CTspDev::InitModemHandler),
				INIT_COMPLETE
				);
			m_pTaskMgr->StartSubTask(
				hTask,
				&(CTspDev::InitModemHandler),
				INIT_COMPLETE
				);

			if (error)
			{
				handle_error;
			}
			else if (subtask_pending)
			{
				goto end_pending;
			}
			// Else sync. success, fall through
		}

		// FALL THROUGH

	case INIT_COMPLETE:

		// Verify state (modem should be inited/aborting)
		if (aborting)
		{
			handle aborting
		}
		pTask->StartSubTask(
				&(CTspDev::DialModemHandler),
				INIT_COMPLETE
				);
		// handle error/pending/sync-success

		// FALL_THROUGH	

	case DIAL_COMPLETE:

		// Verify state (modem should be connected/aborting)
		pTask->Complete(compete-params);
	}
}

tspRet = m_pTaskMgr->StartTask(
						&(CTspDev::TH_MakeCall),
						COMPLETIONCALLBACK,
						void *pvTaskContext,
						UINT cbTaskContext,
						&phTask
						);

m_pTaskMgr->StartSubTask(
	hTaskParent,
	&(CTspDev::InitModemHandler),
	void *pvTaskContext,
	UINT cbTaskContext,
	INIT_COMPLETE
	);
AbortSubTask
AbortSubTask

LLDev
  hCurrentTask
  

class CTspTaskMgr
{
	Load(
	);
};
------------------------------------
1/16/97 JosephJ
//
// Task Structure
//
// After partially implementing several schemes for tracking tasks and subtasks,
// I settled on a simple scheme allowing just one task (and it's stack of sub
// tasks) to exist per device at any one time. This allows us to keep the
// state in a simple array, the 1st element being the root task, and not
// maintain pointers to parents, children, and not maintain a freelist.
// If in the future we decide to impliment multiple independant tasks active
// at the same time, I recommend implementing them as an array of arrays,
// where each sub-array has the current scheme.
//
// hdr.dwFlags maintains task state:
//				fLOADED
//				fABORTING
//				fCOMPLETE
//				fHAS_SUBTASK
//				fROOT
//
// Note: it is important that the following structure contain no pointers
// to itself, so that it can be moved (rebased) and still be valid. This
// allows the space allocated for stack of tasks to be reallocated if required.
//
typedef struct _DEVTASKINFO
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	PFN_CTspDev_TASK_HANDLER pfnHandler;
	BYTE rgbContextData[MAX_CONTEXT_SIZE]; // contains a GENERIC_SMALL_OBJECT

} DEVTASKINFO;

------------------------------------
1/16/97 JosephJ

Generic allocater: starts with a buffer given to it, but uses larger buffers
	if it runs out of space.

Class CDynaBuf
{

public:

	CDynaBuf(BYTE rgbStartBuf[], UINT cbStartBuf)
	{
		m_hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(this));
		m_hdr.dwFlags = 0;
		m_hdr.dwClassID = dwCLASSID_CDynaBuf;
		m_pbCurrentBuf = m_pbStartBuf = rgbStartBuf;
		m_cbCurrentBuf = m_cbStartBuf = cbStartBuf;
	}

	~CDynaBuf()
	{
		ASSERT(!m_pbCurrentBuf || m_pbCurrentBuf==m_pbStartBuf);

		m_hdr.dwSigAndSize = 0;
		m_pbCurrentBuf = NULL;
	}

	UINT ReAlloc(UINT cbNew, BOOL fCopy, BYTE **ppbNew) 
								// changes internal buf
								// size if it can.
	{
		BYTE *pbNew =  LocalAlloc(cbNew);
		ASSERT(pbNew);
		if (pbNew)
		{
			if (fCopy)
			{
				UINT cbCopy  = (cbNew>m_cbCurrentBuf) ? m_cbCurrentBuf : cbNew;
				CopyMemory(pbNew, m_pbCurrentBuf, cbCopy);
			}

			if (m_pbCurrentBuf != m_pbStartBuf)
			{
				LocalFree(m_pbCurrentBuf);
			}

			m_pbCurrentBuf = pbNew;
			m_cbCurrentBuf = cbNew;
		}

		*ppbNew = m_pbCurrentBuf;
		return m_pcCurrentBuf;
	}


	void Reset(void)
	{
		if (m_pbCurrentBuf!=m_pbStartBuf)
		{
			LocalFree(m_pbCurrentBuf);
		 	m_pbCurrentBuf=m_pbStartBuf;
		 	m_cbCurrentBuf=m_cbStartBuf;
		}
	}

private:

	GENERIC_SMALL_OBJECT_HEADER m_hdr;
	BYTE *m_pbStartBuf;
	BYTE *m_pbCurrentBuf;
	UINT m_cbCurrentSize;

};

---------------------------------------------------------------------------------------------
1/22/1997 JosephJ

Task states:
    PENDING
        SUBTASK_PENDING
    ABORTING
    
1/24/1997 JosephJ
Possible bug in NT4.0 TSP: function TSPI_lineGetCallStatus(...)
    unimdm.c line 2427 ASSERT(lpCallStatus->dwCallFeatures == 0);
    This shouldn't be an assert -- dwCallFeatures has not been set yet
    in this codepath, and should be set to 0 here. NT5.0 TSP does this.

1/24/1997 JosephJ
    Split cdev.cpp into cdev.cpp, cdevline.cpp, cdevtask.cpp and cdevcall.cpp

1/25/1997 JosephJ
    BUGBUG: We currently keep the registry key for the device open for as long
        as the modem is open -- which for the server is all the time.
        We don't really need to do this. On a 1000 server system, that's
        1000 open registry keys.

    Current behaviour is that mini driver takes open hKey and expects it
    to be open throught the session. It doesn't close the key itself -- the
    TSP is expected to close it.

1/25/1997 JosephJ
     Console window can display stacklogs from different sources in different
     colors. For example:
        white:    TSPI calls
        red:      APC calls
        yellow:   Minidriver Callbacks
        
1/27/1997 JosephJ
     Some notes on LINEINFO, CALLINFO and LLDEVINFO.
   These structures sit inside the CTspDev object and maintain state about 
   open lines, active calls and open modems, respectively. They are named
   CTspDev::m_Line, CTspDev::m_Call and CTspDev::m_LLDev respectively. Access
   to them is via pointers m_pLine, m_pCall and m_pLLDev respectively. They
   are accessed via pointers simply to make it very clear when they are
   and are not defined (in scope). They are in scope if and only if the pointer 
   is non-NULL (in which case the pointer points to the corresponding struct).
   mfn_LoadLine, mfn_LoadCall and mfn_LoadLLDevInfo bring them in scope and
   functions mfn_UnloadLine, mfn_UnloadCall and mfn_UnloadLLDev take them
   out of scope.
    
1/29/1997 JosephJ Proposed changes to task mechanism:
    - have a predefined "root" task, with a callback -- this root task's
      callback will be the one that calls the TAPI callback function, not
      the individual subtasks handlers, like TH_MakeCall, TH_DropCall, etc.
    - allow queueing of subtasks -- basically the parameters to 
      mfn_StartTask are saved in a structure and pushed in a queue. They
      will be executed when the current task is complete. This will allow,
      for example, a lineMakeCall to be processed while we are in the middle
      of monitoring after a previous call.

1/29/1997 JosephJ Proposed changes to routing of TSPI calls
    - Make the TASKPARAM structures GENERIC_SMALL_OBJECTS, with
      a few extra fields tacked on:
        - TaskID
        - DeviceID -- could be dwDeviceID, hdLine or hdCall based on the
          flags.
    - Get rid of the dwRoutingInfo parameter, move it to hdr.dwFlags.
    - Add "async call" as one of the flags -- these are TSPI calls which
      complete asynchronously.

1/29/1997 JosephJ More details on the changes to the tasking functionality.
    - Instead of a special "root" task, may as well create a TH_AsyncTAPICall
      task which takes as start parameters the dwRequestID and the actual
      handler function for that async call. The latter async call will take
      no parameters -- all relevant information will be available somewhere
      else in the CTspDev object.

      typedef struct
      {
        DWORD dwRequestID;

      } CONTEXT_ASYNCTAPICALL;

CTspDev::mfn_TH_AsyncTAPICall(
					HTSPTASK htspTask,
					void *pvContext,
					DWORD dwMsg,
					DWORD dwParam1,
					DWORD dwParam2,
					CStackLog *psl
					)

CTspDev::mfn_TH_AsyncTAPICall(
					HTSPTASK htspTask,
					DWORD dwMsg,
					DWORD dwParam1,
					DWORD dwParam2,
					CStackLog *psl
					)
GetPrivateContext(hTask, ppContext, cbContext);
GetParams(hTask, ppParams, cbParams);

StartTask(
    hParentTask,
    pvContext,
    cbContext,
    dwTaskID
    pParam1,
    pParam2
)

SUBTASK_COMPLETE:
    pParam1 = pvSubtaskContext;
    pParam2 = dwSubtaskID;
    pParam3 = dwAsyncResult;
);


typedef struct
{
    GENERIC_SMALL_OBJECT_HEADER hdr;
    DWORD dwDevice;
    DWORD dwTASKID;
    DWORD dwReqID;
    LONG  lRet;
}


p.hdr.


1/30/1997 JosephJ
    After much deliberation, have decided on the following:
    * Keep to current task scheme -- single root task active, no special
      root-context available to subtasks.
    * Only one TAPI Async call can be "current" at a time. By current, I
     mean that it is actively being processed by a task.
    * Since there is only one current TAPI async call, we can store its 
     request ID and result in the LINEINFO struct itself, and not some
    where in the task-specific memory.
    * There can be queued TAPI async calls -- these are async calls that
    are queued for execution after the currently executing task is complete.
    (this is as-yet unimplemented).
    * All TAPI async calls are handled as subtasks of a special task, called
    TH_AsyncTSPICall. TH_AsyncTSPICall is passed in a pointr to the handler
    function to actually process the tspi call, and is responsible for
    calling the TAPI callback function when done. In addition, it is also
    responsible for re-posting listen if required -- in fact, I've decided
    that it reposts listen BEFORE asynchronously completing the call --
    this is a CHANGE from previous unimodem behaviour. Win9x and NT4.0
    unimodem would complete, say, lineDrop as soon as the line was dropped,
    so had to deal with the case that a new lineMakeCall could come in
    while we were still posting a listen. With the new scheme, we only
    claim that lineDrop is complete AFTER we have posted the listen. This
    reduces the need to ever queue TSPI calls -- infact maybe we never need
    to queue TSPI calls.
 
1/30/1997 JosephJ
    Some wierd C++ behaviour: you can't cast a pointer to a member function
    to a DWORD -- to get around it, I cast a pointer to pointer to the
    member function to a DWORD. This is required for TH_AsyncTSPICall, which
    is passed in a pointer to a task handler as it's DWORD lParam2 on startup.

1/30/1997 JosephJ
    Validating pointers to task handlers. Given the fact that type info is
    lost when casting the handler function to DWORDS above, and in general
    in the interest of error checking, all handler functions must respond
    to the special message MSG_ARE_YOU_FOR_REAL. See notes on
    MSG_ARE_YOU_FOR_REAL in cdev.h for more info. This works quite well.



2/6/1997 JosephJ
    Pointers to member functions again.
    Because these pointers are larger than dwords they pose problems.
    Hence I define static pointers to these functions and pass pointers
    to these static pointers. These pointers to pointers are ordinary
    32-bit pointers.
    Later we should convert this scheme to a static table of handler functions,
    and all references to handler functions should simply be an index
    into this table. The actual function pointer is accessed only
    when actually calling into this function.

2/6/1997 JosephJ
    FYI: NT4.0 unimodem ignores lpLineCallParams->dwMin/MaxRate and
    ->dwAddressID/Mode. (It checks the latter for valid values on
    lineSetConditionalMediaDetection, but ignores them
    in the LINECALLPARAMS passed into lineMakeCall.


2/6/1997 JosephJ
    Another NT4.0 Bug:
    The DevConfig part of LPLINECALLPARAMS passed into lineMakeCall is
    effectively ignored.
    
    lineMakeCall passes on the devconfig part of lpCallParams to
    TSPI_lineSetCallParams with NULL as the szDeviceClass parameter of the
    latter function. The latter function simply fails because of this
    NULL param and the failure is ignored by lineMakeCall.
    
2/8/1997 JosephJ
    Some comments on the new-vs-old scheme for tsp state diagram.

    The NT4.0 scheme was doubly messed up -- firstly logically there was one
    huge state diagram; secondly this state diagram was implemented all over 
    the place.

    The NT5.0 scheme is hierarchical, and each sub-state diagram is implemented
    in one place.

2/8/1997 JosephJ
    Got to think of some way to eliminate the inter-ring timer. How?
    Can't eliminate it, but can use the SleepEx(xxx) of the APC thread
    to implement timer functionality without any additional resources, like
    events or timers -- basic idea is to control the wit of SleepEx. To wake it
    up earlier, simply submit an apc call which will recalc the sleep amount
    again. We will need to maintain a chain of timers as did NT4.0, but that's
    no problem at all and quite light weight.
    

2/11/1997
Tapitest is still running with 850 successful calls (zero bad) with the new
nt5.0 tsp and minidriver. This is with two real modems on my x86 machine.

We achieved this level of stability in one shot -- i.e., as soon as I got both
dial and answer to work with tapitest, it just kept on running.

This is a testament to our design, the quality of our implementation, and the
quality of the component tests which our test group have developed and have
been testing Brian's mini driver with for some time now.

This is in stark contrast to the pain and months  of effort that went into
getting NT4.0 unimodem to be stable, after send and receive was demonstrated.

Much remains to be done. Although I expect to get RAS, fax and Hyperterm to
work in short order, features such as pre/post terminal, call status, pnp and
of course integration with heather's wave driver are yet to be done.

Heather and I will work on wave integration. Brian is working on PnP and on
providing us with IOCTLS for ipc communication between wave driver/am filter
and the TSP.

I will have RAS and fax working by the end of the week, and we will have wave
and PnP by the end of the month.

The test group is developing their test architecture so that they can run voice
and data stress tests either on the whole system (tapi+tsp+minidriver+wave)
or directly on the minidriver, with most of the test code shared. I can't
emphasize enough how cool this is, both for efficient testing and for
efficient isolation of problems!!!



2/11/1997 JosephJ
    Example of why every bit in every structure matters. HyperTerm was
    watching for the LINEDEVSTATUSFLAGS_INSERVICE bit of
                lpLineDevStatus->dwDevStatusFlags set in the call to
    lineGetLineDevStatus(...), and I wasn't setting it (bug), so it put up a 
    line dialog box asking me to plug in the modem!

2/21/1997 JosephJ
    Fixed bug related to calling lineCloseCall when the call is in various
    stages. There were several problems:
    * simple typo, causing us to CloseHandle on an event twice, resulting in a
      fault.
    * UmInitModem was ignoring the Abort command and returning success, so
      TH_MakeCall would go on to dial even when we were trying to hangup.
      Strictly speaking UmInitModem should be fixed to return async failure
      in case, but anyway I changed TH_MakeCall so that if the call is
      in the aborting state it will force the async return of a subtask
      to be IDERR_OPERATION_ABORTED, so that it doesn't go on to do the next
      thing.
    * I also check if the call still exists on re-entering the Critical
      section after waiting for pending operations in lineCloseCall, because
      in principle anything could have happend while the the devices' critical
      section was not held.

    The TSP is now quite robust w.r.t. dropping calls at various stages
    of making them. I tested this via Dialer and Hyperterm.

2/21/1997 HeatherA
    Added the two new parameters to UmOpenModem (Modem ID and Comm handle).

2/22/1997 JosephJ
    Lightweight timer services.
    On further reflection, I decided to use the waitable timer, but only one.
    Using one waitable timer we can implement an arbitrary number of timers.
    After creating the apc thread, we create a waitable timer on that thread.
    We then maintain a list of light-weight timers, each of which can be 
    set and cleared independently. Each CTspDev creates a light-weight "ring"
    timer when it is Loaded and distroys this timer when it is unloaded.
    When a ring comes in, this timer is set to the inter-ring timeout. If
    the call is answered or dropped, the inter-ring timeout is cancelled.
    Setting and cancelling  timer is fairly lightweight operation. Although
    it does require grabbing the timer's global critical section in practise
    this action will never block because it's always done in a single
    thread's context (the APC thread).


    Light Weight Timer Services
    ---------------------------

    // CreateLWTimer creates a lightweight timer. The callback function
    // will be called with the specified token when the timeout expires.
    //
    HLWTIMER 
    CreateLWTimer(
        LWTIMERCALLBACK pfnCallback,
        DWORD           dwToken
        );

    // Distroy the specified lightweight timer. The handle becomes invalid.
    void
    DistroyLWTimer(
        HLWTIMER
        );


    // Set the timeout for the specified lightweight timer.
    // SetTimer can be called multiple times in succession -- the most
    // recent value is used to fire off the timer. WARNING: it's quite possible
    // that the timer has just fired and the callback is sitting in the apc
    // queue. In this case a 2nd callback will be  sent if and when the new
    // timeout expires.
    //
    // dwFlags indicates how to interpret the specifed dwDelay.
    // The following flags are supported
    //  fLWTIMER_RELATIVE_MS     - dwDelay specifes a relative time in ms from
    //                             the the current time.
    //
    BOOL
    SetLWTimer(
        HLWTIMER, 
        DWORD dwFlags,
        DWORD dwDelay
        );

    // Effectively sets the timeout value to infinite.
    void
    CancelLWTimer(
        HLWTIMER
        );
    

    Implementtion
        * Maintain two UNSORTED lists of timers: ACTIVE list and  INACTIVE list.
        * SetLWTimer moves lwtimer from inactive to active (if not already on 
          active).
        * CancelLWTimer moves lwtimer from inactive to active (if not already
          on inactive).
        * One lwtimer in the active list is selected to be the next timer to
          be activated. A pointer to this next-timer-to-be-activated is 
          maintained. Special action is taken by SetLWTimer and CancelLWTimer 
          they determine that this next-timer-to-be-activated needs to be
          changed.

2/23/1997 JosephJ 9am

    Note the code as checked in today ran for 4,600 calls on my machine, with
    zero failures, using Sorin's mdmtapi stress test on two USR modems.

2/23/1997 JosephJ
    Re-initing and re-monitoring after calls; recovering from hw failures, etc.

    Currently the tsp does not re-init and re-monitor after every call. It
    should.

2/25/1997 JosephJ
    TODO: Need lineGetID(CALLSELECT_LINE, "comm/properties") to return
    COMMPROP structure, instead of requiring app to open handle and go
    a GetCommProperties on the handle.

2/26/1997 JosephJ
    Adding voice.
    The guidline for doing so are examining the pieces of code in unimodem/v
    that are enclosed by _AT_V.

    Specific things I'm not considering for now are: forwarding, distinctive
    ringing and speakerphone related stuff. The latter will eventually go into
    NT5.0, but the former probably never will.

    1st step is to get the voice properties from the registry while creating
    the device. These go into m_StaticInfo.

    2nd step is to modify the key TSPI calls to be voice-aware, looking at
    unimodem/v code for guideance.

    3rd step is to try to make and answer a voice call with tb20,
    following the voice bvt instructions. The unimodem/v state diagram must
    be examined to make sure that there are no holes.

3/21/1997 JosephJ 3am
    Checked in some changes to cdevline.cpp and cdecall.cpp that cleaned up
    the loading/unloading of calls and the lldevice.
    
    Previously CTspDev::mfn_LoadCall and CTspDev::mfn_UnloadCall were
    asymetric in that mfn_LoadCall would not try to load the device but
    mfn_UnloadCall would unload the device IFF it was an outgoing call.
    Other places would unload the device on failure of the call, and there
    was a bug whereby the call would not get unloaded if lineMakeCall failed
    asynchronously (because the call would only get unloaded if lineCloseCall
    is called, and TAPI wasn't calling lineCloseCall if lineMakeCall failed
    asynchronously, probably by design). This was causing the call to never
    get unloaded if, for example, the modem was off and so init failed. There
    was also another possibility of the call not being unloaded -- if the 
    attempt to start the TH_MakeCall failed without invoking TH_MakeCall at
    all.
    The cleanup basically consists of moving the mfn_LoadLLDev from TH_MakeCall
    to mfn_LoadCall and moving mfn_UnloadLLDev from TH_DropCall or other places
    to mfn_UnloadCall (now mfn_UnloadCall ALWAYS calls mfn_UnloadLLDev). The
    cleanup also consists of making sure mfn_UnloadCall is called in all cases.


3/21/1997 JosephJ 6am 
    Checking in code to send LINE_CLOSE if there is a hw failure (either
    failure to init/monitor or an unsolicited hw failure notification sent
    up by the minidriver. Basic idea is to set a "fCALL_HW_FAILURE" bit
    in the call info (m_pLine->pCall) if there is a call or else send
    up a LINE_CLOSE message to TAPI if we are monitoring. When unloading
    the call, we send up a LINE_CLOSE message if the fCALL_HW_FAILURE bit
    is set.

    I found that I was not getting a response from the minidriver if
    I switched the modem off when the line was open with owner privs -- need
    to follow up with Brian re this.

3/21/1997 JosephJ 3pm
    Implementing passthrough...

    Examining NT4 tsp yielded the following observations:
    (a) The key functions are lineMakeCall and lineSetCallParams.
    (b) NT4 switch to/from passthrough was synchronous, and could potentially
        block in the sync call to Devioctl(passthrough on/off).
        On NT5 it is handled async, as it should, but this means
        a slight change in behavour for switching to/from passthrough on
        an already connected call using the synchronous lineSetCallParams:
            On NT4 CONNECTED was sent up in the context of the lineSetCallParams
            call itself, while for NT5 this will be sent later.
        The same thing is true for lineMakeCall, but atleast lineMakeCall is
        in general expected to be an async call, so apps would in general
        be expected to handle an async CONNECTED message.
    (c) Switching in/out of passthrough for an
        already connected call is supported, so we should make sure we don't
        break this functionality.
            

    For NT5, I decided to implement a passthrough call using a passthrough-
    specific task handler for making and dropping a call instead of TH_MakeCall,
    and TH_DropCall. This is very simple to do and allows us to isolate the
    two kinds of calls (changes to the passthrough versions can be done without
    in anyway risking a traditional call), and moreover is cool because it is
    something that would have been essentially impossible to do on NT4
     (i.e., it would not be possible to isolate the implementation of a
     passthrogh call in this way on NT4.0 tsp).

4/8/1997 JosephJ 2am
    All this config dlg stuff....

    I moved all code that runs in the apps context to files with "app" prefix.

    General note:
    TSPI_providerGenericDialogData and
    TUISPI_providerGenericDialogData and
    are used to ferry TSP-specific "blobs" of data back and forth between the
    TSP and the app.

    One issue is how to make this config dlg stuff all extensible. The sequence
    is that TAPI first calls the TSPI's getUIDLL function to get the name
    of the UI DLL. At this time we don't know which device it pertains to.
    Tapi then calls this DLL's entry point with for example
     TUISPI_lineConfigDialog, and specifies a deviceID. 

    One strategy is for TUISPI_lineConfigDialog to send a blob asking unimdm.tsp
    for the ui dll to use for this device and go from there.

4/20/1997 2pm JosephJ
    Extension DLL stuff....
    
    I created subdirectlry ex, which  contains a sample extension dll.
    The file ex.h contains the proposed extension APIs.

    Changes required in the TSP to support extension:
    1. TSP should dynamically load the mini-driver. Currently it is statically
       linked.
        - How is tsp going to determine the mini-driver to load?
          In device's registry key, TSP looks up the REG_BINARY GUID key
          MiniDriverGUID. If it finds, it, it  searches internally amongst its
          loaded mini-drivers for one with this GUID. If it finds it, it 
          increments the loaded mini-drivers' ref count. If it doesn't find it,
          it looks up the REG_STRING name
          Unimodem\MiniDriverSpecific\{<GUID>}\MiniDriverPath,
          whose value is the path of the mini driver. The TSP then loads this
          mini-driver (this includes validating it).

    2. TSP should filter all device-specific calls through the loaded
       mini-driver, if the mini-driver supports extensions.

    3. When the device is unloaded (currently only on exiting the TSP, the
       ref-count of its mini-driver should be decremented, and the mini-driver 
       unloaded if the ref-count goes to zero.


    
4/27/1997 JosephJ
    More tricks by the compiler (unimdmex.dll)
        69301721 FF 74 24 14      push        dword ptr [esp+14h]
        69301725 8B C8            mov         ecx,eax
        69301727 FF 74 24 14      push        dword ptr [esp+14h]
        6930172B FF 74 24 14      push        dword ptr [esp+14h]
        Here it is  in effect executing:
            func(a,b,c)
            {
                ...
                func1(a,b,c)
            }
        Each instance of "push dword ptr[esp+14h]" pushes a different argument
        because the stack itself is being decremented as a result of the push!
        -------------------------

    This time windbg gets confused (and so do I). This is code for
    CTspDevExt::OpenModem in ex\cext.cpp:

        
    The relevant part of the source for member function OpenModem is:
    HANDLE
    CTspDevExt::OpenModem(
        HKEY        ModemRegistry,
        HANDLE      CompletionPort,
        LPUMNOTIFICATIONPROC  AsyncNotificationProc,
        HANDLE      AsyncNotificationContext,
        DWORD       DebugDeviceId,
        HANDLE     *CommPortHandle
    )
    {
        HANDLE h = NULL;
    
        mfn_enter();
    
        if (m_fLoaded && !m_hModemHandle)
        {
    
            //
            // We substitute our own callbacks and context here!
            //
    
            m_hModemHandle = g.pfnUmOpenModem(
                                    g.hLowerLevelDriverHandle,
                                    NULL,
                                    ModemRegistry,
                                    CompletionPort,
                                    OurAsyncNotificationProc,
                                    (HANDLE) this,
                                    DebugDeviceId,
                                    CommPortHandle
                                    );

    The asm as displayed by windbg is:

        CTspDevExt::OpenModem:
        693019A4 55               push        ebp
        693019A5 8B EC            mov         ebp,esp
        693019A7 56               push        esi
        693019A8 8B F1            mov         esi,ecx
        693019AA 57               push        edi
        693019AB 56               push        esi
        693019AC 33 FF            xor         edi,edi
        693019AE FF 15 00 10 30 69 call        dword ptr [__imp__EnterCriti...
        693019B4 39 7E 18         cmp         dword ptr [DebugDeviceId],edi
                                                         ^^^^^^^^^^^^^
                                                        This is wrong!

                            It should be this->m_fLoaded, which happens to be
                            the 7th DWORD in the object (this pointer is ESI),
                            so it m_fLoaded should be [esi+18h].

                            The code itself appears
                            to work, so this looks like a problem with the
                            debugger display. I don't know how to get it
                            to display just raw instruction instead of
                                cmp dwprd ptr [DebugDeviceID],edi

                            The rest of the dump ...
        693019B7 74 39            je          CTspDevExt::OpenModem+4Eh
        693019B9 39 7E 28         cmp         dword ptr [esi+28h],edi
        693019BC 75 34            jne         CTspDevExt::OpenModem+4Eh
        693019BE FF 75 1C         push        dword ptr [CommPortHandle]
        693019C1 FF 75 18         push        dword ptr [DebugDeviceId]
        693019C4 56               push        esi
        693019C5 68 53 19 30 69   push        offset OurAsyncNotificationProc
        693019CA FF 75 0C         push        dword ptr [CompletionPort]
        693019CD FF 75 08         push        dword ptr [ModemRegistry]
        693019D0 57               push        edi
        693019D1 FF 35 44 30 30 69 push        dword ptr [?g@@3UGLOBAL@@A+24h]
        693019D7 FF 15 50 30 30 69 call        dword ptr [?g@@3UGLOBAL@@A+30h]

6/2/1997 JosephJ
    Incorporating ALL _AT_V-encapsulated changes from unimodem/v into the TSP.
    All phone-specific info is kept in PHONEINFO.
    * done unimdmv/cfgdlg.c
    * ignored forward.c (TSPI_lineForward) This feature is not a good match
      for POTS capabilities. According to brianl, all we were doing was to
      send some digits to the wire (which digits depends on the exchange).

6/3/1997 JosephJ Debugger extensions
    Created dbgext.cpp, which exports TSP debugger extensions. The idea
    is that for beta1, these extension apis are exported in the tsp itself,
    to make it easier to track changes, just like flhash.cpp, which contains
    the static fastlog hash table.

    Unfortunately, windbg doesn't like dlls which don't end with .dll, so
    to actually use the extensions, you have to copy unimdm.tsp into
    unimdm.dll.

    The plan is for each internal object to expose a varity of diagnostic-
    related entry points which can be accessed from windbg via a set
    of commands. These commands will be subset of the commands that 
    can also be executed from a remote process by using the mail-slot
    mechanism.  The latter mechanism allows various diagnostic commands to
    be executed in the process' context, so allows more flexibility.

    The basic command format is !tsp <cmd> <args>
    
    <cmd> is one of:
        help [<cmd>]    help

        dds <device> dump device state for line device <device>

        Example: !tsp dds 5

        dsl <address> Dump the stacklog at address <address>

        Example !tsp dsl 0x209890ab

    -*-


6/6/1997 JosephJ Documentation on LINE_REMOVE, taken from the TAPI2.0 design
        documenation (from http:tapi). (PHONE_REMOVE is equivalent).

6.3.6 LINE_REMOVE (new)

LINE_REMOVE 
----------
LINEEVENTPROC params:
    htLine = (DWORD) 0;
    htCall = (DWORD) 0;
    dwMsg = LINE_REMOVE;
    dwParam1 = (DWORD) dwDeviceID;
    dwParam2 = (DWORD) 0;
    dwParam3 = (DWORD) 0;

dwDeviceID
The device that has been removed.
A service provider sends a LINE_REMOVE message to TAPI when it desires to disable an existing line device. This can occur when the removal of the device from the system (in a permanent way) is detected by Plug and Play or through a control panel or other user interface. It should not be used when a device is temporarily disconnected, such as if the device is a PCMCIA card that is extracted (LINEDEVSTATE_DISCONNECTED or _OUTOFSERVICE should be used in this situation). 
When the message is received, TAPI.DLL will close the line device (if it is not already closed) by calling TSPI_lineClose, and send LINE_CLOSE to all applications that have the line open; if any calls are active, TSPI_lineCloseCall will be called on each of them prior to TSPI_lineClose. After processing of the message, TAPI will not call the service provider referencing the removed devices dwDeviceID. TAPI returns LINEERR_NODEVICE to any application that attempts to reference the removed dwDeviceID.
After TSPI_providerShutdown has been called, the service provider should renumber its devices to remove any numbering gaps left by the device removal, so that when TSPI_providerEnumDevices is subsequently called, installed devices are contiguously numbered. The service provider should not reuse the dwPermanentLineID that had been assigned to the device, for as long as possible.
The LINE_REMOVE mechanism is intended to be used only if devices are removed while the service provider is active (i.e., between TSPI_providerInit and TSPI_providerShutdown).
This message is sent to TAPIs LINEEVENT callback entry point. The service provider receives a pointer to this callback in the TSPI_providerEnumDevices function and in each TSPI_lineOpen function; the LINE_REMOVE message can be sent to the LINEEVENT callback function given to any open line or at startup.
Backward Compatibility
Older service providers would not be expected to send this message. If they do, the message will be treated in the same manner as described above for new service providers.

PHONE_REMOVE
-----------
PHONEEVENTPROC parameters:
    htPhone = (DWORD) 0;
    dwMsg = PHONE_REMOVE;
    dwParam1 = (DWORD) dwDeviceID;
    dwParam2 = (DWORD) 0;
    dwParam3 = (DWORD) 0;
    
    #if 0
    MASK
    PATTERN
    SUBMASK

6/11/1997 JosephJ

    More thoughts on the compact representation of state

        IsState    :  ((state&MASK)==PATTERN)
        SetState   :  state = (state & ~SUBMASK) | PATTERN
    
        #define P_ALLOCATED (0x1L<<0)
        #define M_ALLOCATED  P_ALLOCATED
        #define SM_ALLOCATED ((DWORD)-1)
    
        #define IS_ALLOCATED(_state) \
                ((_state & M_ALLOCATED)==P_ALLOCATED)
    
        #define SET_ALLOCATED(_state) \
                (((_state) = (((_state) & ~SM_ALLOCATED) | P_ALLOCATED)))
    
        #define P_LINE      (P_ALLOCATED | (0x1L<<1))
        #define M_LINE      (P_LINE)
        #define SM_LINE     (P_LINE)
    
        #define P_LINEOPEN  (P_LINE | (0x1L<<2))
        #define P_LINEOPEN  (P_LINE | (0x1L<<2))

    --------------------------

6/17/1997 JosephJ
    I am moving the AIPC start/stop from load/unload LLDev to
   dial/answer/hangup. AIPC is started as the final step of tasks
   TH_MakeCall and TH_AnswerCall, and AIPC is stopped as the 1st step
   of TH_DropCall. Introduced new tasks TH_Start/StopAIPCAction.

6/17/1997 JosephJ 
    Thoughts on "IPPSTN gateway APP."

    Interface to media handling DLL.

    Init:
    >>CallState: CONNECTED/DISCONNECTED/DTMF
    <<Action: Disconnect
    

7/13/1997   JosephJ Passthrough revisited...

    How do we get into passthrough mode?

        (a) When making a passthrough call:  by specifying
            the LINEBEARERMODE_PASSTHROUGH bit in
            LPLINECALLPARAMS.dwBearerMode in TSPI_lineMakeCall.

            IMPLEMENTATION: Special Th_MakePassthroughCall handles this...

        (b) Incoming calls: Switching into passthrough mode on
            an offering call:
              lRet = lineSetCallParams(CallHandle,
                                   LINEBEARERMODE_PASSTHROUGH,
                                   0,
                                   0xffffffff,
                                   NULL);

            IMPLEMENTATION: Special Th_SwitchToPassthrough handles this...


        For  (a), the app will wait for a LINECALLSTATE_CONNECTED
        before it tries to get the comm handle.

        For (b), the a LINECALLSTATE_CONNECTED message is sent only
        if the line is not already connected (BUGBUG: so how is the
        app to know that the passthrough operation is completed?)

    How do we get OUT of passthrough mode?

       (a) TAPI_lineDrop

       (b)  lRet = lineSetCallParams(
                           CallHandle,
                           dwBearerModes & ~LINEBEARERMODE_PASSTHROUGH,
                           0,
                           0xffffffff,
                           NULL
                           );

        For, case (b), the call remains in the connected state, and
        disconnect monitoring continues -- this is typicall done prior
        to handoff from fax to RAS.


        From cdevcall.c: (processing lineSetCallParams)
                //
                //  7/14/1997 JosephJ
                //      TODO/BUGBUG: Enable this once we've fleshed out the
                //      semantics
                //      of switching out of passthrough while there is
                //      actually an active data call...
                //


-------------------------------------------------------------------------------

7/15/1997 JosephJ

    Updating commconfig, deciding when to reinit modem (Bugs # 83917 and 81680)
    ---------------------------------------------------------------------------

    Track the DEFAULT commconfig setting closely, unless it has
    been updated programmatically while the line is open.

    The simple way to do this is to keep a fTrackDefaultCommConfig flag in
    LINEINFO (set on LOAD). If this flag is set, update the commconfig settings:
        (a) Just before it is requested via lineGetDevConfig
        (b) 


    
7/17/1997 JosephJ
    Checked in fixes for following bugs:
        88467: wave/in wave/out, tapi/phone class only reported if device
              supports them.
       
        76151: incoming passthrough (lineSetCallParams bearermode PASSTHROUGH)
               supported.

        Also fixed bug in lineGetID(comm\datamodem) where we were setting
            the 2nd dword to the size of the structure, not to the offset to
            the name of the string.

--------------------------------------------------------------------------------
7/22/1997 JosephJ
        Exposing diagnostics through TAPI until we have official APIs for them.

        Basic idea is to use lineDevSpecificFeature.

--------------------------------------------------------------------------------
7/22/1997 JosephJ
        Radical solution: lineGet/SetCommConfig maps
                    to Get/SetDefaultCommConfig.
        This is what I have done see notes below
-----------------------------------------------------------------------------
7/31/1997 JosephJ Checkin fixes for the following.....
76148       _This Milestone TSP 1   04/01/97    josephj +B1: UNIMODEM 5: TSP: Can't  generate DTMF tones.
    Sorin, I'd like to work with you on the1st pass testing this. Please test lineGenerateDigits. I do not currently support queuing, so you can't send back-to-back lineGenerateDigits and expect the 1st to be cancelled and the 2nd started -- instead the 1st will be cancelled and the 2nd call will fail. Also, the call will fail if the wave device was being start/stopped at that time. Please test various boundary conditions, including making sure that lineGenerateDigits returns failure (LINEERRINVAL_DIGITMOD
E) if asked to generate pulse tones.

81680       _This Milestone TSP 1   05/07/97    josephj +B1: UNIMODEM: Modem goes through extra (unnecessary)  initialization phase before answering.
    Please test (by looking at the log file) that the modem is only initialized as needed (including after a change in the modem config via the CPL or via lineSetDevConfig -- ras does the latter). Definitely test with RAS and HYPERTER and stress!

83917       _This Milestone TSP 1   05/21/97    josephj +B1: TSP doesn't refresh modem settings when changed in CPL
    Please verify behaviour under the following conditions:
(a) tapisrv not running
(b) tapisrv running, no lines open
(c) line is open for  incoming calls, but no call in progress
(d) call is in progress
Verify that things work with ras and hyperterm running when the changes are made in the CPL.
WARNING: this fix also changes the behavior of lineSetDevConfig from NT4 -- it now does a lineSetDefaultCommConfig. Why? Because lineSetDevConfig doesn't have a line or call handle, and early behaviour was flaky. We may have to get RAS to move from using this API to using the callparams, but we'll deal with that later. For now main thing to test is that we don't break common usage.

95720   S0725   _This Milestone TSP 1   07/25/97    josephj +Unimdm: Almost all tapi apis (27) that Unimodem not supported return OPERATIONFAILED not OPERATIONUNAVAIL
    All the apis listed in the bug should now return UNAVAIL

------------------------------------------------------------------------------
8/05/1997 JosephJ
    Changed
        cdev.cpp         41   41  out      
        cdev.h           40   40  out      
        cdevcall.cpp     35   35  out      
        cdevll.cpp       19   19  out      
        fastlog.cpp      21   21  out      
        flhash.cpp       31   31  out      
        notes.txt        36   36  out      

    This fixes the following bugs:
95778   *B1: BVT: UNIMODEM: Doesn't send disconnected message when
                 busy is reported
96599   *B1: UNIMODEM: lineSetAppSpecific unimplemented
97815   *B1: UNIMODEM 5: TSP: g3fax media type is declared as supported,
                 but call made with it fails

------------------------------------------------------------------------------

10/11/1997 JosephJ
    Supporting devices which could be either line devices, phone devices or
    both.

    TAPI needs to be told once, during providerEnum, howmany lines and
    phones are present at init time.

    It will then call providerInit with those same numbers, giving a
    base line-deviceid and phone-deviceid, providing an implicit range
    of tapi lineids and phoneids for the tsp to use.


    The unimodem tsp needs to support this mechanism over our concept
    of supporting devices, each of which could be a line device, a phone
    device, or both.

    How should we do this?


    One providerEnum, the mgr asks the fact for a list of pids, as well as
    the number of line-devices and phone-devices. The mgr caches the list
    of pids. So at this point it has a snapshot of: list of pids (length==
    total number of devices), and the number of lines and phones. Note that
    max(lines, phones) <= number-of-devices.

    On providerInit, we actually ask the factory to create the devices
    corresponding to the list of pids it saved away during providerEnum.
    The factory will try create all of them, but if there some have
    gone away it will only create a subset of them.

    We then go through and actually create the devices, allocating each
    a lineID and phoneID from the pool allocated to us.

    Note that this assumes that every providerInit will be preceded by
    a providerEnum (during which we have a sideaffect of caching the
    specific list of PIDs to use). In practise this is was TAPI does.
    Tf in the future we need to be able to work with two successive
    provdierInits without an intervening providerEnum we can deal with
    then. For now we can assert on this situation.
    
10/13/1997 JosephJ   Dealing with line and phone device creation.
------------------

    When we want to create a new device, we notify TAPI by LINE_CREATE and
    PHONE_CREATE. Tapi calls us back with CreateLineDevice
    and CreatePhoneDevice. We call down the device object's
     "RegisterProviderInfo" when we get the 1st of these notifications, and
    follow it with an DeferredActivateTapiDevice(dwDeviceID, fLine);

10/16/1997 JosephJ Modem Configuration Issues
------------------

    Each TUISPI_providerGenericDialog is expected to not return until
    the diaglog is complate. Our implementation in cdevdlg.cpp
    simply sits in a message loop and return from the function only
    after exiting.


10/16/1997 JosephJ Phone Device Support
------------------

    The voice modem is abstracted as follows:

                                 +--------------+
                       /=========|    LINE      | -> to phone line
   audio stream <=====X(1)       +--------------+
     to PC             \     /===|   HANDSET    | -> to external phone
                        \===X(2) +--------------+
                             \===| SPEAKERPHONE | -> to mike and speaker*
                                 +--------------+

    * The mike and speaker are often the system mike and speaker, and a 
      separate wire is run from the modem (internal card) to the system
      audio card -- a big pain. Someone, I think from Lucent, said that some
      OEMS are skipping voice support because of this wire.
        External modems that support speakerphone have their own jack for mic
      and speakerphone.

    If a call is in progress, the device routes the audio between the 
    line and the terminal endpoints (handset and/or speakerphone).
 
    X(1) represents the switch that decides whether audio that actually goes
    to the PC (via the serial port) comes from the line or the phone
    endpoints. I'm not sure if modems allow switching the stream to 
    the terminal endpoins if a call is in progress. Unimodem/V would not
    allow such functionality.

    X(2) represents which of the various terminal endpoints are enabled
    (off hook) or disabled (on hook) at any point in time. Speakerphone
    endpoints "hookswitch state" can be controlled by AT commands. Handset
    "hookswitch state" tracks the physical handset state (as far as the
    modem can detected it by monitoring the electrical state of the wire
    between the modem and attached handset). The modem sends notification
    of changes to handset state through DLE characters.

    The tricky thing with phone-device support for voice modems is deciding when
    to enable playback/record to handset/speakerphone (in this
    mode the line can't be used and we're using the voice-modem as an isolated
    handset device).

    The semantics of the phone device are different depending on whether
    or not a call is in progress.

    phoneSetHookSwitch  is used to change the off/on-hook states of the various
    terminal devices associated with the modem.

    When a call is in progress, changing these determine whether-or-not
    the audio from the call is routed to/from the various terminals
    (the TSP and app is not involved with the actual routing -- this is crucial
    point).

    When there is no call in progress, it determines which terminals get
    the audio stream to/from the PC (today, via the wave devices that unimodem
    exports).

    Unimodem/V required the line device to be open before it allows the
    phone device to be opened -- this is artificial, especially in the case
    of using the phone device in isolation, and I plan on not requiring this.

    The challenge then is how multiplex use of the line and phone abstractions
    given the implicit linkages when the call is active.

    Apps need to  call phoneOpen to get lineGetID(wave/in/out) -- we shouldn't
    simply open the device and actually start monitoring handset activity
    at that point -- or maybe that OK? One optimization is to only actually
    start monitoring under the following conditions:
            * App specifically requests a specific terminal-state to go
              off-hook (via phoneSetHookSwitch)...)
            * App requests, via lineSetStatusMessages, hook-state notifications.

    When do we slip out of the "terminal actually open" state?
            * phoneClose
            * phoneSetHookSwitch indicates to turn off all status reporting
            * AND phoneSetStatusMessages indicates to put terminals on
              hook (it can only control on-hook/off-hook status for
              speakerphone and headset, NOT handset (this is a unimodem/v
              specific restriction -- clearly our intecom phones
              can be physicall off-hook but be logically-on hook -- when
              the user presses the SPKR button).

    How do we deal with random activity on the tapi line device?

    This is a tricky one. This is best handled by treating the lines
    and phones as independend entities that must multiplex use of
    a single resource -- the actual device.

    Logically, we maintain three structures: LINEINFO, PHONEINFO and
    LLDEVINFO. line state is maintained in LINEINFO; phone state in
    PHONEINFO and the device state in LLDEVINFO
    (LLDEV == "Low-Level Device").

    To keep things clean, line-related and phone-related code
    should not snoop into each other structures, but interact only with
    LLDEVINFO. So, for example, when processing lineMakeCall when
    audio to speakerphone is in progress, the code should fail at the time
    the init or dial is requested, based on the fact that the LLDEVINFO is
    being used for some other activity, not by initial checking of the
    PHONEINFO state.

    One tricky problem is to determine when requests need to be queued. Queuing
    adds complexity and should be avoided unless absolutely necessary. But
    some amount of queuing is necessary, such as when dealing with a phoneClose
    in the middle of an ongoing call!


    I discussed this issue with Brian. MSPhone-Unimodem/V had an ad-hoc and
    broken way of using the phone device -- they required the line device
    to be opened first, and they didn't support monitoring of handset activity
    unless there was an actual call in progress! MSPhone, when doing audio
    to/from handset, would simply open the phone' device, the open
    and start using the phone's wave devices -- it wouldn't bother with
    hookswitch monitoring or setting hookswitch!

    Brian did think it would be a good idea to monitor for hookswitch activity
    as part of the phone device, but recommended that the application be
    able to use the line device as long as there was no actual wave audio
    going on.

    In light of all this, here is the plan for multiplexd use of the device
    as both line and phone devices:
        * AIPC monitoring is enabled for as long as the phone device is
          opened, in addition to when it is currently enabled (which is
          when a voice call is in the connected state).
        * We switch the device into "voice monitor" if phoneSetStatusMessages
          is called to turn on hookswitch status monitoring.
        * We also switch into "voice init" mode if we're asked to make
          one of the terminals go off hook.
        * We switch out of voice-init/voice-monitor when the corresponding
          state happen.
        * If we get a HANDSET_WAVE_ACTION APIC message, we will init the
          modem if required and do the action, provided there's no call
          in progress.
        * The right thing's happen if, for example, the line is open for
          owner and the phone is open form initoring hookswitch activity,
          and a ring comes in.


    Phone-Related Tasks
    -------------------

        EnablePhoneForAudio
            -- open and initialize the device for voice if required
            -- startup AIPC server.
            -- (only allow this if there is no call in progress).
            -- when enabled, disallow any calls to be made or answered.

        DisablePhoneForAudio
            -- close down AIPC server.
            -- de-initialize and close device if required.

        StartPhoneAudio
            -- actually switch device to play/record mode
        StopPhoneAudio
            -- get device out of play/record mode

    Information to be maintained in LLDEVINFO:
        dwReInitFlags: stuff to do when re-initing after some activity:
                -- initialize-for-data/voice/...
                -- monitor-for-?


-------------------------------------------------------------------------------
11/02/1997 JosephJ Enhancements to the tasking model:

    Instead of supporting a single queued task, queing is now the
    responsibility of the clients of the task service.

    At the COMPLETION of a root task, we check if there is a need for
    another ask to run, and if so will start another root task. This is only
    done if the completion is asynchronous -- on synch completion, there
    can NEVER be another pending task, otherwise the task would not even
    have been allowed to start (pending task implies there is some task
    actually executing -- note that we claim the critical section before
    trying to add tasks, so we'll never have the case that on entry
    to StartRootTasks we have no tasks pending but on sync return we
    have a task pending.

    Places which currently expect queuing of tasks...
        CTspDev::mfn_monitor
	    TASKID_TSPI_lineMakeCall:
        TH_lineDrop

-------------------------------------------------------------------------------
11/05/1997 JosephJ

    Basic primitives on CTspDev sub-objects LINEINFO, PHONEINFO and LLDEVINFO,
      CALLINFO (subobject of LINEINFO) and AIPC2 (subobject of LLDEVINFO):
            LoadLine UnloadLine
            LoadCall UnloadCall
            LoadLLDev UnloadLLDev   << Refcounted
            AIPC_Load AIPC_Unload   << Refcounted

      All operations are synchronous although under normal circumstances
      they will not block. Specific  cases under which they block are:
        > UnloadLine or UnloadCall called when call is in progress.
        > UnloadLLDev called with AIPC  or voice streaming in progress.

     Since CALLINFO is contained in LINEINFO, calling UnloadLine will
     call UnloadCall if there is a call active. UnloadCall will call
     TH_DropLine if the call is active and will block until it's completed.

-------------------------------------------------------------------------------
11/08/1997 JosephJ

    Thinking about keeping state information in LLDEV:
        
        dwMonitorFlags
        dwDeferredTasks
        dwInitFlags
        dwHookSwitchDevsState
        dwLineState: off-hook, initiating, connecting, conne

----------

    TH_LLDevGoIdle

        if (HandsetOpen)
        {
            TH_WaveAction(CLOSE_HANDSET);
        }
        else if (OFF_HOOK)
        {
            TH_HangupModem
        }

        // Init

        // If monitor, monitor...

-------

    NEW TASKING MECHANISM, to allow eliminating sleeps...

    * Pending tasks can be synchronously aborted, leaving the top-level pending
      task but replacing the lower-level tasks by a dummy TH_AbortedTask.

    * Allow tasks to have "stages" -- which can be asynchronously completed.
      This allows the top level to go through several asynchronous stage
      completions, allowing for more flexibility.

    * When the async state completes with the task in the ABORTING state,
      the task can then switch to cleanup mode.


    All of the above will allow, for example, a lineCloseCall to be
    processed with no blocks even if, say, a TSPI_lineDrop is in progress.

    The goal is NO BLOCKING in any of the CTspDev code.
--------------------------------------------------------------------------------

11/12/1997 JosephJ Aborting continued....

   Decided to can the "stages" concept -- may as well use subtasks for each 
   stage.
   
   Each task should be responsible for handling the MSG_ABORT message. It
   can do what it choses. dwParam1 contains the abort param, and dwParam2
   contains the ID of the subtask that's currently being executed.

    start:
        Start AIPC
    aipc_complete:
        Start WaveAction
    normal_end:

    abort_start:
    abort_stop_waveaction:
    abort_stop_aipc:

    if (fAborting)
    {
        switch(dwTaskID)
        {
        aipc_complete: goto  abort_stop_aipc;
        wave_complete: goto  abort_stop_waveaction:
        wave_complete: goto  abort_stop_waveaction:
        goto c:
        }
    }
    

The sorts of things that need to be deffered in the lldev:
TH_LLDevOpen/Close          (dwMonitorFlags, fAPC)
TH_LLDevReInit              (no flags)
TH_LLDevGoIdle              (?)
TH_LLDevHybridWaveAction    (dwWaveAction, fHandset)

Open(fAIPC)      <- voice call
Open(fMon)       <- line
Open(fAIPC)      <- phone
Open()           <- data call

Algorithm:
Maintain current instanteneous state:
     monitoring,
     faipc-listening
OnOpen, increment ref-count for fMonitoring and fAipcListen
If required queue or defer TH_LLDevOpen, which will, when it executes,
    monitor if it's not monitoring, and start aipc listen if it's not
    started.
OnClose, decrement ref-count for fMonitoring and fAipcListen
If required queue or defer TH_LLDevClose, which will, if required stop
aipc listening.

Actually Addrefing/releasing is NOT done in the context of a task, but on
completion of a task, if the refcount is zero, it will unload the corresponding
resources.

--------------------------------------------------------------------------
11/18/1997
Stuff that doesn't work:
Hyperterm: configure UI
Hyperterm: connection 

On removing a modem when a phone device was open, hung on phoneshutdown -- had
to kill tapisrv.

Tests:
    * Diagnostics reporting.
    * Closing line when...
        - lineGenerateDigits in effect
        - wave play/record in effect
        - phoneSetXXX in effect
        - lineDrop in effect
    * Closing phone when...
        - all conditions above.
        - phone wave play/record in effect
    * Verify Modem is reinited when config is changed
    * Verify proper reporting of TAPI LINE events

----------------------------------------------------------------------------
11/22/1997 JosephJ Structured Exception Handling

    Implemented and then removed using structured exception handling to
    implement pending tasks. I used try, catch and trow. Things worked
    as expected, except that here and there code depends on getting
    back "pending" from subtasks, for example to set state or to
    send some message to tapi.

    I created a type, "PENDING_EXCEPTION" which was thrown by all async
    mini-driver function wrapper tasks, as well as the UtilTH_NOOP tasks.
    These exceptions were caught in the StartRootTask, StartSubTask and
    AsyncCompleteTask. The documentation in the sdk is adequate. One sticking
    point is strictuly speaking, one should enable the /GX option so
    that distructors are called for objects on the stack. I tried placing
    /GX in the sources file but got a message saying /GX was overridden by
    /GX-, which disables this extra cleanup code by default.
    


----------------------------------------------------------------------------
11/22/1997 JosephJ

Stuff to do:
    * document all TH_ tasks, including parameter handling.
    * make use of context consistant (use pointers).
    * code review all cdev*.* files.
    * step through all codepaths in cdev*.*
    * try out the various scenarios above (11/18/1997).

1/25/1998 JosephJ

12-04-97  JosephJ
    * MAJOR rewrite, support phone devices.
      Main change: the LLDEV state exists on its own, and
      LINE and PHONE are clients of it. This allows the
      phone to be operated independantly of the LINE.
      Refcounting is used. Also moved/rewrote many tasks
      to be more clean and partinioned into line-specific,
      call-specific and lldev-specific tasks (see cdev.h,
      under the TH_* definitions).

01-23-98  JosephJ
    * 129683 -- ISDN init/protoc
      This is is hacky -- the dynamic init is maintained as 
      CTspDev::m_Settings.szPreDialCommand. It is updated
      by CTspDev::ConstructNewPreDialCommand based on the
      protocol bits in MODEMSETTINGS.dwPreferredModemOptions.
      See changes to mcx and unimodem.h
      The static Init is written directly to the registry
      by modemui.DLL
      TODO: move all this into the mini driver some day.

01-25-98  JosephJ
    * Added functionality to logging:
        - interlocked-increment sync counter so we can see the
          true order of different stacklogs
        - associated a device-id with each stack log (device id
           may not be known when the stacklog is created, but
           it can be specified during the call tree.
        - allow external program (umcfg) to enable/disable
          the log (this is possible even in retail!)
        - allow external program to dump cmgr and individual
          state
        [above two by using the tspNotif mailslot-based
         interface]
          
    * Cleaned up handling of DEVCFG/COMMCONFIG changes...

      There are 3 ways for these to be changed:
        1.  From CPL (default, except for spkrvolume &
            blind-dial and max.
        2.  From lineSetDevConfig (dynamic changes)
        3.  Indirectly, bi lineConfigDialog, which gets to us
            via TSPI_providerGenericDialogData.
    
      Apps often DO NOT have the line open when they
      do lineSetDevConfig or lineConfigDialog (I checked
      Hyperterm and Dialer).

      Current  behavior is to do a SetDefaultCommConfig
      if the app calls lineSetDevConfig/lineConfigDialog, becase
      afterall there is no hline associated with this. However,
      now that the modem properties are split into static and 
      dynamic, we can switch back to the old (NT4) behavior...
      New behavior: lineGet/SetDevConfig only effect the
         in-memory versions.

      Currently the tsp doesn't immediately re-init the modem
      on updating its devconfig -- only on the next answer/
      dial -- the most important negative ramification of this
      is that DCB settings (in particarl, port speed) are not
      uptated, so for null modems, this breaks answering, because
      the port needs to be set to the proper settings to
      detect the RING! (NT4 tsp didn't re-init the modem, but it
      DID call SetCommConfig right-away).
      New behavior: if line open for monitoring, will re-init
      the modem if the config settings are changed.

      Currently, if the default properties of the cpl were changed, when
      the tsp is notified it will simply take the new defaults, overriding
      anything set perhaps by a previous lineSetDevConfig. So if
      the user sets the speaker volume from the cpl, it will cause
      us to pick up all the default devconfig info! -- this is
      a bit extreme. With the split of modem properties into
      it makes sense to be more selective.
      New behavior: on getting a cpl-config changed notification, the
      tsp will only pick up the new speaker volume, max port speed (
      unused) and blind-dial setting and apply them immediately.

      One unresolved issue is when/if-at-all to pick changes to
       the default commconfig when the user changes them
       by the "change defaults" under the advanced section....

      New Algorithm:
        We keep just the default commconfig in memory.
        We only make a copy if someone does a SetDevConfig/ConfigDialog.
        As long as we don't have a copy, we pick up changes to
        the default comm config (via the cpl).
        After we have a copy, we pickup spkr-vol, max speed and
        blind-dial settings from the cpl, and also other settings but
        only if they've changed from the previous default value.
        In all cases, if there is a change we schedule a re-init of
        the modem.

        Note: this way, if the user *changes* the default properties
        from the advanced->change-defaults, we pick them up right away.
        If the user wants to pick up the current-defaults right away,
        he/she'll have to change them once and change them back--
        anyway changing the advanced defaults is not a recommended
        procedure.

     This seems a good compromise.

     1/28/1998 -- implemeted above, except we don't implement the last para
     -- defaults are not picked up again once the config settings are
    changed by the app. CTspDev::m_Settings.fConfigUpdatedByApp is set 
    when this happens.

    Note: according to SDK documentation, apps should only call
     lineGet/SetDevConfig after the line is open, and should not expect
    the settings to stick after the line is closed, but the fact is that
    dialer and hyperterm don't bother.


1/28/1998 JosephJ
    Note -- had to deal with the race condition that we're in the
    process of initing the modem in response to
    TSPI_lineSetDefaultMediaDetection when the app calls lineSetDevConfig --
    see comments under  CTspDev::mfn_TH_LLDevUmInitModem in cdevll.cpp
    for details. Things work peachy now....

2/3/1998 JosephJ
    Cleaned phone-device behavior (NT5 bug 135605).
    There are two new tasks:
        CTspDev::mfn_TH_PhoneSetSpeakerPhoneState
	    CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneState
    that replace the following:
        CTspDev::mfn_TH_PhoneAsyncTSPICall
        CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneVolGain
        CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneMode
    Also enhanced stacklogging to dump a list of pending tasks, using
    the MSG_DUMPSTATE task message.

2/11/1998 JosephJ
    Dealing with pre/post-connect terminal problems.
    * The central problem is that the tsp currently can not bring down
      the terminal window -- this is unimplemented.
    * To fix we must (infrastructure is in place) send
      the DLG_CMD_DESTROY command from TSP to app's dialog.
      This should be done when lineDrop or lineCloseCall or LINECALLSTATE
      disconnected.
    * We must make sure that there are no race conditions.

2/12/1998 JosephJ
    Fixed all outstanding problems -- now bring down terminal on lineDrop
    or lineCloseCall.
    Lot of the code in appterm.cpp is poorly written.
    Had to fix a hard problem caused by the fact that SetCommMask
    would fail (once line is disconnected) and cause the terminal thread
    which was waiting on WaitCommEvent to never get out of the wait.
    The main change I made to solve this deadlock is to change the
    blocking call to WaitCommEvent to an overlapped call, then
    WaitForMultipleObjects with the overlapped event and the stop-event --
    so if either is signalled I get out of the wait. If it's the stop-event
    then I exit the thread (all this in function TerminalThread ();

2/12/1998 JosephJ
    Fixed bug in TH_LLDevHybridWaveDevice where it was calling close_handset
    when streaming-voice, instead of first calling stop_streaming (bug#138635).

2/15/1998 JosephJ

    Terminal/Manual-dialog-related changes.

    In the process of implementing manual dialog, I am modifying the 
    terminal-dialog handling code in the following way:
    * The following fields of the TerminalWindowState structure are
      removed:
        dwState field (and it's TRMST_ constants)
            -- this field was never used. The terminal window state is
               maintained within the terminal task.
        dwType -- this field is now maintained as part of internal
               context of the TH_CallPutUpTerminalWindow task.
        ^^^^ SORRY I had to put back dwType because the app dialog
            call's back to determine what type of call it is.

    * The Terminal-related code really deals with manual dial as well
      (as well as talk-drop, should we decide to implement it) --
      so all Terminal-related calls need to be renamed to, say
      CallDialog (this hasn't been done yet). TH_CallPutUpTerminalWindow,
      will switch in/out of passthrough and re-init the modem only if
      it's the right kind of terminal.

    * Manual dialog is a stage of TH_CallMakeCall JUST before dialing.
      If manual-dial is in effect, we still dial, but with an empty
      dial string and with fBLIND -- see comments in TH_CallMakeCall.


2/23/1998 JosephJ -- more possibly relavant t3 stuff from tspi.h:
    #define MSPCALLINFOREASON_MSPSETUPCALL          1L
    #define MSPCALLINFOREASON_INFO                  2L
    
    #define PRIVATEOBJECT_NONE                      0x00000001
    #define PRIVATEOBJECT_CALLID                    0x00000002
    #define PRIVATEOBJECT_LINE                      0x00000003
    #define PRIVATEOBJECT_CALL                      0x00000004
    #define PRIVATEOBJECT_PHONE                     0x00000005
    #define PRIVATEOBJECT_ADDRESS                   0x00000006
    
    LONG
    TSPIAPI
    TSPI_lineAnswerMSP(
        DRV_REQUESTID       dwRequestID,
        HDRVCALL            hdCall,
        LPCSTR              lpsUserUserInfo,
        DWORD               dwSize,
        LPLINEMSPCALLINFO   lpMSPCallInfo
        );
    
2/28/1998 JosephJ Tapi3 stuff...

    In previous days, I added support for TSPI_lineAnswerMSP as well -- similar
    handling to TSPI_lineMakeCallMSP -- basically save the msp context and
    and callback and callback when we get to the connected state.

    I also had to set a few new tapi3-specific fields in LINEDEVCAPS:
    #if (TAPI3)
           //
           // If this is a duplex device, say we support MSP stuff...
           //
           if (m_StaticInfo.Voice.dwProperties & fVOICEPROP_DUPLEX)
           {
                lpLineDevCaps->dwDevCapFlags      |=  LINEDEVCAPFLAGS_MSP;
                lpLineDevCaps->dwAddressTypes =  LINEADDRESSTYPE_PHONENUMBER;
                lpLineDevCaps->ProtocolGuid =  TAPIPROTOCOL_PSTN;
                lpLineDevCaps->dwAvailableTracking = 0;
           }
    #endif // TAPI3

    And in mfn_GetCallInfo ....

    #if (TAPI3)
        lpCallInfo->dwAddressType =  LINEADDRESSTYPE_PHONENUMBER;
    #endif // TAPI3


2/28/1998 JosephJ Outstanding ISDN work items...

    * Remove NvRestore key.
      NVSave key has all the required commands to save and restore nvram,
      and will be only done on demand (will be issued when the modem is opened
      for dialing, but only if the settings have changed and on initial
      install). It will have 5 second timeout for geting a response back to
      these NVSave commands.
    
    * Make protocol specification into keys with multiline commands.
      This also allows us to incorporate authentication.
      Read and present protocols from both GSM and isdn.
      Prefix string with "GSM" or "ISDN".
    
    * Add support from RAS configuration: RAS currently doesn't support this --
      they'll need to do that and indicated that it would be easy.
    
    * Allow ISDN protocols to be specified even if switch-type/spid keys are
      not present. Don't put up ISDN page if those keys are not present
      (obviously) -- this is to allow 3rd parties to provide their own
      spid/switch-type wizard -- or put a text message indicating user needs to
      use vendor-provided spid detection and saving program. We decided not to
      put a "browse button" because we do not want to endorse the
      vendor-provided code -- we can revisit this post nt5 beta2.

    * Finalize definition of the protocol bits.

    -----------------------------
3/2/1998 JosephJ

    PROTOCOL DEFINITION: CAPABILITIES AND SETTINGS
    4 Bearermode: ISDN GSM Analog Reserved: 2 bits
    4 dwSingleChannelRate: 4 bits
    4 dwProtocol: 4 bits
    4 dwProtocolSpecificBits:
    //
    //  b - bearer mode (4bits)
    //  p - protocol    (4bits)
    //  s - single-channel-speed (4bits)
    //  d - protocol data (4bits)
    //
    //      dddd ssss pppp bbbb  
    // fedc ba98 7654 3210 fedc ba98 7654 3210
    // ^bit_31                          bit_0^

    Next steps:
    1. Define updated list of protocol key-names, including GSM
    2. Install ISDN modem with this key names
    3. Modify modemui and structures to reflect the fact that protocol
       specification has become a key.
    4. Add code for parsing and displaying ISDN-vs-GSM protocol settings.
    5. TEST modemui

    6. Modify TSP code so that it creates and issues a multisz predial command.
    7. TEST TSP for dialing

    8. Define lineGetDevConfig/lineGetDevCaps structure for protocol caps.
    9. Perhaps pass in this protocol caps in to processing of lineConfigDialog.
    10. TEST

    11. Cleanup structures and code.

    12. TEST.

    13. Try to build RAS ui code, and modify modem ui window.

    From LSteen:
    1. Issue DN before switch type in US switch setting sequences.
    2. NI-1, AT&T Point to MultiPoint (both have one directory number).
    4. Disable speakerphone when non-analog protocol is selected (GSM/ISDN) --
       claim that disabling speaker settings in the INF property line has no
       effect and they remain active.
    
    GSM protocols....
    HKR, Protocol\GSM, AnalogRLP,,                      AT<cr>  
    //Call Analog Radio Link Protocol on  this is the default for a inf
    // supporting a GSM only card.
    //Normal Analog is the default for an Analog/GSM card.
    HKR, Protocol\GSM, AnalogNRLP,,                   AT<cr> 
    //Call Analog  Radio Link Protocol off  - better  performance under  good
    // radio conditions.
    HKR, Protocol\GSM, V120_56K ,,                       "AT<cr>"  
    //Not yet available drafted in latest ETSI  documentation.
    HKR, Protocol\GSM, V110_1DOT2K,,              "AT<cr>"
    HKR, Protocol\GSM, V110_2DOT4K,,              "AT<cr>"
    HKR, Protocol\GSM, V110_4DOT8K,,              "AT<cr>"
    HKR, Protocol\GSM, V110_9DOT6K,,              "AT<cr>"
    //Speeds 1200 ->9600 V110 already available in Portugal, France, Germany,
    // UK, Sweden, Finland, Belgium etc.
    HKR, Protocol\GSM, V110_14DOT4K,,            "AT<cr>"
    //Supported on latest Nokia/Ericsson cards/phones
    HKR, Protocol\GSM, V110_19DOT2K,,            "AT<cr>"
    HKR, Protocol\GSM, V110_28DOT8K,,            "AT<cr>"
    HKR, Protocol\GSM, V110_38DOT4K,,            "AT<cr>"
    HKR, Protocol\GSM, HDLC_PPP_56K,,           "AT<cr>
    HKR, Protocol\GSM, HDLC_PPP_64K,,           "AT<cr>"
    //Future protocols specified in latest ETSI documentation.
    
    Examples of Inits: 
    -----------------
    
    
    HKR, Protocol\GSM, V120_56K ,,                     "AT+CBST=51,,1<cr>"
    HKR, Protocol\GSM, V110_1DOT2K,,             "AT+CBST=66,,1<cr>"
    HKR, Protocol\GSM, V110_2DOT4K,,             "AT+CBST=68,,1<cr>"
    HKR, Protocol\GSM, V110_4DOT8K,,             "AT+CBST=70,,1<cr>"
    HKR, Protocol\GSM, V110_9DOT6K,,             "AT+CBST=71,,1<cr>"
    HKR, Protocol\GSM, V110_14DOT4K,,           "AT+CBST=75,,1<cr>"
    HKR, Protocol\GSM, V110_19DOT2K,,           "AT+CBST=79,,1<cr>"
    HKR, Protocol\GSM, V110_28DOT8K,,           "AT+CBST=80,,1<cr>"
    HKR, Protocol\GSM, V110_38DOT4K,,           "AT+CBST=81,,1<cr>"
    HKR, Protocol\GSM, HDLC_PPP_56K,,          "AT+CBST=115 , ,1<cr>
    HKR, Protocol\GSM, HDLC_PPP_64K,,          "AT+CBST=116, , 1<cr>"
    
    Protocol names need to be changed.
    ----------------------------------
    Remove:
    HKR, Protocol\ISDN, X75_CEPT,,              "AT\N9<cr>"
    HKR, Protocol\ISDN, X75_VT100,,            "AT\N8<cr>"
    Add:
    
    HKR, Protocol\ISDN, X.75_T_70 ,,                              @64K
    HKR, Protocol\ISDN, X.75_BTX.,,                               @64K
    Add: 
    HKR, Protocol\ISDN, AUTO_128K,, 



3/3/1998 JosephJ NVRAM behavior.
--------------------------------
    If the modem has an NVRam key under ISDN static information, we
    create the static-init keys under "NVRamInit" instead of "OptionalInit".
    Furthermore, we clear the volatile value "NVRamInited" each time the
    settings are changed.
    
    The TSP, on providerInit, will look for the NVRamInited field -- if
    it's not there, it will make a note in the CTspDev. On the 1st Init, it
    will issue the commands in NVRamInit (with a 10 second timeout for each
    command) and create the NVRamInited volatile value.
    
    So we will do a nvram init on the 1st init after reboot and also the 1st
    init after the static settings have been changed.

3/8/1998 JosephJ NVRamInit in tsp...
--------------------------------
    If the modem has an NVRam key under ISDN static information, we
    There are two places where TH_LLDevUmInitModem is called:
        (1) from mfn_TH_LLDevNormalize and
        (2) from mfn_TH_CallStartTerminal -- after the pre-connect terminal.

    I decided to put the issuing of the nvram init stage in TH_LLDevNormalize:
    after the call to mfn_TH_LLDevUmInitModem. This means that if
    the ISDN static config is changed during the pre-connect terminal phase
    we will not issue the nvram init commands until after the current call --
    which is perfectly fine.

    I'll create a new task:
        mfn_TH_LLDevIssueMultipleCommands
            dwParam1 == multisz ASCII string containing already-translated
                command strings (which means that the NULL character can't be
                used as a command character -- we can deal with this).
                The string is guaranteed to be available for as long as the
                task is running (the task is not responsible for freeing the
                string).
            dwParam2 == Per-command timeout.
            It will fail on the 1st command that timesout or fails.

    
    mfn_TH_LLDevNormalize will call the above task after it calls
    mfn_TH_LLDevUmInit mode, but only if it needs to: based on the
            fDoNVRamInit flag in CTspDev.

    Note that the protocol command will also use
    mfn_TH_LLDevIssueMultipleCommands.

    Aborting mini-driver async task behavior: set fAborted bit so that
    we don't issue any further commands on aborting.

3/20/1998 JosephJ This concerns  VOICEPROF_MODEM_OVERRIDES_HANDSET and cirrus
                  modems:

    From:   Brian Lieuallen 
    Sent:   Thursday, March 19, 1998 5:30 PM
    To: Costel Radu; Joseph Joy
    Cc: Jim Hood (Volt Computer); Jim Spoltman
    Subject:    RE: Cirrus modem: generate digits


    The reason for this code, was that if we made a class 8 call on a cirrus
    voice modem the handset would be disconnected
    from the line. So if you used dialer to dial a call you could not use
    the handset until the modem was hung up, since
    this is a voice modem, we did not put up the talk drop dialog so the user
    would not know to drop the call in order to talk.

    So for cirrus modems, dialing interactive voice calls we basically use
    the same behavior as dialing a interactive voice call
    with a data modem. When we do this we dial in class 0 and can not send
    the generate digit commands.

    I think that the code for lineGenerateDigits() should be changed to check
    if  dwVoiceProfile & VOICEPROF_MODEM_OVERRIDES_HANDSET is set and if the
    call is an automated voice call then it should allow the call to proceed.
    If it is interactive voice and VOICEPROF_MODEM_OVERRIDES_HANDSET then the
    call should fail.

3/24/1998 JosephJ
    Bug#132798 Race condition when PCMCIA modem is removed.
    One of the manifestations of this problem is if re-enumeration happens
    when the call is in the connected state with no pending tasks --
    re-enum marks the device for removal and sends up a LINE_CLOSE.
    TAPI calls TSPI_lineCloseCall and TSPI_lineClose, both of which 
    return immediately after starting a LLDevNormalize task. On return
    from TSPI_lineClose, the ctspdevmgr unloads and deletes the device,
    because it is marked for removal. However there is still a normalize
    session going.
    A secondary problem is that in the case we debugged, there was also
    a pending TSPI_lineGetCallStatus on another thread -- it was av'ing 
    when it tried to claim the crit-sect of the now-deleted device object.

3/28/1998 JosephJ
    Periodically, run perl script to check for typos, for example:
        T:\SRC\unimodem\nt50\tsp\cdev.cpp (1642):   ASSERT(m_pLine = NULL);
        T:\SRC\unimodem\:qnt50\tsp\cdev.cpp (1648): ASSERT(m_pPhone = NULL);
        T:\SRC\unimodem\nt50\tsp\cdevcall.cpp (2362):   dwCallFeatures == 0;

    Run the typo.pl perl script, which can be found at
         <file://\\itg1\contrib\JohnnyL\typo> 

    Explanations of the flagged lines can be found here and in the typo.pl file:
    
    #   Following potential programming errors are flagged:
    #     I   - semicolon appended to an if statement
    #     II  - use of "==" instead of "=" in assignment statements
    #     III - assignment of a number in an if statement, probably meant
    #           a comparison
    #     IV  - assignment within an Assert
    #     V   - increment/decrement of dereferenced ptr statement
    #     VI  - logical AND with a number
    #     VII - logical OR with a number
    #     VIII- bitwise-AND/OR/XOR of number compared to another value
    #           may have undesired result due to C precedence rules
    #           since bitwise-AND/OR/XOR has lower precedence than
    #           the comparison operators.
    #     IX  - referencing Release/AddRef instead of invoking them
    #     X   - whitespace following a line-continuation character
    #     XI  - shift operator ( <<, >> ) followed by +,-,*,/ may 
    #           have undesired result due to C precedence rules.
    #           The shift operator has lower precedence.

3/28/1998 JosephJ
    Procedure for fixing bug#132798 (3/24 note above).
    * If device being removed, notify CTspDev that device is to be removed,
      so that it will not initiate any new minidriver calls, even hangup.
    * Respect reference count -- NEVER delete until reference count is zero.
    * Make sure that any pending tsp calls, such as lineGetCallStatus above,
      will not cause an assert.
    * Do something about cleaning up pending wave activity.

3/28/1998 JosephJ
    ISDN protocol info
    Q: How to specify protocol caps to application?
    A: Add a new device class: "comm/extendedcaps"
        Doing a lineGetDevConfig on this will get capabilities in an
        extensible format: the LINEDIAGNOSTICSOBJECTHEADER format, which
        should be renamed to be something more general, perhaps.

4/4/98 JosephJ
    Should make sure the a COPY of  szPreDialString is used to actually issue
    the command, because it is now going to be multisz, and therefore,
    it's possible that lineSetDevConfig is called while it's actively
    being used.

4/5/1998 JosephJ
    Migrated the diagnostics parsing and callerid from the extension dll
    to the TSP in about two hours.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspi20_r.txt ===
@name: TSPI_lineAccept
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineAddToConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdConfCall,
		HDRVCALL hdConsultCall
)
;
@name: TSPI_lineAnswer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineBlindTransfer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
;
@name: TSPI_lineCloseCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall
)
;
@name: TSPI_lineCompleteCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPDWORD lpdwCompletionID,
		DWORD dwCompletionMode,
		DWORD dwMessageID
)
;
@name: TSPI_lineCompleteTransfer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HDRVCALL hdConsultCall,
		HTAPICALL htConfCall,
		LPHDRVCALL lphdConfCall,
		DWORD dwTransferMode
)
;
@name: TSPI_lineConditionalMediaDetection
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwMediaModes,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineDevSpecific
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		LPVOID lpParams,
		DWORD dwSize
)
;
@name: TSPI_lineDevSpecificFeature
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwFeature,
		LPVOID lpParams,
		DWORD dwSize
)
;
@name: TSPI_lineDial
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
;
@name: TSPI_lineDrop
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineDropOnClose
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall
)
;
@name: TSPI_lineDropNoOwner
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall
)
;
@name: TSPI_lineForward
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD bAllAddresses,
		DWORD dwAddressID,
		LPLINEFORWARDLIST const lpForwardList,
		DWORD dwNumRingsNoAnswer,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineGatherDigits
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwDigitModes,
		LPWSTR lpsDigits,
		DWORD dwNumDigits,
		LPCWSTR lpszTerminationDigits,
		DWORD dwFirstDigitTimeout,
		DWORD dwInterDigitTimeout
)
;
@name: TSPI_lineGenerateDigits
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwDigitMode,
		LPCWSTR lpszDigits,
		DWORD dwDuration
)
;
@name: TSPI_lineGenerateTone
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwToneMode,
		DWORD dwDuration,
		DWORD dwNumTones,
		LPLINEGENERATETONE const lpTones
)
;
@name: TSPI_lineGetAddressCaps
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwAddressID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPLINEADDRESSCAPS lpAddressCaps
)
;
@name: TSPI_lineGetAddressID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		LPDWORD lpdwAddressID,
		DWORD dwAddressMode,
		LPCWSTR lpsAddress,
		DWORD dwSize
)
;
@name: TSPI_lineGetAddressStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwAddressID,
		LPLINEADDRESSSTATUS lpAddressStatus
)
;
@name: TSPI_lineGetCallAddressID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		LPDWORD lpdwAddressID
)
;
@name: TSPI_lineGetCallInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		LPLINECALLINFO lpCallInfo
)
;
@name: TSPI_lineGetCallStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		LPLINECALLSTATUS lpCallStatus
)
;
@name: TSPI_lineGetDevCaps
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
)
;
@name: TSPI_lineGetDevConfig
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPVARSTRING lpDeviceConfig,
		LPCWSTR lpszDeviceClass
)
;
@name: TSPI_lineGetExtensionID
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		LPLINEEXTENSIONID lpExtensionID
)
;
@name: TSPI_lineGetIcon
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPCWSTR lpszDeviceClass,
		LPHICON lphIcon
)
;
@name: TSPI_lineGetID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass,
		HANDLE hTargetProcess
)
;
@name: TSPI_lineGetLineDevStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		LPLINEDEVSTATUS lpLineDevStatus
)
;
@name: TSPI_lineGetNumAddressIDs
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		LPDWORD lpdwNumAddressIDs
)
;
@name: TSPI_lineHold
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineMakeCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineMonitorDigits
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwDigitModes
)
;
@name: TSPI_lineMonitorMedia
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwMediaModes
)
;
@name: TSPI_lineMonitorTones
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwToneListID,
		LPLINEMONITORTONE const lpToneList,
		DWORD dwNumEntries
)
;
@name: TSPI_lineNegotiateExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwExtVersion
)
;
@name: TSPI_linePark
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwParkMode,
		LPCWSTR lpszDirAddress,
		LPVARSTRING lpNonDirAddress
)
;
@name: TSPI_linePickup
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress,
		LPCWSTR lpszGroupID
)
;
@name: TSPI_linePrepareAddToConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdConfCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineRedirect
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
;
@name: TSPI_lineReleaseUserUserInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineRemoveFromConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineSecureCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineSelectExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwExtVersion
)
;
@name: TSPI_lineSendUserUserInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineSetAppSpecific
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwAppSpecific
)
;
@name: TSPI_lineSetCallData
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPVOID lpCallData,
		DWORD dwSize
)
;
@name: TSPI_lineSetCallParams
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwBearerMode,
		DWORD dwMinRate,
		DWORD dwMaxRate,
		LPLINEDIALPARAMS const lpDialParams
)
;
@name: TSPI_lineSetCallQualityOfService
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPVOID lpSendingFlowspec,
		DWORD dwSendingFlowspecSize,
		LPVOID lpReceivingFlowspec,
		DWORD dwReceivingFlowspecSize
)
;
@name: TSPI_lineSetCallTreatment
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwTreatment
)
;
@name: TSPI_lineSetDefaultMediaDetection
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwMediaModes
)
;
@name: TSPI_lineSetDevConfig
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPVOID const lpDeviceConfig,
		DWORD dwSize,
		LPCWSTR lpszDeviceClass
)
;
@name: TSPI_lineSetLineDevStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwStatusToChange,
		DWORD fStatus
)
;
@name: TSPI_lineSetMediaControl
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		LPLINEMEDIACONTROLDIGIT const lpDigitList,
		DWORD dwDigitNumEntries,
		LPLINEMEDIACONTROLMEDIA const lpMediaList,
		DWORD dwMediaNumEntries,
		LPLINEMEDIACONTROLTONE const lpToneList,
		DWORD dwToneNumEntries,
		LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
		DWORD dwCallStateNumEntries
)
;
@name: TSPI_lineSetMediaMode
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwMediaMode
)
;
@name: TSPI_lineSetStatusMessages
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwLineStates,
		DWORD dwAddressStates
)
;
@name: TSPI_lineSetTerminal
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		DWORD dwTerminalModes,
		DWORD dwTerminalID,
		DWORD bEnable
)
;
@name: TSPI_lineSetupConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HDRVLINE hdLine,
		HTAPICALL htConfCall,
		LPHDRVCALL lphdConfCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		DWORD dwNumParties,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineSetupTransfer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineSwapHold
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdActiveCall,
		HDRVCALL hdHeldCall
)
;
@name: TSPI_lineUncompleteCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwCompletionID
)
;
@name: TSPI_lineUnhold
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineUnpark
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress
)
;
@name: TSPI_phoneDevSpecific
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		LPVOID lpParams,
		DWORD dwSize
)
;
@name: TSPI_phoneGetButtonInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPPHONEBUTTONINFO lpButtonInfo
)
;
@name: TSPI_phoneGetData
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwDataID,
		LPVOID lpData,
		DWORD dwSize
)
;
@name: TSPI_phoneGetDevCaps
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPPHONECAPS lpPhoneCaps
)
;
@name: TSPI_phoneGetDisplay
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPVARSTRING lpDisplay
)
;
@name: TSPI_phoneGetExtensionID
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		LPPHONEEXTENSIONID lpExtensionID
)
;
@name: TSPI_phoneGetGain
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		LPDWORD lpdwGain
)
;
@name: TSPI_phoneGetHookSwitch
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPDWORD lpdwHookSwitchDevs
)
;
@name: TSPI_phoneGetIcon
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPCWSTR lpszDeviceClass,
		LPHICON lphIcon
)
;
@name: TSPI_phoneGetID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass,
		HANDLE hTargetProcess
)
;
@name: TSPI_phoneGetLamp
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPDWORD lpdwLampMode
)
;
@name: TSPI_phoneGetRing
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPDWORD lpdwRingMode,
		LPDWORD lpdwVolume
)
;
@name: TSPI_phoneGetStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPPHONESTATUS lpPhoneStatus
)
;
@name: TSPI_phoneGetVolume
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		LPDWORD lpdwVolume
)
;
@name: TSPI_phoneNegotiateExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwExtVersion
)
;
@name: TSPI_phoneNegotiateTSPIVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwTSPIVersion
)
;
@name: TSPI_phoneSelectExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwExtVersion
)
;
@name: TSPI_phoneSetButtonInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPPHONEBUTTONINFO const lpButtonInfo
)
;
@name: TSPI_phoneSetData
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwDataID,
		LPVOID const lpData,
		DWORD dwSize
)
;
@name: TSPI_phoneSetDisplay
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwRow,
		DWORD dwColumn,
		LPCWSTR lpsDisplay,
		DWORD dwSize
)
;
@name: TSPI_phoneSetGain
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		DWORD dwGain
)
;
@name: TSPI_phoneSetHookSwitch
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDevs,
		DWORD dwHookSwitchMode
)
;
@name: TSPI_phoneSetLamp
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		DWORD dwLampMode
)
;
@name: TSPI_phoneSetRing
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwRingMode,
		DWORD dwVolume
)
;
@name: TSPI_phoneSetStatusMessages
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwPhoneStates,
		DWORD dwButtonModes,
		DWORD dwButtonStates
)
;
@name: TSPI_phoneSetVolume
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		DWORD dwVolume
)
;
@name: TUISPI_lineConfigDialog
 @ret: LONG
@qual: TSPIAPI
@args: (
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass
)
;
@name: TUISPI_lineConfigDialogEdit
 @ret: LONG
@qual: TSPIAPI
@args: (
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass,
		LPVOID const lpDeviceConfigIn,
		DWORD dwSize,
		LPVARSTRING lpDeviceConfigOut
)
;
@name: TUISPI_phoneConfigDialog
 @ret: LONG
@qual: TSPIAPI
@args: (
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass
)
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspi20_p.txt ===
// TAPI 2.0 TSPI function prototypes
// Created from NT4.0 TSPI.H
// 
// 11/08/1996 JosephJ Created
//

LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdConfCall,
    HDRVCALL            hdConsultCall
    );

LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineBlindTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode);

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE            hdLine
    );

LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineCompleteCall(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HDRVCALL            hdConsultCall,
    HTAPICALL           htConfCall,
    LPHDRVCALL          lphdConfCall,
    DWORD               dwTransferMode
    );

LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HDRVCALL            hdCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineDevSpecificFeature(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineDropOnClose(                                           // TSPI v1.4
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineDropNoOwner(                                           // TSPI v1.4
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineForward(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineGatherDigits(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCWSTR             lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwDigitMode,
    LPCWSTR             lpszDigits,
    DWORD               dwDuration
    );

LONG
TSPIAPI
TSPI_lineGenerateTone(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE            hdLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCWSTR             lpsAddress,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL            hdCall,
    LPDWORD             lpdwAddressID
    );

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL            hdCall,
    LPLINECALLINFO      lpCallInfo
    );

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
TSPIAPI
TSPI_lineGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HDRVCALL            hdCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass,
    HANDLE              hTargetProcess                          // TSPI v2.0
    );


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE            hdLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE            hdLine,
    LPDWORD             lpdwNumAddressIDs
    );

LONG
TSPIAPI
TSPI_lineHold(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL            hdCall,
    DWORD               dwDigitModes
    );

LONG
TSPIAPI
TSPI_lineMonitorMedia(
    HDRVCALL            hdCall,
    DWORD               dwMediaModes
    );

LONG
TSPIAPI
TSPI_lineMonitorTones(
    HDRVCALL            hdCall,
    DWORD               dwToneListID,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD               dwDeviceID,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwTSPIVersion
    );

LONG
TSPIAPI
TSPI_lineOpen(
    DWORD               dwDeviceID,
    HTAPILINE           htLine,
    LPHDRVLINE          lphdLine,
    DWORD               dwTSPIVersion,
    LINEEVENT           lpfnEventProc
    );

LONG
TSPIAPI
TSPI_linePark(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwParkMode,
    LPCWSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

LONG
TSPIAPI
TSPI_linePickup(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszGroupID
    );

LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineRedirect(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(                                   // TSPI v1.4
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE            hdLine,
    DWORD               dwExtVersion
    );

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL            hdCall,
    DWORD               dwAppSpecific
    );

LONG
TSPIAPI
TSPI_lineSetCallData(                                           // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
TSPIAPI
TSPI_lineSetCallQualityOfService(                               // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
TSPIAPI
TSPI_lineSetCallTreatment(                                      // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwTreatment
    );

LONG
TSPIAPI
TSPI_lineSetCurrentLocation(                                    // TSPI v1.4
    DWORD               dwLocation
    );

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes
    );

LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TSPI_lineSetLineDevStatus(                                      // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );

LONG
TSPIAPI
TSPI_lineSetMediaControl(
    HDRVLINE                    hdLine,
    DWORD                       dwAddressID,
    HDRVCALL                    hdCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD                       dwCallStateNumEntries
    );

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL            hdCall,
    DWORD               dwMediaMode
    );

LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE            hdLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
TSPIAPI
TSPI_lineSetTerminal(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HDRVCALL            hdCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HDRVLINE            hdLine,
    HTAPICALL           htConfCall,
    LPHDRVCALL          lphdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineSetupTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineSwapHold(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdActiveCall,
    HDRVCALL            hdHeldCall
    );

LONG
TSPIAPI
TSPI_lineUncompleteCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwCompletionID
    );

LONG
TSPIAPI
TSPI_lineUnhold(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineUnpark(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress
    );

LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE           hdPhone
    );

LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

LONG
TSPIAPI
TSPI_phoneGetData(
    HDRVPHONE           hdPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE           hdPhone,
    LPVARSTRING         lpDisplay
    );

LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
TSPIAPI
TSPI_phoneGetGain(
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE           hdPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
TSPIAPI
TSPI_phoneGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE           hdPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass,
    HANDLE              hTargetProcess                          // TSPI v2.0
    );

LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE           hdPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE           hdPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

LONG
TSPIAPI
TSPI_phoneGetVolume(
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
TSPIAPI
TSPI_phoneNegotiateExtVersion(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD               dwDeviceID,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwTSPIVersion
    );

LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD               dwDeviceID,
    HTAPIPHONE          htPhone,
    LPHDRVPHONE         lphdPhone,
    DWORD               dwTSPIVersion,
    PHONEEVENT          lpfnEventProc
    );

LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE           hdPhone,
    DWORD               dwExtVersion
    );

LONG
TSPIAPI
TSPI_phoneSetButtonInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

LONG
TSPIAPI
TSPI_phoneSetData(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCWSTR             lpsDisplay,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneSetGain(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE           hdPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
TSPIAPI
TSPI_phoneSetVolume(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );



LONG
TSPIAPI
TSPI_providerCreateLineDevice(                                  // TSPI v1.4
    DWORD               dwTempID,
    DWORD               dwDeviceID
    );

LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(                                 // TSPI v1.4
    DWORD               dwTempID,
    DWORD               dwDeviceID
    );

LONG
TSPIAPI
TSPI_providerEnumDevices(                                       // TSPI v1.4
    DWORD               dwPermanentProviderID,
    LPDWORD             lpdwNumLines,
    LPDWORD             lpdwNumPhones,
    HPROVIDER           hProvider,
    LINEEVENT           lpfnLineCreateProc,
    PHONEEVENT          lpfnPhoneCreateProc
    );

LONG
TSPIAPI
TSPI_providerFreeDialogInstance(                                // TSPI v2.0
    HDRVDIALOGINSTANCE  hdDlgInst
    );

LONG
TSPIAPI
TSPI_providerGenericDialogData(                                 // TSPI v2.0
    DWORD               dwObjectID,
    DWORD               dwObjectType,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD               dwNumLines,
    DWORD               dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc
    ,
    LPDWORD             lpdwTSPIOptions                         // TSPI v2.0
    );

LONG
TSPIAPI
TSPI_providerInstall(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TSPI_providerRemove(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD               dwTSPIVersion
    ,
    DWORD               dwPermanentProviderID                   // TSPI v2.0
    );

LONG
TSPIAPI
TSPI_providerUIIdentify(                                        // TSPI v2.0
    LPWSTR              lpszUIDLLName
    );



//
// The following function prototypes pertain
// to a service provider's UI module
//

LONG
TSPIAPI
TUISPI_lineConfigDialog(                                        // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TUISPI_lineConfigDialogEdit(                                    // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

LONG
TSPIAPI
TUISPI_phoneConfigDialog(                                       // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TUISPI_providerConfig(                                          // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TUISPI_providerGenericDialog(                                   // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize,
    HANDLE              hEvent
    );

LONG
TSPIAPI
TUISPI_providerGenericDialogData(                               // TSPI v2.0
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TUISPI_providerInstall(                                         // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TUISPI_providerRemove(                                          // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\notes.txt ===
Utility functions:

1. Enable TAPI debugging.
        > set debug <module> <level>
    examples:
        > set debug tapi32.dll 50
2. Open comm port and test it.
        > open port <name>
        > open line <lineid> /[om][diau]
    examples:
        > open port
        <1
3. Dump TAPI line info
        > dump line * /v
        > dump phone
        > dump port
        > dump modem
4. call <deviceid> <phonenumber> /dai
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\placefil.txt ===
migrate.dll  win9xmig\modems
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\frmvoice.log ===
Line 37: Class TabDlg.SSTab of control SSTab1 was not a loaded control class.
Line 87: Class ComctlLib.StatusBar of control StatusBar1 was not a loaded control class.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\simple.ini ===
[Quick]
ATDT
AT 
ATH
ATI0
ATI1
ATI2
ATI3

[Voice]
ATI4
ATI5
ATI6
ATI7
ATI8
ATI9
ATI10
AT+FCLASS=?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\idlog.txt ===
Sunday, June 28, 1998 12:08:05 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:13:13 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:15:48 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:17:41 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:20:20 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:20:59 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:23:44 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:23:55 PM 
 
 Sunday, June 28, 1998 12:24:41 PM 
 Com1 was in use by another program.

 Sunday, June 28, 1998 12:24:46 PM 
 Com1 was in use by another program.

 Sunday, June 28, 1998 12:25:10 PM 
 Com1 was in use by another program.

 Sunday, June 28, 1998 12:25:13 PM 
 Com4 couldn't be opened.

 Sunday, June 28, 1998 12:25:16 PM 
 Com1 was in use by another program.

 Wednesday, August 12, 1998 11:55:29 AM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>5601
ATI0<cr> = <cr><lf>5601
ATI1<cr> = <cr><lf>71F2
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>OK
ATI2<cr> = <cr><lf>OK
ATI3<cr> = <cr><lf>U.S. Robotics 56K FAX EXT V4.9.1
ATI3<cr> = <cr><lf>RoboticsFAXEXT
ATI4<cr> = <cr><lf>U.S. Robotics 56K FAX EXT Settings...
ATI4<cr> = <cr><lf>RoboticsFAXEXTSettings
ATI5<cr> = <cr><lf>U.S. Robotics 56K FAX EXT NVRAM Settings...
ATI5<cr> = <cr><lf>RoboticsFAXEXTNVRAMSettings
ATI6<cr> = <cr><lf>U.S. Robotics 56K FAX EXT Link Diagnostics...
ATI6<cr> = <cr><lf>RoboticsFAXEXTLinkDiagnostics
ATI7<cr> = <cr><lf>Configuration Profile...
ATI7<cr> = <cr><lf>ConfigurationProfile
ATI8<cr> = <cr><lf>OK
ATI8<cr> = <cr><lf>OK
ATI9<cr> = <cr><lf>(1.0USR3040\\Modem\PNPC107\U.S. Robotics 56K FAX EXT)FF
ATI9<cr> = <cr><lf>(USR\\Modem\PNPC\RoboticsFAXEXT)
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEM8A4F5943.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\simple1.ini ===
[Quick]
Command1 = ATDT
Command2 = AT 
Command3 = ATH
Command4 = ATI0
Command5 = ATI1
Command6 = ATI2
Command7 = ATI3

[Voice]
Command8 = ATI4
Command9 = ATI5
Command10 = ATI6
Command11 = ATI7
Command12 = ATI8
Command13 = ATI9
Command14 = ATI10
Command15 = AT+FCLASS=?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\readme.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;} {\f16\froman\fcharset238\fprq2 Times New Roman CE;}{\f17\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f19\froman\fcharset161\fprq2 Times New Roman Greek;}{\f20\froman\fcharset162\fprq2 Times New Roman Tur;} {\f21\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f28\fmodern\fcharset238\fprq1 Courier New CE;}{\f29\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f31\fmodern\fcharset161\fprq1 Courier New Greek;}{\f32\fmodern\fcharset162\fprq1 Courier New Tur;} {\f33\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255; \red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}{\* \cs10 \additive Default Paragraph Font;}{\s15\widctlpar\adjustright \f2\fs20\cgrid \sbasedon0 \snext15 Plain Text;}}{\info{\title Overview: Profile Calculator}{\author Ken Reed}{\operator Ken Reed}{\creatim\yr1998\mo9\dy7\hr19\min47} {\revtim\yr1998\mo9\dy7\hr19\min53}{\version3}{\edmins2}{\nofpages1}{\nofwords0}{\nofchars0}{\*\company Microsoft}{\nofcharsws0}{\vern89}}\margl1319\margr1319 \widowctrl\ftnbj\aenddoc\hyphcaps0\formshade\viewkind4\viewscale86\pgbrdrhead\pgbrdrfoot \fet0 \sectd \linex0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (} {\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \widctlpar\adjustright \fs20\cgrid {Overview: Profile Calculator \par  \par Use Profile calculator to create, edit or translate properties lines within Windows 95 and Windows NT modem INF files. Modem INF properties lines contain device properties settings that are transferred from an INF file to the Windows  Registry at the time a device is installed. Profile calculator is bi-directional: it can translate text values into an INF properties line or translate existing properties lines into text. \par  \par The following are examples of typical properties lines found in a modem INF: \par  \par HKR,, VoiceProfile,    1, 27,03,00,00 \par HKR,, Properties, 1, 80,01,00,00, ff,00,00,00, 00,00,00,00, 07,00,00,00, 07,00,00,00, 77,03,00,00, 00,c2,01,00, 40,38,00,00 \par  \par Notes \par  \par \'b7\tab A properties line is a single line in an INF file without text wrapping. \par  \par }\pard\plain \s15\widctlpar\adjustright \f2\fs20\cgrid {\'b7\tab When Profile Calculator first starts, a list of values the large lower window. The calculated INF properties line is visible in the long upper window. Checking or unchecking  specific values in the lower window toggles the value on or off while reflecting the changes to the properties line in the long upper window. \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\uquery11.ini ===
' 12/19/97  a-jimho: created, added rockwell and global sections
' 12/21/97  a-jimho: added installation sections to manage chipset and global sections

'------------------ Test Setup Commands ----------------------------------

[InitialSetup] ' send six commands in a row, looking for response from modem of either OK or error
Key1 = AT&FE1  ' factory init and echo on 
Key2 = ATE1    ' echo on
Key3 = AT
Key4 = ATZE1
Key5 = ATE1
Key6 = AT

[Setup.1]
Key7 = AT&F   'factory init, begins test

[Reset.1]
Key8 = AT&FE1  ' factory init and echo on

[Reset.2]
Key9 = ATZE1  ' nvram init and echo on

[UnimodemID.Scan]
Key10 = AT&FE1
Key11 = AT
Key12 = ATI0
Key13 = ATI1
Key14 = ATI2
Key15 = ATI3
Key16 = ATI4
Key17 = ATI5
Key18 = ATI6
Key19 = ATI7
Key20 = ATI8
Key21 = ATI9
Key22 = ATI10
Key23 = AT&V
Key24 = AT+FCLASS=?

' -------------Rockwell Installation -----------------------------------

[Rockwell.Data]  ' all of these sections get run in order 
Key25 = Run=RockwellStaticInit,Rockwell.FlowHard,Rockwell.FlowSoft,Rockwell.FlowOff,Rockwell.ECMOn,Rockwell.ECMForced,Rockwell.ECMOff,Rockwell.CompressionOn,Rockwell.CompressionOff,Rockwell.ErrorControl.Cellular,Rockwell.ErrorControl.CellularForced,Rockwell.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.InactivityTimeoutTimer,


' [Rockwell.Voice]  	' future voice section
' Run = foo.bar, foo.bar2, etc


'[Rockwell.Fax]  	' future fax section
'Run = foo.bar, foo.bar2, etc

' -------------Cirrus Installation -----------------------------------



[Cirrus.Data]  ' all of these sections get run in order ' note: the cirrus keys dont exist yet...under construction
Key26 = Run=CirrusStaticInit,Cirrus.FlowHard,Cirrus.FlowSoft,Cirrus.FlowOff,Cirrus.ECMOn,Cirrus.ECMForced,Cirrus.ECMOff,Cirrus.CompressionOn,Cirrus.CompressionOff,Cirrus.ErrorControl.Cellular,Cirrus.ErrorControl.CellularForced,Cirrus.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.CallSetupFailTimer,

'------------------ Rockwell Commands --------------------------------

[Rockwell.StaticInit] ' try each command, use first that works
Key27 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 W2 S95=47 S0=0<cr>"
Key28 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=47 S0=0<cr>"
Key29 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=45 S0=0<cr>"
Key30 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S0=0<cr>"
Key31 = HKR, Init, 2,, "AT Z E0 V1 &D2 &C1 S0=0<cr>"

[Rockwell.FlowHard]
Key32 = HKR, Settings, FlowControl_Hard,, "&K3"
Key33 = HKR, Settings, FlowControl_Hard,, "\Q3"

[Rockwell.FlowSoft]
Key34 = HKR, Settings, FlowControl_Soft,, "&K4"
Key35 = HKR, Settings, FlowControl_Soft,, "\Q1"

[Rockwell.FlowOff]
Key36 = HKR, Settings, FlowControl_Off,, "&K0"
Key37 = HKR, Settings, FlowControl_Off,, "\Q0"

[Rockwell.ECMOn]
Key38 = HKR, Settings, ErrorControl_On,, "\N7"  ' if \N7 try \N6 for forced
Key39 = HKR, Settings, ErrorControl_On,, "\N3"  ' if \N3 try both \N4 and \N2

[Rockwell.ECMForced]
Key40 = HKR, Settings, ErrorControl_Forced,, "\N6"
Key41 = HKR, Settings, ErrorControl_Forced,, "\N4"
Key42 = HKR, Settings, ErrorControl_Forced,, "\N2"

[Rockwell.ECMOff]
Key43 = HKR, Settings, ErrorControl_Off,, "\N0"
Key44 = HKR, Settings, ErrorControl_Off,, "\N"

[Rockwell.CompressionOn]
Key45 = HKR, Settings, Compression_On,, "%%C1"
Key46 = HKR, Settings, Compression_On,, "%%C3"

[Rockwell.CompressionOff]
Key47 = HKR, Settings, Compression_Off,, "%%C0"
Key48 = HKR, Settings, Compression_Off,, "%%C"


[Rockwell.ErrorControl.Cellular]  	' exception processing - prefix with the ecm cmd already found
Key49 = HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
Key50 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
Key51 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
Key52 = HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
Key53 = HKR, Settings, ErrorControl_Cellular,, "-K1"


[Rockwell.ErrorControl.CellularForced]	' exception processing - prefix with the FORCED ecm cmd already found
Key54 = HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
Key55 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
Key56 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
Key57 = HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
Key58 = HKR, Settings, ErrorControl_Cellular,, "-K1"

[Rockwell.InactivityTimeout]' note except macro processing' for this try feeding the command values like ' ATS30=1, ATS30=10, or AT\T1, AT\T30, AT\T60, AT\T90
Key59 = HKR, Settings, InactivityTimeout,, "S30=<#>"   ' first choice
Key60 = HKR, Settings, InactivityTimeout,, "\T<#>"      ' second choice

'------------------ Cirrus Commands ------------------------------------
' not ready



'------------------ USR Commands ------------------------------------
' not ready


'------------------ Global Commands  ------------------------------------

[Global.Reset]
Key61 = HKR,, Reset,, "AT&F<cr>"
Key62 = HKR,, Reset,, "ATZ<cr>"

[Global.CallSetupFailTimer]  ' note except macro processing' for this try feeding S7 registry: ATS7=1, ATS7=10, ATS7=60' all should pass which indicates the command below is the one to use
Key63 = HKR, Settings, CallSetupFailTimer,, "S7="

[Global.BlindOff]   ' these are globals, used regardless of chipset
Key64 = HKR, Settings, Blind_Off,, "X4"

[Global.BlindOn]
Key65 = HKR, Settings, Blind_On,, "X3"

[Global.Pulse]
Key66 = HKR, Settings, Pulse,, "P"   ' exception, you'll have to prefix a D

[Global.Tone]
Key67 = HKR, Settings, Tone,, "T"  ' exception, you'll have to prefix a D

[Global.CCITT]
Key68 = HKR, Settings, Modulation_CCITT,, "B0"

[Global.Bell]
Key69 = HKR, Settings, Modulation_Bell,, "B1"

[Global.Monitor]
Key70 = HKR, Monitor, 1,, "ATS0=0<cr>"   ' exception  - test first cmd but write both
' HKR, Monitor, 2,, "None"

[Global.Hangup]
Key71 = HKR, Hangup, 1,, "ATH<cr>"

[Global.Answer]
Key72 = HKR, Answer, 1,, "ATA<cr>"

[Global.Prefix]
Key73 = HKR, Settings, Prefix,, "AT"   ' exception...this is the AT cmd itself

[Global.DialPrefix]
Key74 = HKR, Settings, DialPrefix,, "D"

[Global.DialSuffix]
Key75 = HKR, Settings, DialSuffix,, ";"
Key76 = HKR, Settings, DialSuffix,, ""

[Global.SpeakerVolumeLow]
Key77 = HKR, Settings, SpeakerVolume_Low,, "L0"

[Global.SpeakerVolumeMed]
Key78 = HKR, Settings, SpeakerVolume_Med,, "L2"

[Global.SpeakerVolumeHigh]
Key79 = HKR, Settings, SpeakerVolume_High,, "L3"

[Global.SpeakerModeOff]
Key80 = HKR, Settings, SpeakerMode_Off,, "M0"

[Global.SpeakerModeDial]
Key81 = HKR, Settings, SpeakerMode_Dial,, "M1"

[Global.SpeakerModeOn]
Key82 = HKR, Settings, SpeakerMode_On,, "M2"

[Global.SpeakerModeSetup]
Key83 = HKR, Settings, SpeakerMode_Setup,, "M3"

[Global.InactivityTimeoutTimer]  ' note macro exception handling
Key84 = HKR, Settings, InactivityTimeout,, "S30=<#>"
Key85 = HKR, Settings, InactivityTimeout,, "\T<#>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\uquery1.ini ===
' 12/19/97  a-jimho: created, added rockwell and global sections
' 12/21/97  a-jimho: added installation sections to manage chipset and global sections

'------------------ Test Setup Commands ----------------------------------

[InitialSetup] ' send six commands in a row, looking for response from modem of either OK or error
AT&FE1  ' factory init and echo on 
ATE1    ' echo on
AT
ATZE1
ATE1
AT

[Setup.1]
AT&F   'factory init, begins test

[Reset.1]
AT&FE1  ' factory init and echo on

[Reset.2]
ATZE1  ' nvram init and echo on

[UnimodemID.Scan]
AT&FE1
AT
ATI0
ATI1
ATI2
ATI3
ATI4
ATI5
ATI6
ATI7
ATI8
ATI9
ATI10
AT&V
AT+FCLASS=?

' -------------Rockwell Installation -----------------------------------

[Rockwell.Data]  ' all of these sections get run in order 
Run=RockwellStaticInit,Rockwell.FlowHard,Rockwell.FlowSoft,Rockwell.FlowOff,Rockwell.ECMOn,Rockwell.ECMForced,Rockwell.ECMOff,Rockwell.CompressionOn,Rockwell.CompressionOff,Rockwell.ErrorControl.Cellular,Rockwell.ErrorControl.CellularForced,Rockwell.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.InactivityTimeoutTimer,


' [Rockwell.Voice]  	' future voice section
' Run = foo.bar, foo.bar2, etc


'[Rockwell.Fax]  	' future fax section
'Run = foo.bar, foo.bar2, etc

' -------------Cirrus Installation -----------------------------------



[Cirrus.Data]  ' all of these sections get run in order ' note: the cirrus keys dont exist yet...under construction
Run=CirrusStaticInit,Cirrus.FlowHard,Cirrus.FlowSoft,Cirrus.FlowOff,Cirrus.ECMOn,Cirrus.ECMForced,Cirrus.ECMOff,Cirrus.CompressionOn,Cirrus.CompressionOff,Cirrus.ErrorControl.Cellular,Cirrus.ErrorControl.CellularForced,Cirrus.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.CallSetupFailTimer,

'------------------ Rockwell Commands --------------------------------

[Rockwell.StaticInit] ' try each command, use first that works
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 W2 S95=47 S0=0<cr>"
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=47 S0=0<cr>"
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=45 S0=0<cr>"
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S0=0<cr>"
HKR, Init, 2,, "AT Z E0 V1 &D2 &C1 S0=0<cr>"

[Rockwell.FlowHard]
HKR, Settings, FlowControl_Hard,, "&K3"
HKR, Settings, FlowControl_Hard,, "\Q3"

[Rockwell.FlowSoft]
HKR, Settings, FlowControl_Soft,, "&K4"
HKR, Settings, FlowControl_Soft,, "\Q1"

[Rockwell.FlowOff]
HKR, Settings, FlowControl_Off,, "&K0"
HKR, Settings, FlowControl_Off,, "\Q0"

[Rockwell.ECMOn]
HKR, Settings, ErrorControl_On,, "\N7"  ' if \N7 try \N6 for forced
HKR, Settings, ErrorControl_On,, "\N3"  ' if \N3 try both \N4 and \N2

[Rockwell.ECMForced]
HKR, Settings, ErrorControl_Forced,, "\N6"
HKR, Settings, ErrorControl_Forced,, "\N4"
HKR, Settings, ErrorControl_Forced,, "\N2"

[Rockwell.ECMOff]
HKR, Settings, ErrorControl_Off,, "\N0"
HKR, Settings, ErrorControl_Off,, "\N"

[Rockwell.CompressionOn]
HKR, Settings, Compression_On,, "%%C1"
HKR, Settings, Compression_On,, "%%C3"

[Rockwell.CompressionOff]
HKR, Settings, Compression_Off,, "%%C0"
HKR, Settings, Compression_Off,, "%%C"


[Rockwell.ErrorControl.Cellular]  	' exception processing - prefix with the ecm cmd already found
HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1"


[Rockwell.ErrorControl.CellularForced]	' exception processing - prefix with the FORCED ecm cmd already found
HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1"

[Rockwell.InactivityTimeout]' note except macro processing' for this try feeding the command values like ' ATS30=1, ATS30=10, or AT\T1, AT\T30, AT\T60, AT\T90
HKR, Settings, InactivityTimeout,, "S30=<#>"   ' first choice
HKR, Settings, InactivityTimeout,, "\T<#>"      ' second choice

'------------------ Cirrus Commands ------------------------------------
' not ready



'------------------ USR Commands ------------------------------------
' not ready


'------------------ Global Commands  ------------------------------------

[Global.Reset]
HKR,, Reset,, "AT&F<cr>"
HKR,, Reset,, "ATZ<cr>"

[Global.CallSetupFailTimer]  ' note except macro processing' for this try feeding S7 registry: ATS7=1, ATS7=10, ATS7=60' all should pass which indicates the command below is the one to use
HKR, Settings, CallSetupFailTimer,, "S7="

[Global.BlindOff]   ' these are globals, used regardless of chipset
HKR, Settings, Blind_Off,, "X4"

[Global.BlindOn]
HKR, Settings, Blind_On,, "X3"

[Global.Pulse]
HKR, Settings, Pulse,, "P"   ' exception, you'll have to prefix a D

[Global.Tone]
HKR, Settings, Tone,, "T"  ' exception, you'll have to prefix a D

[Global.CCITT]
HKR, Settings, Modulation_CCITT,, "B0"

[Global.Bell]
HKR, Settings, Modulation_Bell,, "B1"

[Global.Monitor]
HKR, Monitor, 1,, "ATS0=0<cr>"   ' exception  - test first cmd but write both
' HKR, Monitor, 2,, "None"

[Global.Hangup]
HKR, Hangup, 1,, "ATH<cr>"

[Global.Answer]
HKR, Answer, 1,, "ATA<cr>"

[Global.Prefix]
HKR, Settings, Prefix,, "AT"   ' exception...this is the AT cmd itself

[Global.DialPrefix]
HKR, Settings, DialPrefix,, "D"

[Global.DialSuffix]
HKR, Settings, DialSuffix,, ";"
HKR, Settings, DialSuffix,, ""

[Global.SpeakerVolumeLow]
HKR, Settings, SpeakerVolume_Low,, "L0"

[Global.SpeakerVolumeMed]
HKR, Settings, SpeakerVolume_Med,, "L2"

[Global.SpeakerVolumeHigh]
HKR, Settings, SpeakerVolume_High,, "L3"

[Global.SpeakerModeOff]
HKR, Settings, SpeakerMode_Off,, "M0"

[Global.SpeakerModeDial]
HKR, Settings, SpeakerMode_Dial,, "M1"

[Global.SpeakerModeOn]
HKR, Settings, SpeakerMode_On,, "M2"

[Global.SpeakerModeSetup]
HKR, Settings, SpeakerMode_Setup,, "M3"

[Global.InactivityTimeoutTimer]  ' note macro exception handling
HKR, Settings, InactivityTimeout,, "S30=<#>"
HKR, Settings, InactivityTimeout,, "\T<#>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\tools\src\uqueryr.ini ===
[Rock.336K.Responses]
HKR, Responses, "0<cr>", 1, 00, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "1<cr>", 1, 02, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "2<cr>", 1, 08, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "3<cr>", 1, 04, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "4<cr>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "5<cr>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "6<cr>", 1, 05, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "7<cr>", 1, 06, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "8<cr>", 1, 07, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "9<cr>", 1, 02, 00, 58,02,00,00, 00,00,00,00 
HKR, Responses, "10<cr>", 1, 02, 00, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>OK<cr><lf>", 1, 00, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>ERROR<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>RING<cr><lf>", 1, 08, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>NO CARRIER<cr><lf>", 1, 04, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>NO DIALTONE<cr><lf>", 1, 05, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>BUSY<cr><lf>", 1, 06, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>NO ANSWER<cr><lf>", 1, 07, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT<cr><lf>", 1, 02, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>FAX<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>DATA<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>VOICE<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>+FCON<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>+F4<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 1200/ARQ<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400/ARQ<cr><lf>", 1, 02, 02, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 4800/ARQ<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 9600/ARQ<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 7200/ARQ<cr><lf>", 1, 02, 02, 20,1C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 12000/ARQ<cr><lf>", 1, 02, 02, E0,2E,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 14400/ARQ<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 19200/ARQ<cr><lf>", 1, 02, 02, 00,4B,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 32000/ARQ<cr><lf>", 1, 02, 02, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 34000/ARQ<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 36000/ARQ<cr><lf> ", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000/ARQ<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 40000/ARQ<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 42000/ARQ<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 44000/ARQ<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 46000/ARQ<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 48000/ARQ<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 50000/ARQ<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 52000/ARQ<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 54000/ARQ<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 56000/ARQ<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 58000/ARQ<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 60000/ARQ<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 31200/ARQ<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 33600/ARQ<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 38400/ARQ<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 57600/ARQ<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 115200/ARQ<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 16800/ARQ<cr><lf>", 1, 02, 02, A0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 21600/ARQ<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 24000/ARQ<cr><lf>", 1, 02, 02, C0,5D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 26400/ARQ<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 28800/ARQ<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>DELAYED<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>BLACKLISTED<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 300<cr><lf>", 1, 01, 00, 2C,01,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 1200/75<cr><lf>", 1, 01, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 75/1200<cr><lf>", 1, 01, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 1200<cr><lf>", 1, 01, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 2400<cr><lf>", 1, 01, 00, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 4800<cr><lf>", 1, 01, 00, C0,12,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 7200<cr><lf>", 1, 01, 00, 20,1C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 9600<cr><lf>", 1, 01, 00, 80,25,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 12000<cr><lf>", 1, 01, 00, E0,2E,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 14400<cr><lf>", 1, 01, 00, 40,38,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 16800<cr><lf>", 1, 01, 00, A0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 19200<cr><lf>", 1, 01, 00, 00,4B,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 32000<cr><lf>", 1, 01, 00, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 34000<cr><lf>", 1, 01, 00, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 36000<cr><lf> ", 1, 01, 00, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CARRIER 38000<cr><lf>", 1, 01, 00, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 40000<cr><lf>", 1, 01, 00, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 42000<cr><lf>", 1, 01, 00, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 44000<cr><lf>", 1, 01, 00, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 46000<cr><lf>", 1, 01, 00, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 48000<cr><lf>", 1, 01, 00, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 50000<cr><lf>", 1, 01, 00, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 52000<cr><lf>", 1, 01, 00, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 54000<cr><lf>", 1, 01, 00, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 56000<cr><lf>", 1, 01, 00, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 58000<cr><lf>", 1, 01, 00, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 60000<cr><lf>", 1, 01, 00, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 21600<cr><lf>", 1, 01, 00, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 24000<cr><lf>", 1, 01, 00, C0,5D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 26400<cr><lf>", 1, 01, 00, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 28800<cr><lf>", 1, 01, 00, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 31200<cr><lf>", 1, 01, 00, E0,79,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 33600<cr><lf>", 1, 01, 00, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 14400/VFC<cr><lf>", 1, 01, 00, 40,38,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 16800/VFC<cr><lf>", 1, 01, 00, a0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 19200/VFC<cr><lf>", 1, 01, 00, 00,4b,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 21600/VFC<cr><lf>", 1, 01, 00, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 24000/VFC<cr><lf>", 1, 01, 00, c0,5d,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 26400/VFC<cr><lf>", 1, 01, 00, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 28800/VFC<cr><lf>", 1, 01, 00, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 33600/VFC<cr><lf>", 1, 01, 00, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 32000/VFC<cr><lf>", 1, 01, 00, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 34000/VFC<cr><lf>", 1, 01, 00, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 36000/VFC<cr><lf> ", 1, 01, 00, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CARRIER 38000/VFC<cr><lf>", 1, 01, 00, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 40000/VFC<cr><lf>", 1, 01, 00, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 42000/VFC<cr><lf>", 1, 01, 00, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 44000/VFC<cr><lf>", 1, 01, 00, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 46000/VFC<cr><lf>", 1, 01, 00, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 48000/VFC<cr><lf>", 1, 01, 00, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 50000/VFC<cr><lf>", 1, 01, 00, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 52000/VFC<cr><lf>", 1, 01, 00, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 54000/VFC<cr><lf>", 1, 01, 00, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 56000/VFC<cr><lf>", 1, 01, 00, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 58000/VFC<cr><lf>", 1, 01, 00, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 60000/VFC<cr><lf>", 1, 01, 00, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 1200<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 0600<cr><lf>", 1, 02, 00, 58,02,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 2400<cr><lf>", 1, 02, 00, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 4800<cr><lf>", 1, 02, 00, C0,12,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 9600<cr><lf>", 1, 02, 00, 80,25,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 7200<cr><lf>", 1, 02, 00, 20,1C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 12000<cr><lf>", 1, 02, 00, E0,2E,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400<cr><lf>", 1, 02, 00, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200<cr><lf>", 1, 02, 00, 00,4B,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400<cr><lf>", 1, 02, 00, 00,96,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 57600<cr><lf>", 1, 02, 00, 00,E1,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 115200<cr><lf>", 1, 02, 00, 00,C2,01,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 16800<cr><lf>", 1, 02, 00, A0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 21600<cr><lf>", 1, 02, 00, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 24000<cr><lf>", 1, 02, 00, C0,5D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 26400<cr><lf>", 1, 02, 00, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 28800<cr><lf>", 1, 02, 00, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 31200<cr><lf>", 1, 02, 00, E0,79,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 33600<cr><lf>", 1, 02, 00, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 32000<cr><lf>", 1, 02, 00, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 34000<cr><lf>", 1, 02, 00, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 36000<cr><lf> ", 1, 02, 00, A0,8C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 38000<cr><lf>", 1, 02, 00, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 40000<cr><lf>", 1, 02, 00, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 42000<cr><lf>", 1, 02, 00, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 44000<cr><lf>", 1, 02, 00, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 46000<cr><lf>", 1, 02, 00, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 48000<cr><lf>", 1, 02, 00, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 50000<cr><lf>", 1, 02, 00, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 52000<cr><lf>", 1, 02, 00, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 54000<cr><lf>", 1, 02, 00, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 56000<cr><lf>", 1, 02, 00, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 58000<cr><lf>", 1, 02, 00, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 60000<cr><lf>", 1, 02, 00, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>COMPRESSION: CLASS 5<cr><lf>", 1, 01, 01, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>COMPRESSION: V.42bis<cr><lf>", 1, 01, 01, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>COMPRESSION: NONE<cr><lf>", 1, 01, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: NONE<cr><lf>", 1, 01, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: LAP-M<cr><lf>", 1, 01, 02, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: ALT<cr><lf>", 1, 01, 02, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: ALT - CELLULAR<cr><lf>", 1, 01, 0a, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>+FCERROR<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 230400<cr><lf>", 1, 02, 00, 00,84,03,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300/ARQ<cr><lf>", 1, 02, 02, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 0600/ARQ<cr><lf>", 1, 02, 02, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 230400/ARQ<cr><lf>", 1, 02, 02, 00,84,03,00, 00,00,00,00
HKR, Responses, "<cr><lf>CARRIER 0600<cr><lf>", 1, 01, 00, 58,02,00,00, 00,00,00,00


[Rock.56K.Responses]
HKR, Responses, "<cr><lf>NO DIAL TONE<cr><lf>", 1, 05, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>RINGING<cr><lf>", 1, 08, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300<cr><lf>", 1, 02, 00, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 NoEC<cr><lf>", 1, 02, 00, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 MNP4<cr><lf>", 1, 02, 02, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 MNP5<cr><lf>", 1, 02, 03, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 V42<cr><lf>", 1, 02, 02, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 V42bis<cr><lf>", 1, 02, 03, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600<cr><lf>", 1, 02, 00, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 NoEC<cr><lf>", 1, 02, 00, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 MNP4<cr><lf>", 1, 02, 02, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 MNP5<cr><lf>", 1, 02, 03, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 V42<cr><lf>", 1, 02, 02, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 V42bis<cr><lf>", 1, 02, 03, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 NoEC<cr><lf>", 1, 02, 00, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 MNP4<cr><lf>", 1, 02, 02, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 MNP5<cr><lf>", 1, 02, 03, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42<cr><lf>", 1, 02, 02, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42bis<cr><lf>", 1, 02, 03, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 NoEC<cr><lf>", 1, 02, 00, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 MNP4<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 MNP5<cr><lf>", 1, 02, 03, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42bis<cr><lf>", 1, 02, 03, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42 DSVD<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42bis DSVD<cr><lf>", 1, 02, 03, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 NoEC<cr><lf>", 1, 02, 00, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 MNP4<cr><lf>", 1, 02, 02, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 MNP5<cr><lf>", 1, 02, 03, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42<cr><lf>", 1, 02, 02, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42bis<cr><lf>", 1, 02, 03, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42 DSVD<cr><lf>", 1, 02, 02, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42bis DSVD<cr><lf>", 1, 02, 03, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 NoEC<cr><lf>", 1, 02, 00, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 MNP4<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 MNP5<cr><lf>", 1, 02, 03, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42bis<cr><lf>", 1, 02, 03, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42 DSVD<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42bis DSVD<cr><lf>", 1, 02, 03, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 NoEC<cr><lf>", 1, 02, 00, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 MNP4<cr><lf>", 1, 02, 02, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 MNP5<cr><lf>", 1, 02, 03, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42<cr><lf>", 1, 02, 02, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42bis<cr><lf>", 1, 02, 03, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42 DSVD<cr><lf>", 1, 02, 02, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42bis DSVD<cr><lf>", 1, 02, 03, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 NoEC<cr><lf>", 1, 02, 00, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 MNP4<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 MNP5<cr><lf>", 1, 02, 03, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42bis<cr><lf>", 1, 02, 03, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42 DSVD<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42bis DSVD<cr><lf>", 1, 02, 03, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 NoEC<cr><lf>", 1, 02, 00, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 MNP4<cr><lf>", 1, 02, 02, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 MNP5<cr><lf>", 1, 02, 03, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42<cr><lf>", 1, 02, 02, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42bis<cr><lf>", 1, 02, 03, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42 DSVD<cr><lf>", 1, 02, 02, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42bis DSVD<cr><lf>", 1, 02, 03, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 NoEC<cr><lf>", 1, 02, 00, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 MNP4<cr><lf>", 1, 02, 02, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 MNP5<cr><lf>", 1, 02, 03, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42<cr><lf>", 1, 02, 02, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42bis<cr><lf>", 1, 02, 03, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42 DSVD<cr><lf>", 1, 02, 02, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42bis DSVD<cr><lf>", 1, 02, 03, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 NoEC<cr><lf>", 1, 02, 00, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 MNP4<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 MNP5<cr><lf>", 1, 02, 03, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42bis<cr><lf>", 1, 02, 03, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42 DSVD<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42bis DSVD<cr><lf>", 1, 02, 03, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 NoEC<cr><lf>", 1, 02, 00, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 MNP4<cr><lf>", 1, 02, 02, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 MNP5<cr><lf>", 1, 02, 03, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42<cr><lf>", 1, 02, 02, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42bis<cr><lf>", 1, 02, 03, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42 DSVD<cr><lf>", 1, 02, 02, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42bis DSVD<cr><lf>", 1, 02, 03, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 NoEC<cr><lf>", 1, 02, 00, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 MNP4<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 MNP5<cr><lf>", 1, 02, 03, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42bis<cr><lf>", 1, 02, 03, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42 DSVD<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42bis DSVD<cr><lf>", 1, 02, 03, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 NoEC<cr><lf>", 1, 02, 00, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 MNP4<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 MNP5<cr><lf>", 1, 02, 03, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42bis<cr><lf>", 1, 02, 03, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42 DSVD<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42bis DSVD<cr><lf>", 1, 02, 03, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 NoEC<cr><lf>", 1, 02, 00, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 MNP4<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 MNP5<cr><lf>", 1, 02, 03, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42bis<cr><lf>", 1, 02, 03, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42 DSVD<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42bis DSVD<cr><lf>", 1, 02, 03, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 NoEC<cr><lf>", 1, 02, 00, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 MNP4<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 MNP5<cr><lf>", 1, 02, 03, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42bis<cr><lf>", 1, 02, 03, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42 DSVD<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42bis DSVD<cr><lf>", 1, 02, 03, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 NoEC<cr><lf>", 1, 02, 00, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 MNP4<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 MNP5<cr><lf>", 1, 02, 03, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42bis<cr><lf>", 1, 02, 03, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42 DSVD<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42bis DSVD<cr><lf>", 1, 02, 03, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 NoEC<cr><lf>", 1, 02, 00, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 MNP4<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 MNP5<cr><lf>", 1, 02, 03, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42bis<cr><lf>", 1, 02, 03, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42 DSVD<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42bis DSVD<cr><lf>", 1, 02, 03, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 NoEC<cr><lf>", 1, 02, 00, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 MNP4<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 MNP5<cr><lf>", 1, 02, 03, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42bis<cr><lf>", 1, 02, 03, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42 DSVD<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42bis DSVD<cr><lf>", 1, 02, 03, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 NoEC<cr><lf>", 1, 02, 00, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 MNP4<cr><lf>", 1, 02, 02, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 MNP5<cr><lf>", 1, 02, 03, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42<cr><lf>", 1, 02, 02, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42bis<cr><lf>", 1, 02, 03, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42 DSVD<cr><lf>", 1, 02, 02, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42bis DSVD<cr><lf>", 1, 02, 03, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 NoEC<cr><lf>", 1, 02, 00, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 MNP4<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 MNP5<cr><lf>", 1, 02, 03, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42bis<cr><lf>", 1, 02, 03, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42 DSVD<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42bis DSVD<cr><lf>", 1, 02, 03, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 NoEC<cr><lf>", 1, 02, 00, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 MNP4<cr><lf>", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 MNP5<cr><lf>", 1, 02, 03, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42<cr><lf>", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42bis<cr><lf>", 1, 02, 03, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42 DSVD<cr><lf>", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42bis DSVD<cr><lf>", 1, 02, 03, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 NoEC<cr><lf>", 1, 02, 00, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 MNP4<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 MNP5<cr><lf>", 1, 02, 03, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42bis<cr><lf>", 1, 02, 03, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42 DSVD<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42bis DSVD<cr><lf>", 1, 02, 03, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 NoEC<cr><lf>", 1, 02, 00, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 MNP4<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 MNP5<cr><lf>", 1, 02, 03, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42bis<cr><lf>", 1, 02, 03, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42 DSVD<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42bis DSVD<cr><lf>", 1, 02, 03, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 NoEC<cr><lf>", 1, 02, 00, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 MNP4<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 MNP5<cr><lf>", 1, 02, 03, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42bis<cr><lf>", 1, 02, 03, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42 DSVD<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42bis DSVD<cr><lf>", 1, 02, 03, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 NoEC<cr><lf>", 1, 02, 00, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 MNP4<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 MNP5<cr><lf>", 1, 02, 03, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42bis<cr><lf>", 1, 02, 03, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42 DSVD<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42bis DSVD<cr><lf>", 1, 02, 03, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 NoEC<cr><lf>", 1, 02, 00, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 MNP4<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 MNP5<cr><lf>", 1, 02, 03, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42bis<cr><lf>", 1, 02, 03, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42 DSVD<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42bis DSVD<cr><lf>", 1, 02, 03, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 NoEC<cr><lf>", 1, 02, 00, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 MNP4<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 MNP5<cr><lf>", 1, 02, 03, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42bis<cr><lf>", 1, 02, 03, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42 DSVD<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42bis DSVD<cr><lf>", 1, 02, 03, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 NoEC<cr><lf>", 1, 02, 00, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 MNP4<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 MNP5<cr><lf>", 1, 02, 03, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42bis<cr><lf>", 1, 02, 03, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42 DSVD<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42bis DSVD<cr><lf>", 1, 02, 03, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 NoEC<cr><lf>", 1, 02, 00, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 MNP4<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 MNP5<cr><lf>", 1, 02, 03, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42bis<cr><lf>", 1, 02, 03, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42 DSVD<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42bis DSVD<cr><lf>", 1, 02, 03, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 NoEC<cr><lf>", 1, 02, 00, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 MNP4<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 MNP5<cr><lf>", 1, 02, 03, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42bis<cr><lf>", 1, 02, 03, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42 DSVD<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42bis DSVD<cr><lf>", 1, 02, 03, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 NoEC<cr><lf>", 1, 02, 00, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 MNP4<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 MNP5<cr><lf>", 1, 02, 03, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42bis<cr><lf>", 1, 02, 03, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42 DSVD<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42bis DSVD<cr><lf>", 1, 02, 03, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 NoEC<cr><lf>", 1, 02, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 MNP4<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 MNP5<cr><lf>", 1, 02, 03, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42bis<cr><lf>", 1, 02, 03, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42 DSVD<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42bis DSVD<cr><lf>", 1, 02, 03, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 NoEC<cr><lf>", 1, 02, 00, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 MNP4<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 MNP5<cr><lf>", 1, 02, 03, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42bis<cr><lf>", 1, 02, 03, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42 DSVD<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42bis DSVD<cr><lf>", 1, 02, 03, 60,EA,00,00, 00,00,00,00
' responses
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\readme.txt ===
How to get UPnP device host up and running
Mason Bendixen
Sep 25, 2000

This is the beginnings of how to install the UPnP Device host. This is some onetime work that needs to be done.

1. Install IIS
2. Create a virtual directory off of the root called upnphost (C:\upnphost is used by setup.bat)
3. Give said virtual directory execute permissions and full process isolation
4. Copy setup.bat to a test machine (file assumes it will be on e:)
5. Map the given network drive to the drive on your dev machine with your source tree
6. Change setup.bat's path (m:\nt2) to point to the correct location
7. Install UPnP client stuff (for SSDP)

This is what needs to be done to get fresh binaries:

1. Disconnect debuggers attached to udhisapi.dll and upnphost.dll
2. Restart IIS
3. Run setup.bat

Yeah this is rough, but think of it as a character building experience until we have a real install program. If you have any suggestions either let me know or change the files yourself.

Thanks
    Mason
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\inst\desc.xml ===
<?xml version="1.0"?>
<root xmlns="urn:schemas-upnp-org:device-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <URLBase></URLBase>

  <device>
    <deviceType>urn:schemas-upnp-org:device.lighting.1</deviceType>
    <friendlyName>UPnP Device Host Test</friendlyName>
    <manufacturer>Microsoft</manufacturer>
    <manufacturerURL>http://www.microsoft.com/</manufacturerURL>
    <modelDescription>UPnP-X10 Light and Dimmer control</modelDescription>  
    <modelName>X-10L1</modelName>
    <modelNumber>L1</modelNumber>
    <modelURL>http://www.microsoft.com/</modelURL>
    <serialNumber>0000001</serialNumber>
    <UDN>DummyUDN</UDN>
    <UPC>00000-00001</UPC>
 
    <iconList>
       <icon>
          <mimetype>image/png</mimetype>
          <width>16</width>
          <height>16</height>
          <depth>2</depth>
          <url>icon.png</url>
       </icon>
    </iconList>
    <serviceList>
      <service>
        <serviceType>urn:schemas-upnp-org:service:pwrdim:1</serviceType>
        <serviceId>upnp:id:pwrdim</serviceId>
        <controlURL></controlURL>
        <eventSubURL></eventSubURL>
        <SCPDURL>Service.xml</SCPDURL>
      </service>
    </serviceList>

    <presentationURL></presentationURL>

   </device>

</root>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\inst\service.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">

  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <serviceStateTable>

    <stateVariable>
      <name>Power</name>
      <dataType>Boolean</dataType>
      <defaultValue>0</defaultValue>
    </stateVariable>

    <stateVariable>
      <name>Level</name>
      <dataType>i4</dataType>
        <allowedValueRange>
          <minimum>0</minimum>
          <maximum>10</maximum>
          <step>1</step>
        </allowedValueRange>
      <defaultValue>0</defaultValue>
    </stateVariable>

  </serviceStateTable>

  <actionList>

    <action>
      <name>PowerOn</name>
    </action>

    <action>
      <name>PowerOff</name>    
    </action>

    <action>
      <name>SetLevel</name>
      <argumentList>
        <argument>
        <name>NewLevel</name>
          <relatedStateVariable>Level</relatedStateVariable>
          <direction>in</direction>
        </argument>
      </argumentList>
    </action>

    <action>
      <name>IncreaseLevel</name>       
    </action>

    <action>
      <name>DecreaseLevel</name>       
    </action>
    
    <action>
      <name>Test</name>
      <argumentList>
        <argument>
          <name>Multiplier</name>
          <direction>in</direction>
          <relatedStateVariable>Level</relatedStateVariable>
        </argument>        
	<argument>
          <name>OldValue</name>
          <direction>out</direction>
          <relatedStateVariable>Level</relatedStateVariable>
          <retval/>
        </argument>
        <argument>
          <name>NewValue</name>
          <direction>out</direction>
          <relatedStateVariable>Level</relatedStateVariable>
        </argument>
      </argumentList>
    </action>

  </actionList>


</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upnpdbg.ini ===
[DebugFlags]
BreakOnAddLegacy=0
BreakOnAlloc=0
BreakOnDoUnattend=0
BreakOnDwrefProblem=0
BreakOnError=0
BreakOnHr=0
BreakOnHrInteration=0
BreakOnIteration=0
BreakOnNetInstall=0
BreakOnWizard=0
DisableTray=0
DumpLeaks=1
DumpNetCfgTree=0
NetShellBreakOnInit=0
ShowIgnoredErrors=0
ShowProcessAndThreadIds=1
ShowIdsInHex=1
SkipLanEnum=0
TracingTimeStamps=0
Extreme Tracing=0
ShowAdaptersPage=0
BreakOnPrematureDllUnload=0
BreakOnStartOfUpgrade=0
BreakOnEndOfUpgrade=0
DisableShellThreading=0
NoErrorText=0

[Default]
OutputToDebug=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : downloadctest
========================================================================


AppWizard has created this downloadctest application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your downloadctest application.

downloadctest.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

downloadctest.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CDownloadctestApp application class.

downloadctest.cpp
    This is the main application source file that contains the application
    class CDownloadctestApp.

downloadctest.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

downloadctest.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\downloadctest.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file downloadctest.rc.

res\downloadctest.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.




/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

downloadctestDlg.h, downloadctestDlg.cpp - the dialog
    These files contain your CDownloadctestDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in downloadctest.rc, which can be edited in Microsoft
	Visual C++.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named downloadctest.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\winsctrs.ini ===
[info]
drivername=Wins
symbolfile=winsctrs.h

[languages]
009=English

[text]
WINSCTRS_COUNTER_OBJECT_009_NAME=WINS Server
WINSCTRS_COUNTER_OBJECT_009_HELP=The WINS Server object type includes counters specific to the WINS Server service.

WINSCTRS_UNIQUE_REGISTRATIONS_009_NAME=Unique Registrations/sec
WINSCTRS_UNIQUE_REGISTRATIONS_009_HELP=Unique Registrations/sec is the rate at which unique registration are received by the WINS server.

WINSCTRS_GROUP_REGISTRATIONS_009_NAME=Group Registrations/sec
WINSCTRS_GROUP_REGISTRATIONS_009_HELP=Group Registrations/sec is the rate at which group registration are received by the WINS server.

WINSCTRS_TOTAL_REGISTRATIONS_009_NAME=Total Number of Registrations/sec
WINSCTRS_TOTAL_REGISTRATIONS_009_HELP=Total Number of Registrations/sec is the sum of the Unique and Group registrations per sec.  This is the total rate at which registration are received by the WINS server.

WINSCTRS_UNIQUE_REFRESHES_009_NAME=Unique Refreshes/sec
WINSCTRS_UNIQUE_REFRESHES_009_HELP=Unique Refreshes/sec is the rate at which unique registration are received by the WINS server.

WINSCTRS_GROUP_REFRESHES_009_NAME=Group Refreshes/sec
WINSCTRS_GROUP_REFRESHES_009_HELP=Group Refreshes/sec is the rate at which group registration are received by the WINS server.

WINSCTRS_TOTAL_REFRESHES_009_NAME=Total Number of Refreshes/sec
WINSCTRS_TOTAL_REFRESHES_009_HELP=Total Number of Refreshes/sec is the sum of the Unique and Group registrations per sec.  This is the total rate at which refreshes are received by the WINS server.

WINSCTRS_RELEASES_009_NAME=Releases/sec
WINSCTRS_RELEASES_009_HELP=Total Number of Releases/sec is the rate at which releases are received by the WINS server.

WINSCTRS_QUERIES_009_NAME=Queries/sec
WINSCTRS_QUERIES_009_HELP=Total Number of Queries/sec is the rate at which queries are received by the WINS server.

WINSCTRS_UNIQUE_CONFLICTS_009_NAME=Unique Conflicts/sec
WINSCTRS_UNIQUE_CONFLICTS_009_HELP=Unique Conflicts/sec is the rate at which unique registrations/refreshes received by the WINS server resulted in conflicts with records in the database.

WINSCTRS_GROUP_CONFLICTS_009_NAME=Group Conflicts/sec
WINSCTRS_GROUP_CONFLICTS_009_HELP=Group Conflicts/sec is the rate at which group registration received by the WINS server resulted in conflicts with records in the database.

WINSCTRS_TOTAL_CONFLICTS_009_NAME=Total Number of Conflicts/sec
WINSCTRS_TOTAL_CONFLICTS_009_HELP=Total Number of Conflicts/sec is the sum of the Unique and Group conflicts per sec.  This is the total rate at which conflicts were seen by the WINS server.

WINSCTRS_SUCC_RELEASES_009_NAME=Successful Releases/sec
WINSCTRS_SUCC_RELEASES_009_HELP=Total Number of Successful Releases/sec

WINSCTRS_FAIL_RELEASES_009_NAME=Failed Releases/sec
WINSCTRS_FAIL_RELEASES_009_HELP=Total Number of Failed Releases/sec

WINSCTRS_SUCC_QUERIES_009_NAME=Successful Queries/sec
WINSCTRS_SUCC_QUERIES_009_HELP=Total Number of Successful Queries/sec

WINSCTRS_FAIL_QUERIES_009_NAME=Failed Queries/sec
WINSCTRS_FAIL_QUERIES_009_HELP=Total Number of Failed Queries/sec
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\rpc\readme.txt ===
winscl.exe is a non-gui administration tool for WINS. It can be used
for monitoring a WINS's activity and for examining its database.
It can also be used for sending commands to WINS to initiate an activity 
such as  replication,  scavenging, registering a record, etc. 
 
Note: Unlike WINS Manager, winscl can not be used to configure a WINS.


The following commands are supported by winscl


 RN - Register Name

 You can register a unique/multihomed/normal group/internet group names.

 QN - Query Name

 You can query any name in the wins db.


 DN  - Delete Name

 Deletes a name.  This action permanently gets rid of the name from the
 WINS db.

 GV  - Get Version Counter Value

 Gets the current value of the version counter used to stamp records with
 version numbers

 GM  - Get Mappings

 Gets the configuration intervals being used by WINS.  These intervals
 are in secs.  It also retrieves the priority class and the number of
 query threads in WINS.  The owner id to address to version number mappings 
 used by the replicator to determine how up-to-date the WINS db is relative
 to other WINSs is also retrieved.  This command works only with an 
 NT 3.51 WINS.  Note: Owner Id is a number corresponding to a WINS address
 that is stored with a record in the WINS db. It indicates who the owner
 of the record is.

 
 GMO  - Get Mappings (to be used with NT 3.5 WINS)

 Same as above except that this command should be used when connected to an
 NT 3.5 WINS.


 GST - Get Statistics

 Gets the various timestamps and statistics maintained by WINS.  This command
 works only with an NT 3.51 WINS

 GSTO - Get Statistics (to be used with NT 3.5 WINS)

 Same as above except that this command should be used when going to an
 NT 3.5 WINS.

 PUSHT - Push Trigger
  
 Used to instruct the connected WINS to send a push trigger to another WINS.  
 The local WINS will send a push trigger to the remote WINS only if either the 
 remote WINS is listed under the Wins\Parameters\Push key in the registry or 
 if RplOnlyWCnfPnrs value of the Wins\Parameters key in the registry is 
 either non-existent or is set to 0.  Likewise, the remote WINS will accept 
 this trigger only of the local WINS is either listed listed under the 
 Wins\Parameters\Pull key in its registry or if  RplOnlyWCnfPnrs value of the 
 Wins\Parameters key in its registry is either  non-existent or is set to 0.  

 Once the trigger is sent and accepted, the remote WINS, depending upon 
 whether or not its db is out of sync with the connected WINS's db may or 
 may not pull records from the local WINS.

 PULLT - Pull Trigger

 Used to instruct the connected WINS to send a pull trigger to another WINS.  
 The local WINS will send a pull trigger to the remote WINS only if its db
 is out of sync with it and if and only if the remote WINS is either listed 
 under  the Wins\Parameters\Pull key or if RplOnlyWCnfPnrs value of the 
 Wins\Parameters key either non-existent or is set to 0.  Likewise,
 the remote WINS will accept this trigger only of the local WINS is either
 listed listed under the Wins\Parameters\Push key in its registry or if 
 RplOnlyWCnfPnrs value of the Wins\Parameters key in its registry is either 
 non-existent or is set to 0.  

 
 SI - Statically Initialize WINS

 Used to statically initialize WINS from a file which has records in
 the format used in an lmhosts file.

 CC - Use this command to initiate Consistency Checking on WINS. Consistency
      checking results in WINS communicating with other WINSs to check the
      consistency of its database.  THIS OPERATION RESULTS IN HIGH OVERHEAD
      ON THE WINS AND ALSO CAN HOG UP NETWORK BW (A FULL REPLICATION IS DONE).
      If you have a large database, you should probably do this at times when
      there is less network traffic. 
 
 SC - Scavenge  records
 
 Used to instruct WINS to scavenge records. This means that records that
 are old enough to be released will be released. Those that need to be
 made extinct will be made so.  Extinct records that need to be deleted
 will be deleted.  replica records that need to be verified will be verified.

 DRR - Delete all or a range of records 

 Used to deleted records by giving the range of version numbers.  You can
 delete all records of a WINS too.  Only the records owned by the WINS
 selected (when prompted) will be deleted.  Other information regarding
 the WINS, such as highest version number pulled, will not be deleted.

 PRR - Pull all or a range of records


 Used to pull a range of records from another WINS.  The range is given
 in terms of version numbers. If the range being pulled overlaps records
 of the remote WINS already there in the WINS db, they will first be 
 deleted before the new records are pulled.  This command is used to pull
 record(s) that somehow never got replicated and have no chance of
 replicating unless their version number becomes more than the highest the
 local WINS has for the remote WINS. 

 Again, like the PULLT command, the replication will happen only after the
 appropriate registry check (refer: PULLT command)


 GRBN - Get record by Name 

 Retreives one or more records starting with a string.  The names of
 records are lexicographically sorted in the WINS db (Exception:
 Names with 0x1B in the 16th byte are stored with the 1st and 16th byte
 transposed - they are displayed correctly). You are given a choice to
 search the db from the beginning or the end.  So, if you want to retrieve
 lets say 100 names starting with Z, it is a good idea to specify that
 WINS should search the names from the end of the db.  This will cause
 less overhead on WINS.

 
 GRBV  - Get records by version numbers

 Retrieve records from the local WINS db by specifying the range of 
 version numbers.

 BK  - Backup the WINS db.

 Backup the WINS db to a directory on the same machine as WINS.

 RSO  - Restore the WINS db (db created by WINS prior to SUR)

 Restores the WINS db to the directory it was backed up from.  NOTE: WINS
 SHOULD NOT BE RUNNING WHEN YOU RUN THIS COMMAND. 

 RS  - Restore the WINS db (db created by WINS in SUR or beyond)

 Restores the WINS db to the directory it was backed up from.  NOTE: WINS
 SHOULD NOT BE RUNNING WHEN YOU RUN THIS COMMAND. 

 RC  - Reset WINS counters

 Resets the WINS counters displayed via GST (or GSTO for NT 3.5 WINS) to
 0.

 CR  - Count records in the db.

 Counts the number of records for an owner in the WINS db.  The owner 
 is identified by the address.  You can either count all or a range of
 records.   NOTE: this can be a high overhead operation when the records
 being counted are a lot.


 SDB  - Search the db

 Search the database for records for a record with a particular name or
 address.  NOTE: When the db contains a lot of records, this can be 
 a time-consuming and "consistent overhead" operation on WINS.


 GD  - Get domain names
  
 Gets the list of domain names registered in the WINS db.  These are the
 1B names (0x1B in the 16th byte) registered by PDCs of the domains.


 DW  - Delete Wins

 This deletes all the information relevant to a WINS (identified by its
 address) from the db of the connected WINS.  This includes all records
 belonging to the WINS as well as administrative information kept for the
 WINS.  When the connected WINS is specified for deletion, all its records
 are deleted. Other information such as highest version number of records
 in db. is not removed.


 CW - Connect to Wins


 MENU - Show MENU

 NOMENU - Don't show MENU (helpful if you don't want to clutter up the output
          from a script driving the tool).
 Used to connect to another WINS

 EX - Exit the tool



 Points to Note:

  1) Addresses of WINS should be given in dotted decimal notation
  2) A version number is 64 bits long.  When prompted for it, it should be 
     given in decimal with the high word first followed by the low word 
     The two words should be seperated by a space.
  3) Many commands such as PULLT, PUSHT, SI, PRR, etc are executed
     in the background. A return status of SUCCESS indicates that the
     command has been queued to WINS for execution. It does not mean that
     WINS has successfully executed the command. 
  4) winscl is case sensitive.  So, BOB is  different from bob or Bob (when
     input to RN, QN, DN, etc).
  5) Scope if given should be in domain name form  - explained in 
     rfc 883.  Example: netbios.com. 
  6) Whenever a pull (or a push) replication is done, the local WINS will 
     send a request for it to the remote WINS only if the remote WINS is 
     either listed under the Wins\Parameters\Pull (or Push) key or 
     if RplOnlyWCnfPnrs value of the Wins\Parameters key is either 
     non-existent or is set to 0.  Likewise, the remote WINS will accept 
     the above request only if the WINS making the request is either 
     listed under the Wins\Parameters\Push (or Pull) key or if 
     the RplOnlyWCnfPnrs value of the  Wins\Parameters key is either 
      non-existent or is set to 0.  

     The two WINSs look up the above keys/values in their local registries. 
  7) When prompted for Version Number, give it in the following form
       <high word> <long word>. Example  0 9567.  The numbers are in decimal.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\private-changes.txt ===
/*
 * This file is a log of the changes to the NLB private branch, wlbs.
 * This includes all check-ins, integrates and other relevant notes
 * that affect the current state of the private tree.
 */

*** Date, user: Detailed list of changes (operations)

*** 04.27.01, shouse: Checking in private.changes - initial checkin.
*** 05.02.01, josephj:  Bugfixes for

    330799  SLD:  Improper file resource "netcfgx.dll" ...
    317200  SLD:  Need to autofix ...
    372527  the term "Virtual IP Address" in the Port Rules page ...

*** 05.15.01, shouse: Two small IPSec/PPTP session support fixes and bug fixes for

    252258 Misconfigured hosts respond to remote queries.
    391877 PREFIX:net: \nt\net\wlbs\driver\main.c: Main_recv_indicate: using uninitialized memory 'sig'
    391878 PREFIX:net: \nt\net\wlbs\driver\main.c: Main_recv: using uninitialized memory 'sig'
    391881 PREFIX:net: \nt\net\wlbs\nlbkd\print.c: PrintResp: using uninitialized memory 'pMPReserved'
    391883 PREFIX:net: \nt\net\wlbs\nlbkd\print.c: PrintResp: using uninitialized memory 'pIMReserved'
    392999 NLB: Need to back out current behavior (both converged) if one host is unicast and the other is multicast

*** 05.15.01, josephj: prefix bugs to nlbmgr code

391879  josephj PREFIX:net: \nt\net\wlbs\nlbmgr\inetcfg...
391880  josephj PREFIX:net: \nt\net\wlbs\nlbmgr\exe\...

*** 05.15.01, josephj: Fixes to the following netcfgx.dll bugs:
396770  josephj Wrong error message displayed when entering...
372527  josephj the term "Virtual IP Address" in the Port Rules...


*** 05.15.01, josephj: Fixes to the following nlbmgr.dll bugs:
396172  josephj NLB:nlbmgr:remove test menu option from the cluster menu
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\notes.txt ===
12/11/00 JosephJ Fix for #23727
    23727   wlbs drain all command should return an error message
    if no port rules exist.

    The problem (if you can call it that) is that if there are NO user-specified
    port rules, we treat port-specific operations directed to "ALL" ports as
    successful. These commands are start,stop, drain and set (adjust weights).
    Fix is for Load_port_change to return IOCTL_CVY_NOT_FOUND in this case.
    Note that  Load_port_change does some special casing for
    IOCTL_CVY_CLUSTER_DRAIN and IOCTL_CVY_CLUSTER_PLUG -- it includes
    the default port rule.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
FUNC TRACE_CONVERGENCE{LEVEL=Convergence}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\dlg.txt ===
"NLB Install Pack"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\list.txt ===
NLBWizard.exe,Network Load Balancing Install Pack,http://www.microsoft.com
NLBUninst.exe,Network Load Balancing Uninstall Pack,http://www.microsoft.com
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\readme.txt ===
This install pack is for NLB installation on Windows 2000 Server only.
The NLB bits are expected to be previously installed on the machine,
via either SP1 + the NLB hotfix or SP2 - this install pack does not
place them there.

Two executables are generated; NLBWizard.exe (which is to be used in the
Install Pack) and uninstall.exe (for uninstalling NLB and removing the
netwlbs.inf file).

In case of changes to the install pack, first generate the NLBWizard.exe
and uninstall.exe and get them signed by prslab code signing tool as a
generic Microsoft Windows Component.

http://prslab/codesign

Create a new request and follow the on-line instructions.

Job Description: Generic Microsoft Windows Component
Virus Checker: Probably Innoculan
Macro Virus Check: No
Operating System: 32-Bit Windows
Language: English
Certificate Type: Microsoft External Code Distribution
Virus Checker Engine Version: Probably 19.00
Encryption: Not High Crypto
Product Version: 1.0

List.txt must be copied into the directory containing the binaries to 
be signed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\notes.txt ===
3/17/01 JosephJ Stuff to do
    1. Define interfaces for async error reporting.

0. Make ConfigureAndBind take an out parameter which is a generation number.

Sequence of steps:
1. Check for connectivity using ping
2. Do WMI operation
3. Verify result


1 hour: review code, make notes.
Operation: Connect To Existing
    LeftView::OnWorldConnect 
         ClusterConnectPage::ClusterConnectPage
            CommonNLB::connectToClusterIndirect
                MNLBMachine::getClusterProperties
                    MwmiObject::getSpecificInstance
                        WMI core APIs


List of classes

LeftView.h (exe):class LeftView : public CTreeView, public DataSinkI
LeftView.cpp (exe):LeftView::LeftView()
LeftView.cpp (exe):LeftView::~LeftView()
LeftView.cpp (exe):LeftView::GetDocument()
LeftView.cpp (exe):LeftView::OnInitialUpdate()
LeftView.cpp (exe):LeftView::OnRButtonDown( UINT nFlags, CPoint point )
LeftView.cpp (exe):LeftView::OnWorldConnect()
LeftView.cpp (exe):LeftView::OnWorldNewCluster()
LeftView.cpp (exe):LeftView::OnClusterProperties()
LeftView.cpp (exe):LeftView::OnClusterManageVIPS()
LeftView.cpp (exe):LeftView::OnHostProperties()
LeftView.cpp (exe):LeftView::OnClusterRemove()
LeftView.cpp (exe):LeftView::OnClusterUnmanage()
LeftView.cpp (exe):LeftView::OnClusterAddHost()
LeftView.cpp (exe):LeftView::OnHostRemove()
LeftView.cpp (exe):LeftView::OnClusterControl( UINT nID )
LeftView.cpp (exe):LeftView::OnClusterPortControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostPortControl( UINT nID )
LeftView.cpp (exe):LeftView::dataSink( _bstr_t data )
LeftView.cpp (exe):LeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
LeftView.cpp (exe):LeftView::doesClusterExistInView( const _bstr_t& clusterToCheck )




JosephJ 3/21/01
Search MSDN for "Idle Loop Processing" -- there is code there for
adding MFC-compatible message processing while doing blocking operations.

JosephJ 3/24/01  using namespace std, vectors.

To use the <vector> template as is you need the statement:
        using namespace std;

JosephJ 5/19/01 Code paths for main operations

1. Create New Cluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\nlbmgrissues.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation TitleJoseph M. Joy Normal Joseph M. Joy Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags Minute Z|@X} 0J(57NLB Manager Issues JosephJ General comments on code organization Lots of instances of cut pasted duplicate code   for example the creation of cluster node in the treeview. References to details of cluster configurations (like port rules) scattered around the code. Massive use of non-trivial operations in constructors or implicitly in calls to dialog functions like DoModal. For example: LeftView::OnWorldConnectIndirect() ClusterData* p_clusterData = new ClusterData; ClusterConnectIndirectPage clusterConnect( p_clusterData, this ); _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING CPropertySheet tabbedDlg( tabbedDlgCaption ); tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW;  tabbedDlg.AddPage( &clusterConnect ); int rc = tabbedDlg.DoModal(); The DoModal above ends up attempting to connect to all the hosts in the cluster! Cluster view left pane pane displays unnecessary details: subnet-mask; MAC address; mode; Remote  We should get rid of these columns and instead  Left view: naming clusters: Change name from ip to domain-name(ip): eg: cluster.microsoft.com(10.0.0.1) Connect to host Current state: You get here through connect to existing, in which case you have to specify the cluster vip first. Add host to cluster  m getting an AV here. To do: fix AV Only choice in the connect-to-host dialog: machine IP. Can t cut paste ip address! To do: Allow arbitrary bind string. If you specify an incorrect IP, you wait and wait and wait! To do: Resolve machine first. Then ping machine, and allow user to retry ping. If you connect to a machine, but the cluster members  ip addresses are not reachable, you wait and wait To do: keep a database of hosts and the ip addresses they own. Each time you see a new dedicated/connection IP address, if you don t know the bind-string associated with that address, put up a ui. If you have a connection problem (resolve and ping first), also put up UI. The connection status window is hokey. I ve see that I press ok, see the following displayed in the dialog window: Connecting 157.59.142.143 Done  Finding host  But the dialog doesn t go away   probably because it encountered some error. To do: Get rid of connection-status window   Just make status display what we re currently doing, and also report to the log pane below (prefixed by HH:MM:SS eg: 04:45:05 Connecting to host xxxx of cluster xxxx 04:45:06  Could not ping host xxx Logging support Global log class, Has a method: Log(ID, display-flags, message, params) Display-type: Level: 1, 2, 3 (translate to indent and emphasis); Disposition: error, warning, informational (translate to color: red for errors, black-with yellow background for warnings, normal for informational). Optionally logs to a specified file. Managing Operations on Hosts We need a single and unique object for each physical host. We need to route all operations on that host to this object. This is for the following reasons: We keep connectivity information regarding a host in one place, regardless of how we get to that host (from multiple clusters, say) We don t attempt multiple operations to that host concurrently   say trying to connect to that host in the context of one cluster while we re attempting to manage it in the context of another cluster. Features: For simplicity, we don t allow concurrent operations on the same host, even if its for different clusters on that host. We keep connectivity information, and persist it. Supporting Ghost Clusters and Hosts A new cluster is a template (husk or ghost) until it s actually realized with one or more hosts. Likewise, a host node can also be a ghost until we ve connected to it successfully. So we need the concept of placeholders for both clusters and hosts in the cluster. The UI should handle this and we should be able to persist this. MipAddressAdmin AV  in MipAddressAdmin. MIPAddressAdmin::getIPAddresses. The code blindly assumes the result is an array, and access-violates if if s VT_NULL. Hit this AV. Todo: add error checking to this function.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\notes.txt ===
3/17/01 JosephJ Stuff to do
    1. Define interfaces for async error reporting.

0. Make ConfigureAndBind take an out parameter which is a generation number.

Sequence of steps:
1. Check for connectivity using ping
2. Do WMI operation
3. Verify result


1 hour: review code, make notes.
Operation: Connect To Existing
    LeftView::OnWorldConnect 
         ClusterConnectPage::ClusterConnectPage
            CommonNLB::connectToClusterIndirect
                MNLBMachine::getClusterProperties
                    MwmiObject::getSpecificInstance
                        WMI core APIs


List of classes

LeftView.h (exe):class LeftView : public CTreeView, public DataSinkI
LeftView.cpp (exe):LeftView::LeftView()
LeftView.cpp (exe):LeftView::~LeftView()
LeftView.cpp (exe):LeftView::GetDocument()
LeftView.cpp (exe):LeftView::OnInitialUpdate()
LeftView.cpp (exe):LeftView::OnRButtonDown( UINT nFlags, CPoint point )
LeftView.cpp (exe):LeftView::OnWorldConnect()
LeftView.cpp (exe):LeftView::OnWorldNewCluster()
LeftView.cpp (exe):LeftView::OnClusterProperties()
LeftView.cpp (exe):LeftView::OnClusterManageVIPS()
LeftView.cpp (exe):LeftView::OnHostProperties()
LeftView.cpp (exe):LeftView::OnClusterRemove()
LeftView.cpp (exe):LeftView::OnClusterUnmanage()
LeftView.cpp (exe):LeftView::OnClusterAddHost()
LeftView.cpp (exe):LeftView::OnHostRemove()
LeftView.cpp (exe):LeftView::OnClusterControl( UINT nID )
LeftView.cpp (exe):LeftView::OnClusterPortControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostPortControl( UINT nID )
LeftView.cpp (exe):LeftView::dataSink( _bstr_t data )
LeftView.cpp (exe):LeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
LeftView.cpp (exe):LeftView::doesClusterExistInView( const _bstr_t& clusterToCheck )




JosephJ 3/21/01
Search MSDN for "Idle Loop Processing" -- there is code there for
adding MFC-compatible message processing while doing blocking operations.

JosephJ 3/24/01  using namespace std, vectors.

To use the <vector> template as is you need the statement:
        using namespace std;

JosephJ 5/19/01 Code paths for main operations

1. Create New Cluster, add a host
2. Connect to existing cluster
3. Modify existing cluster's properties.

05/19/2001  JosephJ
Cluster node in treview is created in several places --
    LeftView::OnWorldNewCluster.
LeftView::OnWorldConnect
LeftView::OnWorldConnectIndirect
The name is set there (currently the cluster ip address)

Application Initialization
---------------------------

05/20/2001  JosephJ
When implementing the disclaimer dialog box, which has a checkbox...
DDX macros don't work in the context of the Application::InitInstance
function. So I had to use the CWnd::IsDlgButtonChecked macro.
This works. HOWEVER the DDX macros now work too -- so I changed something
and now it works.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\sqlwmisample.txt ===
FROM: nt\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.cpp

HRESULT
CEnumClusCfgIPAddresses::HrGetAdapterConfiguration(
    IWbemClassObject * pNetworkAdapterIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    VARIANT                 var;
    WCHAR                   sz[ 256 ];
    IEnumWbemClassObject *  pConfigurations = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pConfiguration = NULL;
    int                     cFound = 0;
    BSTR                    bstrAdapterName = NULL;
    int                     idx;

    VariantInit( &var );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    _snwprintf( sz, ARRAYSIZE( sz ), L"Associators of {Win32_NetworkAdapter.DeviceID='%s'} where AssocClass=Win32_NetworkAdapterSetting", var.bstrVal );

    bstrQuery = TraceSysAllocString( sz );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrAdapterName = TraceSysAllocString( var.bstrVal );
    if ( bstrAdapterName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pConfigurations ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING(
                TASKID_Major_Find_Devices,
                TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
                IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED,
                bstrAdapterName,
                hr
                );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        hr = pConfigurations->Next( WBEM_INFINITE, 1, &pConfiguration, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            //
            //  KB: 25-AUG-2000 GalenB
            //
            //  WMI only supports one configuration per adapter!
            //
            Assert( idx < 1 );

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pConfiguration, L"IPEnabled", VT_BOOL, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If this configuration is not for TCP/IP then skip it.
            //
            if ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Non_Tcp_Config, IDS_WARNING__NON_TCP_CONFIG, bstrAdapterName, hr );
                continue;
            } // if:

            hr = STHR( HrSaveIPAddresses( bstrAdapterName, pConfiguration ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  KB: 24-AUG-2000 GalenB
            //
            //  If any configuration returns S_FALSE then we skip.
            //
            if ( hr == S_FALSE )
            {
                pConfiguration->Release();
                pConfiguration = NULL;
                continue;
            } // if:

            cFound++;
            pConfiguration->Release();
            pConfiguration = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find any valid configurations then we should return S_FALSE
    //  to tell the caller to ingore that adpater.
    //
    if ( cFound == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_No_Valid_TCP_Configs, IDS_WARNING_NO_VALID_TCP_CONFIGS, bstrAdapterName, hr );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetAdapterConfiguration, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrAdapterName );

    if ( pConfiguration != NULL )
    {
        pConfiguration->Release();
    } // if:

    if ( pConfigurations != NULL )
    {
        pConfigurations->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrGetAdapterConfiguration
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\notes.txt ===
TO DO LIST
----------


1. Report NIC Friendly Name
    - Add szFriendlyName to CfgUtilGetStaticIpAddresses
        Friendly name: "NetConnectionID"
        Note: Adapter name is "Name"
        Check out other properties of cimv2\Win32_NetworkAdapter 
    - Make "tprov niclist" report reporting friendly names and first ip addr.
      Format:
        {B2CD5533-5091-4F49-B80F-A07844B14209} 10.0.0.1/255.0.0.0 "1394 Adapter"
    - Add (fIncludeDisabled) flag to NicList.
    - Add friendly name and device-state to EXTENDED_CONFIGURATION structure
    - Dump this information in display_config (if non-NULL)
    - Implement filling out this information in EXTENDED_CONFIGURATION structure
    - Add friendly name to MOF
    - Implement reporting this in wmiupdate

2. Impliment CompatibleNicList in WMI
    - Add GetCompatibleAdapterGuids method to MOF.
    - Add support for wminiclist in tprov

3. Implement popup if no non-nlb adapters left in nlbmgr.exe

4. Change ip address to bind string in connect-dialog, first ping for the 
   address, etc...


3. Demonstrate fundamental plumbing is working:
     x Modify existing test to optionally go through WMI
        -- get rid of nlbhost class (nlbhost.cpp)
     x Verify we can get partial input and output parameters for GetConfig
     x Implement and test GetClusterConfig with partial params
     x Re-test local (non-wmi) functionality, including bind/unbind, change IPs
     x Implement QueryUpdate and UpdateConfig
     x test UpdateConfig with partial params

     - Implement and test getting port rules information
     - Implement and test settings port rule information
     - Implement and test getting full information 
     - Implement and test setting full information 
4. Hook into nlb manager

4. Add "partial-update" semantics 
    New parameter:  BOOL PartialUpdate
    OPTIONAL parameter Generation -- if specified, we'll verify that the
    Generation matches the current generation.
    parameter value NULL === don't change
    port rules: require the following property on each PR for partial-updates:
        action=[ADD|DELETE|UPDATE]
    IP addresses: require the ip address to be prefixed by
        "add:" "delete:" or "update:" (latter for changing subnet masks)
        
        UI:
        add:{10.1.1.3}
        delete:{10.1.1.3, 255.0.0}
        update:{10.1.1.3, 255.0.0}

    EXAMPLE 1:
        PartialUpdate=TRUE
        PortRules="action=update ip=10.1.1.3 start=80 end=288 weight=20 ...."

    EXAMPLE 2:
        PartialUpdate=TRUE
        IpAddresses="add:10.0.0.1/255.255.0.0", "delete:10.0.0.2"
        Generation=8
5. Switch from events to using two mutexes
6. Explicitly report the following errors
    - other update pending
    - netcfg write lock held
7. Use resource strings
8. Use internal constants for error codes and literal strings
9. Follow up on WMI SDK errors -- DaveIce
    WBEM_E_SERVER_NOT_FOUND -- where is this defined.
    0x800706bf -- no definition in any header (and I checked in
            index2a with interesting results), recoverable error.
    0x80070767 -- no defn
    0x80070005 -- no defn
------------------------------------                

"Persistant" state for a particular NIC is mainained as a (for now)
volatile key under  SYSTEM\CurrentControlSet\Services\WLBS\ConfigurationHistory\{GUID}
Under this GUID, there is are a set of reg-binary values (which are lighter weight than keys). They value-name is the generation number, and the value is a struct concatenated with a log. The struct has the format:
typedef struct {
    UINT Version;
    UINT HeaderSize;
    UINT Generation;
    UINT CompletionCode;
    UINT OffsetToLog;       // from start of this structure
    UINT LogSize;           // 0 == no log
    UINT Reserved1;
    UINT Reserved2;
};


    swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\
\Interface\\%s",
            szAdapterGuid);

    RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                           fReadOnly? KEY_READ : KEY_WRITE, & hKey);

    return hKey;
       status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                          KEY_QUERY_VALUE, & key);
HKEY hKey;

    status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, & key, & disp);


[HLKM\SYSTEM\CurrentControlSet\Services\WLBS\ConfigurationHistory]
       [{EBE09517-07B4-4E88-AAF1-E06F5540608B}]
            Generation (DWORD)
            [PendingOperation]
                Generation (DWORD)
                ThreadId (String)
            [Completions]
                1   Binary
                2   Binary

Mutex Name
NLB_D6901862{EBE09517-07B4-4E88-AAF1-E06F5540608B}
HANDLE CreateMutex(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,
                       // pointer to security attributes
  BOOL bInitialOwner,  // flag for initial ownership
  LPCTSTR lpName       // pointer to mutex-object name
);



04/10/2001  JosephJ Mutex vs Event vs Registry
    Finally settled on a named event because:
    1. Needs to recover from a process crash (so can't use registry)
    2. Needs to be cross process -- so must used named object
    3. Need to "acquire" in one thread and "release" in another -- so can't
        use mutex.
    
    The auto-reset event is normally signalled. It is non-signalled whenever
    an operation is pending. It is manually set back to signalled whenever
    the operation is completed.
bp tprov!NlbConfigurationUpdate__DoUpdate 
bp tprov!NlbConfigurationUpdate__s_AsyncUpdateThreadProc 
-------
Sean, you can do this semi-automatically by creating a new and temporary tree just for the merging process.

So for example, create a new directory driver2 in the private tree (or your scratch depot) and checkin the latest netvbl2  checked-in sources..
From one enlistment, open the files for edit, and copy over your BDA privates (but dont checkin).
From a second enlistment, open the files for edit, and copy over the latest privates from the private tree (this has virtual cluster support), and check this in.
Go back to the first enlistment and resolve.
-------

04/15/2001  JosephJ lightweight wmi wrapper.

    Connect-to-machine
    Get-object

04/15/2001  JosephJ Consider using IWbemServices::ExecQuery

04/25/2001 JosephJ Adding/removing IP addresses.
    Binding/Re-binding NLB:
        we require the explicit list of IP addresses to be specified.
        We'll check that
        (a) dedicated ip address, if specified, is first.
        (b) cluster_vip and subnet mask match are present.
        (c) vips for any per-ip port rules are present.
    We honor the specified order of ip addresses.
    
    Unbinding NLB:
        We set the specified list of ip addresses.
        If NULL, we'll switch the adapter to DHCP, which could take a while.

z:\nt\net\wlbs\api\obj\i386;Z:\nt\net\wlbs\nlbmgr\provider\tests\obj\i386;symsrv*symsrv.dll*\\symbols\symbols

10.1.x.x {A25EF21A-4634-4B15-AE7F-6825DFAD9FA6}
10.0.x.x {AD4DA14D-CAAE-42DD-97E3-5355E55247C2}

Utility function wrappers for exec method

CfgUtilGetWmiObjectInstance(szRoot, szPropertyName, szPropertyValue)
CfgUtilGetWmiRelPath(szRoot, szPropertyName, szPropertyValue)
CfgUtilGetWmiInputInstance(
    IN szRoot,
    IN szPropertyName,   "NlbsNic"
    IN szPropertyValue,  "guid"
    IN szMethod          "EnableStatic"
    OUT IInputInstance,
    OUT szRelPath,

GetMethodInstanceByProperty
SetupInParams --> 
ExecMethod
GetOutParams

bp tprov!CfgUtilGetWmiInputInstanceAndRelPath


WBEMSTATUS
IWbemSvc *pSvc

WBEMSTATUS
ConnectToWMi(
    MACHINE-NAME, // NULL == Don't us WMI, "" == local, 
    szAdminPassword, // OPTIONAL
    szAdminDomain, // OPTIONAL
    szNicGuid,
    info
);

WBEMSTATUS
GetClusterConfig(
    MACHINE-NAME, // NULL == Don't us WMI, "" == local, 
    szAdminPassword, // OPTIONAL
    szAdminDomain, // OPTIONAL
    szNicGuid,
    info
    );


05/12/2001  JosephJ
To do:
1. Remove NlbState property, add BOOL NlbBound property
2. Get rid of SubnetMask string array -- Instead place subnet mask
   after ip address: "10.1.1.1/255.255.255.255"
3. Demonstrate fundamental plumbing is working:
     x Modify existing test to optionally go through WMI
        -- get rid of nlbhost class (nlbhost.cpp)
     x Verify we can get partial input and output parameters for GetConfig
     x Implement and test GetClusterConfig with partial params
     x Re-test local (non-wmi) functionality, including bind/unbind, change IPs
     x Implement QueryUpdate and UpdateConfig
     x test UpdateConfig with partial params
     - Implement and test getting port rules information
     - Implement and test settings port rule information
     - Implement and test getting full information 
     - Implement and test setting full information 
4. Hook into nlb manager

4. Add "partial-update" semantics 
    New parameter:  BOOL PartialUpdate
    OPTIONAL parameter Generation -- if specified, we'll verify that the
    Generation matches the current generation.
    parameter value NULL === don't change
    port rules: require the following property on each PR for partial-updates:
        action=[ADD|DELETE|UPDATE]
    IP addresses: require the ip address to be prefixed by
        "add:" "delete:" or "update:" (latter for changing subnet masks)
        
        UI:
        add:{10.1.1.3}
        delete:{10.1.1.3, 255.0.0}
        update:{10.1.1.3, 255.0.0}

    EXAMPLE 1:
        PartialUpdate=TRUE
        PortRules="action=update ip=10.1.1.3 start=80 end=288 weight=20 ...."

    EXAMPLE 2:
        PartialUpdate=TRUE
        IpAddresses="add:10.0.0.1/255.255.0.0", "delete:10.0.0.2"
        Generation=8
5. Switch from events to using two mutexes
6. Explicitly report the following errors
    - other update pending
    - netcfg write lock held
7. Use resource strings
8. Use internal constants for error codes and literal strings
9. Follow up on WMI SDK errors -- DaveIce
    WBEM_E_SERVER_NOT_FOUND -- where is this defined.
    0x800706bf -- no definition in any header (and I checked in
            index2a with interesting results), recoverable error.
    0x80070767 -- no defn
    0x80070005 -- no defn
                
!sympath .\obj\i386;symsrv*symsrv.dll*\\symbols\symbols
bp tprov!CfgUtilGetWmiInputInstanceAndRelPath
bp tprov!NlbHostGetConfiguration

05/17/2001  JosephJ more on partial updates

        // Determine if this is a partial or full update.
        // If partial update, we allow a subset of cluster configuration
        // parameters to be specified, but allow only a restricted set
        // of update operations.
        //
        // Disallowed partial update operations:
        //  - Transitions between bound and !bound 
        //  - Currently bound  but nlb parameters are invalid
        //
        // Some allowed partial updates:
        //  - Modifying IP address lists
        //  - Modifying cluster / dedicated addresses/subnets
        //  - Modifying existing portrules
        //  - Adding/deleting port rules
        //
Successfully connected to NLB on JOSEPHJ4E...

Going call QueryConfigurationUpdateStatus...

QueryConfigurationUpdateStatus returns successfully

Connecting to NLB on JOSEPHJ4E ...

Successfully connected to NLB on JOSEPHJ4E...
Going call QueryConfigurationUpdateStatus...
QueryConfigurationUpdateStatus returns successfully
Connecting to NLB on JOSEPHJ4E ...

Sample framework provier...
C:\Microsoft Platform SDK\Samples\SysMgmt\WMI\VC\FrameworkProv
http://msdn.microsoft.com/library/default.asp?URL=/library/psdk/wmisdk/framework_1h0l.htm
Static methods -- implementation
    Declaring static: add "static" in mof ... [Implemented, static, ...]
    Them in the ExecMethod class, simply ignore the Instance parameter.

Static methods -- calling
A method may or may not be static. Static methods are designated by the presence of the Static qualifier on their definition. Static methods are executed against a class, not a particular instance of that class. The path specified to a method execution API for a static method must, therefore, be a class name. Non-static methods are executed against a particular instance of a class. The path specified to a method execution for a non-static method must, therefore, be an instance path

Nadir Ahmed
Nadir Ahmed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\wbemcli.txt ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for wbemcli.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemcli_h__
#define __wbemcli_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemBackupRestoreEx_FWD_DEFINED__
#define __IWbemBackupRestoreEx_FWD_DEFINED__
typedef interface IWbemBackupRestoreEx IWbemBackupRestoreEx;
#endif 	/* __IWbemBackupRestoreEx_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemClassObject_FWD_DEFINED__
#define __WbemClassObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemClassObject WbemClassObject;
#else
typedef struct WbemClassObject WbemClassObject;
#endif /* __cplusplus */

#endif 	/* __WbemClassObject_FWD_DEFINED__ */


#ifndef __MofCompiler_FWD_DEFINED__
#define __MofCompiler_FWD_DEFINED__

#ifdef __cplusplus
typedef class MofCompiler MofCompiler;
#else
typedef struct MofCompiler MofCompiler;
#endif /* __cplusplus */

#endif 	/* __MofCompiler_FWD_DEFINED__ */


#ifndef __WbemStatusCodeText_FWD_DEFINED__
#define __WbemStatusCodeText_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemStatusCodeText WbemStatusCodeText;
#else
typedef struct WbemStatusCodeText WbemStatusCodeText;
#endif /* __cplusplus */

#endif 	/* __WbemStatusCodeText_FWD_DEFINED__ */


#ifndef __WbemBackupRestore_FWD_DEFINED__
#define __WbemBackupRestore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemBackupRestore WbemBackupRestore;
#else
typedef struct WbemBackupRestore WbemBackupRestore;
#endif /* __cplusplus */

#endif 	/* __WbemBackupRestore_FWD_DEFINED__ */


#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif /* __cplusplus */

#endif 	/* __WbemRefresher_FWD_DEFINED__ */


#ifndef __WbemObjectTextSrc_FWD_DEFINED__
#define __WbemObjectTextSrc_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemObjectTextSrc WbemObjectTextSrc;
#else
typedef struct WbemObjectTextSrc WbemObjectTextSrc;
#endif /* __cplusplus */

#endif 	/* __WbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemRawSdAccessor_FWD_DEFINED__
#define __IWbemRawSdAccessor_FWD_DEFINED__
typedef interface IWbemRawSdAccessor IWbemRawSdAccessor;
#endif 	/* __IWbemRawSdAccessor_FWD_DEFINED__ */


#ifndef __IWbemShutdown_FWD_DEFINED__
#define __IWbemShutdown_FWD_DEFINED__
typedef interface IWbemShutdown IWbemShutdown;
#endif 	/* __IWbemShutdown_FWD_DEFINED__ */


#ifndef __IWbemCallStatus_FWD_DEFINED__
#define __IWbemCallStatus_FWD_DEFINED__
typedef interface IWbemCallStatus IWbemCallStatus;
#endif 	/* __IWbemCallStatus_FWD_DEFINED__ */


#ifndef __IWbemObjectTextSrc_FWD_DEFINED__
#define __IWbemObjectTextSrc_FWD_DEFINED__
typedef interface IWbemObjectTextSrc IWbemObjectTextSrc;
#endif 	/* __IWbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IMofCompiler_FWD_DEFINED__
#define __IMofCompiler_FWD_DEFINED__
typedef interface IMofCompiler IMofCompiler;
#endif 	/* __IMofCompiler_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemBackupRestoreEx_FWD_DEFINED__
#define __IWbemBackupRestoreEx_FWD_DEFINED__
typedef interface IWbemBackupRestoreEx IWbemBackupRestoreEx;
#endif 	/* __IWbemBackupRestoreEx_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/* library WbemClient_v1 */
/* [uuid] */ 




















typedef /* [v1_enum] */ 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    } 	WBEM_GENUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2,
	WBEM_FLAG_UPDATE_COMPATIBLE	= 0,
	WBEM_FLAG_UPDATE_SAFE_MODE	= 0x20,
	WBEM_FLAG_UPDATE_FORCE_MODE	= 0x40,
	WBEM_MASK_UPDATE_MODE	= 0x60,
	WBEM_FLAG_ADVISORY	= 0x10000
    } 	WBEM_CHANGE_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GENERIC_FLAG_TYPE
    {	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_WBEM_COMPLETE	= 0,
	WBEM_FLAG_BIDIRECTIONAL	= 0,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_RETURN_ERROR_OBJECT	= 0,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0,
	WBEM_FLAG_ENSURE_LOCATABLE	= 0x100,
	WBEM_FLAG_DIRECT_READ	= 0x200,
	WBEM_FLAG_SEND_ONLY_SELECTED	= 0,
	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10,
	WBEM_MASK_RESERVED_FLAGS	= 0x1f000,
	WBEM_FLAG_USE_AMENDED_QUALIFIERS	= 0x20000,
	WBEM_FLAG_STRONG_VALIDATION	= 0x100000
    } 	WBEM_GENERIC_FLAG_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    } 	WBEM_STATUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    } 	WBEM_TIMEOUT_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70,
	WBEM_FLAG_CLASS_OVERRIDES_ONLY	= 0x100,
	WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES	= 0x200,
	WBEM_MASK_CLASS_CONDITION	= 0x300
    } 	WBEM_CONDITION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60,
	WBEM_FLAVOR_NOT_AMENDED	= 0,
	WBEM_FLAVOR_AMENDED	= 0x80,
	WBEM_FLAVOR_MASK_AMENDED	= 0x80
    } 	WBEM_FLAVOR_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    } 	WBEM_QUERY_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_SECURITY_FLAGS
    {	WBEM_ENABLE	= 1,
	WBEM_METHOD_EXECUTE	= 2,
	WBEM_FULL_WRITE_REP	= 4,
	WBEM_PARTIAL_WRITE_REP	= 8,
	WBEM_WRITE_PROVIDER	= 0x10,
	WBEM_REMOTE_ACCESS	= 0x20,
	WBEM_RIGHT_SUBSCRIBE	= 0x1,
	WBEM_RIGHT_PUBLISH	= 0x1
    } 	WBEM_SECURITY_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    } 	WBEM_LIMITATION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    } 	WBEM_TEXT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    } 	WBEM_COMPARISON_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    } 	WBEM_LOCKING_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
    } 	CIMTYPE_ENUMERATION;

typedef /* [v1_enum] */ 
enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {	WBEM_FLAG_BACKUP_RESTORE_DEFAULT	= 0,
	WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN	= 1
    } 	WBEM_BACKUP_RESTORE_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_REFRESHER_FLAGS
    {	WBEM_FLAG_REFRESH_AUTO_RECONNECT	= 0,
	WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT	= 1
    } 	WBEM_REFRESHER_FLAGS;

typedef 
enum tag_WBEM_SHUTDOWN_FLAGS
    {	WBEM_SHUTDOWN_UNLOAD_COMPONENT	= 1,
	WBEM_SHUTDOWN_WMI	= 2,
	WBEM_SHUTDOWN_OS	= 3
    } 	WBEM_SHUTDOWN_FLAGS;

typedef long CIMTYPE;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS_FORMAT
    {	WBEMSTATUS_FORMAT_NEWLINE	= 0,
	WBEMSTATUS_FORMAT_NO_NEWLINE	= 1
    } 	WBEMSTATUS_FORMAT;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= 0x40002,
	WBEM_S_DIFFERENT	= 0x40003,
	WBEM_S_TIMEDOUT	= 0x40004,
	WBEM_S_NO_MORE_DATA	= 0x40005,
	WBEM_S_OPERATION_CANCELLED	= 0x40006,
	WBEM_S_PENDING	= 0x40007,
	WBEM_S_DUPLICATE_OBJECTS	= 0x40008,
	WBEM_S_ACCESS_DENIED	= 0x40009,
	WBEM_S_PARTIAL_RESULTS	= 0x40010,
	WBEM_S_NO_POSTHOOK	= 0x40011,
	WBEM_S_POSTHOOK_WITH_BOTH	= 0x40012,
	WBEM_S_POSTHOOK_WITH_NEW	= 0x40013,
	WBEM_S_POSTHOOK_WITH_STATUS	= 0x40014,
	WBEM_S_POSTHOOK_WITH_OLD	= 0x40015,
	WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT	= 0x40016,
	WBEM_S_SOURCE_NOT_AVAILABLE	= 0x40017,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= 0x80041002,
	WBEM_E_ACCESS_DENIED	= 0x80041003,
	WBEM_E_PROVIDER_FAILURE	= 0x80041004,
	WBEM_E_TYPE_MISMATCH	= 0x80041005,
	WBEM_E_OUT_OF_MEMORY	= 0x80041006,
	WBEM_E_INVALID_CONTEXT	= 0x80041007,
	WBEM_E_INVALID_PARAMETER	= 0x80041008,
	WBEM_E_NOT_AVAILABLE	= 0x80041009,
	WBEM_E_CRITICAL_ERROR	= 0x8004100a,
	WBEM_E_INVALID_STREAM	= 0x8004100b,
	WBEM_E_NOT_SUPPORTED	= 0x8004100c,
	WBEM_E_INVALID_SUPERCLASS	= 0x8004100d,
	WBEM_E_INVALID_NAMESPACE	= 0x8004100e,
	WBEM_E_INVALID_OBJECT	= 0x8004100f,
	WBEM_E_INVALID_CLASS	= 0x80041010,
	WBEM_E_PROVIDER_NOT_FOUND	= 0x80041011,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= 0x80041012,
	WBEM_E_PROVIDER_LOAD_FAILURE	= 0x80041013,
	WBEM_E_INITIALIZATION_FAILURE	= 0x80041014,
	WBEM_E_TRANSPORT_FAILURE	= 0x80041015,
	WBEM_E_INVALID_OPERATION	= 0x80041016,
	WBEM_E_INVALID_QUERY	= 0x80041017,
	WBEM_E_INVALID_QUERY_TYPE	= 0x80041018,
	WBEM_E_ALREADY_EXISTS	= 0x80041019,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= 0x8004101a,
	WBEM_E_PROPAGATED_QUALIFIER	= 0x8004101b,
	WBEM_E_PROPAGATED_PROPERTY	= 0x8004101c,
	WBEM_E_UNEXPECTED	= 0x8004101d,
	WBEM_E_ILLEGAL_OPERATION	= 0x8004101e,
	WBEM_E_CANNOT_BE_KEY	= 0x8004101f,
	WBEM_E_INCOMPLETE_CLASS	= 0x80041020,
	WBEM_E_INVALID_SYNTAX	= 0x80041021,
	WBEM_E_NONDECORATED_OBJECT	= 0x80041022,
	WBEM_E_READ_ONLY	= 0x80041023,
	WBEM_E_PROVIDER_NOT_CAPABLE	= 0x80041024,
	WBEM_E_CLASS_HAS_CHILDREN	= 0x80041025,
	WBEM_E_CLASS_HAS_INSTANCES	= 0x80041026,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= 0x80041027,
	WBEM_E_ILLEGAL_NULL	= 0x80041028,
	WBEM_E_INVALID_QUALIFIER_TYPE	= 0x80041029,
	WBEM_E_INVALID_PROPERTY_TYPE	= 0x8004102a,
	WBEM_E_VALUE_OUT_OF_RANGE	= 0x8004102b,
	WBEM_E_CANNOT_BE_SINGLETON	= 0x8004102c,
	WBEM_E_INVALID_CIM_TYPE	= 0x8004102d,
	WBEM_E_INVALID_METHOD	= 0x8004102e,
	WBEM_E_INVALID_METHOD_PARAMETERS	= 0x8004102f,
	WBEM_E_SYSTEM_PROPERTY	= 0x80041030,
	WBEM_E_INVALID_PROPERTY	= 0x80041031,
	WBEM_E_CALL_CANCELLED	= 0x80041032,
	WBEM_E_SHUTTING_DOWN	= 0x80041033,
	WBEM_E_PROPAGATED_METHOD	= 0x80041034,
	WBEM_E_UNSUPPORTED_PARAMETER	= 0x80041035,
	WBEM_E_MISSING_PARAMETER_ID	= 0x80041036,
	WBEM_E_INVALID_PARAMETER_ID	= 0x80041037,
	WBEM_E_NONCONSECUTIVE_PARAMETER_IDS	= 0x80041038,
	WBEM_E_PARAMETER_ID_ON_RETVAL	= 0x80041039,
	WBEM_E_INVALID_OBJECT_PATH	= 0x8004103a,
	WBEM_E_OUT_OF_DISK_SPACE	= 0x8004103b,
	WBEM_E_BUFFER_TOO_SMALL	= 0x8004103c,
	WBEM_E_UNSUPPORTED_PUT_EXTENSION	= 0x8004103d,
	WBEM_E_UNKNOWN_OBJECT_TYPE	= 0x8004103e,
	WBEM_E_UNKNOWN_PACKET_TYPE	= 0x8004103f,
	WBEM_E_MARSHAL_VERSION_MISMATCH	= 0x80041040,
	WBEM_E_MARSHAL_INVALID_SIGNATURE	= 0x80041041,
	WBEM_E_INVALID_QUALIFIER	= 0x80041042,
	WBEM_E_INVALID_DUPLICATE_PARAMETER	= 0x80041043,
	WBEM_E_TOO_MUCH_DATA	= 0x80041044,
	WBEM_E_SERVER_TOO_BUSY	= 0x80041045,
	WBEM_E_INVALID_FLAVOR	= 0x80041046,
	WBEM_E_CIRCULAR_REFERENCE	= 0x80041047,
	WBEM_E_UNSUPPORTED_CLASS_UPDATE	= 0x80041048,
	WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE	= 0x80041049,
	WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE	= 0x80041050,
	WBEM_E_TOO_MANY_PROPERTIES	= 0x80041051,
	WBEM_E_UPDATE_TYPE_MISMATCH	= 0x80041052,
	WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED	= 0x80041053,
	WBEM_E_UPDATE_PROPAGATED_METHOD	= 0x80041054,
	WBEM_E_METHOD_NOT_IMPLEMENTED	= 0x80041055,
	WBEM_E_METHOD_DISABLED	= 0x80041056,
	WBEM_E_REFRESHER_BUSY	= 0x80041057,
	WBEM_E_UNPARSABLE_QUERY	= 0x80041058,
	WBEM_E_NOT_EVENT_CLASS	= 0x80041059,
	WBEM_E_MISSING_GROUP_WITHIN	= 0x8004105a,
	WBEM_E_MISSING_AGGREGATION_LIST	= 0x8004105b,
	WBEM_E_PROPERTY_NOT_AN_OBJECT	= 0x8004105c,
	WBEM_E_AGGREGATING_BY_OBJECT	= 0x8004105d,
	WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY	= 0x8004105f,
	WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING	= 0x80041060,
	WBEM_E_QUEUE_OVERFLOW	= 0x80041061,
	WBEM_E_PRIVILEGE_NOT_HELD	= 0x80041062,
	WBEM_E_INVALID_OPERATOR	= 0x80041063,
	WBEM_E_LOCAL_CREDENTIALS	= 0x80041064,
	WBEM_E_CANNOT_BE_ABSTRACT	= 0x80041065,
	WBEM_E_AMENDED_OBJECT	= 0x80041066,
	WBEM_E_CLIENT_TOO_SLOW	= 0x80041067,
	WBEM_E_NULL_SECURITY_DESCRIPTOR	= 0x80041068,
	WBEM_E_TIMED_OUT	= 0x80041069,
	WBEM_E_INVALID_ASSOCIATION	= 0x8004106a,
	WBEM_E_AMBIGUOUS_OPERATION	= 0x8004106b,
	WBEM_E_QUOTA_VIOLATION	= 0x8004106c,
	WBEM_E_RESERVED_001	= 0x8004106d,
	WBEM_E_RESERVED_002	= 0x8004106e,
	WBEM_E_UNSUPPORTED_LOCALE	= 0x8004106f,
	WBEM_E_HANDLE_OUT_OF_DATE	= 0x80041070,
	WBEM_E_CONNECTION_FAILED	= 0x80041071,
	WBEM_E_INVALID_HANDLE_REQUEST	= 0x80041072,
	WBEM_E_PROPERTY_NAME_TOO_WIDE	= 0x80041073,
	WBEM_E_CLASS_NAME_TOO_WIDE	= 0x80041074,
	WBEM_E_METHOD_NAME_TOO_WIDE	= 0x80041075,
	WBEM_E_QUALIFIER_NAME_TOO_WIDE	= 0x80041076,
	WBEM_E_RERUN_COMMAND	= 0x80041077,
	WBEM_E_DATABASE_VER_MISMATCH	= 0x80041078,
	WBEM_E_VETO_DELETE	= 0x80041079,
	WBEM_E_VETO_PUT	= 0x8004107a,
	WBEM_E_INVALID_LOCALE	= 0x80041080,
	WBEM_E_PROVIDER_SUSPENDED	= 0x80041081,
	WBEM_E_SYNCHRONIZATION_REQUIRED	= 0x80041082,
	WBEM_E_NO_SCHEMA	= 0x80041083,
	WBEM_E_PROVIDER_ALREADY_REGISTERED	= 0x80041084,
	WBEM_E_PROVIDER_NOT_REGISTERED	= 0x80041085,
	WBEM_E_FATAL_TRANSPORT_ERROR	= 0x80041086,
	WBEM_E_ENCRYPTED_CONNECTION_REQUIRED	= 0x80041087,
	WBEM_E_PROVIDER_TIMED_OUT	= 0x80041088,
	WBEM_E_NO_KEY	= 0x80041089,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80042001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= 0x80042002,
	WBEMMOF_E_EXPECTED_QUALIFIER_NAME	= 0x80044001,
	WBEMMOF_E_EXPECTED_SEMI	= 0x80044002,
	WBEMMOF_E_EXPECTED_OPEN_BRACE	= 0x80044003,
	WBEMMOF_E_EXPECTED_CLOSE_BRACE	= 0x80044004,
	WBEMMOF_E_EXPECTED_CLOSE_BRACKET	= 0x80044005,
	WBEMMOF_E_EXPECTED_CLOSE_PAREN	= 0x80044006,
	WBEMMOF_E_ILLEGAL_CONSTANT_VALUE	= 0x80044007,
	WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER	= 0x80044008,
	WBEMMOF_E_EXPECTED_OPEN_PAREN	= 0x80044009,
	WBEMMOF_E_UNRECOGNIZED_TOKEN	= 0x8004400a,
	WBEMMOF_E_UNRECOGNIZED_TYPE	= 0x8004400b,
	WBEMMOF_E_EXPECTED_PROPERTY_NAME	= 0x8004400c,
	WBEMMOF_E_TYPEDEF_NOT_SUPPORTED	= 0x8004400d,
	WBEMMOF_E_UNEXPECTED_ALIAS	= 0x8004400e,
	WBEMMOF_E_UNEXPECTED_ARRAY_INIT	= 0x8004400f,
	WBEMMOF_E_INVALID_AMENDMENT_SYNTAX	= 0x80044010,
	WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT	= 0x80044011,
	WBEMMOF_E_INVALID_PRAGMA	= 0x80044012,
	WBEMMOF_E_INVALID_NAMESPACE_SYNTAX	= 0x80044013,
	WBEMMOF_E_EXPECTED_CLASS_NAME	= 0x80044014,
	WBEMMOF_E_TYPE_MISMATCH	= 0x80044015,
	WBEMMOF_E_EXPECTED_ALIAS_NAME	= 0x80044016,
	WBEMMOF_E_INVALID_CLASS_DECLARATION	= 0x80044017,
	WBEMMOF_E_INVALID_INSTANCE_DECLARATION	= 0x80044018,
	WBEMMOF_E_EXPECTED_DOLLAR	= 0x80044019,
	WBEMMOF_E_CIMTYPE_QUALIFIER	= 0x8004401a,
	WBEMMOF_E_DUPLICATE_PROPERTY	= 0x8004401b,
	WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION	= 0x8004401c,
	WBEMMOF_E_OUT_OF_RANGE	= 0x8004401d,
	WBEMMOF_E_INVALID_FILE	= 0x8004401e,
	WBEMMOF_E_ALIASES_IN_EMBEDDED	= 0x8004401f,
	WBEMMOF_E_NULL_ARRAY_ELEM	= 0x80044020,
	WBEMMOF_E_DUPLICATE_QUALIFIER	= 0x80044021,
	WBEMMOF_E_EXPECTED_FLAVOR_TYPE	= 0x80044022,
	WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES	= 0x80044023,
	WBEMMOF_E_MULTIPLE_ALIASES	= 0x80044024,
	WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2	= 0x80044025,
	WBEMMOF_E_NO_ARRAYS_RETURNED	= 0x80044026,
	WBEMMOF_E_MUST_BE_IN_OR_OUT	= 0x80044027,
	WBEMMOF_E_INVALID_FLAGS_SYNTAX	= 0x80044028,
	WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE	= 0x80044029,
	WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE	= 0x8004402a,
	WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE	= 0x8004402b,
	WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX	= 0x8004402c,
	WBEMMOF_E_INVALID_QUALIFIER_SYNTAX	= 0x8004402d,
	WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE	= 0x8004402e,
	WBEMMOF_E_ERROR_CREATING_TEMP_FILE	= 0x8004402f,
	WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE	= 0x80044030,
	WBEMMOF_E_INVALID_DELETECLASS_SYNTAX	= 0x80044031
    } 	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/* interface IWbemClassObject */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject **ppCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ LPCWSTR strAncestor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemClassObject * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemClassObject * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemClassObject * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemClassObject_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemClassObject_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemClassObject_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemClassObject_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pVal,
    /* [in] */ CIMTYPE Type);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszQualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pQualifierVal,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *strName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszProperty,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemClassObject **ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject * This,
    /* [in] */ LPCWSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppInSignature,
    /* [out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pInSignature,
    /* [in] */ IWbemClassObject *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ IWbemClassObject **ppInSignature,
    /* [unique][in][out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethod,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethodName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/* interface IWbemObjectAccess */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemObjectAccess * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyHandle )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *ReadQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInfoByHandle )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemObjectAccess_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemObjectAccess_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemObjectAccess_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,wszPropertyName,pType,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,wszPropertyName,pType,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,aData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pType)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [string][in] */ LPCWSTR wszPropertyName,
    /* [out] */ CIMTYPE *pType,
    /* [out] */ long *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ const byte *aData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long *plNumBytes,
    /* [length_is][size_is][out] */ byte *aData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ unsigned __int64 *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ unsigned __int64 pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR *pstrName,
    /* [out] */ CIMTYPE *pType);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/* interface IWbemQualifierSet */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemQualifierSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemQualifierSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemQualifierSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemQualifierSet * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,wszName,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,wszName,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,wszName,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ VARIANT *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/* interface IWbemServices */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            IWbemServices * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAsyncCall )( 
            IWbemServices * This,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObjectSink )( 
            IWbemServices * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutClass )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutClassAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClass )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstance )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstance )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethod )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethodAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult **ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink **ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemClassObject **ppObject,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [unique][in][out] */ IWbemClassObject **ppOutParams,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/* interface IWbemLocator */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectServer )( 
            IWbemLocator * This,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator * This,
    /* [in] */ const BSTR strNetworkResource,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ const BSTR strAuthority,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/* interface IWbemObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemObjectSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemObjectSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject **apObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/* interface IEnumWbemClassObject */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *NextAsync )( 
            IEnumWbemClassObject * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWbemClassObject * This,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,apObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject * This,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/* interface IWbemCallResult */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultObject )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultString )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultServices )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject **ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices **ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ long *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/* interface IWbemContext */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext **ppNewCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemContext * This,
            /* [out] */ IWbemContext **ppNewCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemContext * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAll )( 
            IWbemContext * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,ppNewCopy)	\
    (This)->lpVtbl -> Clone(This,ppNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pstrName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,wszName,lFlags,pValue)

#define IWbemContext_GetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,wszName,lFlags,pValue)

#define IWbemContext_DeleteValue(This,wszName,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,wszName,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext * This,
    /* [out] */ IWbemContext **ppNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrName,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/* interface IUnsecuredApartment */
/* [object][uuid][restricted] */ 


EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUnsecuredApartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUnsecuredApartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUnsecuredApartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObjectStub )( 
            IUnsecuredApartment * This,
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment * This,
    /* [in] */ IUnknown *pObject,
    /* [out] */ IUnknown **ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifndef __IWbemStatusCodeText_INTERFACE_DEFINED__
#define __IWbemStatusCodeText_INTERFACE_DEFINED__

/* interface IWbemStatusCodeText */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemStatusCodeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eb87e1bc-3233-11d2-aec9-00c04fb68820")
    IWbemStatusCodeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFacilityCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemStatusCodeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemStatusCodeText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemStatusCodeText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemStatusCodeText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        HRESULT ( STDMETHODCALLTYPE *GetFacilityCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        END_INTERFACE
    } IWbemStatusCodeTextVtbl;

    interface IWbemStatusCodeText
    {
        CONST_VTBL struct IWbemStatusCodeTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemStatusCodeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemStatusCodeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemStatusCodeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemStatusCodeText_GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)

#define IWbemStatusCodeText_GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetErrorCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetErrorCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetFacilityCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetFacilityCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemStatusCodeText_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestore_INTERFACE_DEFINED__
#define __IWbemBackupRestore_INTERFACE_DEFINED__

/* interface IWbemBackupRestore */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C49E32C7-BC8B-11d2-85D4-00105A1F8304")
    IWbemBackupRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemBackupRestore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemBackupRestore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemBackupRestore * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemBackupRestoreVtbl;

    interface IWbemBackupRestore
    {
        CONST_VTBL struct IWbemBackupRestoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestore_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestore_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Backup_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strBackupToFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Restore_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strRestoreFromFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestore_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestoreEx_INTERFACE_DEFINED__
#define __IWbemBackupRestoreEx_INTERFACE_DEFINED__

/* interface IWbemBackupRestoreEx */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestoreEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A359DEC5-E813-4834-8A2A-BA7F1D777D76")
    IWbemBackupRestoreEx : public IWbemBackupRestore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemBackupRestoreEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemBackupRestoreEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemBackupRestoreEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IWbemBackupRestoreEx * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IWbemBackupRestoreEx * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWbemBackupRestoreEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IWbemBackupRestoreEx * This);
        
        END_INTERFACE
    } IWbemBackupRestoreExVtbl;

    interface IWbemBackupRestoreEx
    {
        CONST_VTBL struct IWbemBackupRestoreExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestoreEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestoreEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestoreEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestoreEx_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestoreEx_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)


#define IWbemBackupRestoreEx_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWbemBackupRestoreEx_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestoreEx_Pause_Proxy( 
    IWbemBackupRestoreEx * This);


void __RPC_STUB IWbemBackupRestoreEx_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestoreEx_Resume_Proxy( 
    IWbemBackupRestoreEx * This);


void __RPC_STUB IWbemBackupRestoreEx_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestoreEx_INTERFACE_DEFINED__ */


#ifndef __IWbemRefresher_INTERFACE_DEFINED__
#define __IWbemRefresher_INTERFACE_DEFINED__

/* interface IWbemRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c99-516b-11d1-aea6-00c04fb68820")
    IWbemRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWbemRefresher * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemRefresherVtbl;

    interface IWbemRefresher
    {
        CONST_VTBL struct IWbemRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRefresher_Refresh(This,lFlags)	\
    (This)->lpVtbl -> Refresh(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRefresher_Refresh_Proxy( 
    IWbemRefresher * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemRefresher_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemHiPerfEnum_INTERFACE_DEFINED__
#define __IWbemHiPerfEnum_INTERFACE_DEFINED__

/* interface IWbemHiPerfEnum */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemHiPerfEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2705C288-79AE-11d2-B348-00105A1F8177")
    IWbemHiPerfEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemHiPerfEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemHiPerfEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemHiPerfEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemHiPerfEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemHiPerfEnumVtbl;

    interface IWbemHiPerfEnum
    {
        CONST_VTBL struct IWbemHiPerfEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemHiPerfEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemHiPerfEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemHiPerfEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemHiPerfEnum_AddObjects(This,lFlags,uNumObjects,apIds,apObj)	\
    (This)->lpVtbl -> AddObjects(This,lFlags,uNumObjects,apIds,apObj)

#define IWbemHiPerfEnum_RemoveObjects(This,lFlags,uNumObjects,apIds)	\
    (This)->lpVtbl -> RemoveObjects(This,lFlags,uNumObjects,apIds)

#define IWbemHiPerfEnum_GetObjects(This,lFlags,uNumObjects,apObj,puReturned)	\
    (This)->lpVtbl -> GetObjects(This,lFlags,uNumObjects,apObj,puReturned)

#define IWbemHiPerfEnum_RemoveAll(This,lFlags)	\
    (This)->lpVtbl -> RemoveAll(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_AddObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds,
    /* [size_is][in] */ IWbemObjectAccess **apObj);


void __RPC_STUB IWbemHiPerfEnum_AddObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds);


void __RPC_STUB IWbemHiPerfEnum_RemoveObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_GetObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IWbemHiPerfEnum_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveAll_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemHiPerfEnum_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemHiPerfEnum_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigureRefresher_INTERFACE_DEFINED__
#define __IWbemConfigureRefresher_INTERFACE_DEFINED__

/* interface IWbemConfigureRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemConfigureRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c92-516b-11d1-aea6-00c04fb68820")
    IWbemConfigureRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjectByPath( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectByTemplate( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefresher( 
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConfigureRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConfigureRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConfigureRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByPath )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByTemplate )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddRefresher )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWbemConfigureRefresher * This,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnum )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId);
        
        END_INTERFACE
    } IWbemConfigureRefresherVtbl;

    interface IWbemConfigureRefresher
    {
        CONST_VTBL struct IWbemConfigureRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigureRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigureRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigureRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigureRefresher_AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddRefresher(This,pRefresher,lFlags,plId)	\
    (This)->lpVtbl -> AddRefresher(This,pRefresher,lFlags,plId)

#define IWbemConfigureRefresher_Remove(This,lId,lFlags)	\
    (This)->lpVtbl -> Remove(This,lId,lFlags)

#define IWbemConfigureRefresher_AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByPath_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByTemplate_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ IWbemClassObject *pTemplate,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddRefresher_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_Remove_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigureRefresher_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddEnum_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszClassName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemHiPerfEnum **ppEnum,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigureRefresher_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

EXTERN_C const CLSID CLSID_WbemContext;

#ifdef __cplusplus

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

EXTERN_C const CLSID CLSID_UnsecuredApartment;

#ifdef __cplusplus

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif

EXTERN_C const CLSID CLSID_WbemClassObject;

#ifdef __cplusplus

class DECLSPEC_UUID("9A653086-174F-11d2-B5F9-00104B703EFD")
WbemClassObject;
#endif

EXTERN_C const CLSID CLSID_MofCompiler;

#ifdef __cplusplus

class DECLSPEC_UUID("6daf9757-2e37-11d2-aec9-00c04fb68820")
MofCompiler;
#endif

EXTERN_C const CLSID CLSID_WbemStatusCodeText;

#ifdef __cplusplus

class DECLSPEC_UUID("eb87e1bd-3233-11d2-aec9-00c04fb68820")
WbemStatusCodeText;
#endif

EXTERN_C const CLSID CLSID_WbemBackupRestore;

#ifdef __cplusplus

class DECLSPEC_UUID("C49E32C6-BC8B-11d2-85D4-00105A1F8304")
WbemBackupRestore;
#endif

EXTERN_C const CLSID CLSID_WbemRefresher;

#ifdef __cplusplus

class DECLSPEC_UUID("c71566f2-561e-11d1-ad87-00c04fd8fdff")
WbemRefresher;
#endif

EXTERN_C const CLSID CLSID_WbemObjectTextSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("8D1C559D-84F0-4bb3-A7D5-56A7435A9BA6")
WbemObjectTextSrc;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wbemcli_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0109 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0109_v0_0_s_ifspec;

#ifndef __IWbemRawSdAccessor_INTERFACE_DEFINED__
#define __IWbemRawSdAccessor_INTERFACE_DEFINED__

/* interface IWbemRawSdAccessor */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemRawSdAccessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1e2d759-cabd-11d3-a11b-00105a1f515a")
    IWbemRawSdAccessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRawSdAccessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRawSdAccessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRawSdAccessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRawSdAccessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD);
        
        END_INTERFACE
    } IWbemRawSdAccessorVtbl;

    interface IWbemRawSdAccessor
    {
        CONST_VTBL struct IWbemRawSdAccessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRawSdAccessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRawSdAccessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRawSdAccessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRawSdAccessor_Get(This,lFlags,uBufSize,puSDSize,pSD)	\
    (This)->lpVtbl -> Get(This,lFlags,uBufSize,puSDSize,pSD)

#define IWbemRawSdAccessor_Put(This,lFlags,uBufSize,pSD)	\
    (This)->lpVtbl -> Put(This,lFlags,uBufSize,pSD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Get_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [out] */ ULONG *puSDSize,
    /* [length_is][size_is][out][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Put_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [size_is][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRawSdAccessor_INTERFACE_DEFINED__ */


#ifndef __IWbemShutdown_INTERFACE_DEFINED__
#define __IWbemShutdown_INTERFACE_DEFINED__

/* interface IWbemShutdown */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWbemShutdown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7b31df9-d515-11d3-a11c-00105a1f515a")
    IWbemShutdown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Shutdown( 
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemShutdownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemShutdown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemShutdown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemShutdown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IWbemShutdown * This,
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx);
        
        END_INTERFACE
    } IWbemShutdownVtbl;

    interface IWbemShutdown
    {
        CONST_VTBL struct IWbemShutdownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemShutdown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemShutdown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemShutdown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemShutdown_Shutdown(This,uReason,uMaxMilliseconds,pCtx)	\
    (This)->lpVtbl -> Shutdown(This,uReason,uMaxMilliseconds,pCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemShutdown_Shutdown_Proxy( 
    IWbemShutdown * This,
    /* [in] */ LONG uReason,
    /* [in] */ ULONG uMaxMilliseconds,
    /* [in] */ IWbemContext *pCtx);


void __RPC_STUB IWbemShutdown_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemShutdown_INTERFACE_DEFINED__ */


#ifndef __IWbemCallStatus_INTERFACE_DEFINED__
#define __IWbemCallStatus_INTERFACE_DEFINED__

/* interface IWbemCallStatus */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemCallStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4212dc47-142e-4c6c-bc49-6ca232dd0959")
    IWbemCallStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallStatus * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj);
        
        END_INTERFACE
    } IWbemCallStatusVtbl;

    interface IWbemCallStatus
    {
        CONST_VTBL struct IWbemCallStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallStatus_GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)	\
    (This)->lpVtbl -> GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallStatus_GetCallStatus_Proxy( 
    IWbemCallStatus * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ LCID lLocale,
    /* [out] */ HRESULT *phRes,
    /* [out] */ BSTR *pszMsg,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID *pObj);


void __RPC_STUB IWbemCallStatus_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0118 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WMI_OBJ_TEXT
    {	WMI_OBJ_TEXT_CIM_DTD_2_0	= 1,
	WMI_OBJ_TEXT_WMI_DTD_2_0	= 2,
	WMI_OBJ_TEXT_WMI_EXT1	= 3,
	WMI_OBJ_TEXT_WMI_EXT2	= 4,
	WMI_OBJ_TEXT_WMI_EXT3	= 5,
	WMI_OBJ_TEXT_WMI_EXT4	= 6,
	WMI_OBJ_TEXT_WMI_EXT5	= 7,
	WMI_OBJ_TEXT_WMI_EXT6	= 8,
	WMI_OBJ_TEXT_WMI_EXT7	= 9,
	WMI_OBJ_TEXT_WMI_EXT8	= 10,
	WMI_OBJ_TEXT_WMI_EXT9	= 11,
	WMI_OBJ_TEXT_WMI_EXT10	= 12,
	WMI_OBJ_TEXT_LAST	= 13
    } 	WMI_OBJ_TEXT;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0118_v0_0_s_ifspec;

#ifndef __IWbemObjectTextSrc_INTERFACE_DEFINED__
#define __IWbemObjectTextSrc_INTERFACE_DEFINED__

/* interface IWbemObjectTextSrc */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectTextSrc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfbf883a-cad7-11d3-a11b-00105a1f515a")
    IWbemObjectTextSrc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromText( 
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectTextSrcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectTextSrc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectTextSrc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectTextSrc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFromText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj);
        
        END_INTERFACE
    } IWbemObjectTextSrcVtbl;

    interface IWbemObjectTextSrc
    {
        CONST_VTBL struct IWbemObjectTextSrcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectTextSrc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectTextSrc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectTextSrc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectTextSrc_GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)	\
    (This)->lpVtbl -> GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)

#define IWbemObjectTextSrc_CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)	\
    (This)->lpVtbl -> CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_GetText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ BSTR *strText);


void __RPC_STUB IWbemObjectTextSrc_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_CreateFromText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ BSTR strText,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemClassObject **pNewObj);


void __RPC_STUB IWbemObjectTextSrc_CreateFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectTextSrc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0120 */
/* [local] */ 

typedef struct tag_CompileStatusInfo
    {
    long lPhaseError;
    HRESULT hRes;
    long ObjectNum;
    long FirstLine;
    long LastLine;
    DWORD dwOutFlags;
    } 	WBEM_COMPILE_STATUS_INFO;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPILER_OPTIONS
    {	WBEM_FLAG_CHECK_ONLY	= 0x1,
	WBEM_FLAG_AUTORECOVER	= 0x2,
	WBEM_FLAG_WMI_CHECK	= 0x4,
	WBEM_FLAG_CONSOLE_PRINT	= 0x8,
	WBEM_FLAG_DONT_ADD_TO_LIST	= 0x10,
	WBEM_FLAG_SPLIT_FILES	= 0x20,
	WBEM_FLAG_CONNECT_REPOSITORY_ONLY	= 0x40
    } 	WBEM_COMPILER_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0120_v0_0_s_ifspec;

#ifndef __IMofCompiler_INTERFACE_DEFINED__
#define __IMofCompiler_INTERFACE_DEFINED__

/* interface IMofCompiler */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IMofCompiler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6daf974e-2e37-11d2-aec9-00c04fb68820")
    IMofCompiler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMofCompilerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMofCompiler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMofCompiler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMofCompiler * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompileFile )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CompileBuffer )( 
            IMofCompiler * This,
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBMOF )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        END_INTERFACE
    } IMofCompilerVtbl;

    interface IMofCompiler
    {
        CONST_VTBL struct IMofCompilerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMofCompiler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMofCompiler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMofCompiler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMofCompiler_CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMofCompiler_CompileFile_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR FileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CompileBuffer_Proxy( 
    IMofCompiler * This,
    /* [in] */ long BuffSize,
    /* [size_is][in] */ BYTE *pBuffer,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CreateBMOF_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR TextFileName,
    /* [string][in] */ LPWSTR BMOFFileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CreateBMOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMofCompiler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0122 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_INFORMATION_FLAG_TYPE
    {	WBEM_FLAG_SHORT_NAME	= 0x1,
	WBEM_FLAG_LONG_NAME	= 0x2
    } 	WBEM_INFORMATION_FLAG_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0122_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\provider\tests\wlbsconfig.txt ===
//+----------------------------------------------------------------------------
//
// File:	 wlbsconfig.h
//
// Module:	 Network Load Balancing 
//
// Description: Internal APIs for cluster configuration.  Thes APIs are internal 
//              to WLBS team only, and no plan backward compatability.
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 fengsun Created    3/2/00
//
//+----------------------------------------------------------------------------



#ifndef _WLBSCONFIG_H
#define _WLBSCONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

#include "wlbsctrl.h"

/* Maximum lengths of parameter strings. */

#define WLBS_MAX_VIRTUAL_NIC     256
#define WLBS_MAX_CLUSTER_NIC     256
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_CL_IP_ADDR      17
#define WLBS_MAX_CL_NET_MASK     17
#define WLBS_MAX_DED_IP_ADDR     17 
#define WLBS_MAX_DED_NET_MASK    17
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_LICENSE_KEY     20
#define WLBS_MAX_DOMAIN_NAME     100
#define WLBS_MAX_BDA_TEAM_ID     40

/* Port group rule - used in registry parameters.
   NOTE! do not access value marked with I. These are for internal use only. */

#pragma pack(1)

typedef struct
{
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_OLD_PORT_RULE, * PWLBS_OLD_PORT_RULE;

/* Structure to hold the bi-directional affinity registry settings. */
typedef struct _CVY_BDA {
    WCHAR       team_id[WLBS_MAX_BDA_TEAM_ID + 1];  /* The team ID - MUST be a GUID. */
    ULONG       active;                             /* On write, this flag determines whether to create BDATeaming key - BDA on/off switch. */
    ULONG       master;                             /* Boolean indication of master status. */
    ULONG       reverse_hash;                       /* Sets direction of hashing - forward (normal) or reverse. */
} WLBS_BDA, PWLBS_BDA;

typedef struct
{
    TCHAR       virtual_ip_addr [WLBS_MAX_CL_IP_ADDR + 1]; /* Virtual IP Address */
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_PORT_RULE, * PWLBS_PORT_RULE;

#pragma pack()


#ifdef __cplusplus
typedef struct __declspec(dllexport)
#else
typedef struct 
#endif
{
    /* public - can be modified by clients of this API */
    DWORD       host_priority;          /* Host priority ID. */
    DWORD       alive_period;           /* Period for sending "I am alive" messages
                                           in milliseconds. */
    DWORD       alive_tolerance;        /* How many "I am alive" messages can be
                                           missed from other servers before assuming
                                           that the host is dead. */
    DWORD       num_actions;            /* Number of actions per allocation. */
    DWORD       num_packets;            /* number of packets per allocation. */
    DWORD       num_send_msgs;          /* Number of heartbeats per allocation. */
    DWORD       install_date;           /* Install time stamp, used to create a unique code for the host. */
    DWORD       rct_port;               /* Remote control UDP port. */
    DWORD       rct_enabled;            /* TRUE - remote control enabled. */
    DWORD       cluster_mode;           /* TRUE - join cluster on boot. */
    DWORD       dscr_per_alloc;         /* Number of connection tracking
                                           descriptor per allocation. */
    DWORD       max_dscr_allocs;        /* Maximum number of connection tracking
                                           descriptor allocations. */
    DWORD       mcast_support;          /* TRUE - multicast mode,
                                           FALSE - unicast mode */
    DWORD       mask_src_mac;           /* TRUE - Mangle source MAC address to
                                           prevent switch learning. FALSE -
                                           cluster is on a hub, optimizes switch
                                           performance by re-enabling learning. */

    TCHAR       cl_mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
                                        /* Cluster MAC address. */
    TCHAR       cl_ip_addr [WLBS_MAX_CL_IP_ADDR + 1];
                                        /* Cluster IP address. */
    TCHAR       cl_net_mask [WLBS_MAX_CL_NET_MASK + 1];
                                        /* Netmask for cluster IP. */
    TCHAR       ded_ip_addr [WLBS_MAX_DED_IP_ADDR + 1];
                                        /* Dedicated IP address or "" for none. */
    TCHAR       ded_net_mask [WLBS_MAX_DED_NET_MASK + 1];
                                        /* Netmask for dedicated IP address
                                           or "" for none */
    TCHAR       domain_name [WLBS_MAX_DOMAIN_NAME + 1];
                                        /* FQDN of the cluster. */

    //
    // IGMP support
    //
    BOOL        fIGMPSupport; // whether to send IGMP join periodically
    WCHAR       szMCastIpAddress[WLBS_MAX_CL_IP_ADDR + 1]; // multicast IP
    BOOL        fIpToMCastIp; // whether to generate multicast IP from cluster IP
    
    WLBS_BDA    bda_teaming;

#ifdef __cplusplus
#ifndef WLBSAPI_INTERNAL_ONLY

    //
    // private - should be treated as opaque 
    //
    // Do not change these field directly
    //
    private:

#endif
#endif


    /* obtained from the registry */

    DWORD       i_parms_ver;            /* I: Parameter structure version. */
    DWORD       i_verify_date;          /* I: Encoded install time stamp. */
    DWORD       i_rmt_password;         /* I: Remote maintenance password. */
    DWORD       i_rct_password;         /* I: Remote control password (use
                                            WlbsSetRemotePassword to set this
                                            value). */
    DWORD       i_num_rules;            /* I: # active port group rules (changed
                                            through WlbsAddPortRule and
                                            WlbsDelPortRule routines). */
    DWORD       i_cleanup_delay;        /* I: Dirty connection cleanup delay in
                                            milliseconds, 0 - delay. */
    DWORD       i_scale_client;         /* I: Legacy parameter. */
    DWORD       i_mcast_spoof;          /* I: TRUE - Provide ARP resolution in
                                            multicast mode. FALSE - clients
                                            will rely on static ARP entries. */
    DWORD       i_convert_mac;          /* I: TRUE - automatically generate MAC
                                            address based on cluster IP
                                            address in UI. */
    DWORD       i_ip_chg_delay;         /* I: Delay in milliseconds to block
                                            outgoing ARPs while IP address
                                            change is in process. */
    DWORD       i_nbt_support;          /* I: TRUE - NBT cluster name support
                                            enabled. */
    DWORD       i_netmon_alive;         /* I: TRUE - pass heartbeat messages
                                            to the protocols (netmon). */
    DWORD       i_effective_version;    /* I: Effective version of NLB */

    /* strings */

    TCHAR       i_virtual_nic_name [WLBS_MAX_VIRTUAL_NIC + 1];
                                        /* I: Virtual NIC name or GUID. */
//    TCHAR       cluster_nic_name [WLBS_MAX_CLUSTER_NIC + 1];
                                        /* I: Cluster NIC name or GUID. */
    TCHAR       i_license_key [WLBS_MAX_LICENSE_KEY + 1];
                                      /* I: Legacy parameter. */

    WLBS_PORT_RULE  i_port_rules [WLBS_MAX_RULES];
                                        /* I: Port rules (changed
                                              through WlbsAddPortRule and
                                              WlbsDelPortRule routines). */
    /* computed */

    DWORD       i_max_hosts;            /* Legacy parameter. */
    DWORD       i_max_rules;            /* Legacy parameter. */
//    DWORD       i_expiration;           /* Legacy parameter. */
//    DWORD       i_ft_rules_enabled;     /* Legacy parameter. */
//    DWORD       version;              /* Legacy parameter. */

    DWORD i_dwReserved;
}
WLBS_REG_PARAMS, * PWLBS_REG_PARAMS;



/* API commands for WlbsFormatMessage */
typedef enum
{
    CmdWlbsAddPortRule,
    CmdWlbsAddressToName,
    CmdWlbsAddressToString,
    CmdWlbsAdjust,
    CmdWlbsCommitChanges,
    CmdWlbsDeletePortRule,
    CmdWlbsDestinationSet,
    CmdWlbsDisable,
    CmdWlbsDrain,
    CmdWlbsDrainStop,
    CmdWlbsEnable,
    CmdWlbsFormatMessage,
    CmdWlbsGetEffectiveVersion,
    CmdWlbsGetNumPortRules,
    CmdWlbsEnumPortRules,
    CmdWlbsGetPortRule,
    CmdWlbsInit,
    CmdWlbsPasswordSet,
    CmdWlbsPortSet,
    CmdWlbsQuery,
    CmdWlbsReadReg,
    CmdWlbsResolve,
    CmdWlbsResume,
    CmdWlbsSetDefaults,
    CmdWlbsSetRemotePassword,
    CmdWlbsStart,
    CmdWlbsStop,
    CmdWlbsSuspend,
    CmdWlbsTimeoutSet,
    CmdWlbsWriteReg
}
WLBS_COMMAND;

extern BOOL WINAPI WlbsFormatMessage
(
    DWORD           error,      /* IN  - WLBS_... or WSA... return value. */
    WLBS_COMMAND    command,    /* IN  - Which routine returned the value. */
    BOOL            cluster,    /* IN  - TRUE - command was issued on entire
                                         cluster, FALSE - single host. */
    WCHAR*          messagep,   /* IN  - Pointer to user-allocated buffer. */
    PDWORD          lenp        /* IN  - Buffer size.
                                   OUT - The required buffer size if the current
                                         size is insufficient */
);
/*
    Return character string describing specified WLBS API return code. Note that
    message will depend on the command which returned the code and if it was
    issued in cluster-wide or single-host mode.

    returns:
        TRUE  => Message formatted successfully.
        FALSE => Bad error code (lenp will contain 0 on exit) or buffer is not
                 big enough to contain entire string (lenp will contain required
                 buffer size on exit).
*/

/* Support routines: */


extern DWORD WINAPI WlbsResolve
(
    const WCHAR*           address     /* IN  - Internet host name or IP address in
                                         dotted notation. */
);
/*
    Resolve Internet host name to its IP address. This routine can also be
    used to convert a string containing an IP address in dotted notation to a
    value that can be passed to cluster control routines.

    returns:
        0               => failed to resolve host name.
        <address>       => IP address corresponding to the specified address.
                           This value can be used in subsequent calls to
                           cluster control routines.
*/


extern BOOL WINAPI WlbsAddressToString
(
    DWORD           address,    /* IN  - IP address. */
    WCHAR*           buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Convert IP address to a string in dotted notation.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


extern BOOL WINAPI WlbsAddressToName
(
    DWORD    address,    /* IN  - IP address. */
    WCHAR*          buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Resolve IP address to Internet host name.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


/******************************************************************************
    Cluster host configuration routines. Note that in current implementation,
    cluster and host parameters need to be set to WLBS_LOCAL_CLUSTER and
    WLBS_LOCAL_HOST.
 ******************************************************************************/


extern DWORD WINAPI WlbsReadReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    PWLBS_REG_PARAMS reg_data   /* OUT - Registry parameters */
);
/*
    Read WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => reg_data is NULL
    WLBS_REG_ERROR   => Error reading from the registry

    Local:

    WLBS_OK          => Registry parameters successfully read.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsWriteReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_REG_ERROR   => Error accessing the registry.

    Local:

    WLBS_OK          => Registry parameters successfully written.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsCommitChanges
(
    DWORD           cluster    /* IN  - WLBS_LOCAL_CLUSTER */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.

    Local:

    WLBS_OK          => Changes have been successfully applied.
    WLBS_BAD_PARAMS  => Registry parameters were not accepted by the driver.
                        Reload was not performed
    WLBS_REBOOT      => Reboot required in order for config changes to
                        take effect.
    WLBS_IO_ERROR    => Error while writing to the driver.
    WLBS_REG_ERROR   => Error while trying to write MAC address changes to the
                        registry

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsSetDefaults
(
    PWLBS_REG_PARAMS       reg_data     /* OUT - Default values    */
);
/*
    Fills in the reg_data structure with default values

    returns:

    WLBS_INIT_ERROR    => Error initializing control module. Cannot perform
                          control operations.

    WLBS_BAD_PARAMS    => Invalid structure

    Local:

    WLBS_OK            => Structure was filled in with the default values.

    Remote:

    WLBS_LOCAL_ONLY    => This call is implemented for local only operation.

*/

/******************************************************************************
    Registry parameter manipulation routines. Note that these routines operate
    WLBS_REG_PARAMS structure filled out by calling WlbsReadReg. Some parameters
    can be manipulated directly. Please make sure to use manipulation routines
    for the ones that they are provided for.
 ******************************************************************************/

extern DWORD WINAPI WlbsGetEffectiveVersion
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns the effective version of cluster 

    returns:

    CVY_VERSION_FULL  => There is atleast one port rule that has a specific 
                         vip associated with it 
                        
    CVY_VERSION_LOWEST_CLIENT_FULL  => All port rules have the "All vip" associated with them

*/


extern DWORD WINAPI WlbsGetNumPortRules
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns number of port rules currently in the parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    1...WLBS_MAX_RULES

*/


extern DWORD WINAPI WlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    PWLBS_PORT_RULE rules,      /* OUT - Array of port rules. */
    PDWORD          num_rules   /* IN  - Size of rules array.
                                   OUT - Number of rules retrieved. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few rules that fit
                                         in the array are returned. */
);
/*
    Enumerate all port rules in the list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_TRUNCATED   => All port rules did not fit into specified array.
    WLBS_OK          => Rule has been successfully retrieved.

*/


extern DWORD WINAPI WlbsGetPortRule
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port,       /* IN  - Port, which rule to retrieve. */
    PWLBS_PORT_RULE rule        /* OUT - Port rule. */
);
/*
    Retrieve port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Rule has been successfully retrieved.
    WLBS_NOT_FOUND   => Port not found among port rules.

*/


extern DWORD WINAPI WlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const PWLBS_PORT_RULE rule        /* IN  - Port rule to add. */
);
/*
    Add port to list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                           control operations.
    WLBS_BAD_PARAMS     => Registry parameter structure is invalid.
    WLBS_OK             => Rule has been successfully added.
    WLBS_PORT_OVERLAP   => Port rule overlaps with existing port rule.
    WLBS_BAD_PORT_PARAMS=> Invalid port rule parameters.
    WLBS_MAX_PORT_RULES => Maximum number of port rules already reached.
*/


extern DWORD WINAPI WlbsDeletePortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port        /* IN  - Port, which rule to delete. */
);
/*
    Remove port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_NOT_FOUND   => Port not found among port rules.

    WLBS_OK          => Rule has been successfully deleted.

*/


extern DWORD WINAPI WlbsSetRemotePassword
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const WCHAR*           password   /* IN  - Password or NULL for no password. */
);
/*
    Set remote password code to encrypted value of the specified password.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Password has been successfully set.

*/

DWORD WINAPI WlbsNotifyConfigChange(DWORD cluster);


#ifdef __cplusplus
} /* extern "C" */
#endif


#endif _WLBSCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\ping.txt ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ping.c

Abstract:

    Packet INternet Groper utility for TCP/IP.

Author:

    Numerous TCP/IP folks.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    MohsinA,    21-Oct-96.  INADDR_NONE check to avoid broadcast.
    MohsinA,    13-Nov-96.  Max packet size < 64K.

Notes:

--*/

//:ts=4
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>

#include "llinfo.h"
#include "tcpcmd.h"
#include "ipexport.h"
#include "icmpapi.h"
#include "nlstxt.h"


#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 128
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             4000L
#define MIN_INTERVAL                1000L
#define STDOUT                      1

uchar   SendOptions[MAX_OPT_SIZE];

WSADATA WsaData;

struct IPErrorTable {
    IP_STATUS  Error;                   // The IP Error
    DWORD ErrorNlsID;                   // NLS string ID
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,         PING_BUF_TOO_SMALL},
    { IP_DEST_NET_UNREACHABLE,  PING_DEST_NET_UNREACHABLE},
    { IP_DEST_HOST_UNREACHABLE, PING_DEST_HOST_UNREACHABLE},
    { IP_DEST_PROT_UNREACHABLE, PING_DEST_PROT_UNREACHABLE},
    { IP_DEST_PORT_UNREACHABLE, PING_DEST_PORT_UNREACHABLE},
    { IP_NO_RESOURCES,          PING_NO_RESOURCES},
    { IP_BAD_OPTION,            PING_BAD_OPTION},
    { IP_HW_ERROR,              PING_HW_ERROR},
    { IP_PACKET_TOO_BIG,        PING_PACKET_TOO_BIG},
    { IP_REQ_TIMED_OUT,         PING_REQ_TIMED_OUT},
    { IP_BAD_REQ,               PING_BAD_REQ},
    { IP_BAD_ROUTE,             PING_BAD_ROUTE},
    { IP_TTL_EXPIRED_TRANSIT,   PING_TTL_EXPIRED_TRANSIT},
    { IP_TTL_EXPIRED_REASSEM,   PING_TTL_EXPIRED_REASSEM},
    { IP_PARAM_PROBLEM,         PING_PARAM_PROBLEM},
    { IP_SOURCE_QUENCH,         PING_SOURCE_QUENCH},
    { IP_OPTION_TOO_BIG,        PING_OPTION_TOO_BIG},
    { IP_BAD_DESTINATION,       PING_BAD_DESTINATION},
    { IP_NEGOTIATING_IPSEC,     PING_NEGOTIATING_IPSEC},
    { IP_GENERAL_FAILURE,       PING_GENERAL_FAILURE}
};


unsigned
NlsPutMsg(unsigned Handle, unsigned usMsgNum, ...)
{
    unsigned msglen;
    VOID * vp;
    va_list arglist;
    DWORD StrLen;

    va_start(arglist, usMsgNum);
    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 usMsgNum,
                                 0L,    // Default country ID.
                                 (LPTSTR)&vp,
                                 0,
                                 &arglist)))
        return(0);

    // Convert vp to oem
    StrLen=strlen(vp);
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,StrLen);

    msglen = _write(Handle, vp, StrLen);
    LocalFree(vp);

    return(msglen);
}

void
PrintUsage(void)
{
    NlsPutMsg( STDOUT, PING_USAGE );

//     printf(
//     "Usage: ping [-s size] [-c count] [-d] [-l TTL] [-o options] [-t TOS]\n"
//     "            [-w timeout] address.\n"
//     "Options:\n"
//     "    -t            Ping the specifed host until interrupted.\n"
//     "    -l size       Send buffer size.\n"
//     "    -n count      Send count.\n"
//     "    -f            Don't fragment.\n"
//     "    -i TTL        Time to live.\n"
//     "    -v TOS        Type of service\n"
//     "    -w timeout    Timeout (in milliseconds)\n"
//     "    -r routes     Record route.\n"
//     "    -s routes     Timestamp route.\n"
//     "    -j ipaddress  Loose source route.\n"
//     "    -k ipaddress  Strict source route.\n"
//     "    -o            IP options:\n"
//     "                      -ol hop list     Loose source route.\n"
//     "                      -ot              Timestamp.\n"
//     "                      -or              Record route\n"
//     );

}

// ========================================================================
// Caveat: return 0 for invalid, else internet address.
//         I would prefer -1 for error. - MohsinA, 21-Nov-96.

unsigned long
get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
    struct hostent *hostp = NULL;
    long            inaddr;

    if ( strcmp( ahstr, "255.255.255.255" ) == 0 ) {
        return(0L);
    }

    if ((inaddr = inet_addr(ahstr)) == -1L) {
        hostp = gethostbyname(ahstr);
        if (hostp) {
            /*
             * If we find a host entry, set up the internet address
             */
            inaddr = *(long *)hostp->h_addr;
            *was_inaddr = 0;
        } else {
            // Neither dotted, not name.
            return(0L);
        }

    } else {
        // Is dotted.
        *was_inaddr = 1;
        if (dnsreq == 1) {
            hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
        }
    }

    *hstr = hostp ? hostp->h_name : (char *)NULL;
    return(inaddr);
}

unsigned long
str2ip(char *addr, int *EndOffset)
{
    char    *endptr;
    char    *start = addr;
    int     i;                          // Counter variable.
    unsigned long curaddr = 0;
    unsigned long temp;
    struct hostent *hostp = NULL;

    for (i = 0; i < 4; i++) {
        temp = strtoul(addr, &endptr, 10);
        if (temp > 255)
            return 0L;
        if (endptr[0] != '.')
            if (i != 3)
                return 0L;
            else
                if (endptr[0] != '\0' && endptr[0] != ' ')
                return 0L;
        addr = endptr+1;
        curaddr = (curaddr << 8) + temp;
    }

    *EndOffset += (int)(endptr - start);
    return net_long(curaddr);
}

ulong
param(char **argv, int argc, int current, ulong min, ulong max)
{
    ulong   temp;
    char    *dummy;

    if (current == (argc - 1) ) {
        NlsPutMsg( STDOUT, PING_MESSAGE_1, argv[current] );
        // printf( "Value must be supplied for option %s.\n", argv[current]);
        exit(1);
    }

    temp = strtoul(argv[current+1], &dummy, 0);
    if (temp < min || temp > max) {
        NlsPutMsg( STDOUT, PING_MESSAGE_2, argv[current], min, max );
        // printf( "Bad value for option %s. range min..max\n",
        //         argv[current], min, max );
        exit(1);
    }

    return temp;
}

void
ProcessOptions(
    ICMP_ECHO_REPLY *reply,
    BOOLEAN          DoReverseLookup)
{
    UCHAR     *optionPtr;
    UCHAR     *endPtr;
    BOOLEAN    done = FALSE;
    UCHAR      optionLength;
    UCHAR      entryEndPtr;
    UCHAR      entryPtr;
    UCHAR      addressMode;
    int        entryCount = 0;


    optionPtr = reply->Options.OptionsData;
    endPtr = optionPtr + reply->Options.OptionsSize;

    while ((optionPtr < endPtr) && !done) {
        switch (*optionPtr) {
        case IP_OPT_EOL:
            done = TRUE;
            break;

        case IP_OPT_NOP:
            optionPtr++;
            break;

        case IP_OPT_SECURITY:
            optionPtr += 11;
            break;

        case IP_OPT_SID:
            optionPtr += 4;
            break;

        case IP_OPT_RR:
        case IP_OPT_LSRR:
        case IP_OPT_SSRR:
            if ((optionPtr + 3) > endPtr) {
                NlsPutMsg(STDOUT, PING_INVALID_RR_OPTION);
                done = TRUE;
                break;
            }

            optionLength = optionPtr[1];

            if (((optionPtr + optionLength) > endPtr) ||
                (optionLength < 3)
               ) {
                NlsPutMsg(STDOUT, PING_INVALID_RR_OPTION);
                done = TRUE;
                break;
            }

            entryEndPtr = optionPtr[2];

            if (entryEndPtr < 4) {
                NlsPutMsg(STDOUT, PING_INVALID_RR_OPTION);
                optionPtr += optionLength;
                break;
            }

            if (entryEndPtr > (optionLength + 1)) {
                entryEndPtr = optionLength + 1;
            }

            entryPtr = 4;
            entryCount = 0;

            NlsPutMsg(STDOUT, PING_ROUTE_HEADER1);

            while ((entryPtr + 3) < entryEndPtr) {
                struct in_addr  routeAddress;

                if (entryCount) {
                    NlsPutMsg(
                             STDOUT,
                             PING_ROUTE_SEPARATOR
                             );

                    if (entryCount == 1) {
                        NlsPutMsg(STDOUT, PING_CR);
                        NlsPutMsg(
                                 STDOUT,
                                 PING_ROUTE_HEADER2
                                 );
                        entryCount = 0;
                    }
                }

                entryCount++;

                routeAddress.S_un.S_addr =
                *( (IPAddr UNALIGNED *)
                   (optionPtr + entryPtr - 1)
                 );

                if (DoReverseLookup) {
                    struct hostent *hostEntry;

                    hostEntry = gethostbyaddr(
                                             (char *) &routeAddress,
                                             sizeof(routeAddress),
                                             AF_INET
                                             );

                    if (hostEntry != NULL) {
                        NlsPutMsg(
                                 STDOUT,
                                 PING_FULL_ROUTE_ENTRY,
                                 hostEntry->h_name,
                                 inet_ntoa(routeAddress)
                                 );
                    } else {
                        NlsPutMsg(
                                 STDOUT,
                                 PING_ROUTE_ENTRY,
                                 inet_ntoa(routeAddress)
                                 );
                    }
                } else {
                    NlsPutMsg(
                             STDOUT,
                             PING_ROUTE_ENTRY,
                             inet_ntoa(routeAddress)
                             );
                }

                entryPtr += 4;
            }

            NlsPutMsg(STDOUT, PING_CR);

            optionPtr += optionLength;
            break;

        case IP_OPT_TS:
            if ((optionPtr + 4) > endPtr) {
                NlsPutMsg(STDOUT, PING_INVALID_TS_OPTION);
                done = TRUE;
                break;
            }

            optionLength = optionPtr[1];
            entryEndPtr = optionPtr[2];

            if (entryEndPtr < 5) {
                NlsPutMsg(STDOUT, PING_INVALID_TS_OPTION);
                optionPtr += optionLength;
                break;
            }

            addressMode = optionPtr[3] & 1;

            if (entryEndPtr > (optionLength + 1)) {
                entryEndPtr = optionLength + 1;
            }

            entryPtr = 5;
            entryCount = 0;
            NlsPutMsg(STDOUT, PING_TS_HEADER1);

            while ((entryPtr + 3) < entryEndPtr) {
                struct in_addr  routeAddress;
                ULONG           timeStamp;

                if (entryCount) {
                    NlsPutMsg(
                             STDOUT,
                             PING_ROUTE_SEPARATOR
                             );

                    if (entryCount == 1) {
                        NlsPutMsg(STDOUT, PING_CR);
                        NlsPutMsg(STDOUT, PING_TS_HEADER2);
                        entryCount = 0;
                    }
                }

                entryCount++;

                if (addressMode) {
                    if ((entryPtr + 8) > entryEndPtr) {
                        break;
                    }

                    routeAddress.S_un.S_addr =
                    *( (IPAddr UNALIGNED *)
                       (optionPtr + entryPtr - 1)
                     );

                    if (DoReverseLookup) {
                        struct hostent *hostEntry;

                        hostEntry = gethostbyaddr(
                                                 (char *) &routeAddress,
                                                 sizeof(routeAddress),
                                                 AF_INET
                                                 );

                        if (hostEntry != NULL) {
                            NlsPutMsg(
                                     STDOUT,
                                     PING_FULL_TS_ADDRESS,
                                     hostEntry->h_name,
                                     inet_ntoa(routeAddress)
                                     );
                        } else {
                            NlsPutMsg(
                                     STDOUT,
                                     PING_TS_ADDRESS,
                                     inet_ntoa(routeAddress)
                                     );
                        }
                    } else {
                        NlsPutMsg(
                                 STDOUT,
                                 PING_TS_ADDRESS,
                                 inet_ntoa(routeAddress)
                                 );
                    }

                    entryPtr += 4;

                }

                timeStamp = *( (ULONG UNALIGNED *)
                               (optionPtr + entryPtr - 1)
                             );
                timeStamp = net_long(timeStamp);

                NlsPutMsg(
                         STDOUT,
                         PING_TS_TIMESTAMP,
                         timeStamp
                         );

                entryPtr += 4;
            }

            NlsPutMsg(STDOUT, PING_CR);

            optionPtr += optionLength;
            break;

        default:
            if ((optionPtr + 2) > endPtr) {
                done = TRUE;
                break;
            }

            optionPtr += optionPtr[1];
            break;
        }
    }
}

// ========================================================================
// MohsinA, 05-Dec-96.

IPAddr  address=0;                      // was local to main earlier.
uint    num_send=0, num_recv=0,
time_min=(uint)-1, time_max=0, time_total=0;

void
print_statistics(  )
{
    struct in_addr addr;

    if (num_send > 0) {
        addr.s_addr = address;

        if (time_min == (uint) -1) {  // all times were off.
            time_min = 0;
        }

        // printf
        //         "Ping statistics for %s:\n"
        //         "Packets: Sent=%ul, received=%ul, lost=%d (%u%% loss),\n"
        //         "Round trip times in milli-seconds: "
        //         "minimum=%dms, maximum=%dms, average=%dms\n" ....

        NlsPutMsg(STDOUT, PING_STATISTICS,
            inet_ntoa(addr),
            num_send, num_recv, num_send - num_recv,
            (uint) ( 100 * (num_send - num_recv) / num_send ));

        if (num_recv > 0) {
            NlsPutMsg(STDOUT, PING_STATISTICS2,
                 time_min, time_max, time_total / num_recv );
        }
    }
}

// ========================================================================
// MohsinA, 05-Dec-96.
// Press C-c to      print and abort.
// Press C-break to  print and continue.

BOOL
ConsoleControlHandler(DWORD dwCtrlType)
{
    print_statistics();
    switch ( dwCtrlType ) {
    case CTRL_BREAK_EVENT:
        NlsPutMsg( STDOUT, PING_BREAK );
        return TRUE;
        break;
    case CTRL_C_EVENT:
        NlsPutMsg( STDOUT, PING_INTERRUPT );
    default: break;
    }
    return FALSE;
}

uchar
GetDefaultTTL(void)
{
    HKEY registry=0;
    DWORD DefaultTTL=0;
    DWORD key_type;
    DWORD key_size = sizeof(DWORD);
    uchar TTL;
    DWORD Stat;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                     0,
                     KEY_QUERY_VALUE,
                     &registry) == ERROR_SUCCESS) {


        Stat=RegQueryValueEx(registry,
                             "DefaultTTL",
                             0,
                             &key_type,
                             (unsigned char *)&DefaultTTL,
                             &key_size);
    }
    if (DefaultTTL) {
        TTL = (unsigned char)DefaultTTL;
    } else {
        TTL = DEFAULT_TTL;
    }
    if (registry) {
        RegCloseKey(registry);
    }

    return TTL;
}

// ========================================================================

void
__cdecl
main(int argc, char **argv)
{
    char    *arg;
    uint    i;
    uint    j;
    int     found_addr = 0;
    int     dnsreq = 0;
    char    *hostname = NULL;
    int     was_inaddr;
    DWORD   numberOfReplies;
    uint    Count = DEFAULT_COUNT;
    uchar   TTL = 0;
    uchar   *Opt = NULL;                // Pointer to send options
    uint    OptLength = 0;
    int     OptIndex = 0;               // Current index into SendOptions
    int     SRIndex = -1;               // Where to put address, if source routing
    uchar   TOS = DEFAULT_TOS;
    uchar   Flags = 0;
    ulong   Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    int     EndOffset;
    ulong   TempAddr;
    uchar   TempCount;
    DWORD   errorCode;
    HANDLE  IcmpHandle;
    int     err;
    struct in_addr addr;
    BOOL    result;
    PICMP_ECHO_REPLY  reply;
    BOOL    sourceRouting = FALSE;
    char    *SendBuffer, *RcvBuffer;
    uint    RcvSize;
    uint    SendSize = DEFAULT_SEND_SIZE;

    // ====================================================================

    err = WSAStartup( 0x0101, &WsaData);

    if (err) {
        NlsPutMsg(STDOUT, PING_WSASTARTUP_FAILED, GetLastError());
        exit(1);
    }

    TTL = GetDefaultTTL();

    if (argc < 2) {
        PrintUsage();
        exit(1);
    } else {
        i = 1;
        while (i < (uint) argc) {
            arg = argv[i];
            if ( (arg[0] == '-') || (arg[0] == '/') ) {    // Have an option
                switch (arg[1]) {
                case '?':
                    PrintUsage();
                    exit(0);

                case 'l':
                    // SendSize = (uint)param(argv, argc, i++, 0, 0xfff7);
                    // A ping with packet size >= 64K can crash
                    // some tcpip stacks during re-assembly,
                    // So changed 'max' from 0xfff7 to 65500
                    // - MohsinA, 13-Nov-96.

                    SendSize = (uint)param(argv, argc, i++, 0, 65500 );
                    break;

                case 't':
                    Count = (uint)-1;
                    break;

                case 'n':
                    Count = (uint)param(argv, argc, i++, 1, 0xffffffff);
                    break;

                case 'f':
                    Flags = IP_FLAG_DF;
                    break;

                case 'i':
                    // TTL of zero is invalid, MohsinA, 13-Mar-97.
                    TTL = (uchar)param(argv, argc, i++, 1, 0xff);
                    break;

                case 'v':
                    TOS = (uchar)param(argv, argc, i++, 0, 0xff);
                    break;

                case 'w':
                    Timeout = param(argv, argc, i++, 0, 0xffffffff);
                    break;

                case 'a':
                    dnsreq = 1;
                    break;

                case 'r':               // Record Route
                    if ((OptIndex + 3) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        exit(1);
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_RR;
                    Opt[OptIndex + 2] = 4;    // Set initial pointer value
                    // min is 1 not zero, MohsinA, 16-4-97.
                    TempCount = (uchar)param(argv, argc, i++, 1, 9);
                    TempCount = (TempCount * sizeof(ulong)) + 3;

                    if ((TempCount + OptIndex) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        exit(1);
                    }

                    Opt[OptIndex+1] = TempCount;
                    OptLength += TempCount;
                    OptIndex += TempCount;
                    break;

                case 's':               // Timestamp
                    if ((OptIndex + 4) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        exit(1);
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_TS;
                    Opt[OptIndex + 2] = 5;    // Set initial pointer value
                    TempCount = (uchar)param(argv, argc, i++, 1, 4);
                    TempCount = (TempCount * (sizeof(ulong) * 2)) + 4;

                    if ((TempCount + OptIndex) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        exit(1);
                    }

                    Opt[OptIndex+1] = TempCount;
                    Opt[OptIndex+3] = 1;
                    OptLength += TempCount;
                    OptIndex += TempCount;
                    break;

                case 'j':               // Loose source routing

                    if (sourceRouting) {
                        NlsPutMsg(STDOUT, PING_BAD_OPTION_COMBO);
                        exit(1);
                    }

                    if ((OptIndex + 3) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        exit(1);
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_LSRR;
                    Opt[OptIndex+1] = 3;
                    Opt[OptIndex + 2] = 4;    // Set initial pointer value
                    OptLength += 3;
                    while ( (i < (uint)(argc - 2)) && (*argv[i+1] != '-')) {
                        if ((OptIndex + 3) > (MAX_OPT_SIZE - 4)) {
                            NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                            exit(1);
                        }

                        arg = argv[++i];
                        EndOffset = 0;
                        do {
                            TempAddr = str2ip(arg + EndOffset, &EndOffset);
                            if (!TempAddr) {
                                NlsPutMsg( STDOUT, PING_MESSAGE_4 );
                                // printf("Bad route specified for loose source route");
                                exit(1);
                            }
                            j = Opt[OptIndex+1];
                            *(ulong UNALIGNED *)&Opt[j+OptIndex] = TempAddr;
                            Opt[OptIndex+1] += 4;
                            OptLength += 4;
                            while (arg[EndOffset] != '\0' && isspace(arg[EndOffset]))
                                EndOffset++;
                        } while (arg[EndOffset] != '\0');
                    }
                    SRIndex = Opt[OptIndex+1] + OptIndex;
                    Opt[OptIndex+1] += 4;    // Save space for dest. addr
                    OptIndex += Opt[OptIndex+1];
                    OptLength += 4;
                    sourceRouting = TRUE;
                    break;

                case 'k':               // Strict source routing

                    if (sourceRouting) {
                        NlsPutMsg(STDOUT, PING_BAD_OPTION_COMBO);
                        exit(1);
                    }

                    if ((OptIndex + 3) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        exit(1);
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_SSRR;
                    Opt[OptIndex+1] = 3;
                    Opt[OptIndex + 2] = 4;    // Set initial pointer value
                    OptLength += 3;
                    while ( (i < (uint)(argc - 2)) && (*argv[i+1] != '-')) {
                        if ((OptIndex + 3) > (MAX_OPT_SIZE - 4)) {
                            NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                            exit(1);
                        }

                        arg = argv[++i];
                        EndOffset = 0;
                        do {
                            TempAddr = str2ip(arg + EndOffset, &EndOffset);
                            if (!TempAddr) {
                                NlsPutMsg( STDOUT, PING_MESSAGE_4 );
                                // printf("Bad route specified for loose source route");
                                exit(1);
                            }
                            j = Opt[OptIndex+1];
                            *(ulong UNALIGNED *)&Opt[j+OptIndex] = TempAddr;
                            Opt[OptIndex+1] += 4;
                            OptLength += 4;
                            while (arg[EndOffset] != '\0' && isspace(arg[EndOffset]))
                                EndOffset++;
                        } while (arg[EndOffset] != '\0');
                    }
                    SRIndex = Opt[OptIndex+1] + OptIndex;
                    Opt[OptIndex+1] += 4;    // Save space for dest. addr
                    OptIndex += Opt[OptIndex+1];
                    OptLength += 4;
                    sourceRouting = TRUE;
                    break;

                default:
                    NlsPutMsg( STDOUT, PING_MESSAGE_11, arg );
                    // printf( "Bad option %s.\n\n", arg);
                    PrintUsage();
                    exit(1);
                    break;
                }
                i++;
            } else {                    // Not an option, must be an IP address.
                if (found_addr) {
                    NlsPutMsg( STDOUT, PING_MESSAGE_12, arg );
                    // printf( "Bad parameter %s.\n", arg);
                    exit(1);
                }

                // Added check for INADDR_NONE, MohsinA, 21-Oct-96.

                address = get_pingee(arg, &hostname, &was_inaddr, dnsreq);
                if ( address && (address != INADDR_NONE) ) {
                    found_addr = 1;
                    i++;
                } else {
                    NlsPutMsg( STDOUT, PING_MESSAGE_13, arg );
                    // printf( "Bad IP address %s.\n", arg);
                    // "Unknown host %s.", was Bug 1368.
                    exit(1);
                }
            }
        }
    }

    if (!found_addr) {
        NlsPutMsg( STDOUT, PING_MESSAGE_14 );
        // printf("IP address must be specified.\n");
        exit(1);
    }

    if (SRIndex != -1) {
        *(ulong UNALIGNED *)&SendOptions[SRIndex] = address;
    }

    IcmpHandle = IcmpCreateFile();

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        NlsPutMsg( STDOUT, PING_MESSAGE_15, GetLastError() );

        // printf( "Unable to contact IP driver, error code %d.\n",
        //        GetLastError() );

        exit(1);
    }

    SendBuffer = LocalAlloc(LMEM_FIXED, SendSize);

    if (SendBuffer == NULL) {
        NlsPutMsg(STDOUT, PING_NO_MEMORY);
        exit(1);
    }

    //
    // Calculate receive buffer size and try to allocate it.
    //
    if (SendSize <= DEFAULT_SEND_SIZE) {
        RcvSize = DEFAULT_BUFFER_SIZE;
    } else {
        RcvSize = MAX_BUFFER_SIZE;
    }

    RcvBuffer = LocalAlloc(LMEM_FIXED, RcvSize);

    if (RcvBuffer == NULL) {
        NlsPutMsg(STDOUT, PING_NO_MEMORY);
        LocalFree(SendBuffer);
        exit(1);
    }

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = 'a' + (i % 23);
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (uchar)OptLength;
    SendOpts.Ttl = TTL;
    SendOpts.Tos = TOS;
    SendOpts.Flags = Flags;

    addr.s_addr = address;

    if (hostname) {
        NlsPutMsg(
                 STDOUT,
                 PING_HEADER1,
                 hostname,
                 inet_ntoa(addr),
                 SendSize
                 );
        // printf("Pinging Host %s [%s]\n", hostname, inet_ntoa(addr));
    } else {
        NlsPutMsg(
                 STDOUT,
                 PING_HEADER2,
                 inet_ntoa(addr),
                 SendSize
                 );
        // printf("Pinging Host [%s]\n", inet_ntoa(addr));
    }

    SetConsoleCtrlHandler( &ConsoleControlHandler, TRUE );

    for (i = 0; i < Count; i++) {
        numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        address,
                                        SendBuffer,
                                        (unsigned short) SendSize,
                                        &SendOpts,
                                        RcvBuffer,
                                        RcvSize,
                                        Timeout);

        num_send++;

        if (numberOfReplies == 0) {

            errorCode = GetLastError();

            if (errorCode < IP_STATUS_BASE) {
                NlsPutMsg( STDOUT, PING_MESSAGE_18, errorCode );
                // printf("PING: transmit failed, error code %lu\n", errorCode);
            } else {
                for (j = 0; ErrorTable[j].Error != errorCode &&
                    ErrorTable[j].Error != IP_GENERAL_FAILURE;j++)
                    ;

                NlsPutMsg( STDOUT, ErrorTable[j].ErrorNlsID );
                // printf("PING: %s.\n", ErrorTable[j].ErrorString);
            }

            if (i < (Count - 1)) {
                Sleep(MIN_INTERVAL);
            }

        } else {

            reply = (PICMP_ECHO_REPLY) RcvBuffer;

            while (numberOfReplies--) {
                struct in_addr addr;

                addr.S_un.S_addr = reply->Address;

                NlsPutMsg(STDOUT, PING_MESSAGE_19, inet_ntoa(addr));
                // printf(
                //     "Reply from %s:",
                //     inet_ntoa(addr),
                //         );

                if (reply->Status == IP_SUCCESS) {

                    NlsPutMsg( STDOUT, PING_MESSAGE_25, (int) reply->DataSize);
                    // printf(
                    //     "Echo size=%d ",
                    //         reply->DataSize
                    //         );

                    if (reply->DataSize != SendSize) {
                        NlsPutMsg( STDOUT, PING_MESSAGE_20, SendSize );
                        // printf("(sent %d) ", SendSize);
                    } else {
                        char *sendptr, *recvptr;

                        sendptr = &(SendBuffer[0]);
                        recvptr = (char *) reply->Data;

                        for (j = 0; j < SendSize; j++)
                            if (*sendptr++ != *recvptr++) {
                                NlsPutMsg( STDOUT, PING_MESSAGE_21, j );
                                // printf("- MISCOMPARE at offset %d - ", j);
                                break;
                            }
                    }

                    if (reply->RoundTripTime) {
                        NlsPutMsg( STDOUT, PING_MESSAGE_22, reply->RoundTripTime );
                        // Collect stats.

                        time_total += reply->RoundTripTime;
                        if ( reply->RoundTripTime < time_min ) {
                            time_min = reply->RoundTripTime;
                        }
                        if ( reply->RoundTripTime > time_max ) {
                            time_max = reply->RoundTripTime;
                        }

                    }

                    else {
                        NlsPutMsg( STDOUT, PING_MESSAGE_23 );
                        // printf("time<1ms ");

                        time_min = 0;
                    }


                    // printf("\n time rt=%dms min %d, max %d, total %d\n",
                    //        reply->RoundTripTime,
                    //        time_min, time_max, time_total );

                    NlsPutMsg( STDOUT, PING_MESSAGE_24, (uint)reply->Options.Ttl );
                    // printf("TTL=%u\n", (uint)reply->Options.Ttl);

                    if (reply->Options.OptionsSize) {
                        ProcessOptions(reply, (BOOLEAN) dnsreq);
                    }
                } else {
                    for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                        if (ErrorTable[j].Error == reply->Status) {
                            break;
                        }
                    }

                    NlsPutMsg( STDOUT, ErrorTable[j].ErrorNlsID);
                }

                num_recv++;
                reply++;
            }

            if (i < (Count - 1)) {
                reply--;

                if (reply->RoundTripTime < MIN_INTERVAL) {
                    Sleep(MIN_INTERVAL - reply->RoundTripTime);
                }
            }
        }
    }

    // MohsinA, 05-Dec-96. DCR # 65503.
    print_statistics();

    result = IcmpCloseHandle(IcmpHandle);

    LocalFree(SendBuffer);
    LocalFree(RcvBuffer);

    exit(0 == num_recv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\tmgr\notes.txt ===
3/17/01 JosephJ Stuff to do
    1. Define interfaces for async error reporting.

0. Make ConfigureAndBind take an out parameter which is a generation number.

Sequence of steps:
1. Check for connectivity using ping
2. Do WMI operation
3. Verify result


1 hour: review code, make notes.
Operation: Connect To Existing
    LeftView::OnWorldConnect 
         ClusterConnectPage::ClusterConnectPage
            CommonNLB::connectToClusterIndirect
                MNLBMachine::getClusterProperties
                    MwmiObject::getSpecificInstance
                        WMI core APIs


List of classes

LeftView.h (exe):class LeftView : public CTreeView, public DataSinkI
LeftView.cpp (exe):LeftView::LeftView()
LeftView.cpp (exe):LeftView::~LeftView()
LeftView.cpp (exe):LeftView::GetDocument()
LeftView.cpp (exe):LeftView::OnInitialUpdate()
LeftView.cpp (exe):LeftView::OnRButtonDown( UINT nFlags, CPoint point )
LeftView.cpp (exe):LeftView::OnWorldConnect()
LeftView.cpp (exe):LeftView::OnWorldNewCluster()
LeftView.cpp (exe):LeftView::OnClusterProperties()
LeftView.cpp (exe):LeftView::OnClusterManageVIPS()
LeftView.cpp (exe):LeftView::OnHostProperties()
LeftView.cpp (exe):LeftView::OnClusterRemove()
LeftView.cpp (exe):LeftView::OnClusterUnmanage()
LeftView.cpp (exe):LeftView::OnClusterAddHost()
LeftView.cpp (exe):LeftView::OnHostRemove()
LeftView.cpp (exe):LeftView::OnClusterControl( UINT nID )
LeftView.cpp (exe):LeftView::OnClusterPortControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostPortControl( UINT nID )
LeftView.cpp (exe):LeftView::dataSink( _bstr_t data )
LeftView.cpp (exe):LeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
LeftView.cpp (exe):LeftView::doesClusterExistInView( const _bstr_t& clusterToCheck )


Things should be greatly simplified:

UtilityFunctions:
    PingHost

HostInformation:
    Host.GetHostInformation(HostInfo)
            Machine name, dns name
            List of NICs and IPs bound to them

Configuration operations:
    Host.GetClusterConfiguration(NIC-Guid, &Config)
    Host.SetClusterConfiguration(NIC-Guid, Params, &RequestId) --> Async return
    Host.GetAsyncResult(RequestId, &ResultCode, &ResultStrings);

Management operations:
    Host.GetClusterState(NIC-Guid, &ClusterState)
    Host.SetClusterState(NIC-Guid, ClusterState)

Command-line arguments:
do -host: -nic: -config: -cmd:

To Do:
1. Host.Host("connection information");
2. Host.Ping();
3. Host.Connect();
3. Host.Disconnect();
4. Host.GetHostInfo
4. Host.Get/SetClusterConfiguration()


JosephJ 3/21/01
Search MSDN for "Idle Loop Processing" -- there is code there for
adding MFC-compatible message processing while doing blocking operations.

JosephJ 3/24/01  using namespace std, vectors.

To use the <vector> template as is you need the statement:
        using namespace std;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\utilities\tracing\readme.txt ===
Sample batch files for generating and viewing wmi event tracing logs

For information on WMI event tracing, goto  http://coreos/tech/tracing/

dolog.cmd           Enables a real-time log called "mylog" for the guids in
                    wlbs.ctl
dofmt.cmd           Monitors the above log in real time
wlbs.ctl            Lists the provider guids to log

Note: the underlying utilities, tracelog.exe and tracefmt.exe, and tracepdb.exe
are available
under the idw directory (eg \\winbuilds\release\main\usa\latest.idw\x86fre\bin\idw).
The sources for these utilities are under nt\sdktools\trace
You need to copy trace*.*, which includes a supporting dll.



I've created two trace GUIDs, one for regular (for configuration related info
and errors) and one for packets (for packets, including heartbeats).
We can add/modify this list as required, but I think this should suffice.

I've defined macros TRACE_CRIT (for critical, including most errors),
TRACE_INFO, TRACE_VERB and TRACE_ALL (max verbosity), as well as TRACE_HB
(for heartbeat) and TRACE_TCPCTRL (for tcp control packets).

The Guids are defined in \net\inc\wlbsparm.h. The macros are defined
in the tracewpp.ini file under each component directory.
 

I've added one or two trace statements to each instrumented component
you can now add more trace statements we should trace all key entry points,
errors, etc. I've deliberately not mapped existing debugprintfs to trace
statements as I want these trace statements to be enabled in retail builds
so we should take the time to decide what we want to trace.

 

Real output by console app tracefmt.exe:

[0]0000.0000::04/02/2001-06:17:21.537 [driver]Recv HB from host 0
     << this is a trace of an actual heart beat message from the specified
     <<  host. I'll add more info to this msg later.

[0]0000.0000::04/02/2001-06:17:22.537 [driver]Recv HB from host 0

[0]0670.06C4::04/02/2001-06:17:22.944 [api]->WlbsInit(product=<null>,version=51,reserved=00000000)

[0]0670.06C4::04/02/2001-06:17:23.131 [api]<-WlbsInit returns 1010

[0]0000.0000::04/02/2001-06:17:23.537 [driver]Recv HB from host 0

[0]0000.0000::04/02/2001-06:17:24.537 [driver]Recv HB from host 0

 

The above output has nicely merged the output from the driver and a user-mode
dll [api].

 

The wmi event tracing support added by means of the WPP macros are some
of the most bizarre and brilliant use of pre-processing I've ever seen!
You can see the final result for each source file by defining adding
USER_C_FLAGS=$(USER_C_FLAGS) -P to your sources file, resulting the
preprocessed files being created with an .i extension. It's amazing to see how
multiple trace flags spanning multiple GUIDs are handled.


NOTE: For tracing to nlb stuff in NETCFGX.DLL you need to specially build
    NETCFGX.DLL
Do the following
    cd  net\config\netcfg\dll
    sd edit sources
    add the following line to the end of the sources file:
    RUN_WPP= -dll
    build netcfgx.dll


There's been problems with tracefmt recognizing the auto-generated tmf files.
Until that's resolved, use tracepdb to generate these files from the
pdb files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\wmi2\readme.txt ===
TO BE DONE :
1. WLBS_PortRule.cpp : 
   EnumInstances() & GetInstance() has to be modified for supporting the new PortRuleEx class
   FillIwbemInstance() needs to fill in "FilteringMode"
2. WLBS_Node.cpp :
   Disallow operation on remote nodes in the new Ex methods
3. MOF File has to be modified to add the new methods and the new class
4. Some of the macros may have to be defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\microsoftnlb.xml ===
<?xml version="1.0"?>
<Schema xmlns="urn:schemas-microsoft-com:xml-data" xmlns:dt="urn:schemas-microsoft-com:datatypes">
<ElementType name="GUID" content="textOnly" dt:type="uuid"/>
<ElementType name="Name" content="textOnly" dt:type="string"/>
<ElementType name="Adapter" order="one" content="eltOnly" model="closed">
  <element type="GUID"/>
  <element type="Name"/>
</ElementType>
<ElementType name="Address" content="textOnly" dt:type="string"/>
<ElementType name="SubnetMask" content="textOnly" dt:type="string"/>
<ElementType name="IPAddress" order="seq" content="eltOnly" model="closed">
  <AttributeType name="Type" dt:type="enumeration" required="yes" dt:values="Primary Secondary IGMP Virtual Dedicated Connection"/>
  <attribute type="Type"/>
  <element type="Address" minOccurs="1" maxOccurs="1"/>
  <element type="SubnetMask" minOccurs = "0" maxOccurs="1"/>
  <element type="Adapter" minOccurs = "0" maxOccurs="1"/>
</ElementType>
<ElementType name="Mode" content="textOnly" dt:type="enumeration" dt:values="Unicast Multicast IGMP"/>
<ElementType name="NetworkAddress" content="textOnly" dt:type="string"/>
<ElementType name="DomainName" content="textOnly" dt:type="string"/>
<ElementType name="Password" content="textOnly" dt:type="string"/>
<ElementType name="RemoteControl" order="seq" content="eltOnly" model="closed">
  <AttributeType name="Enabled" dt:type="enumeration" required="yes" dt:values="Yes No"/>
  <attribute type="Enabled"/>
  <element type="Password" minOccurs="0" maxOccurs="1"/>
</ElementType>
<ElementType name="Properties" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="0" maxOccurs="*"/>
    <element type="DomainName" minOccurs="0" maxOccurs="1"/>
    <element type="Mode" minOccurs="0" maxOccurs="1"/>
    <element type="NetworkAddress" minOccurs="0" maxOccurs="1"/>
    <element type="RemoteControl" minOccurs="0" maxOccurs="1"/>
</ElementType>
<ElementType name="HostName" content="textOnly" dt:type="string"/>
<ElementType name="Host" order="seq" content="eltOnly" model="closed">
  <AttributeType name="Name" dt:type="id" required="yes"/>
  <AttributeType name="Text" dt:type="string" required="no"/>
  <AttributeType name="HostID" dt:type="int" required="yes"/>
  <AttributeType name="State" dt:type="enumeration" required="no" dt:values="Started Stopped Suspended"/>
  <attribute type="Name"/>	
  <attribute type="Text"/>
  <attribute type="HostID"/>
  <attribute type="State" default="Started"/>
  <element type="HostName" minOccurs="0" maxOccurs="1"/>
  <element type="Adapter" minOccurs="0" maxOccurs="1"/>
  <element type="IPAddress" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="Hosts" order="seq" content="eltOnly" model="closed">
  <element type="Host" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="Node" order="seq" content="empty" model="closed">
  <AttributeType name="Name" dt:type="idref" required="yes"/>
  <AttributeType name="Priority" dt:type="int" required="no"/>
  <AttributeType name="Weight" dt:type="int" required="no"/>
  <attribute type="Name"/>
  <attribute type="Priority" default="1"/>
  <attribute type="Weight" default="50"/>
</ElementType>
<ElementType name="Priority" order="seq" content="eltOnly" model="closed">
  <element type="Node" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="Load" order="seq" content="eltOnly" model="closed">
  <element type="Node" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="Filtering" order="seq" content="eltOnly" model="closed">
  <AttributeType name="Mode" dt:type="enumeration" required="no" dt:values="Single Multiple Disabled"/>
  <AttributeType name="Affinity" dt:type="enumeration" required="no" dt:values="None Single ClassC"/>
  <attribute type="Mode" default="Multiple"/>
  <attribute type="Affinity" default="Single"/>
  <group order="one" minOccurs="0" maxOccurs="1">
    <element type="Priority"/>
    <element type="Load"/>
  </group>
</ElementType>
<ElementType name="PortRule" order="seq" content="eltOnly" model="closed">
  <AttributeType name="Name" dt:type="id" required="yes"/>
  <AttributeType name="Text" dt:type="string" required="no"/>
  <AttributeType name="Start" dt:type="int" required="yes"/>
  <AttributeType name="End" dt:type="int" required="yes"/>
  <AttributeType name="Protocol" dt:type="enumeration" required="no" dt:values="TCP UDP Both"/>
  <AttributeType name="State" dt:type="enumeration" required="no" dt:values="Enabled Disabled Draining"/>
  <attribute type="Name"/>
  <attribute type="Text"/>
  <attribute type="Start"/>
  <attribute type="End"/>
  <attribute type="Protocol" default="Both"/>
  <attribute type="State" default="Enabled"/>
  <element type="IPAddress" minOccurs="0" maxOccurs="1"/>
  <element type="Filtering" minOccurs="0" maxOccurs="1"/>
</ElementType>
<ElementType name="PortRules" order="seq" content="eltOnly" model="closed">
  <element type="PortRule" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="Cluster" order="seq" content="eltOnly" model="closed">
  <AttributeType name="Name" dt:type="id" required="yes"/>
  <AttributeType name="Text" dt:type="string" required="no"/>
  <attribute type="Name"/>
  <attribute type="Text"/>
  <element type="Properties" minOccurs="0" maxOccurs="1"/>
  <element type="Hosts" minOccurs="0" maxOccurs="1"/>
  <element type="PortRules" minOccurs="0" maxOccurs="1"/>
</ElementType>
<ElementType name="NLB" content="eltOnly" model="closed">
  <element type="Cluster" minOccurs="1" maxOccurs="*"/>
</ElementType>
</Schema>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\xml\nlb-example.xml ===
<?xml version ="1.0"?>
<NLB xmlns="x-schema:MicrosoftNLB.xml">
  <Cluster Name="Microsoft.com" Text="My Favorite NLB Cluster">
    <Properties>
      <IPAddress Type="Primary">
        <Address>11.11.1.1</Address>
        <SubnetMask>255.0.0.0</SubnetMask>
      </IPAddress>
      <IPAddress Type="Secondary">
        <Address>11.11.1.4</Address>
        <SubnetMask>255.255.0.0</SubnetMask>
      </IPAddress>
      <IPAddress Type="Secondary">
        <Address>11.11.1.5</Address>
        <SubnetMask>255.255.0.0</SubnetMask>
      </IPAddress>
      <IPAddress Type="IGMP">
        <Address>239.255.202.134</Address>
      </IPAddress>
      <DomainName>www.microsoft.com</DomainName>
      <Mode>IGMP</Mode>
      <NetworkAddress>02-BF-0B-0B-01-01</NetworkAddress>
      <RemoteControl Enabled="Yes">
        <Password>PEZHead</Password>
      </RemoteControl>
    </Properties>
    <Hosts>
      <Host Name="Test2" HostID="21" Text="Bench 3, Seat 4" State="Suspended">
        <Adapter>
          <Name>Intel 10/100 Pro Server Adapter #2</Name>
        </Adapter>
        <IPAddress Type="Dedicated">
          <Address>192.12.6.132</Address>
          <SubnetMask>255.255.248.0</SubnetMask>
        </IPAddress>
      </Host>
      <Host Name="Test1" HostID="3" Text="The little host that could">
        <HostName>shouse-test1.corp.microsoft.com</HostName>
        <IPAddress Type="Dedicated">
          <Address>12.12.4.13</Address>
          <SubnetMask>255.0.0.0</SubnetMask>
        </IPAddress>
        <IPAddress Type="Connection">
          <Address>192.121.43.128</Address>
          <SubnetMask>255.255.0.0</SubnetMask>
          <Adapter>
            <GUID>f5460169-2e75-4e03-b9af-eef89bff1cca</GUID>
          </Adapter>
        </IPAddress>
      </Host>
    </Hosts>
  </Cluster>
  <Cluster Name="www.msn.com">
  </Cluster>
</NLB>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\coffbase.txt ===
;
; fax dlls
;

usermode    0x01000000  0x60000000
faxab32     0x64000000  0x000c0000
faxcfg      0x640c0000  0x000c0000
faxdrv      0x64200000  0x000c0000
faxext32    0x642c0000  0x000c0000
faxmon      0x64300000  0x000c0000
faxperf     0x643c0000  0x000c0000
faxt30      0x644c0000  0x000c0000
faxui       0x64500000  0x000c0000
faxwiz      0x645c0000  0x000c0000
faxxp32     0x64600000  0x000c0000
winfax      0x646c0000  0x000c0000
faxtiff     0x64700000  0x000c0000
faxmapi     0x647c0000  0x000c0000
faxroute    0x64800000  0x000c0000
faxevent    0x648c0000  0x000c0000
winfaxp     0x64900000  0x000c0000
faxcfgd     0x649c0000  0x000c0000
faxitg      0x64a00000  0x000c0000
faxcom      0x64ac0000  0x000c0000
faxisapi    0x64b00000  0x000c0000
faxxp32w    0x64bc0000  0x000c0000
faxab32w    0x64c00000  0x000c0000
faxocm      0x64cc0000  0x000c0000
faxadmin    0x64d00000  0x000c0000
fax         0x64dc0000  0x000c0000
routeext    0x64e00000  0x000c0000
fspext    0x64ec0000  0x000c0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\placefil.txt ===
;
; fax binaries
;

basenote.cov     retail
confdent.cov     retail
fax.cpl          retail
faxab32.dll      retail
faxab32w.dll     retail
faxadmin.dll     retail
faxadapt.lst     retail
faxadmin.dll     retail
faxcfg.cpl       retail
faxcfg.exe       retail
faxcfgd.dll      retail
faxcfgst.exe     retail
faxclnt.inf      retail
faxcom.dll       retail
faxcount.h       retail
faxcover.exe     retail
faxdrv.dll       retail
faxevent.dll     retail
faxext.ecf       retail
faxext32.dll     retail
faxisapi.dll     retail
faxmapi.dll      retail
faxmon.dll       retail
faxoc.inf        retail
faxocm.dll       retail
faxperf.dll      retail
faxperf.ini      retail
faxqueue.exe     retail
faxroute.dll     retail
faxsend.exe      retail
faxsetup.exe     retail
faxsetup.inf     retail
faxshell.dll     retail
faxstat.exe      retail
faxsvc.exe       retail
faxt30.dll       retail
faxtiff.dll      retail
faxui.dll        retail
faxwiz.dll       retail
faxxp32.dll      retail
faxxp32w.dll     retail
fyi.cov          retail
generic.cov      retail
layout.exe       retail
urgent.cov       retail
winfax.dll       retail
routeext.dll     retail
faxserv.msc      retail
fspext.dll       dump

; test binaries
faxrcv.dll       dump
faxvrfy.exe      dump
faxvrfy.cnt      dump
faxvrfy.hlp      dump
faxvrfy.ini      dump
faxbvt.tif       dump
faxwhql.tif      dump
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ddk\ddk_printscan.ini ===
; FORMAT : SourceDir, SourceFile, DestDir, DestFile, OPERATION
; All fields are required
; [subname]* is allowed for source, in which case * required for destination

print\drivers\usermode\ddk\bin                                    , makentf.exe , tools\print\x86                                   , *           , COPY
print\drivers\usermode\ddk\bin                                    , pgremlin.msi, tools\print\x86                                   , *           , COPY
print\drivers\usermode\ddk\mdt                                    , mdt.htm     , tools\print\x86                                   , mdt.htm     , HSPLIT
print\drivers\usermode\ddk\mdt                                    , minidev.cnt , tools\print\x86                                   , minidev.cnt , HSPLIT
print\drivers\usermode\ddk\mdt                                    , minidev.hlp , tools\print\x86                                   , minidev.hlp , COPY
print\drivers\usermode\ddk\mdt                                    , minidev.exe , tools\print\x86                                   , minidev.exe , COPY
print\drivers\usermode\ddk\mdt                                    , stdnames.gpd, tools\print\x86                                   , stdnames.gpd, HSPLIT
print\drivers\usermode\ddk\mdt                                    , tips.txt    , tools\print\x86                                   , tips.txt    , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL                         , *           , src\print\oemdll                                  , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\NT4                     , *           , src\print\oemdll\NT4                              , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\NT4\INC                 , *           , src\print\oemdll\NT4\INC                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMPS                   , *           , src\print\oemdll\oemps                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMPS\KMODE             , *           , src\print\oemdll\oemps\kmode                      , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMPS\UMODE             , *           , src\print\oemdll\oemps\umode                      , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUI                   , *           , src\print\oemdll\oemui                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUNI                  , *           , src\print\oemdll\oemuni                           , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUNI\KMODE            , *           , src\print\oemdll\oemuni\kmode                     , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUNI\UMODE            , *           , src\print\oemdll\oemuni\umode                     , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK               , *           , src\print\oemdll\watermark                        , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK\COMMON        , *           , src\print\oemdll\watermark\common                 , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK\wmarkps       , *           , src\print\oemdll\watermark\wmarkps                , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK\wmarkps\umode , *           , src\print\oemdll\watermark\wmarkps\umode          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\watermark\wmarkui       , *           , src\print\oemdll\watermark\wmarkui                , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\custhlp                 , *           , src\print\oemdll\custhlp                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\custhlp\customhelp      , *           , src\print\oemdll\custhlp\customhelp               , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\SyncSet                 , *           , src\print\oemdll\SyncSet                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\ThemeUI                 , *           , src\print\oemdll\ThemeUI                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\PSUIRep                 , *           , src\print\oemdll\PSUIRep                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\infs\driver5                   , *           , src\print\infs\driver5                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\infs\mfp                       , *           , src\print\infs\mfp                                , *           , HSPLIT
print\drivers\usermode\ddk\samples\mini\readme.htm                , * , src\print\mini\readme.htm                                   , *      , HSPLIT
print\drivers\usermode\ddk\samples\mini\mdw                       , * , src\print\mini\mdw                                          , *      , HSPLIT
;
; Mini samples
;
print\drivers\usermode\ddk\samples\mini\MDW                  ,README.HTM    ,src\print\mini                      , README.HTM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres         ,pcl5ems.MDW   ,src\print\mini\MDW\pcl5eres         , pcl5ems.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres         ,pcl5eres.htm  ,src\print\mini\MDW\pcl5eres         , pcl5eres.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hp1600c.GPD   ,src\print\mini\MDW\pcl5eres\w2k     , hp1600c.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hp4simx.GPD   ,src\print\mini\MDW\pcl5eres\w2k     , hp4simx.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hpclj.GPD     ,src\print\mini\MDW\pcl5eres\w2k     , hpclj.GPD     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hplj4.GPD     ,src\print\mini\MDW\pcl5eres\w2k     , hplj4.GPD     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hplj5.GPD     ,src\print\mini\MDW\pcl5eres\w2k     , hplj5.GPD     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,makefile      ,src\print\mini\MDW\pcl5eres\w2k     , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,OEMPRINT.INF  ,src\print\mini\MDW\pcl5eres\w2k     , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,pcl5ems.RC    ,src\print\mini\MDW\pcl5eres\w2k     , pcl5ems.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,pcl5eres.def  ,src\print\mini\MDW\pcl5eres\w2k     , pcl5eres.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,sources       ,src\print\mini\MDW\pcl5eres\w2k     , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,stdnames.gpd  ,src\print\mini\MDW\pcl5eres\w2k     , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,ttfsub.gpd    ,src\print\mini\MDW\pcl5eres\w2k     , ttfsub.gpd    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBERTR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBERTR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBERTX.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBERTX.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBRVILR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBRVILR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBRVILX.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBRVILX.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOAKLANB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOAKLANB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOAKLANI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOAKLANI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOAKLANR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOAKLANR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVEB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVEB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVECB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVECB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVEI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVEI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVER.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVER.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONIB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONIB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONII.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONII.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONIJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONIJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONIR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONIR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10X.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10X.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12X.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12X.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16B.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16I.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16I.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16R.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16R.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16X.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16X.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRSYMBOL.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRSYMBOL.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG06R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG06R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG11B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG11B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG11I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG11I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG11R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG11R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG14I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG14I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG14R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG14R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG18B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG18B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG24B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG24B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CLARCD.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CLARCD.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CLEVECD.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , CLEVECD.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG16Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG16Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CONNETIC.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CONNETIC.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COOPERBK.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COOPERBK.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CORONETR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CORONETR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CT10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CT10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CT14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CT14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBAT1.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBAT1.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBAT2.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBAT2.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBAT3.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBAT3.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBATS.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBATS.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBATV.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBATV.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HC24R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HC24R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKIB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKIB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKII.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKII.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKIJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKIJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKIR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKIR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HO24B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HO24B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG27Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG27Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LD121UMU.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LD121UMU.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LETGOTHB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LETGOTHB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LETGOTHI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LETGOTHI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LETGOTHR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LETGOTHR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG27Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG27Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP16Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP16Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG16R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG16R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG18R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG18R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG27R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG27R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP16Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP16Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP04R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP04R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP16R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP16R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,MARGOLDR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , MARGOLDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,MARYLNDR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , MARYLNDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OA10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , OA10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OB10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , OB10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR05B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR05B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR06B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR06B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR08B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR08B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,REVUER.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , REVUER.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SE24B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , SE24B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONX.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONX.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIEB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIEB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIEI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIEI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIEJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIEJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIER.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIER.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SYMBOL.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , SYMBOL.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNB.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNB.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNI.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNI.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNJ.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNJ.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNR.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNR.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN06R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN06R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN08B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN08B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN14R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN14R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN18R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN18R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN24R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN24R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHB.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHB.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHI.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHI.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHJ.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHJ.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHR.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHR.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,WDINGBAT.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , WDINGBAT.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,WINGDING.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , WINGDING.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Rd.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Rd.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HO24Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HO24Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV08Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV08Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV14Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV14Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV14Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV14Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG10Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG10Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Bc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Bc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ic.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ic.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rd.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rd.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Re.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Re.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rf.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rf.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Rd.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Rd.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR05Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR05Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR06Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR06Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR08Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR08Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SE24Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , SE24Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR08Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR08Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR08Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR08Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,DINGBAT1.GTT  ,src\print\mini\MDW\pcl5eres\w2k\gtt , DINGBAT1.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,DINGBAT2.GTT  ,src\print\mini\MDW\pcl5eres\w2k\gtt , DINGBAT2.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,ECMA94.GTT    ,src\print\mini\MDW\pcl5eres\w2k\gtt , ECMA94.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,GENERIC7.GTT  ,src\print\mini\MDW\pcl5eres\w2k\gtt , GENERIC7.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,MATH8.GTT     ,src\print\mini\MDW\pcl5eres\w2k\gtt , MATH8.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,ROMAN8.GTT    ,src\print\mini\MDW\pcl5eres\w2k\gtt , ROMAN8.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,USASCII.GTT   ,src\print\mini\MDW\pcl5eres\w2k\gtt , USASCII.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,WIN31.GTT     ,src\print\mini\MDW\pcl5eres\w2k\gtt , WIN31.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,WIN31A.GTT    ,src\print\mini\MDW\pcl5eres\w2k\gtt , WIN31A.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,WP.GTT        ,src\print\mini\MDW\pcl5eres\w2k\gtt , WP.GTT        ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,Z1A.GTT       ,src\print\mini\MDW\pcl5eres\w2k\gtt , Z1A.GTT       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,makefile     ,src\print\mini\MDW\pclxl            , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,pclxl.def    ,src\print\mini\MDW\pclxl            , pclxl.def     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,pclxl.rc     ,src\print\mini\MDW\pclxl            , pclxl.rc      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,sources      ,src\print\mini\MDW\pclxl            , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,DINGBAT1.GTT ,src\print\mini\MDW\pclxl\gtt        , DINGBAT1.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,DINGBAT2.GTT ,src\print\mini\MDW\pclxl\gtt        , DINGBAT2.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,ECMA94.GTT   ,src\print\mini\MDW\pclxl\gtt        , ECMA94.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,GENERIC7.GTT ,src\print\mini\MDW\pclxl\gtt        , GENERIC7.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,MATH8.GTT    ,src\print\mini\MDW\pclxl\gtt        , MATH8.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,ROMAN8.GTT   ,src\print\mini\MDW\pclxl\gtt        , ROMAN8.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,USASCII.GTT  ,src\print\mini\MDW\pclxl\gtt        , USASCII.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,WIN31.GTT    ,src\print\mini\MDW\pclxl\gtt        , WIN31.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,WIN31A.GTT   ,src\print\mini\MDW\pclxl\gtt        , WIN31A.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,WP.GTT       ,src\print\mini\MDW\pclxl\gtt        , WP.GTT        ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,Z1A.GTT      ,src\print\mini\MDW\pclxl\gtt        , Z1A.GTT       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ALBERTR.UFM  ,src\print\mini\MDW\pclxl\ufm        , ALBERTR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ALBERTX.UFM  ,src\print\mini\MDW\pclxl\ufm        , ALBERTX.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,AOLIVEB.UFM  ,src\print\mini\MDW\pclxl\ufm        , AOLIVEB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,AOLIVEI.UFM  ,src\print\mini\MDW\pclxl\ufm        , AOLIVEI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,AOLIVER.UFM  ,src\print\mini\MDW\pclxl\ufm        , AOLIVER.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALB.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALI.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALJ.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALR.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATB.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATI.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATJ.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATR.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANB.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANI.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANJ.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANR.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMB.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMI.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMJ.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMR.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAB.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAI.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAJ.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAR.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESB.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESI.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESJ.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESR.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CLARCD.UFM   ,src\print\mini\MDW\pclxl\ufm        , CLARCD.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CORONETR.UFM, src\print\mini\MDW\pclxl\ufm        , CORONETR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERB.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERI.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERJ.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERR.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDB.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDI.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDJ.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDR.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,LETGOTHB.UFM, src\print\mini\MDW\pclxl\ufm        , LETGOTHB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,LETGOTHI.UFM, src\print\mini\MDW\pclxl\ufm        , LETGOTHI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,LETGOTHR.UFM, src\print\mini\MDW\pclxl\ufm        , LETGOTHR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,MARGOLDR.UFM, src\print\mini\MDW\pclxl\ufm        , MARGOLDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,SYMBOL.UFM  , src\print\mini\MDW\pclxl\ufm        , SYMBOL.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRB.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRI.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRJ.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRR.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCB.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCI.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCJ.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCR.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSA.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSA.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSB.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSC.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSC.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSD.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSD.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSE.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSE.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSI.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSJ.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSR.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,WDINGBAT.UFM, src\print\mini\MDW\pclxl\ufm        , WDINGBAT.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,WINGDING.UFM, src\print\mini\MDW\pclxl\ufm        , WINGDING.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres          ,hpdjres.htm   ,src\print\mini\MDW\hpdjres          , hpdjres.htm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres          ,hpdjres.MDW   ,src\print\mini\MDW\hpdjres          , hpdjres.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdj400.GPD   ,src\print\mini\MDW\hpdjres\w2k      , hpdj400.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdj400m.GPD  ,src\print\mini\MDW\hpdjres\w2k      , hpdj400m.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,HPDJ600.GPD   ,src\print\mini\MDW\hpdjres\w2k      , HPDJ600.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,HPDJ600M.GPD  ,src\print\mini\MDW\hpdjres\w2k      , HPDJ600M.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdjres.def   ,src\print\mini\MDW\hpdjres\w2k      , hpdjres.def   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdskjet.RC   ,src\print\mini\MDW\hpdjres\w2k      , hpdskjet.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpoffjet.GPD  ,src\print\mini\MDW\hpdjres\w2k      , hpoffjet.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,makefile      ,src\print\mini\MDW\hpdjres\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,OEMPRINT.INF  ,src\print\mini\MDW\hpdjres\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,sources       ,src\print\mini\MDW\hpdjres\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,stdnames.gpd  ,src\print\mini\MDW\hpdjres\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA10.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA10.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA10I.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA10I.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA12.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA12.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA12I.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA12I.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA14.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA14.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA14I.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA14I.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA5.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA5.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA5I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA5I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA6.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA6.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA6I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA6I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA7.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA7.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA7I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA7I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA8.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA8.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA8I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA8I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BR120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BR120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BR180RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BR180RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BR240RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BR240RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM128.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM128.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM128I.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM128I.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM32.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM32.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM32I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM32I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM80.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM80.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM80I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM80I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms10.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms10i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms10i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS12.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms14.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms14.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms14i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms14i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms5.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms5.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms5i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms5i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS6.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS6.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS6I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS6I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms8.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms8.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms8i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms8i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CO120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CO120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COUR10.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH12.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH12.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH1B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH1B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH6.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH6.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH6B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH6B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM12.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM12.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM1B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM1B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM6.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM6.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM6B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM6B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV12.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV12.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV1B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV1B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV6.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV6.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV6B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV6B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS100BMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS100BMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC140RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC140RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC180RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC180RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC240RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC240RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA120BMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA120BMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA120IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA120IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA120RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA120RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA140BMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA140BMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA50IMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA50IMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA50RMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA50RMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA60BMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA60BMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA60IMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA60IMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA60RMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA60RMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA70BMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA70BMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV300RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV300RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG095RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG095RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG100RPP.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG100RPP.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG140RPN.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG140RPN.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PE070RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PE070RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PE100IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PE100IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PE100RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PE100RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR03_18B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR03_18B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR04_08B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR04_08B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR04_16B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR04_16B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR06_09B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR06_09B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR08_08B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR08_08B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR13_09B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR13_09B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR13_18B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR13_18B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR140RPB.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR140RPB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR160RPB.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR160RPB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR16_08B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR16_08B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR16_16B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR16_16B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR180RPB.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR180RPB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,tcourc12.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , tcourc12.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,tcourc6.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , tcourc6.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TM100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TM100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TM140RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TM140RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TN120IVP.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TN120IVP.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TN120RVP.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TN120RVP.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR300RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR300RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV128.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV128.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV128I.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV128I.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV32.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV32.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV32I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV32I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV80.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV80.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV80I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV80I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr10.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr10i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr10i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr12.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr12i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr12i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr14.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr14.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr5.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr5.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr5i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr5i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIVR6.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIVR6.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIVR6I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIVR6I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIVR7.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIVR7.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr8.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr8.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS12i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS12i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COUR10i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COUR10i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR16_16a.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR16_16a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,ECMA94.GTT     ,src\print\mini\MDW\hpdjres\w2k\gtt  , ECMA94.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,GENERIC7.GTT   ,src\print\mini\MDW\hpdjres\w2k\gtt  , GENERIC7.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,MATH8.GTT      ,src\print\mini\MDW\hpdjres\w2k\gtt  , MATH8.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,ROMAN8.GTT     ,src\print\mini\MDW\hpdjres\w2k\gtt  , ROMAN8.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,USASCII.GTT    ,src\print\mini\MDW\hpdjres\w2k\gtt  , USASCII.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res        ,escp2ms.MDW    ,src\print\mini\MDW\escp2res         , escp2ms.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res        ,escp2res.htm   ,src\print\mini\MDW\escp2res         , escp2res.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,epdq3000.GPD   ,src\print\mini\MDW\escp2res\w2k     , epdq3000.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,epdq3xxx.gpd   ,src\print\mini\MDW\escp2res\w2k     , epdq3xxx.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq1170.GPD   ,src\print\mini\MDW\escp2res\w2k     , eplq1170.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq2170.GPD   ,src\print\mini\MDW\escp2res\w2k     , eplq2170.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq300.GPD    ,src\print\mini\MDW\escp2res\w2k     , eplq300.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq670.gpd    ,src\print\mini\MDW\escp2res\w2k     , eplq670.gpd   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,escp2ms.RC     ,src\print\mini\MDW\escp2res\w2k     , escp2ms.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,makefile       ,src\print\mini\MDW\escp2res\w2k     , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,OEMPRINT.INF   ,src\print\mini\MDW\escp2res\w2k     , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,sources        ,src\print\mini\MDW\escp2res\w2k     , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,stdnames.gpd   ,src\print\mini\MDW\escp2res\w2k     , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,escp2eres.def  ,src\print\mini\MDW\escp2res\w2k     , escp2eres.def ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res          ,ep9res.htm     ,src\print\mini\MDW\ep9res           , ep9res.htm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res          ,epson9.MDW     ,src\print\mini\MDW\ep9res           , epson9.MDW    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,ep9res.def     ,src\print\mini\MDW\ep9res\w2k       , ep9res.def    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epcomp9.GPD    ,src\print\mini\MDW\ep9res\w2k       , epcomp9.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epd8000.GPD    ,src\print\mini\MDW\ep9res\w2k       , epd8000.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epfx2170.GPD   ,src\print\mini\MDW\ep9res\w2k       , epfx2170.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,eplx300.GPD    ,src\print\mini\MDW\ep9res\w2k       , eplx300.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epson9.RC      ,src\print\mini\MDW\ep9res\w2k       , epson9.RC     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epx1050p.GPD   ,src\print\mini\MDW\ep9res\w2k       , epx1050p.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,makefile       ,src\print\mini\MDW\ep9res\w2k       , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,OEMPRINT.INF   ,src\print\mini\MDW\ep9res\w2k       , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,sources        ,src\print\mini\MDW\ep9res\w2k       , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,stdnames.gpd   ,src\print\mini\MDW\ep9res\w2k       , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT05.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT06.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT10.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT12.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT15.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT17.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT17L.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT17L.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT20.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT20L.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT20L.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPS7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPS7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPSa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPSa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPX7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPX7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPX7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPX7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN05.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN057.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN057.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPXa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPXa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN05DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN05DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN06.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN067.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN067.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS10a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS10a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN06DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN06DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN10.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN107.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN107.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS12a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS12a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN10DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN10DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN12.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN127.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN127.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS17a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS17a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN12DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN12DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN15.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN17.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN177.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN177.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS20a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS20a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN20.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN207.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN207.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPS7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPS7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPX7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPX7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANIPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANIPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANIPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANIPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANIPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANIPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS05.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS05DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS05DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS06.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS06DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS06DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS10.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS10DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS10DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS12.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS12DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS12DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS15.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS17.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS20.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANSPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANSPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANSPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANSPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANSPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPS7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPS7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPSa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPSa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPX7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPX7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPXa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPXa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN057a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN057a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN057b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN057b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN05a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN05a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN067a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN067a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN067b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN067b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN06a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN06a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN107a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN107a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN107b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN107b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN10a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN10a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN127a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN127a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN127b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN127b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN12a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN12a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN177a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN177a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN177b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN177b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN17a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN17a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN20a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN20a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPS7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPS7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\gtt  ,epn_intl.GTT   ,src\print\mini\MDW\ep9res\w2k\gtt   , epn_intl.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\gtt  ,EPSONXTA.GTT   ,src\print\mini\MDW\ep9res\w2k\gtt   , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\gtt  ,no_intl.GTT    ,src\print\mini\MDW\ep9res\w2k\gtt   , no_intl.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res         ,ep24res.htm    ,src\print\mini\MDW\ep24res          , ep24res.htm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res         ,epson24.MDW    ,src\print\mini\MDW\ep24res          , epson24.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep1060p.GPD    ,src\print\mini\MDW\ep24res\w2k      , ep1060p.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep106x.gpd     ,src\print\mini\MDW\ep24res\w2k      , ep106x.gpd    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep2000.GPD     ,src\print\mini\MDW\ep24res\w2k      , ep2000.GPD    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep9res.def     ,src\print\mini\MDW\ep24res\w2k      , ep9res.def    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,epcomp24.GPD   ,src\print\mini\MDW\ep24res\w2k      , epcomp24.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,epl1050p.GPD   ,src\print\mini\MDW\ep24res\w2k      , epl1050p.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,epl105x.gpd    ,src\print\mini\MDW\ep24res\w2k      , epl105x.gpd   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,eplq560.GPD    ,src\print\mini\MDW\ep24res\w2k      , eplq560.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,EPSON24.RC     ,src\print\mini\MDW\ep24res\w2k      , EPSON24.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,OEMPRINT.INF   ,src\print\mini\MDW\ep24res\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,makefile       ,src\print\mini\MDW\ep24res\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,sources        ,src\print\mini\MDW\ep24res\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,stdnames.gpd   ,src\print\mini\MDW\ep24res\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR05.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR06.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR10.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR12.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR15.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR17.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR20.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,OCRA.UFM       ,src\print\mini\MDW\ep24res\w2k\ufm  , OCRA.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,OCRB.UFM       ,src\print\mini\MDW\ep24res\w2k\ufm  , OCRB.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ORATOR.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , ORATOR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ORATORS.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ORATORS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST05.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST06.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST10.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST12.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST15.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST17.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST20.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN05.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN06.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN10.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN12.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN15.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN17.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN20.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMANPS.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS05.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS06.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS10.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS12.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS15.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS17.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS20.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANSPS.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT05.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT05.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT06.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT06.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT10.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT10.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT12.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT12.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT15.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT15.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT17.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT17.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT20.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT20.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\gtt ,EPSONXTA.GTT   ,src\print\mini\MDW\ep24res\w2k\gtt  , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\gtt ,EPSONXTB.GTT   ,src\print\mini\MDW\ep24res\w2k\gtt  , EPSONXTB.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres        ,ecp2eres.htm   ,src\print\mini\MDW\ecp2eres         , ecp2eres.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres        ,escp2e.MDW     ,src\print\mini\MDW\ecp2eres         , escp2e.MDW    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ecp2eres.def   ,src\print\mini\MDW\ecp2eres\w2k     , ecp2eres.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep100sf.GPD    ,src\print\mini\MDW\ecp2eres\w2k     , ep100sf.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep1070sf.GPD   ,src\print\mini\MDW\ecp2eres\w2k     , ep1070sf.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep1170sf.GPD   ,src\print\mini\MDW\ecp2eres\w2k     , ep1170sf.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep570sf.GPD    ,src\print\mini\MDW\ecp2eres\w2k     , ep570sf.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,eps1170s.GPD   ,src\print\mini\MDW\ecp2eres\w2k     , eps1170s.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,escp2e.RC      ,src\print\mini\MDW\ecp2eres\w2k     , escp2e.RC     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,makefile       ,src\print\mini\MDW\ecp2eres\w2k     , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,OEMPRINT.INF   ,src\print\mini\MDW\ecp2eres\w2k     , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,sources        ,src\print\mini\MDW\ecp2eres\w2k     , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,stdnames.gpd   ,src\print\mini\MDW\ecp2eres\w2k     , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR05.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR06.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR10.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR12.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR15.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR17.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR20.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro08ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro08ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro10ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro10ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro12ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro12ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro14ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro14ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro16ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro16ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro18ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro18ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro20ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro20ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro22ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro22ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro24ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro24ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro26ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro26ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro28ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro28ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro30ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro30ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro32ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro32ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss08ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpss08ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss10ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss10ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss12ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss12ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss14ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss14ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss16ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss16ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss18ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss18ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss20ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss20ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss22ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss22ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss24ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss24ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss26ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss26ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss28ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss28ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss30ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss30ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss32ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss32ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,OCRB10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , OCRB10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ORAS10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ORAS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ORAT10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ORAT10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST05.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST06.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST10.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST12.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST17.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST20.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMANPS.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN05.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN06.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN12.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN15.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN17.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN20.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS05.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS06.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS12.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS15.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS17.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS20.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANSPS.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRC10PS.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRC10PS.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI05.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI06.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI12.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI17.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI20.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\gtt ,CP850EX.GTT  ,src\print\mini\MDW\ecp2eres\w2k\gtt  , CP850EX.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v         ,canon10v.MDW ,src\print\mini\MDW\canon10v          , canon10v.MDW  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v         ,canon10v.htm ,src\print\mini\MDW\canon10v          , canon10v.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,canon10v.def ,src\print\mini\MDW\canon10v\w2k      , canon10v.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CANON10V.RC  ,src\print\mini\MDW\canon10v\w2k      , CANON10V.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VCJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN10VCJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VJ.GPD   ,src\print\mini\MDW\canon10v\w2k      , CN10VJ.GPD    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VLJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN10VLJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VSJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN10VSJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN15VJ.GPD   ,src\print\mini\MDW\canon10v\w2k      , CN15VJ.GPD    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN15VPJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN15VPJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,makefile     ,src\print\mini\MDW\canon10v\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,OEMPRINT.INF ,src\print\mini\MDW\canon10v\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,sources      ,src\print\mini\MDW\canon10v\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,stdnames.gpd ,src\print\mini\MDW\canon10v\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR05.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR06.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR10.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR12.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR15.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COURPS.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COURPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth05.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth06.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth10.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth12.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth15.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,GOTHIC.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , GOTHIC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,GOTHIC2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , GOTHIC2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,gothps.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , gothps.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,gyosho.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , gyosho.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,gyosho2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , gyosho2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,kaisho.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , kaisho.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,kaisho2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , kaisho2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MINCHO.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , MINCHO.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MINCHO2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , MINCHO2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MOHITSU.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , MOHITSU.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MOHITSU2.UFM ,src\print\mini\MDW\canon10v\w2k\ufm  , MOHITSU2.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc         ,escp24sc.MDW ,src\print\mini\MDW\escp24sc          , escp24sc.MDW  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc         ,escp24sc.htm ,src\print\mini\MDW\escp24sc          , escp24sc.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,EPLQ16KC.GPD ,src\print\mini\MDW\escp24sc\w2k      , EPLQ16KC.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,escp24sc.def ,src\print\mini\MDW\escp24sc\w2k      , escp24sc.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,ESCP24SC.RC  ,src\print\mini\MDW\escp24sc\w2k      , ESCP24SC.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,makefile     ,src\print\mini\MDW\escp24sc\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,OEMPRINT.INF ,src\print\mini\MDW\escp24sc\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,sources      ,src\print\mini\MDW\escp24sc\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,stdnames.gpd ,src\print\mini\MDW\escp24sc\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN05.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN06.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN10.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN12.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN17.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN20.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMANPS.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,rotate.UFM   ,src\print\mini\MDW\escp24sc\w2k\ufm  , rotate.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sng1nh.UFM   ,src\print\mini\MDW\escp24sc\w2k\ufm  , sng1nh.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sng2nh.UFM   ,src\print\mini\MDW\escp24sc\w2k\ufm  , sng2nh.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sng3d.ufm    ,src\print\mini\MDW\escp24sc\w2k\ufm  , sng3d.ufm     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sngkong.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , sngkong.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sngyin.ufm   ,src\print\mini\MDW\escp24sc\w2k\ufm  , sngyin.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\gtt ,EPSONXTA.GTT ,src\print\mini\MDW\escp24sc\w2k\gtt  , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc         ,ESCP24TC.MDW ,src\print\mini\MDW\escp24tc          , ESCP24TC.MDW  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc         ,escp24tc.htm ,src\print\mini\MDW\escp24tc          , escp24tc.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,EPLQ207T.GPD ,src\print\mini\MDW\escp24tc\w2k      , EPLQ207T.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,EPLQ217T.GPD ,src\print\mini\MDW\escp24tc\w2k      , EPLQ217T.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,EPLQ67T.GPD  ,src\print\mini\MDW\escp24tc\w2k      , EPLQ67T.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,escp24tc.def ,src\print\mini\MDW\escp24tc\w2k      , escp24tc.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,escp24tc.RC  ,src\print\mini\MDW\escp24tc\w2k      , escp24tc.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,makefile     ,src\print\mini\MDW\escp24tc\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,OEMPRINT.INF ,src\print\mini\MDW\escp24tc\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,sources      ,src\print\mini\MDW\escp24tc\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,stdnames.gpd ,src\print\mini\MDW\escp24tc\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,OCRA.UFM     ,src\print\mini\MDW\escp24tc\w2k\ufm  , OCRA.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,OCRB.UFM     ,src\print\mini\MDW\escp24tc\w2k\ufm  , OCRB.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ORATOR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , ORATOR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ORATORS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ORATORS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN05.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN06.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN10.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN12.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN15.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN17.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN20.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMANPS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS05.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS06.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS10.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS12.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS15.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS17.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS20.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANSPS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\gtt ,EPSONXTA.GTT ,src\print\mini\MDW\escp24tc\w2k\gtt  , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201          ,pcpr201.MDW  ,src\print\mini\MDW\pcpr201           , pcpr201.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201          ,pcpr201.htm  ,src\print\mini\MDW\pcpr201           , pcpr201.htm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,makefile     ,src\print\mini\MDW\pcpr201\w2k       , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,NC2180AJ.GPD ,src\print\mini\MDW\pcpr201\w2k       , NC2180AJ.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,pcpr201.def  ,src\print\mini\MDW\pcpr201\w2k       , pcpr201.def   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,PCPR201.RC   ,src\print\mini\MDW\pcpr201\w2k       , PCPR201.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,OEMPRINT.INF ,src\print\mini\MDW\pcpr201\w2k       , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,sources      ,src\print\mini\MDW\pcpr201\w2k       , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,stdnames.gpd ,src\print\mini\MDW\pcpr201\w2k       , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO10.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO10.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO12.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO12.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO17.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO17.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO5.UFM      ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO5.UFM       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO6.UFM      ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO6.UFM       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO8.UFM      ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO8.UFM       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,go_oR.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , go_oR.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,go_R.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , go_R.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,mi.UFM       ,src\print\mini\MDW\pcpr201\w2k\ufm   , mi.UFM        ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,mi_o.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , mi_o.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,mi_R.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , mi_R.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN10.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN12.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN17.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN5.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN5.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN6.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN6.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN8.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN8.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMANPS.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS10.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS12.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS17.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS5.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS5.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS6.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS6.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS8.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS8.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANSPS.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vgo_boR.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vgo_boR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vgo_bR.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vgo_bR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vmi_b.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vmi_b.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vmi_bo.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vmi_bo.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vmi_bR.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vmi_bR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\gtt  ,necxta.gtt   ,src\print\mini\MDW\pcpr201\w2k\gtt   , necxta.gtt    ,COPY
print\drivers\usermode\msplot                         , *           , src\print\msplot                                  , *           , HSPLIT
print\drivers\usermode\msplot\hlp                     , plotui.hlp  , src\print\msplot                                  , plotui.hlp  , COPY
print\drivers\usermode\msplot\inc                     , *.h         , src\print\msplot\inc                              , *           , HSPLIT
print\drivers\usermode\msplot\inf                     , plotter.inf , src\print\msplot                                  , plotter.inf , COPY
print\drivers\usermode\msplot\lib                     , *           , src\print\msplot\lib                              , *           , HSPLIT
print\drivers\usermode\msplot\lib\km                  , *           , src\print\msplot\lib\km                           , *           , HSPLIT
print\drivers\usermode\msplot\lib\um                  , *           , src\print\msplot\lib\um                           , *           , HSPLIT
print\drivers\usermode\msplot\mini                    , *           , src\print\msplot\mini                             , *           , HSPLIT
print\drivers\usermode\msplot\mini\hp20022                        , hp20022.pcd , src\print\msplot\mini\hp20022                     , hp20022.pcd , COPY
print\drivers\usermode\msplot\mini\hp20022                        , hp20022.txt , src\print\msplot\mini\hp20022                     , hp20022.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp20036                        , hp20036.pcd , src\print\msplot\mini\hp20036                     , hp20036.pcd , COPY
print\drivers\usermode\msplot\mini\hp20036                        , hp20036.txt , src\print\msplot\mini\hp20036                     , hp20036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp22024                        , hp22024.pcd , src\print\msplot\mini\hp22024                     , hp22024.pcd , COPY
print\drivers\usermode\msplot\mini\hp22024                        , hp22024.txt , src\print\msplot\mini\hp22024                     , hp22024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp22036                        , hp22036.pcd , src\print\msplot\mini\hp22036                     , hp22036.pcd , COPY
print\drivers\usermode\msplot\mini\hp22036                        , hp22036.txt , src\print\msplot\mini\hp22036                     , hp22036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp23024                        , hp23024.pcd , src\print\msplot\mini\hp23024                     , hp23024.pcd , COPY
print\drivers\usermode\msplot\mini\hp23024                        , hp23024.txt , src\print\msplot\mini\hp23024                     , hp23024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp23036                        , hp23036.pcd , src\print\msplot\mini\hp23036                     , hp23036.pcd , COPY
print\drivers\usermode\msplot\mini\hp23036                        , hp23036.txt , src\print\msplot\mini\hp23036                     , hp23036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp25024                        , hp25024.pcd , src\print\msplot\mini\hp25024                     , hp25024.pcd , COPY
print\drivers\usermode\msplot\mini\hp25024                        , hp25024.txt , src\print\msplot\mini\hp25024                     , hp25024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp25036                        , hp25036.pcd , src\print\msplot\mini\hp25036                     , hp25036.pcd , COPY
print\drivers\usermode\msplot\mini\hp25036                        , hp25036.txt , src\print\msplot\mini\hp25036                     , hp25036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp33024                        , hp33024.pcd , src\print\msplot\mini\hp33024                     , hp33024.pcd , COPY
print\drivers\usermode\msplot\mini\hp33024                        , hp33024.txt , src\print\msplot\mini\hp33024                     , hp33024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp33036                        , hp33036.pcd , src\print\msplot\mini\hp33036                     , hp33036.pcd , COPY
print\drivers\usermode\msplot\mini\hp33036                        , hp33036.txt , src\print\msplot\mini\hp33036                     , hp33036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp35024                        , hp35024.pcd , src\print\msplot\mini\hp35024                     , hp35024.pcd , COPY
print\drivers\usermode\msplot\mini\hp35024                        , hp35024.txt , src\print\msplot\mini\hp35024                     , hp35024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp35036                        , hp35036.pcd , src\print\msplot\mini\hp35036                     , hp35036.pcd , COPY
print\drivers\usermode\msplot\mini\hp35036                        , hp35036.txt , src\print\msplot\mini\hp35036                     , hp35036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp60022                        , hp60022.pcd , src\print\msplot\mini\hp60022                     , hp60022.pcd , COPY
print\drivers\usermode\msplot\mini\hp60022                        , hp60022.txt , src\print\msplot\mini\hp60022                     , hp60022.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp60036                        , hp60036.pcd , src\print\msplot\mini\hp60036                     , hp60036.pcd , COPY
print\drivers\usermode\msplot\mini\hp60036                        , hp60036.txt , src\print\msplot\mini\hp60036                     , hp60036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp650c22                       , hp650c22.pcd, src\print\msplot\mini\hp650c22                    , hp650c22.pcd, COPY
print\drivers\usermode\msplot\mini\hp650c22                       , hp650c22.txt, src\print\msplot\mini\hp650c22                    , hp650c22.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp650c36                       , hp650c36.pcd, src\print\msplot\mini\hp650c36                    , hp650c36.pcd, COPY
print\drivers\usermode\msplot\mini\hp650c36                       , hp650c36.txt, src\print\msplot\mini\hp650c36                    , hp650c36.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp75024                        , hp75024.pcd , src\print\msplot\mini\hp75024                     , hp75024.pcd , COPY
print\drivers\usermode\msplot\mini\hp75024                        , hp75024.txt , src\print\msplot\mini\hp75024                     , hp75024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp75036                        , hp75036.pcd , src\print\msplot\mini\hp75036                     , hp75036.pcd , COPY
print\drivers\usermode\msplot\mini\hp75036                        , hp75036.txt , src\print\msplot\mini\hp75036                     , hp75036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp750m24                       , hp750m24.pcd, src\print\msplot\mini\hp750m24                    , hp750m24.pcd, COPY
print\drivers\usermode\msplot\mini\hp750m24                       , hp750m24.txt, src\print\msplot\mini\hp750m24                    , hp750m24.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp750m36                       , hp750m36.pcd, src\print\msplot\mini\hp750m36                    , hp750m36.pcd, COPY
print\drivers\usermode\msplot\mini\hp750m36                       , hp750m36.txt, src\print\msplot\mini\hp750m36                    , hp750m36.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp7550pl                       , hp7550pl.pcd, src\print\msplot\mini\hp7550pl                    , hp7550pl.pcd, COPY
print\drivers\usermode\msplot\mini\hp7550pl                       , hp7550pl.txt, src\print\msplot\mini\hp7550pl                    , hp7550pl.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp755cm                        , hp755cm.pcd , src\print\msplot\mini\hp755cm                     , hp755cm.pcd , COPY
print\drivers\usermode\msplot\mini\hp755cm                        , hp755cm.txt , src\print\msplot\mini\hp755cm                     , hp755cm.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp755cmm                       , hp755cmm.pcd, src\print\msplot\mini\hp755cmm                    , hp755cmm.pcd, COPY
print\drivers\usermode\msplot\mini\hp755cmm                       , hp755cmm.txt, src\print\msplot\mini\hp755cmm                    , hp755cmm.txt, HSPLIT
print\drivers\usermode\msplot\mini\hpdesign                       , hpdesign.pcd, src\print\msplot\mini\hpdesign                    , hpdesign.pcd, COPY
print\drivers\usermode\msplot\mini\hpdesign                       , hpdesign.txt, src\print\msplot\mini\hpdesign                    , hpdesign.txt, HSPLIT
print\drivers\usermode\msplot\mini\hpdmrxmx                       , hpdmrxmx.pcd, src\print\msplot\mini\hpdmrxmx                    , hpdmrxmx.pcd, COPY
print\drivers\usermode\msplot\mini\hpdmrxmx                       , hpdmrxmx.txt, src\print\msplot\mini\hpdmrxmx                    , hpdmrxmx.txt, HSPLIT
print\drivers\usermode\msplot\mini\hpdmsx                         , hpdmsx.pcd  , src\print\msplot\mini\hpdmsx                      , hpdmsx.pcd  , COPY
print\drivers\usermode\msplot\mini\hpdmsx                         , hpdmsx.txt  , src\print\msplot\mini\hpdmsx                      , hpdmsx.txt  , HSPLIT
print\drivers\usermode\msplot\mini\hpdpp22                        , hpdpp22.pcd , src\print\msplot\mini\hpdpp22                     , hpdpp22.pcd , COPY
print\drivers\usermode\msplot\mini\hpdpp22                        , hpdpp22.txt , src\print\msplot\mini\hpdpp22                     , hpdpp22.txt , HSPLIT
print\drivers\usermode\msplot\mini\hpdpp36                        , hpdpp36.pcd , src\print\msplot\mini\hpdpp36                     , hpdpp36.pcd , COPY
print\drivers\usermode\msplot\mini\hpdpp36                        , hpdpp36.txt , src\print\msplot\mini\hpdpp36                     , hpdpp36.txt , HSPLIT
print\drivers\usermode\msplot\mini\hpgl2pen                       , hpgl2pen.pcd, src\print\msplot\mini\hpgl2pen                    , hpgl2pen.pcd, COPY
print\drivers\usermode\msplot\mini\hpgl2pen                       , hpgl2pen.txt, src\print\msplot\mini\hpgl2pen                    , hpgl2pen.txt, HSPLIT
print\drivers\usermode\msplot\plotter                             , *           , src\print\msplot\plotter                          , *           , HSPLIT
print\drivers\usermode\msplot\plotui                              , *           , src\print\msplot\plotui                           , *           , HSPLIT
print\drivers\usermode\msplot\plotui\icons                        , *           , src\print\msplot\plotui\icons                     , *           , HSPLIT
print\drivers\usermode\msplot\tools                               , *           , src\print\msplot\tools                            , *           , HSPLIT
print\drivers\usermode\msplot\tools\ntres                         , *           , src\print\msplot\tools\ntres                      , *           , HSPLIT
print\drivers\usermode\tools\ps\makentf\cjkafm                    , psfamily.dat, tools\print                                       , *           , COPY
print\drivers\usermode\tools\ps\makentf\cjkafm                    , *.map, tools\print                                              , *           , COPY
print\drivers\usermode\tools\ps\makentf\cjkafm                    , *.ps, tools\print                                               , *           , COPY
ui\compstui\sample                                                , *           , src\print\cpsuisam                                , *           , HSPLIT
ui\compstui\sample\icons                                          , apple.ico   , src\print\cpsuisam\icons                          , apple.ico   , COPY
ui\compstui\sample\icons                                          , cpsuisam.ico, src\print\cpsuisam\icons                          , cpsuisam.ico, COPY
print\spooler\monitors\local                                      , *           , src\print\monitors\localmon                       , *           , HSPLIT
print\spooler\monitors\localui                                    , *           , src\print\monitors\localui                        , *           , HSPLIT
print\spooler\monitors\pjlmon                                     , *           , src\print\monitors\pjlmon                         , *           , HSPLIT
print\spooler\prtprocs\winprint                                   , emf.c       , src\print\genprint                                , emf.c       , HSPLIT
print\spooler\prtprocs\winprint                                   , genprint.htm, src\print\genprint                                , genprint.htm, HSPLIT
print\spooler\prtprocs\winprint                                   , local.c     , src\print\genprint                                , local.c     , HSPLIT
print\spooler\prtprocs\winprint                                   , local.h     , src\print\genprint                                , local.h     , HSPLIT
print\spooler\prtprocs\winprint                                   , makefile    , src\print\genprint                                , makefile    , HSPLIT
print\spooler\prtprocs\winprint                                   , parsparm.c  , src\print\genprint                                , parsparm.c  , HSPLIT
print\spooler\prtprocs\winprint                                   , raw.c       , src\print\genprint                                , raw.c       , HSPLIT
print\spooler\prtprocs\winprint                                   , sources     , src\print\genprint                                , sources     , HSPLIT
print\spooler\prtprocs\winprint                                   , support.c   , src\print\genprint                                , support.c   , HSPLIT
print\spooler\prtprocs\winprint                                   , text.c      , src\print\genprint                                , text.c      , HSPLIT
print\spooler\prtprocs\winprint                                   , util.c      , src\print\genprint                                , util.c      , HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.c  , src\print\genprint                                , winprint.c  , HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.def, src\print\genprint                                , winprint.def, HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.h  , src\print\genprint                                , winprint.h  , HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.prf, src\print\genprint                                , winprint.prf, HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.rc , src\print\genprint                                , winprint.rc , HSPLIT
print\spooler\test\inet\qview                                     , *           , src\print\queueASP                                , *           , HSPLIT
print\spooler\test\pp                                             , makefile    , src\print\pp                                      , makefile    , HSPLIT
print\spooler\test\pp                                             , port.c      , src\print\pp                                      , port.c      , HSPLIT
print\spooler\test\pp                                             , pp.c        , src\print\pp                                      , pp.c        , HSPLIT
print\spooler\test\pp                                             , pp.def      , src\print\pp                                      , pp.def      , HSPLIT
print\spooler\test\pp                                             , pp.h        , src\print\pp                                      , pp.h        , HSPLIT
print\spooler\test\pp                                             , pp.htm      , src\print\pp                                      , pp.htm      , HSPLIT
print\spooler\test\pp                                             , sources     , src\print\pp                                      , sources     , HSPLIT

; TTY Samples

print\drivers\usermode\oemdrv\tty  ,tty.htm     ,src\print\tty  , tty.htm    ,COPY
print\drivers\usermode\oemdrv\tty  ,tty.gpd     ,src\print\tty  , tty.gpd    ,COPY
print\drivers\usermode\oemdrv\tty  ,tty.inf     ,src\print\tty  , tty.inf    ,COPY
print\drivers\usermode\oemdrv\tty  ,tty.ini     ,src\print\tty  , tty.ini    ,COPY
print\drivers\usermode\oemdrv\tty  ,ttyui.hlp   ,src\print\tty  , ttyui.hlp    ,COPY

print\drivers\usermode\oemdrv\tty\ufm  ,10cpib.UFM   ,src\print\tty\ufm  , 10cpib.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,12cpib.UFM   ,src\print\tty\ufm  , 12cpib.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,17cpib.UFM   ,src\print\tty\ufm  , 17cpib.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_437.UFM   ,src\print\tty\ufm  , df10_437.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_437.UFM   ,src\print\tty\ufm  , df12_437.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_437.UFM   ,src\print\tty\ufm  , df17_437.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_850.UFM   ,src\print\tty\ufm  , df10_850.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_850.UFM   ,src\print\tty\ufm  , df12_850.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_850.UFM   ,src\print\tty\ufm  , df17_850.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_852.UFM   ,src\print\tty\ufm  , df10_852.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_852.UFM   ,src\print\tty\ufm  , df12_852.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_852.UFM   ,src\print\tty\ufm  , df17_852.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_857.UFM   ,src\print\tty\ufm  , df10_857.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_857.UFM   ,src\print\tty\ufm  , df12_857.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_857.UFM   ,src\print\tty\ufm  , df17_857.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_863.UFM   ,src\print\tty\ufm  , df10_863.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_863.UFM   ,src\print\tty\ufm  , df12_863.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_863.UFM   ,src\print\tty\ufm  , df17_863.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_932.UFM   ,src\print\tty\ufm  , df10_932.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_932.UFM   ,src\print\tty\ufm  , df12_932.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_932.UFM   ,src\print\tty\ufm  , df17_932.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_936.UFM   ,src\print\tty\ufm  , df10_936.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_936.UFM   ,src\print\tty\ufm  , df12_936.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_936.UFM   ,src\print\tty\ufm  , df17_936.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_949.UFM   ,src\print\tty\ufm  , df10_949.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_949.UFM   ,src\print\tty\ufm  , df12_949.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_949.UFM   ,src\print\tty\ufm  , df17_949.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_950.UFM   ,src\print\tty\ufm  , df10_950.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_950.UFM   ,src\print\tty\ufm  , df12_950.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_950.UFM   ,src\print\tty\ufm  , df17_950.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1250.UFM   ,src\print\tty\ufm  , df10_1250.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1250.UFM   ,src\print\tty\ufm  , df12_1250.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1250.UFM   ,src\print\tty\ufm  , df17_1250.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1251.UFM   ,src\print\tty\ufm  , df10_1251.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1251.UFM   ,src\print\tty\ufm  , df12_1251.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1251.UFM   ,src\print\tty\ufm  , df17_1251.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1252.UFM   ,src\print\tty\ufm  , df10_1252.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1252.UFM   ,src\print\tty\ufm  , df12_1252.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1252.UFM   ,src\print\tty\ufm  , df17_1252.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1253.UFM   ,src\print\tty\ufm  , df10_1253.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1253.UFM   ,src\print\tty\ufm  , df12_1253.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1253.UFM   ,src\print\tty\ufm  , df17_1253.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1254.UFM   ,src\print\tty\ufm  , df10_1254.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1254.UFM   ,src\print\tty\ufm  , df12_1254.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1254.UFM   ,src\print\tty\ufm  , df17_1254.UFM    ,COPY

print\drivers\usermode\oemdrv\tty\gtt  ,850.GTT    ,src\print\tty\gtt  , 850.GTT     ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,852.GTT    ,src\print\tty\gtt  , 852.GTT     ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,857.GTT    ,src\print\tty\gtt  , 857.GTT     ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1250.GTT   ,src\print\tty\gtt  , 1250.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1251.GTT   ,src\print\tty\gtt  , 1251.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1252.GTT   ,src\print\tty\gtt  , 1252.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1253.GTT   ,src\print\tty\gtt  , 1253.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1254.GTT   ,src\print\tty\gtt  , 1254.GTT    ,COPY

print\drivers\usermode\oemdrv\tty\render  ,debug.cpp    ,src\print\tty\render  , debug.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\render  ,debug.h      ,src\print\tty\render  , debug.h      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,kmode.h      ,src\print\tty\render  , kmode.h      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,makefile     ,src\print\tty\render  , makefile     ,COPY
print\drivers\usermode\oemdrv\tty\render  ,oem.h        ,src\print\tty\render  , oem.h        ,COPY
print\drivers\usermode\oemdrv\tty\render  ,oemcom.cpp   ,src\print\tty\render  , oemcom.cpp   ,COPY
print\drivers\usermode\oemdrv\tty\render  ,oemcom.h     ,src\print\tty\render  , oemcom.h     ,COPY
print\drivers\usermode\oemdrv\tty\render  ,precomp.h    ,src\print\tty\render  , precomp.h    ,COPY
print\drivers\usermode\oemdrv\tty\render  ,resource.h   ,src\print\tty\render  , resource.h  ,COPY
print\drivers\usermode\oemdrv\tty\render  ,sources      ,src\print\tty\render  , sources      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,ttyud.cpp    ,src\print\tty\render  , ttyud.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\render  ,ttyud.h      ,src\print\tty\render  , ttyud.h      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,ttyud.rc     ,src\print\tty\render  , ttyud.rc     ,COPY
print\drivers\usermode\oemdrv\tty\render  ,tty.def      ,src\print\tty\render  , tty.def     ,COPY

print\drivers\usermode\oemdrv\tty\ui  ,debug.cpp        ,src\print\tty\ui  , debug.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,debug.h          ,src\print\tty\ui  , debug.h      ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,kmode.h          ,src\print\tty\ui  , kmode.h      ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,makefile         ,src\print\tty\ui  , makefile     ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,oem.h            ,src\print\tty\ui  , oem.h        ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,oemcom.cpp       ,src\print\tty\ui  , oemcom.cpp   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,oemcomui.h       ,src\print\tty\ui  , oemcomui.h   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,precomp.h        ,src\print\tty\ui  , precomp.h    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,resource.h       ,src\print\tty\ui  , resource.h   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,sources          ,src\print\tty\ui  , sources      ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.cpp        ,src\print\tty\ui  , ttyui.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.rc         ,src\print\tty\ui  , ttyui.rc     ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.rcv        ,src\print\tty\ui  , ttyui.rcv    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyuihlp.h       ,src\print\tty\ui  , ttyuihlp.h   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.def        ,src\print\tty\ui  , ttyui.def    ,COPY

print\drivers\usermode\oemdrv\tty\rc  ,makefile         ,src\print\tty\rc  , makefile       ,COPY
print\drivers\usermode\oemdrv\tty\rc  ,sources          ,src\print\tty\rc  , sources       ,COPY
print\drivers\usermode\oemdrv\tty\rc  ,tty.rc           ,src\print\tty\rc  , tty.rc       ,COPY

print\drivers\usermode\oemdrv\tty\inc  ,name.h          ,src\print\tty\inc   , name.h       ,COPY
print\drivers\usermode\oemdrv\tty\inc  ,tty.h           ,src\print\tty\inc   , tty.h       ,COPY
print\drivers\usermode\oemdrv\tty\inc  ,ttyui.h         ,src\print\tty\inc   , ttyui.h       ,COPY

;
; Vector minidriver samples
;

print\drivers\usermode\ddk\samples\mini\MDW\vector\hpgl2 ,HPGL2.GPD      ,src\print\mini\MDW\vector\hpgl2  , HPGL2.GPD      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\vector\hpgl2 ,HPGL2.INF      ,src\print\mini\MDW\vector\hpgl2  , HPGL2.INF      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\vector\pcl6  ,P6SAMPLE.GPD   ,src\print\mini\MDW\vector\pcl6   , P6SAMPLE.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\vector\pcl6  ,P6SAMPLE.INF   ,src\print\mini\MDW\vector\pcl6   , P6SAMPLE.INF   ,COPY

;
; Old STI samples
;

;scan\scancam\ddk\sample\hpsjusd                                  , *           , src\wdm\scancam\dll\hpsjusd                       , *           , HSPLIT
;scan\scancam\ddk\sample\sampcpl                                  , *           , src\wdm\scancam\sampcpl                           , *           , HSPLIT
;scan\scancam\ddk\sample\sampusd                                  , *           , src\wdm\scancam\dll\sampusd                       , *           , HSPLIT
;scan\scancam\ddk\sample\stillvue                                 , *           , src\wdm\scancam\app                               , *           , HSPLIT
;scan\scancam\kernel\scsiscan                                     , *           , src\wdm\scancam\scsiscan                          , *           , HSPLIT


;
; WIA Samples and Tools
;
; Note: tools\wia\scanpanl.exe, tools\wia\wiatest.exe and tools\wia\wialogcfg.exe are binplaced into the DDK by printscan\wia\placefil.txt
;

wia\ddk                                                           , *           , src\wdm\wia                                       , *           , HSPLIT

wia\drivers\scanner\microsft\wiascanr                             , *           , src\wdm\wia\wiascanr                              , *           , HSPLIT
wia\drivers\scanner\microsft\microdrv                             , *           , src\wdm\wia\microdrv                              , *           , HSPLIT
wia\drivers\camera\microsft\wiacam                                , *           , src\wdm\wia\wiacam                                , *           , HSPLIT
wia\drivers\camera\microsft\fakecam                               , *           , src\wdm\wia\microcam                              , *           , HSPLIT
ui\extend\dll                                                     , *           , src\wdm\wia\extend                                , *           , HSPLIT
ui\extend\dll\images                                              , *           , src\wdm\wia\extend                                , *           , COPY

wia\inc                                                           , wiamindr.idl, src\wdm\wia\idl                                   , *           , HSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\faxadmin\readme.txt ===
Outstanding issues in priority order:

t-darouy [Dec-10-97]

1. 

Darwin package. I couldn't get the packing tool to work in time so someone else 
will have to investigate this.

2.

Error messages are pretty goofy right now. The most pressing one is the 
access denied on fax connect server. Right now it give up and says "The Fax
server is down." which may not be correct. Most other error messages are 
just FormatMessage() strings and as such, are not really human readable. :-) 

Exception handlers are native C++. This means I can't retrieve native NT SEH
information. This also leads to goofy errors where I can get an exception, and
return an incorrect error message. Either I should switch back to SEH,
use a wrapper to convert SEH to C++ Exceptions, or I should simply display
a general "Something bad happened" dialog.


3.

Help file.

4. 

Show an X through the root node folder if the fax server can't be connected,
or the RPC connection breaks. This change is dependent on the MMC guys adding
support to change the icon of the root folder.

5. 

The sorting in the devices pane for priorities is pretty bad. I
update the priority number and call the MMC's sort function on that
column. Problem is, the MMC likes to sort in descending order the 
first time I call the sort function, so I call it twice to get around this.
This is bad if there are a large number of devices, which is not an issue at
the present time.

6. 

Thread faxconnect since it can take a while.

7.

Think about having a task pad for global fax server settings,
since it is not immediately obvious that fax properties are under
the root node.

8.

Use the new dynamic extension CCF format to programmatically enable
the Fax routing extension.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\sample.txt ===
Microsoft            	(206)926-7329
Starship Enterprize  	(123)STAR-TREK
Derian Lambert       	(123)GO-2193
DOS Lab              	67208
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ext\faxext.ini ===
\registry\machine\software\microsoft\exchange\client\extensions
    FaxExtensions = 4.0;d:\winnt\system32\faxext32.dll;1;00000100000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\help\build.95\faxinf4.txt ===
----------------------------------------------------------
              Fax Server Client for Windows 95
                      December 1997
----------------------------------------------------------
        (c) Copyright Microsoft Corporation, 1997

Microsoft Fax Server Client for Windows 95 enables 
Windows 95 network clients to use a shared Microsoft
Windows NT Fax Server printer to fax documents and
quick notes.

----------------------------------------------------------
Sending Faxes
----------------------------------------------------------

You can send a fax with either of the following methods:

	*	Fax an open document directly from its 
		program simply by selecting a fax printer
		as your target printer. 

	*	Use the Fax Send Utility to quickly compose
		and fax a message (click Start, point to
		Programs, point to Microsoft Fax Server
		Client, and then click Fax Send Utility).

----------------------------------------------------------
Receiving Faxes
----------------------------------------------------------

All faxes are received by the fax server. Your system
administrator can tell you how faxes are received on your
system and distributed to network users.

----------------------------------------------------------
Getting Help
----------------------------------------------------------

Windows 95 Fax Server Client provides two ways to get help: 
an online Help system and context-sensitive Help.

Online Help provides step-by-step guidance for faxing tasks,
such as sending, receiving, and viewing faxes.

>>>	To open online Help

	1. Click Start, and then point to Programs.
	2. Point to Microsoft Fax Server Client.
	3. Click Fax Client Help.
	
Context-sensitive Help explains options in the Fax Client
Properties dialog box.

>>>	To use context-sensitive Help while in the Fax Properties 
	dialog box

	1. Click the ? button in the upper-right corner of the 
	   dialog box.
	2. Point to the item you want described and click.

	Note: You can also right-click the item and then click 
	What's This?

To open the Fax Client Properties dialog box, click Start, point
to Settings, an then click Control Panel. In Control Panel,
double-click the Fax Client icon.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\help\install.txt ===
Last Revision Date 4/1/1997 - John Mikesell

Location: \\orville\razzle\src\fax\help\install.txt

This install.txt file provides file locations, installation instructions, and uninstall instructions for Windows NT fax help, Windows 95 and WFG/3.11 Fax Clients help.

*** WHAT'S NEW ***
4/1/97
    1. RELEASE folder removed.
    2. WFW, W95 relnotes & readme files renamed
    3. WFW, W95 relnotes & readme placeholder files added

3/28/97
    1. Notes/readme files added to each build folder and install instructions.
    3. Fax client hlp/cnt files added to SERVER installation.
    4. Instructions added for Win95
    5. Headings added for 3.11/WFW (F-G) install/uninstall instructions.
    6. Faxview cnt/hlp files removed.
    7. Fax0.hlp added, notation in NT Windows.Cnt changed :Index fax.hlp -> fax0.hlp.
       See note H.1 at end of this file.

*** CONTENTS ***
    A. Locations of Help files in SLM fax project
    B. Windows NT Installation Instructions
       1. For all Windows NT installations
       2. Files for NT Server installations
       3. Files for NT Client installations
       4. Files for NT Personal Fax installations
    C. Windows NT Uninstall Instructions
       1. For all Windows NT installations
       2. Files removed for NT Server installations
       3. Files removed for NT Client installations
       4. Files removed for NT Personal Fax installations
    D. Windows 95 Fax Client Install
    E. Windows 95 Fax Client Uninstall
    F. Windows WFW and 3.11 Fax Client Install
    G. Windows WFW and 3.11 Fax Client Uninstall
    H. Notes

A. Locations of All Help files in SLM fax project

\\orville\razzle\src\fax\help\.

Copy files for Fax Server/Clients help from these locations only. No other locations are guaranteed to have the latest help files for Fax Server & Clients. 

Release (REMOVED)
   RELEASE NOTES AND README ARE NOW IN BUILD FOLDERS.

.\
   Install.txt - this file

.\Build
   Fax0.hlp  (called from windows.hlp contents)
   Fax.hlp
   Fax.cnt
   Faxcover.hlp
   Faxcover.cnt
   Faxui.hlp

.\Build.Srv
   Faxsrv.hlp
   Faxsrv.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.Clt
   Faxclt.hlp
   Faxclt.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.Wks  (Personal Fax)
   Faxwks.hlp
   Faxwks.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.WFW
   Fax3.hlp
   faxinf3.txt
   faxrel3.txt

.\Build.95
   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   faxinf4.txt
   faxrel4.txt

B. Windows NT Installation Instructions:

HLP and CNT files should go into the sysroot\help folder.

B.1. For all Windows NT installations

The following entry should be inserted in alphabetical order in the text file sysroot\system32\windows.cnt if not already inserted:

    :Index Fax Help=fax0.hlp

The following files should be deleted from  the sysroot\system32 folder, if they are present:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

Files to be added for ALL installations
   Fax0.hlp
   Fax.hlp
   Fax.cnt
   Faxcover.hlp
   Faxcover.cnt
   Faxui.hlp

B.2. Files for NT Server installations
   Faxsrv.hlp
   Faxsrv.cnt
   Faxclt.hlp
   Faxclt.cnt
   faxinfos.txt
   faxrelnts.txt

B.3. Files for NT Client installations
   Faxclt.hlp
   Faxclt.cnt
   faxinfoc.txt
   faxrelntc.txt

B.4. Files for NT Personal Fax installations
   Faxwks.hlp
   Faxwks.cnt
   faxinfo.txt
   faxrelnt.txt

C. Windows NT Uninstall Instructions:

Note: These instructions apply completely only if all installations (client, server, & workstation) are being removed. * marks items that don't apply if one is being removed and another one left on.

C.1. For all Windows NT installations

* The following entry should be removed from the text file sysroot\system32\windows.cnt file. This actually won't affect program operation if it is left in and fax.hlp isn't there.

    :Index Fax Help=fax.hlp

* The following files should be deleted from  the sysroot\system32 folder:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

* Files to be removed if all installations (server, workstation and client) are removed:

   Fax0.hlp
   Fax.hlp
   Fax.cnt
   Fax.gid
   Fax.fts
   Fax.ftg
   Faxcover.hlp
   Faxcover.cnt
   Faxcover.gid
   Faxcover.fts
   Faxcover.ftg
   Faxui.hlp
   Faxview.hlp
   Faxview.cnt
   Faxview.gid
   Faxview.fts
   Faxview.ftg

C.2. Files removed for NT Server installations

   Faxsrv.hlp
   Faxsrv.cnt
   Faxsrv.gid
   Faxsrv.fts
   Faxsrv.ftg
   Faxclt.hlp
   Faxclt.cnt
   Faxclt.gid
   Faxclt.fts
   Faxclt.ftg
   faxinfos.txt
   faxrelnts.txt

C.3. Files removed for NT Client installations

   Faxclt.hlp
   Faxclt.cnt
   Faxclt.gid
   Faxclt.fts
   Faxclt.ftg
   faxinfoc.txt
   faxrelntc.txt

C.4. Files removed for NT Personal Fax installations

   Faxwks.hlp
   Faxwks.cnt
   Faxwks.gid
   Faxwks.fts
   Faxwks.ftg
   faxinfo.txt
   faxrelnt.txt

D. Windows 95 Install

HLP and CNT files should go into the sysroot\help folder.

The following entry should be inserted in alphabetical order in the text file sysroot\help\windows.cnt if not already inserted:

    :Index Fax Help=fax40.hlp

The following files should be deleted from  the sysroot\system32 folder, if they are present:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

The following files should be installed:

   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   Faxui.hlp
   faxinfo4.txt
   faxrelnt4.txt

E. Windows 95 Uninstall

The following entry should be removed from the text file sysroot\system32\windows.cnt file. This actually won't affect program operation if it is left in and fax.hlp isn't there.

    :Index Fax Help=fax40.hlp

The following files should be deleted from  the sysroot\system32 folder:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

The following files should be removed:

   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   Fax4.gid
   Fax4.fts
   Fax4.ftg
   Faxui.hlp
   faxinfo4.txt
   faxrelnt4.txt

F. Windows WFG and 3.11 Install
   Fax3.hlp
   Faxui.hlp
   faxinfo3.txt
   faxrelnt3.txt

G. Windows WFG and 3.11 Uninstall (tentative)
   Fax3.hlp
   Faxui.hlp
   faxinfo3.txt
   faxrelnt3.txt

H. NOTES

H.1 Right now we reference fax.hlp in the NT Windows.Cnt by adding an ":Index Fax0.Hlp" (changed from Fax.hlp in 3/28/97 version of install instructions). This file has a topic which creates entries for "fax procedures" in the Windows.Hlp index users open on the start menu. If installing (Personal, Client/Server) fax becomes standard in any release of Windows NT, then this should be added to the Windows.Cnt file, and steps for inserting it here should be removed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\help\build.wks\faxinfo.txt ===
----------------------------------------------------------
            Microsoft Fax for Windows
                      May 1997
----------------------------------------------------------
        (c) Copyright Microsoft Corporation, 1997

Contents

	1.	What Is Microsoft Fax for Windows?
	2.	Sending Faxes
   	3.	Receiving Faxes
      4.    Setting Up Your Modem and Configuring Fax Server
      5.    Setting Up and Configuring Fax Clients
   	6.	Getting Help
      7.    Where Do I Go From Here?


----------------------------------------------------------
1. What Is Microsoft Fax for Windows?
----------------------------------------------------------

Microsoft Fax for Windows is a Fax Server program that
enables network users to fax documents, quick notes, and
E-mail messages from any Windows computer on the network.

To fax documents, quick notes or E-mail messages, you
you need only install the Fax Client and add a shared fax
printer on your computer. Fax documents the same way
you ordinarily print documents. When you print a document,
the fax printer appears in the Printer list. You fax quick
notes with the Fax Send Utility. You fax E-mail messages
by sending them to a fax address. Fax Server also faxes
documents inserted in E-mail messages.

All faxes are sent and received through fax devices installed
on the Server Computer. The Fax Server recognizes any
communication device capable of initiating and receiving
type 3 fax calls. Most commonly, this is a standard fax
modem, a fax card, or a virtual fax port (for Internet
faxing).

Fax for Windows automatically answers calls to fax
devices on the server computer. Received faxes can be
printed immediately, distributed to a folder on the
network or sent to an inbox. If you have a fax modem with
adaptive answer capability, Microsoft Fax Server can
distinguish between fax and data calls.

Microsoft Fax for Windows converts all outgoing and
incoming faxes to Tag Image File Format (TIFF) files,
which you can print or view and store online.

Note: The Small Business Server version of Microsoft
Fax for Windows supports up to four fax devices.

----------------------------------------------------------
2. Sending Faxes
----------------------------------------------------------

You can send a fax in any of three ways.

	*	You can fax an open document directly from its 
		program simply by selecting your fax printer as 
		your target printer. On the File menu of the program, 
		click Print, and the Fax Send Utility opens 
		to guide you through each step. Click Send to
            fax a document in an E-mail message.

	*	You can use the Fax Send Utility (Start/Programs/Fax)
		to quickly create and fax a message. Use this method
		when you do not need to include file attachments or
            simultaneously send the message to E-mail addresses.

	*	You can send a fax from Exchange or Outlook
            simultaneously to both fax and E-mail addresses.
		In Exchange you use special fax addresses
		you define in your Personal Address Book. 
		In Outlook you use the fax address for any contact
		with a fax number. When you select a recipient with
		a fax address, the e-mail that you type becomes your fax. 
		A copy of each fax you send is stored in the Sent
		or Sent Items folder, just as e-mail messages are.

Regardless of the method you use to send your fax, you can 
open the fax printer queue in the Printers folder in My Computer
to monitor the progress of your fax. When you use Exchange or
Outlook to send a fax, you'll be automatically notified by e-mail
whether your fax transmission was successful.

Each Fax Printer provides several standard cover pages you can
include with your document. The printer may also permit you to
use personal cover pages. You can create or modify personal
cover pages on a Windows NT computer with the Fax Cover Page 
Editor. Windows 95, Windows 3.11, and Windows For Workgroups
fax clients do not have a cover page editor. You can use
Windows 95 fax cover pages if you first open and save them
with the Fax Cover Page Editor on Windows NT.


----------------------------------------------------------
3. Receiving Faxes
----------------------------------------------------------

All faxes are received on the server. You can combine any
of the following methods to manage faxes received on the
server:

	*	You can automatically route all incoming faxes to a
		folder on the server computer or on another networked
            computer.

	*	You can automatically print each fax upon arrival.

	*	You can automatically send received faxes in mail
            messages to an Exchange or Outlook Inbox.

To view a received fax online, use the Fax Document Viewer 
(Start/Programs/Fax).


----------------------------------------------------------
4. Setting Up Your Modem and Configuring the Fax Server
----------------------------------------------------------

Note: If you are using the Small Business Server, install
modems and configure the Fax Server using the options
in the Small Business Server setup program or in the
Small Business Server Console.

First, install your fax device in your computer according to the 
manufacturer's instructions. Please see the release notes for 
a list of supported modems.

Next, install Microsoft Fax for Windows. It adds Fax
Server and Fax Client icons to Control Panel
(Start/Settings/Control Panel).

Use the Fax Server Properties dialog box to specify the server
settings, such as:

	*	The number of times you want the modem to redial after 
		an unsuccessful call attempt, and the interval between 
		redials.

	*	Additional fax printers.

	*	The cover pages you want to use with each printer.

	*	Printer properties, such as the devices to send faxes,
            discount calling period, and where to archive sent faxes.

	*	The number of rings before a call is answered, and
		how you want to handle incoming faxes.

	*	The logging priority level for successful and unsuccessful 
		fax events. You can view fax events in the Event Viewer, 
		which you can find under Start/Programs/Administrator Tools.

	*	Fax monitoring options.

If you are going to send and receive faxes from the Fax Server computer,
you can also open the Fax Client Properties to configure the client
settings as described next (under 5). 

----------------------------------------------------------
5. Setting Up and Configuring Fax Clients
----------------------------------------------------------


When you install Fax Server it also installs the Fax Client
software. On a Fax Client computer, you need to install the
client and specify a shared fax printer. The Fax Client setup
adds a Fax icon to Control Panel which opens the Fax Properties
dialog box.

Next, use the Fax Properties dialog box to specify fax settings, 
such as:

	*	Paper size, image quality, and page orientation.

	*	Whether to send the fax immediately or at another time, 
		such as during off-peak hours when usage and long-distance 
		phone rates are lower, or at a specific time.

      *     An E-mail address for Fax Server to notify you of the
            status of your sent faxes.

	*	Any personal cover pages you want to use along with those
            provided by the shared printer.

	*	Your name, fax number, and other personal information 
		you want to include on the cover pages of outgoing faxes.

Finally, if you chose during setup to use Windows Messaging to
specify fax recipients and to send faxes via email, set the following
options in Microsoft Exchange or Microsoft Outlook for
the Fax Mail Transport service.

	*	The fax printer to use to send messages.

	*	Whether to include a cover page with faxes sent from
		Exchange or Outlook and the default cover page you want
		to use.

	*	The default message font for faxes sent by programs
		that do not support rich-text formatting.


----------------------------------------------------------
6. Where Do I Go From Here?
----------------------------------------------------------

Setting up Microsoft Fax for Windows adds the following items to 
your Start menu, in a new Fax group, under Programs.

	*	Cover Page Editor
	*	Fax Configuration
	*	Fax Viewer
	*	Fax Send Utility
	*	Help
	*	Problem Reporting Form
	*	Read Me First
	*	Release Notes

On the Fax Server computer, Setup adds a Fax Server and a Fax Client icon to
Control Panel. On the Fax Client, it adds a Fax icon.

>>>	To open the Fax Properties dialog box

	1.	Click Start, point to Programs,
            then point to Fax (Common).
	2.	Click Fax Configuration.

	Note: Note, on the Fax Server computer, this opens
      Fax Server Properties. On a Fax Client computer, this
      opens Fax Properties (for the Fax Client). You can also
      open the Fax Properties dialog box in the Control Panel. 

If you chose to use Windows Messaging for the Fax Client, Setup
also adds the Fax Mail Transport service in Exchange or Outlook.

>>>	To view the Fax Mail Transport properties

	1.	Click Start, point to Programs, and then
		click Microsoft Exchange or Microsoft Outlook.
	2.	On the Tools menu, click Services.
	3.	On the Services tab, click Fax Mail Transport.
	4.	Click Properties.


----------------------------------------------------------
7. Getting Help
----------------------------------------------------------

Fax for Windows gives you two ways to get help: a 
complete online Help system and context-sensitive Help.

Online Help provides step-by-step guidance for faxing tasks.

>>>	To open online Help

	1. Click Start, point at Programs,
         and point at Fax (Common).
      2. Click Help.

Context-sensitive Help explains options in the Fax Properties,
Fax Server Properties, and Fax Client Properties dialog boxes. 

>>>	To use context-sensitive Help

	1.	Click the ? button in the upper-right corner of the 
		dialog box.
	2.	Point to the item you want described and click.

	Note: You can also right-click the item and then click 
	What's This?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\help\build.95\faxrel4.txt ===
----------------------------------------------------------
Release Notes for the Fax Server Client for Windows 95

Small Business Server
December, 1997
----------------------------------------------------------

Contents

1. You cannot fax E-mail messages in Windows 95
2. If you fax using the Send command in Windows 95
3. If you don't receive an expected fax
4. I added a fax printer, so why can't I do anything other
    than fax with the Print command?

----------------------------------------------------------
1. You cannot fax E-mail messages in Windows 95
----------------------------------------------------------

The Windows 95 client for Microsoft Fax Server does not
fax E-mail messages from Microsoft Outlook or Exchange
in this release.

----------------------------------------------------------
2. If you fax using the Send command in Windows 95
----------------------------------------------------------

In this release, the Windows 95 client for Microsoft Fax
Server does not support the Send command to fax documents.

----------------------------------------------------------
3. If you don't receive an expected fax
----------------------------------------------------------

Faxes are received by Microsoft Fax Server. You need to
ask your system supervisor how faxes received by the
server computer are distributed in your organization.

----------------------------------------------------------
4. I added a fax printer, so why can't I do anything other
    than fax with the Print command?
----------------------------------------------------------

Microsoft Fax Client for Windows 95 does not support
faxing with the Send command or with Windows Messaging
(Outlook or Exchange).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\help\build.wks\faxrelnt.txt ===
----------------------------------------------------------
Release Notes for Microsoft Personal Fax for Windows
January, 1997
----------------------------------------------------------

Contents

	 1.  	Monitoring Fax Transmissions and Answering Calls Manually
  	 2.  	Setting the Number of Rings Before Answering
  	 3.  	Using the Same Modem for a Remote Access Server and 
		for Faxing
  	 4.  	If You've Changed Your Fax Administrator Account Password
  	 5.  	Turning Off Print Spooler Event Logging for Fax Events
  	 6.  	If You Receive a "Could Not Process All Attachments" Message
  	 7.  	If You Can't Send a Fax After Replacing or Reinstalling 
		Your Modem
  	 8.  	If Windows Messaging Stops Responding After You've Installed 
		Personal Fax for Windows
	 9.  	If You Don't Receive an Expected Fax
	10.  	If the Paste Command Is Unavailable in Cover Page Editor
	11.  	If You Don't Receive Fax Status E-mail when Using the 
		Send Fax Utility or Faxing from a Program
	12.  	To Report Bugs
	13.  	List of Tested Modems


----------------------------------------------------------
1. Monitoring Fax Transmissions and Answering Calls Manually
----------------------------------------------------------

This release of Microsoft Personal Fax for Windows includes 
Fax Monitor and an option to answer calls manually. You can 
use Fax Monitor to see the current status of Personal Fax, to 
interrupt calls, and to turn off manual answering for the next 
call. The options for Fax Monitor are controlled on the Monitor tab 
in the Fax Properties dialog box, where you can set options to 
do the following.

	* 	Use an icon on the taskbar to display Fax Monitor or 
  		its options
	* 	Display Fax Monitor automatically when you send or 
  		receive a fax
	* 	Display Fax Monitor on top of all other windows
	* 	Play a sound when you receive a fax
	* 	Turn on Manual Answer

>>>	To change settings for Fax Monitor
      	1. 	Click Start, point to Settings, click Control Panel, and then 
		double-click Fax.
      	2. 	Click the Monitor tab.
      	3. 	Select the options you want.

If your phone line is used for both fax and voice calls, enabling 
Manual Answer lets you choose to answer calls manually. If you 
receive a phone call while this feature is turned on, Personal Fax 
prompts you to answer the call. After you answer and find that the 
call is a fax call, you can click Yes to receive the fax.

>>>	To turn on Manual Answer
      	1. 	Click Start, point to Settings, click Control Panel, and then 
		double-click Fax.
      	2. 	Click the Monitor tab.
      	3. 	Select the Enable Manual Answer check box.

When you know in advance that the next call will be a fax call,
you can set Personal Fax to ignore Manual Answer for that call only.

>>>	To turn off Manual Answer for the next call
      	1. 	On the taskbar, click the Fax icon.
      	2. 	In Fax Monitor, select the Answer Next Call check box.


----------------------------------------------------------
2. Setting the Number of Rings Before Answering
----------------------------------------------------------

With this release, you can now specify how many rings you 
want before Personal Fax answers a call.

>>>	To set the number of rings before answering
      	1. 	Click Start, point to Settings, click Control Panel, and then 
		double-click Fax.
      	2. 	Click the Receive tab.
      	3. 	In Rings Before Answer, type the number of rings you want.

Note: When the Manual Answer check box is selected on the 
Monitor tab in the Fax Properties dialog box, the number of rings 
is automatically set to 99.


----------------------------------------------------------
3. Using the Same Modem for a Remote Access Server and 
for Faxing
----------------------------------------------------------

You can use the same modem for both a Remote Access 
Server (RAS) and for fax transmissions as long as the modem 
supports a feature called "adaptive answer." If your modem 
doesn't support adaptive answer, you can still use the same 
modem for outgoing RAS and fax transmissions. You won't, 
however, be able to receive both faxes and dial-in RAS calls. 
To receive dial-in RAS calls on a non-adaptive-answer modem, 
you need to disable your modem for fax receipt.

>>>	To disable your modem for fax receipt
      	1. 	Click Start, point to Settings, click Control Panel, and then 
		double-click Fax.
      	2. 	Click the Receive tab.
      	3. 	Under Device Name, click to clear the check box next to 
		the name of your modem.


----------------------------------------------------------
4. If You've Changed Your Fax Administrator Account Password
----------------------------------------------------------

If you've changed the password for your Fax Administrator 
account (the account specified during Setup), you will also need 
to change the password for your Fax Service so that the two 
passwords match.

>>>	To change your Fax Service password
      	1. 	Click Start, point to Settings, click Control Panel, and then 
		double-click Services.
      	2. 	Under Services, click Microsoft Fax Service, and then click 
		the Startup button.
      	3. 	Under Log On As, type the new password in the Password box.
      	4. 	Type the new password again in the Confirm Password box.
      	5. 	Click OK in each dialog box.


----------------------------------------------------------
5. Turning Off Print Spooler Event Logging for Fax Events
----------------------------------------------------------

If you prefer not to log print spooler fax events, you can turn off 
this option by disabling print system event logging. Please note that 
doing so will also disable all events logged by the print spooler.

>>>	To disable print system event logging
      	1. 	Click Start, point to Settings, and then click Printers.
      	2. 	On the File menu, click Server Properties.
      	3. 	Click the Advanced tab.
      	4. 	Click to clear the check box next to Log spooler 
		information events.


----------------------------------------------------------
6. If You Receive a "Could Not Process All Attachments" Message
----------------------------------------------------------

This message appears after sending a fax from Windows 
Messaging when you've attached a file from a program that 
doesn't support file attachments.

To fax a file from a program that doesn't support file 
attachments when faxing from Windows Messaging, send the 
file from the program directly.

>>>	To fax a file from a program
      	1. 	In the program, select your fax printer as the target
		printer.
      	2. 	On the File menu, click Print or Send.
      	3. 	Follow the instructions in the Fax Send Utility.


----------------------------------------------------------
7. If You Can't Send a Fax After Replacing or Reinstalling Your Modem
----------------------------------------------------------

If you have problems faxing after replacing or reinstalling your 
modem, restart Windows NT 4.0. If that doesn't clear up the 
problem, reinstall Personal Fax for Windows.


----------------------------------------------------------
8. If Windows Messaging Stops Responding After You've Installed 
Personal Fax for Windows
----------------------------------------------------------

If, after installing Personal Fax, Windows Messaging does 
nothing when you try to open it, restart Windows NT 4.0, and then, 
do the following.

      	1. 	Click Start, point to Settings, click Control Panel, and then 
		double-click Mail.
      	2. 	Click Show Profiles.
      	3. 	Click the profile that you specified during fax Setup, and 
		then click Properties.
      	4. 	Select Fax Mail Transport, and then click Remove.

You will be able to open Windows Messaging, but you won't 
be able to send faxes from it. Instead, you can  send faxes by 
using the Send Fax Utility or by faxing documents directly from 
their programs.


----------------------------------------------------------
9. If You Don't Receive an Expected Fax
----------------------------------------------------------

There are two possible reasons you may not receive an 
expected fax.

	1.   	The destination printer, folder, or inbox specified on the 
		Receive tab in the Fax Properties dialog box is unavailable.
		This generates the NT Fax event "The device is not ready."

		To receive the fax, make the destination available, and
		the fax normally will be delivered after 10 or 20 minutes.

		If the destination cannot be made available, specify a
		different destination on the Receive tab in the Fax Properties
		dialog box, cancel the document in the printer queue, and
		have the fax resent.

	2.   	The drive where your Windows NT system files reside is at 
		or near capacity. The Fax Service will attempt to answer an 
		incoming fax, but will immediately stop. The fax won't be
		received and no event will be generated.

		To resume receiving faxes, delete some files to free up space,
		and then have the fax resent.


----------------------------------------------------------
10. If the Paste Command Is Unavailable in Cover Page Editor
----------------------------------------------------------

Cover Page Editor allows one Note field for each cover page. 
If you try to copy and paste a second Note field into a cover 
page, the Paste command will be unavailable. To paste a Note 
field into a cover page, select the one already in the cover page, 
and then delete it. The Paste command will become available.


----------------------------------------------------------
11. If You Don't Receive Fax Status E-mail when Using the Send Fax Utility or 
Faxing from a Program
----------------------------------------------------------

For this release, fax status e-mail is sent only when you send a 
fax by using Windows Messaging. To view the progress of a fax 
transmission or to learn the status of recent fax transmissions, 
you can use Fax Monitor (see release note 1). To find out if 
you've received a fax, you can also check the destination you 
set up for receiving faxes, such as a certain folder or printer.

For complete information about fax events, you can use the 
Windows NT Event Viewer.

>>>	To view details of fax events in Event Viewer
      	1. 	Click Start, point to Programs, point to Administrative 
		Tools (Common), and then click Event Viewer.
      	2. 	On the Log menu, click Application.
      	3. 	Under Source, look for NT Fax events.
      	4. 	Double-click an event to see a complete description.


----------------------------------------------------------
12. To Report Bugs
----------------------------------------------------------

You can report bugs by filling out the Problem Reporting Form 
included in this release.

>>>	To use the Problem Reporting Form
      	1. 	Click Start, point to Programs, point to Fax (Common), 
		and then click Problem Reporting Form.
      	2. 	Fill out the form, and then e-mail it to ntbug@microsoft.com


----------------------------------------------------------
13. List of Tested Modems
----------------------------------------------------------

The modems in the following list have been tested with Microsoft 
Personal Fax for Windows. Other modems may also work.

AT&T
	DataPort Express External
Boca Research
	28.8 Kbps MV.34i Internal
	28.8 Kbps V.34 MV.34E External
Cardinal
	MVP 288XF 28.8 Kbps V.34 Fax Modem
Hayes
	*Accura External 14400 FAX144 (Model 5105AM)
	*Optima External 288 V.34/V.FC+fax+Voice
	*Accura External 288 V.FC+FAX (Model 5205AM) 
	Optima External 336 V.34/V.FC+fax+Voice
	Accura External 288 V.34 +FAX
MaxTech
	28.8 Data Fax Internal, XM288i
	28.8 Data Fax External, XM288E
Megahertz
	PCMCIA XJ-CC4288
	PCMCIA XJ2288
	P2144 V.32bis Pocket Modem
Motorola
	Premier Internal 33.6 PnP
	Premier External 33.6 Desktop
	ModemSURFR Internal 28.8 PnP
	Lifestyle External 288
	CELLect PCMCIA 14.4
	LifeStyle PCMCIA 14.4
	Premier External 336 
Practical Peripherals
	*PM288MT II External V.34 
Supra
	Express Internal 336i PnP
	SupraFaxModem 144LC 
	SupraExpress External 144 Plus 
	SupraFaxModem External V.32bis 
	SupraExpress Internal 144I
	SupraSonic 33.6 V+ 
US Robotics
	Total Control External rack mount / Quad V.34 Card
	Courier External V.everything
	Sportster External 28800
	Sportster 288-336 Internal
	Sportster 288-336 External
	Sportster Internal 14400 FAX PC
	Sportster External 14400 FAX
	Courier PCMCIA V.Everything
	Courier External Turbo V.32bis Fax 
Zoom
	VFX External V.34X
	VFP Internal 14.4i
	VFX External 14.4
	VFP Internal 14.4VH
	VFP Internal 14.4V

* These devices have been tested for the adaptive answer
  required for Fax/RAS interoperability.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\perfmon\faxperf.ini ===
[info]
drivername=fax
symbolfile=faxcount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Fax Server
FAXOBJ_009_HELP=Fax Server
INBOUND_BYTES_009_HELP=Inbound bytes
INBOUND_BYTES_009_NAME=Inbound bytes
INBOUND_FAILED_RECEIVE_009_HELP=Inbound failed receptions
INBOUND_FAILED_RECEIVE_009_NAME=Inbound failed receptions
INBOUND_FAXES_009_HELP=Inbound faxes
INBOUND_FAXES_009_NAME=Inbound faxes
INBOUND_MINUTES_009_HELP=Inbound minutes receiving
INBOUND_MINUTES_009_NAME=Inbound minutes receiving
INBOUND_PAGES_009_HELP=Inbound pages
INBOUND_PAGES_009_NAME=Inbound pages
OUTBOUND_BYTES_009_HELP=Outbound bytes
OUTBOUND_BYTES_009_NAME=Outbound bytes
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Outbound failed connections
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Outbound failed connections
OUTBOUND_FAILED_XMIT_009_HELP=Outbound failed transmissions
OUTBOUND_FAILED_XMIT_009_NAME=Outbound failed transmissions
OUTBOUND_FAXES_009_HELP=Outbound faxes
OUTBOUND_FAXES_009_NAME=Outbound faxes
OUTBOUND_MINUTES_009_HELP=Outbound minutes sending
OUTBOUND_MINUTES_009_NAME=Outbound minutes sending
OUTBOUND_PAGES_009_HELP=Outbound pages
OUTBOUND_PAGES_009_NAME=Outbound pages
TOTAL_BYTES_009_HELP=Total bytes
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total faxes
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total minutes sending/receiving
TOTAL_MINUTES_009_NAME=Total minutes sending/receiving
TOTAL_PAGES_009_HELP=Total pages
TOTAL_PAGES_009_NAME=Total pages
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\print\faxprint\faxdrv\runcodes.txt ===
Table 1a. Terminating White Codes
Code            Lng     Run
---------------------------
00110101        8       0
000111          6       1
0111            4       2
1000            4       3
1011            4       4
1100            4       5
1110            4       6
1111            4       7
10011           5       8
10100           5       9
00111           5       10
01000           5       11
001000          6       12
000011          6       13
110100          6       14
110101          6       15
101010          6       16
101011          6       17
0100111         7       18
0001100         7       19
0001000         7       20
0010111         7       21
0000011         7       22
0000100         7       23
0101000         7       24
0101011         7       25
0010011         7       26
0100100         7       27
0011000         7       28
00000010        8       29
00000011        8       30
00011010        8       31
00011011        8       32
00010010        8       33
00010011        8       34
00010100        8       35
00010101        8       36
00010110        8       37
00010111        8       38
00101000        8       39
00101001        8       40
00101010        8       41
00101011        8       42
00101100        8       43
00101101        8       44
00000100        8       45
00000101        8       46
00001010        8       47
00001011        8       48
01010010        8       49
01010011        8       50
01010100        8       51
01010101        8       52
00100100        8       53
00100101        8       54
01011000        8       55
01011001        8       56
01011010        8       57
01011011        8       58
01001010        8       59
01001011        8       60
00110010        8       61
00110011        8       62
00110100        8       63
11011           5       64
10010           5       128
010111          6       192
0110111         7       256
00110110        8       320
00110111        8       384
01100100        8       448
01100101        8       512
01101000        8       576
01100111        8       640
011001100       9       704
011001101       9       768
011010010       9       832
011010011       9       896
011010100       9       960
011010101       9       1024
011010110       9       1088
011010111       9       1152
011011000       9       1216
011011001       9       1280
011011010       9       1344
011011011       9       1408
010011000       9       1472
010011001       9       1536
010011010       9       1600
011000          6       1664
010011011       9       1728
00000001000     11      1792
00000001100     11      1856
00000001101     11      1920
000000010010    12      1984
000000010011    12      2048
000000010100    12      2112
000000010101    12      2176
000000010110    12      2240
000000010111    12      2304
000000011100    12      2368
000000011101    12      2432
000000011110    12      2496
000000011111    12      2560


Table 2a. Terminating Black Codes
Code            Lng     Run
---------------------------
0000110111      10      0
010             3       1
11              2       2
10              2       3
011             3       4
0011            4       5
0010            4       6
00011           5       7
000101          6       8
000100          6       9
0000100         7       10
0000101         7       11
0000111         7       12
00000100        8       13
00000111        8       14
000011000       9       15
0000010111      10      16
0000011000      10      17
0000001000      10      18
00001100111     11      19
00001101000     11      20
00001101100     11      21
00000110111     11      22
00000101000     11      23
00000010111     11      24
00000011000     11      25
000011001010    12      26
000011001011    12      27
000011001100    12      28
000011001101    12      29
000001101000    12      30
000001101001    12      31
000001101010    12      32
000001101011    12      33
000011010010    12      34
000011010011    12      35
000011010100    12      36
000011010101    12      37
000011010110    12      38
000011010111    12      39
000001101100    12      40
000001101101    12      41
000011011010    12      42
000011011011    12      43
000001010100    12      44
000001010101    12      45
000001010110    12      46
000001010111    12      47
000001100100    12      48
000001100101    12      49
000001010010    12      50
000001010011    12      51
000000100100    12      52
000000110111    12      53
000000111000    12      54
000000100111    12      55
000000101000    12      56
000001011000    12      57
000001011001    12      58
000000101011    12      59
000000101100    12      60
000001011010    12      61
000001100110    12      62
000001100111    12      63
0000001111      10      64
000011001000    12      128
000011001001    12      192
000001011011    12      256
000000110011    12      320
000000110100    12      384
000000110101    12      448
0000001101100   13      512
0000001101101   13      576
0000001001010   13      640
0000001001011   13      704
0000001001100   13      768
0000001001101   13      832
0000001110010   13      896
0000001110011   13      960
0000001110100   13      1024
0000001110101   13      1088
0000001110110   13      1152
0000001110111   13      1216
0000001010010   13      1280
0000001010011   13      1344
0000001010100   13      1408
0000001010101   13      1472
0000001011010   13      1536
0000001011011   13      1600
0000001100100   13      1664
0000001100101   13      1728
00000001000     11      1792
00000001100     11      1856
00000001101     11      1920
000000010010    12      1984
000000010011    12      2048
000000010100    12      2112
000000010101    12      2176
000000010110    12      2240
000000010111    12      2304
000000011100    12      2368
000000011101    12      2432
000000011110    12      2496
000000011111    12      2560
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\comm\special.txt ===
MODEMS REQUIRING SPECIAL SETTINGS (not yet on awmodem.inf)
	---------------------------------

Anderson Jacobson 1446 FX. Snowball SetupCommand=AT*LG1 (See pcfax bug 84).

Intel  High-Speed External Faxmodem 144/144e. Needs to be forced to be Class2
(pfcax bug 1510).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\readme.txt ===
--------------------------------------
		COMMON directory for LocalFax Modules
		--------------------------------------

defs.h	Common defines
lpc.h   Interface to home-brew local RPC.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\broadcast\readme.txt ===
simple
======
This C/C++ sample illustrates the use of FaxConnectFaxServer, FaxCompleteJobParams, 
and FaxSendDocument.

Furthermore, it illustrates the use of an IO Completion Port to retrieve real-time status
for a fax server.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\faxapi.ini ===
[FaxAbort]
Prototype=WINFAXAPI BOOL WINAPI FaxAbort( IN HANDLE FaxJobHandle);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Abort the specified FAX job.  All outstanding FAX operations are terminated.
NumberOfParameters=1
ParameterName0=FaxJobHandle
ParameterType0=HANDLE
ParameterDescr0=FaxJobHandle - To be determined

[FaxClose]
Prototype=WINFAXAPI BOOL WINAPI FaxClose( IN HANDLE FaxHandle);
ReturnType=BOOL
ReturnValueDescription=FaxClose - To be determined
Remarks=FaxClose - To be determined
NumberOfParameters=1
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined

[FaxConnectFaxServerA]
Prototype=WINFAXAPI BOOL WINAPI FaxConnectFaxServerA( IN  LPSTR MachineName OPTIONAL, OUT LPHANDLE FaxHandle);
ReturnType=BOOL 
ReturnValueDescription=TRUE Indicates Success. FALSE Indicates Failure, call GetLastError() for more error information.
Remarks=Creates a connection to a FAX server. The binding handle that is returned is used for all subsequent FAX API calls.
NumberOfParameters=2
ParameterName0=MachineName
ParameterType0=LPSTR
ParameterDescr0=Machine name, NULL, or "."
ParameterName1=FaxHandle
ParameterType1=LPHANDLE
ParameterDescr1=Pointer to a FAX handle

[FaxConnectFaxServerW]
Prototype=WINFAXAPI BOOL WINAPI FaxConnectFaxServerW( IN  LPWSTR MachineName OPTIONAL, OUT LPHANDLE FaxHandle);
ReturnType=BOOL 
ReturnValueDescription=TRUE Indicates Success. FALSE Indicates Failure, call GetLastError() for more error information.
Remarks=Creates a connection to a FAX server. The binding handle that is returned is used for all subsequent FAX API calls.
NumberOfParameters=2
ParameterName0=MachineName
ParameterType0=LPWSTR
ParameterDescr0=Machine name, NULL, or "."
ParameterName1=FaxHandle
ParameterType1=LPHANDLE
ParameterDescr1=Pointer to a FAX handle

[FaxEnableRoutingMethodA]
Prototype=WINFAXAPI BOOL WINAPI FaxEnableRoutingMethodA( IN  HANDLE FaxPortHandle, IN  LPSTR RoutingGuid, IN  BOOL Enabled);
ReturnType=BOOL
ReturnValueDescription=FaxEnableRoutingMethodA - To Be Determined
Remarks=FaxEnableRoutingMethodA - To Be Determined
NumberOfParameters=3
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingGuid
ParameterType1=LPSTR
ParameterDescr1=RoutingGuid - To be determined
ParameterName2=Enabled
ParameterType2=BOOL
ParameterDescr2=Enabled - To be determined

[FaxEnableRoutingMethodW]
Prototype=WINFAXAPI BOOL WINAPI FaxEnableRoutingMethodW( IN  HANDLE FaxPortHandle, IN  LPWSTR RoutingGuid, IN  BOOL Enabled);
ReturnType=BOOL
ReturnValueDescription=FaxEnableRoutingMethodW - To Be Determined
Remarks=FaxEnableRoutingMethodW - To Be Determined
NumberOfParameters=3
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingGuid
ParameterType1=LPWSTR
ParameterDescr1=RoutingGuid - To be determined
ParameterName2=Enabled
ParameterType2=BOOL
ParameterDescr2=Enabled - To be determined

[FaxEnumJobsA]
Prototype=WINFAXAPI BOOL WINAPI FaxEnumJobsA( IN  HANDLE FaxHandle, OUT PFAX_JOB_ENTRYA *JobEntry, OUT LPDWORD JobsReturned);
ReturnType=BOOL
ReturnValueDescription=FaxEnumJobsA - To Be Determined
Remarks=FaxEnumJobsA - To be determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - to be determined
ParameterName1=JobEntry
ParameterType1=PFAX_JOB_ENTRYA *
ParameterDescr1=JobEntry - To be determined
ParameterName2=JobsReturned
ParameterType2=LPDWORD
ParameterDescr2=JobsReturned - To be determined

[FaxEnumJobsW]
Prototype=WINFAXAPI BOOL WINAPI FaxEnumJobsW( IN  HANDLE FaxHandle, OUT PFAX_JOB_ENTRYW *JobEntry, OUT LPDWORD JobsReturned);
ReturnType=BOOL
ReturnValueDescription=FaxEnumJobsW - To Be Determined
Remarks=FaxEnumJobsW - To be determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=JobEntry
ParameterType1=PFAX_JOB_ENTRYW *
ParameterDescr1=JobEntry - To be determined
ParameterName2=JobsReturned
ParameterType2=LPDWORD
ParameterDescr2=JobsReturned - To be determined

[FaxEnumPortsA]
Prototype=WINFAXAPI BOOL WINAPI FaxEnumPortsA( IN HANDLE FaxHandle, OUT PFAX_PORT_INFOA *PortInfo, OUT LPDWORD PortsReturned);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Enumerates all of the FAX devices attached to the FAX server. The port state information is returned for each device.
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=PortInfo
ParameterType1=PFAX_PORT_INFOA *
ParameterDescr1=Buffer to hold the port information
ParameterName2=PortsReturned
ParameterType2=LPDWORD
ParameterDescr2=The number of ports in the buffer

[FaxEnumPortsW]
Prototype=WINFAXAPI BOOL WINAPI FaxEnumPortsW( IN  HANDLE FaxHandle, OUT PFAX_PORT_INFOW *PortInfo, OUT LPDWORD PortsReturned);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Enumerates all of the FAX devices attached to the FAX server. The port state information is returned for each device.
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=PortInfo
ParameterType1=PFAX_PORT_INFOW *
ParameterDescr1=Buffer to hold the port information
ParameterName2=PortsReturned
ParameterType2=LPDWORD
ParameterDescr2=The number of ports in the buffer

[FaxEnumRoutingMethodsA]
Prototype=WINFAXAPI BOOL WINAPI FaxEnumRoutingMethodsA( IN  HANDLE FaxPortHandle, OUT PFAX_ROUTING_METHODA *RoutingMethod, OUT LPDWORD MethodsReturned);
ReturnType=BOOL
ReturnValueDescription=FaxEnumRoutingMethodsA - To Be Determined
Remarks=FaxEnumRoutingMethodsA - To Be Determined
NumberOfParameters=3
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingMethod
ParameterType1=PFAX_ROUTING_METHODA *
ParameterDescr1=RoutingMethod - To be determined
ParameterName2=MethodsReturned
ParameterType2=LPDWORD
ParameterDescr2=MethodsReturned - To be determined

[FaxEnumRoutingMethodsW]
Prototype=WINFAXAPI BOOL WINAPI FaxEnumRoutingMethodsW( IN  HANDLE FaxPortHandle, OUT PFAX_ROUTING_METHODW *RoutingMethod, OUT LPDWORD MethodsReturned);
ReturnType=BOOL
ReturnValueDescription=FaxEnumRoutingMethodsW - To Be Determined
Remarks=FaxEnumRoutingMethodsA - To Be Determined
NumberOfParameters=3
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingMethod
ParameterType1=PFAX_ROUTING_METHODW *
ParameterDescr1=RoutingMethod - To be determined
ParameterName2=MethodsReturned
ParameterType2=LPDWORD
ParameterDescr2=MethodsReturned - To be determined

[FaxFreeBuffer]
Prototype=WINFAXAPI VOID WINAPI FaxFreeBuffer( LPVOID Buffer);
ReturnType=VOID 
ReturnValueDescription=Frees a block of memory.
Remarks=Frees a block of memory.
NumberOfParameters=1
ParameterName0=Buffer
ParameterType0=LPVOID
ParameterDescr0=Points to a block of memory to be freed.

[FaxGetConfigurationA]
Prototype=WINFAXAPI BOOL WINAPI FaxGetConfigurationA( IN HANDLE FaxHandle, OUT PFAX_CONFIGURATIONA *FaxConfig);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Retrieves the FAX configuration from the FAX server. The SizeOfStruct in the FaxConfig argument MUST be set to a value=>= sizeof(FAX_CONFIGURATION).
NumberOfParameters=2
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=FaxConfig
ParameterType1=PFAX_CONFIGURATIONA *
ParameterDescr1=Pointer to a FAX_CONFIGURATIONA structure.

[FaxGetConfigurationW]
Prototype=WINFAXAPI BOOL WINAPI FaxGetConfigurationW( IN HANDLE FaxHandle, OUT PFAX_CONFIGURATIONW *FaxConfig);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Retrieves the FAX configuration from the FAX server. The SizeOfStruct in the FaxConfig argument MUST be set to a value=>= sizeof(FAX_CONFIGURATION).
NumberOfParameters=2
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=FaxConfig
ParameterType1=PFAX_CONFIGURATIONW *
ParameterDescr1=Pointer to a FAX_CONFIGURATIONW structure.

[FaxGetDeviceStatusA]
Prototype=WINFAXAPI BOOL WINAPI FaxGetDeviceStatusA( IN  HANDLE FaxPortHandle, OUT PFAX_DEVICE_STATUSA *DeviceStatus);
ReturnType=BOOL 
ReturnValueDescription=To Be Determined
Remarks=Obtains a status report for the FAX devices being used by the FAX server.
NumberOfParameters=2
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=DeviceStatus
ParameterType1=PFAX_DEVICE_STATUSA *
ParameterDescr1=DeviceStatus - To be determined

[FaxGetDeviceStatusW]
Prototype=WINFAXAPI BOOL WINAPI FaxGetDeviceStatusW( IN  HANDLE FaxPortHandle, OUT PFAX_DEVICE_STATUSW *DeviceStatus);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Obtains a status report for the FAX devices being used by the FAX server.
NumberOfParameters=2
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=DeviceStatus
ParameterType1=PFAX_DEVICE_STATUSW *
ParameterDescr1=DeviceStatus - To be determined

[FaxGetJobA]
Prototype=WINFAXAPI BOOL WINAPI FaxGetJobA( IN HANDLE FaxHandle, IN DWORD JobId, OUT PFAX_JOB_ENTRYA *JobEntry);
ReturnType=BOOL 
ReturnValueDescription=FaxGetJobA - To Be Determined
Remarks=FaxGetJobA - To be determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=JobId
ParameterType1=DWORD
ParameterDescr1=JobId - To be determined
ParameterName2=JobEntry
ParameterType2=PFAX_JOB_ENTRYA *
ParameterDescr2=JobEntry - To be determined

[FaxGetJobW]
Prototype=WINFAXAPI BOOL WINAPI FaxGetJobW( IN HANDLE FaxHandle, IN DWORD JobId, OUT PFAX_JOB_ENTRYW *JobEntry);
ReturnType=BOOL 
ReturnValueDescription=FaxGetJobW - To Be Determined
Remarks=FaxGetJobA - To be determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=JobId
ParameterType1=DWORD
ParameterDescr1=JobId - To be determined
ParameterName2=JobEntry
ParameterType2=PFAX_JOB_ENTRYW *
ParameterDescr2=JobEntry - To be determined

[FaxGetLoggingCategoriesA]
Prototype=WINFAXAPI BOOL WINAPI FaxGetLoggingCategoriesA( IN  HANDLE FaxHandle, OUT PFAX_LOG_CATEGORY *Categories, OUT LPDWORD NumberCategories);
ReturnType=BOOL 
ReturnValueDescription=FaxGetLoggingCategoriesA - To Be Determined
Remarks=FaxGetLoggingCategoriesA - To Be Determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=Categories
ParameterType1=PFAX_LOG_CATEGORY *
ParameterDescr1=Categories - To be determined
ParameterName2=NumberCategories
ParameterType2=LPDWORD
ParameterDescr2=NumberCategories - To be determined

[FaxGetLoggingCategoriesW]
Prototype=WINFAXAPI BOOL WINAPI FaxGetLoggingCategoriesW( IN  HANDLE FaxHandle, OUT PFAX_LOG_CATEGORY *Categories, OUT LPDWORD NumberCategories);
ReturnType=BOOL 
ReturnValueDescription=FaxGetLoggingCategoriesW - To Be Determined
Remarks=FaxGetLoggingCategoriesW - To Be Determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=Categories
ParameterType1=PFAX_LOG_CATEGORY *
ParameterDescr1=Categories - To be determined
ParameterName2=NumberCategories
ParameterType2=LPDWORD
ParameterDescr2=NumberCategories - To be determined

; TO BE ELIMINATED FROM THE API
;[FaxGetPageData]
;Prototype=WINFAXAPI BOOL WINAPI FaxGetPageData( IN HANDLE FaxHandle, IN DWORD JobId, OUT LPBYTE *Buffer, OUT LPDWORD BufferSize, OUT LPDWORD ImageWidth, OUT LPDWORD ImageHeight);
;ReturnType=BOOL 
;ReturnValueDescription=FaxGetPageData - To Be Determined
;Remarks=FaxGetPageData - To Be Determined
;NumberOfParameters=6
;ParameterName0=FaxHandle
;ParameterType0=HANDLE
;ParameterDescr0=FaxHandle - To be determined
;ParameterName1=JobId
;ParameterType1=DWORD
;ParameterDescr1=JobId - To be determined
;ParameterName2=Buffer
;ParameterType2=LPBYTE *
;ParameterDescr2=Buffer - To be determined
;ParameterName3=BufferSize
;ParameterType3=LPDWORD
;ParameterDescr3=BufferSize - To be determined
;ParameterName4=ImageWidth
;ParameterType4=LPDWORD
;ParameterDescr4=ImageWidth - To be determined
;ParameterName5=ImageHeight
;ParameterType5=LPDWORD
;ParameterDescr5=ImageHeight - To be determined

[FaxGetPortA]
Prototype=WINFAXAPI BOOL WINAPI FaxGetPortA( IN  HANDLE FaxPortHandle, OUT PFAX_PORT_INFOA *PortInfo);
ReturnType=BOOL 
ReturnValueDescription=ERROR_SUCCESS for success, otherwise a WIN32 error code.
Remarks=Returns port status information for a requested port. The device id passed in should be optained from FAXEnumPorts.
NumberOfParameters=2
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=PortInfo
ParameterType1=PFAX_PORT_INFOA *
ParameterDescr1=Buffer to hold the port information

[FaxGetPortW]
Prototype=WINFAXAPI BOOL WINAPI FaxGetPortW( IN  HANDLE FaxPortHandle, OUT PFAX_PORT_INFOW *PortInfo);
ReturnType=BOOL 
ReturnValueDescription=ERROR_SUCCESS for success, otherwise a WIN32 error code.
Remarks=Returns port status information for a requested port. The device id passed in should be optained from FAXEnumPorts.
NumberOfParameters=2
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=PortInfo
ParameterType1=PFAX_PORT_INFOW *
ParameterDescr1=Buffer to hold the port information

[FaxGetRoutingInfoA]
Prototype=WINFAXAPI BOOL WINAPI FaxGetRoutingInfoA( IN  HANDLE FaxPortHandle, IN  LPSTR RoutingGuid, OUT LPBYTE *RoutingInfoBuffer, OUT LPDWORD RoutingInfoBufferSize);
ReturnType=BOOL
ReturnValueDescription=FaxGetRoutingInfoA - To Be Determined
Remarks=FaxGetRoutingInfoA - To Be Determined
NumberOfParameters=4
Parametername0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingGuid
ParameterType1=LPSTR
ParameterDescr1=RoutingGuid - To be determined
ParameterName2=RoutingInfoBuffer
ParameterType2=LPBYTE *
ParameterDescr2=RoutingBuffer - To be determined
ParameterName3=RoutingInfoBufferSize
ParameterType3=LPDWORD
ParameterDescr3=RoutingInfoBufferSize - To be determined

[FaxGetRoutingInfoW]
Prototype=WINFAXAPI BOOL WINAPI FaxGetRoutingInfoW( IN  HANDLE FaxPortHandle, IN  LPWSTR RoutingGuid, OUT LPBYTE *RoutingInfoBuffer, OUT LPDWORD RoutingInfoBufferSize);
ReturnType=BOOL
ReturnValueDescription=FaxGetRoutingInfoW - To Be Determined
Remarks=FaxGetRoutingInfoW - To Be Determined
NumberOfParameters=4
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingGuid
ParameterType1=LPWSTR
ParameterDescr1=RoutingGuid - To be determined
ParameterName2=RoutingInfoBuffer
ParameterType2=LPBYTE *
ParameterDescr2=RoutingBuffer - To be determined
ParameterName3=RoutingInfoBufferSize
ParameterType3=LPDWORD
ParameterDescr3=RoutingInfoBufferSize - To be determined

[FaxInitializeEventQueue]
Prototype=WINFAXAPI BOOL WINAPI FaxInitializeEventQueue( IN  HANDLE FaxHandle, IN  HANDLE CompletionPort, IN  DWORD CompletionKey);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Initializes the client side event queue.  There can be one event queue initialized for each fax server that the client app is connected to.
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=CompletionPort
ParameterType1=HANDLE
ParameterDescr1=Handle of an existing completion port opened using CreateIoCompletionPort.
ParameterName2=CompletionKey
ParameterType2=DWORD
ParameterDescr2=A value that will be returned through the lpCompletionKey parameter of GetQueuedCompletionStaus.

; ELIMINATED FROM THE API
;[FaxOpenJob]
;Prototype=BOOL WINAPI FaxOpenJob( IN HANDLE FaxPortHandle, OUT LPHANDLE FaxJobHandle );
;ReturnType=BOOL 
;ReturnValueDescription=To Be Determined
;NumberOfParameters=2
;ParameterName0=FaxPortHandle
;ParameterType0=HANDLE
;ParameterName1=FaxJobHandle
;ParameterType1=LPHANDLE

[FaxOpenPort]
Prototype=WINFAXAPI BOOL WINAPI FaxOpenPort( IN  HANDLE FaxHandle, IN  DWORD DeviceId, IN  DWORD Flags, OUT LPHANDLE FaxPortHandle); 
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Opens a fax port for subsequent use in other fax APIs.
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=DeviceId
ParameterType1=DWORD
ParameterDescr1=Requested device id
ParameterName2=Flags
ParameterType2=DWORD
ParameterDescr2=To be determined
ParameterName3=FaxPortHandle
ParameterType3=LPHANDLE
ParameterDescr3=The resulting FAX port handle.

[FaxPrintCoverPageA]
Prototype=WINFAXAPI BOOL WINAPI FaxPrintCoverPageA( IN HDC hDC, IN LPSTR CoverPageName, IN BOOL ServerCoverPage, IN PFAX_COVERPAGE_INFOA CoverPageInfo);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Prints a coverpage into the printer DC provided.
NumberOfParameters=4
ParameterName0=hDC
ParameterType0=HDC
ParameterDescr0=Printer DC
ParameterName1=CoverPageName
ParameterType1=LPSTR
ParameterDescr1=Coverpage file name, no path or extension
ParameterName2=ServerCoverPage
ParameterType2=BOOL
ParameterDescr2=ServerCoverPage - To be determined
ParameterName3=CoverPageInfo
ParameterType3=PFAX_COVERPAGE_INFOA
ParameterDescr3=Cover page information

[FaxPrintCoverPageW]
Prototype=WINFAXAPI BOOL WINAPI FaxPrintCoverPageW( IN HDC hDC, IN LPWSTR CoverPageName, IN BOOL ServerCoverPage, IN PFAX_COVERPAGE_INFOW CoverPageInfo);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Prints a coverpage into the printer DC provided.
NumberOfParameters=4
ParameterName0=hDC
ParameterType0=HDC
ParameterDescr0=Printer DC
ParameterName1=CoverPageName
ParameterType1=LPWSTR
ParameterDescr1=Coverpage file name, no path or extension
ParameterName2=ServerCoverPage
ParameterType2=BOOL
ParameterDescr2=ServerCoverPage - To be determined
ParameterName3=CoverPageInfo
ParameterType3=PFAX_COVERPAGE_INFOW
ParameterDescr3=Cover page information

[FaxReceiveDocumentA]
Prototype=WINFAXAPI BOOL WINAPI FaxReceiveDocumentA( IN HANDLE FaxHandle, OUT LPSTR FileName, IN  DWORD FileNameSize, OUT LPHANDLE FaxJobHandle);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Receives a FAX document.
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=FileName
ParameterType1=LPSTR
ParameterDescr1=File name of the received fax.
ParameterName2=FileNameSize
ParameterType2=DWORD
ParameterDescr2=Size of the file name buffer.
ParameterName3=FaxJobHandle
ParameterType3=HANDLE
ParameterDescr3=FaxJobHandle - To be determined

[FaxReceiveDocumentW]
Prototype=WINFAXAPI BOOL WINAPI FaxReceiveDocumentW( IN HANDLE FaxHandle, OUT LPWSTR FileName, IN  DWORD FileNameSize, OUT LPHANDLE FaxJobHandle);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Receives a FAX document.
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=FileName
ParameterType1=LPWSTR
ParameterDescr1=File name of the received fax.
ParameterName2=FileNameSize
ParameterType2=DWORD
ParameterDescr2=Size of the file name buffer.
ParameterName3=FaxJobHandle
ParameterType3=HANDLE
ParameterDescr3=FaxJobHandle - To be determined

[FaxSendDocumentA]
Prototype=BOOL WINAPI FaxSendDocumentA( IN HANDLE FaxHandle, IN LPSTR FileName, IN PFAX_JOB_PARAMA JobParams, OUT LPDWORD FaxJobId );
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Sends a FAX document to the specified recipient. This is an asychronous operation. Use FaxReportStatus to determine when the send is completed.
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=FileName
ParameterType1=LPSTR
ParameterDescr1=File containing the TIFF-F FAX document.
ParameterName2=JobParams
ParameterType2=PFAX_JOB_PARAMA
ParameterDescr2=Pointer to FAX_JOB_PARAMA struct.
ParameterName3=FaxJobId
ParameterType3=LPDWORD
ParameterDescr3=FaxJobId - To be determined

[FaxSendDocumentW]
Prototype=WINFAXAPI BOOL WINAPI FaxSendDocumentW( IN HANDLE FaxHandle, IN LPWSTR FileName, IN PFAX_JOB_PARAMW JobParams, OUT LPDWORD FaxJobId);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Sends a FAX document to the specified recipient. This is an asychronous operation. Use FaxReportStatus to determine when the send is completed.
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FAX handle obtained from FaxConnectFaxServer.
ParameterName1=FileName
ParameterType1=LPWSTR
ParameterDescr1=File containing the TIFF-F FAX document.
ParameterName2=JobParams
ParameterType2=PFAX_JOB_PARAMW
ParameterDescr2=Pointer to FAX_JOB_PARAMW struct.
ParameterName3=FaxJobId
ParameterType3=LPDWORD
ParameterDescr3=FaxJobId - To be determined

[FaxSetConfigurationA]
Prototype=WINFAXAPI BOOL WINAPI FaxSetConfigurationA( IN HANDLE FaxHandle, IN PFAX_CONFIGURATIONA FaxConfig );
ReturnType=BOOL 
ReturnValueDescription=FaxSetConfigurationA - To Be Determined
Remarks=FaxSetConfigurationA - To Be Determined
NumberOfParameters=2
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=FaxConfig
ParameterType1=PFAX_CONFIGURATIONA
ParameterDescr1=FaxConfig - To be determined

[FaxSetConfigurationW]
Prototype=WINFAXAPI BOOL WINAPI FaxSetConfigurationW( IN HANDLE FaxHandle, IN PFAX_CONFIGURATIONW FaxConfig);
ReturnType=BOOL 
ReturnValueDescription=FaxSetConfigurationW - To Be Determined
Remarks=FaxSetConfigurationW - To Be Determined
NumberOfParameters=2
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=FaxConfig
ParameterType1=PFAX_CONFIGURATIONW
ParameterDescr1=FaxConfig - To be determined

[FaxSetJobA]
Prototype=WINFAXAPI BOOL WINAPI FaxSetJobA( IN HANDLE FaxHandle, IN DWORD JobId, IN DWORD Command, IN PFAX_JOB_ENTRYA JobEntry);
ReturnType=BOOL 
ReturnValueDescription=FaxSetJobA - To Be Determined
Remarks=FaxSetJobA - To be determined
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=JobId
ParameterType1=DWORD
ParameterDescr1=JobId - To be determined
ParameterName2=Command
ParameterType2=DWORD
ParameterDescr2=Command - To be determined
ParameterName3=JobEntry
ParameterType3=PFAX_JOB_ENTRYA
ParameterDescr3=JobEntry - To be determined

[FaxSetJobW]
Prototype=WINFAXAPI BOOL WINAPI FaxSetJobW( IN HANDLE FaxHandle, IN DWORD JobId, IN DWORD Command, IN PFAX_JOB_ENTRYW JobEntry);
ReturnType=BOOL 
ReturnValueDescription=FaxSetJobW - To Be Determined
Remarks=FaxSetJobW - To be determined
NumberOfParameters=4
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=JobId
ParameterType1=DWORD
ParameterDescr1=JobId - To be determined
ParameterName2=Command
ParameterType2=DWORD
ParameterDescr2=Command - To be determined
ParameterName3=JobEntry
ParameterType3=PFAX_JOB_ENTRYW
ParameterDescr3=JobEntry - To be determined

[FaxSetLoggingCategoriesA]
Prototype=WINFAXAPI BOOL WINAPI FaxSetLoggingCategoriesA( IN  HANDLE FaxHandle, IN  PFAX_LOG_CATEGORY Categories, IN  DWORD NumberCategories);
ReturnType=BOOL 
ReturnValueDescription=FaxHandle - To Be Determined
Remarks=FaxSetLoggingCategoriesA - To be determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=Categories
ParameterType1=PFAX_LOG_CATEGORY
ParameterDescr1=Categories - To be determined
ParameterName2=NumberCategories
ParameterType2=DWORD
ParameterDescr2=NumberCategories - To be determined

[FaxSetLoggingCategoriesW]
Prototype=WINFAXAPI BOOL WINAPI FaxSetLoggingCategoriesW( IN  HANDLE FaxHandle, IN  PFAX_LOG_CATEGORY Categories, IN  DWORD NumberCategories);
ReturnType=BOOL 
ReturnValueDescription=FaxHandle - To Be Determined
Remarks=FaxSetLoggingCategoriesW - To be determined
NumberOfParameters=3
ParameterName0=FaxHandle
ParameterType0=HANDLE
ParameterDescr0=FaxHandle - To be determined
ParameterName1=Categories
ParameterType1=PFAX_LOG_CATEGORY
ParameterDescr1=Categories - To be determined
ParameterName2=NumberCategories
ParameterType2=DWORD
ParameterDescr2=NumberCategories - To be determined

[FaxSetPortA]
Prototype=WINFAXAPI BOOL WINAPI FaxSetPortA( IN  HANDLE FaxPortHandle, IN  PFAX_PORT_INFOA PortInfo);
ReturnType=BOOL 
ReturnValueDescription=ERROR_SUCCESS for success, otherwise a WIN32 error code.
Remarks=Changes the port capability mask.  This allows the caller to enable or disable sending & receiving on a port basis.
NumberOfParameters=2
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=PortInfo
ParameterType1=PFAX_PORT_INFOA
ParameterDescr1=PortInfo - To be determined

[FaxSetPortW]
Prototype=WINFAXAPI BOOL WINAPI FaxSetPortW( IN  HANDLE FaxPortHandle, IN  PFAX_PORT_INFOW PortInfo);
ReturnType=BOOL 
ReturnValueDescription=ERROR_SUCCESS for success, otherwise a WIN32 error code.
Remarks=Changes the port capability mask.  This allows the caller to enable or disable sending & receiving on a port basis.
NumberOfParameters=2
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName2=PortInfo
ParameterType2=PFAX_PORT_INFOW
ParameterDescr1=PortInfo - To be determined

[FaxSetRoutingInfoA]
Prototype=WINFAXAPI BOOL WINAPI FaxSetRoutingInfoA( IN  HANDLE FaxPortHandle, IN  LPSTR RoutingGuid, IN  LPBYTE RoutingInfoBuffer, IN  DWORD RoutingInfoBufferSize);
ReturnType=BOOL
ReturnValueDescription=FaxSetRoutingInfoA - To Be Determined
Remarks=FaxSetRoutingInfoA - To Be Determined
NumberOfParameters=4
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingGuid
ParameterType1=LPSTR
ParameterDescr1=RoutingGuid - To be determined
ParameterName2=RoutingInfoBuffer
ParameterType2=LPBYTE
ParameterDescr2=RoutingInfoBuffer - To be determined
ParameterName3=RoutingInfoBufferSize
ParameterType3=DWORD
ParameterDescr3=RoutingInfoBufferSize - To be determined

[FaxSetRoutingInfoW]
Prototype=WINFAXAPI BOOL WINAPI FaxSetRoutingInfoW( IN  HANDLE FaxPortHandle, IN  LPWSTR RoutingGuid, IN  LPBYTE RoutingInfoBuffer, IN  DWORD RoutingInfoBufferSize);
ReturnType=BOOL
ReturnValueDescription=FaxSetRoutingInfoW - To Be Determined
Remarks=FaxSetRoutingInfoW - To Be Determined
NumberOfParameters=4
ParameterName0=FaxPortHandle
ParameterType0=HANDLE
ParameterDescr0=FaxPortHandle - To be determined
ParameterName1=RoutingGuid
ParameterType1=LPWSTR
ParameterDescr1=RoutingGuid - To be determined
ParameterName2=RoutingInfoBuffer
ParameterType2=LPBYTE
ParameterDescr2=RoutingInfoBuffer - To be determined
ParameterName3=RoutingInfoBufferSize
ParameterType3=DWORD
ParameterDescr3=RoutingInfoBufferSize - To be determined

[FaxStartPrintJobA]
Prototype=WINFAXAPI BOOL WINAPI FaxStartPrintJobA( IN  LPSTR PrinterName, IN  PFAX_PRINT_INFOA PrintInfo, OUT LPDWORD FaxJobId, OUT HDC *FaxDeviceContext);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Starts a print job for the specified printer. This function provides functionality beyond what the caller can provide by using StartDoc(). This function disables the display of the fax send wizard and also passes along the information that would otherwise be gathered by the fax wizard ui.
NumberOfParameters=4
ParameterName0=PrinterName
ParameterType0=LPSTR
ParameterDescr0=Fax printer name (must be a fax printer)
ParameterName1=PrintInfo
ParameterType1=PFAX_PRINT_INFOA
ParameterDescr1=Fax print information
ParameterName2=FaxJobId
ParameterType2=LPDWORD
ParameterDescr2=Job id of the resulting print job
ParameterName3=FaxDeviceContext
ParameterType3=HDC *
ParameterDescr3=Points to the Handle to the newly created device context

[FaxStartPrintJobW]
Prototype=WINFAXAPI BOOL WINAPI FaxStartPrintJobW( IN  LPWSTR PrinterName, IN  PFAX_PRINT_INFOW PrintInfo, OUT LPDWORD FaxJobId, OUT HDC *FaxDeviceContext);
ReturnType=BOOL 
ReturnValueDescription=TRUE indicates Success. FALSE indicates Failure. Call GetLastError() for more information.
Remarks=Starts a print job for the specified printer. This function provides functionality beyond what the caller can provide by using StartDoc(). This function disables the display of the fax send wizard and also passes along the information that would otherwise be gathered by the fax wizard ui.
NumberOfParameters=4
ParameterName0=PrinterName
ParameterType0=LPWSTR
ParameterDescr0=Fax printer name (must be a fax printer)
ParameterName1=PrintInfo
ParameterType1=PFAX_PRINT_INFOW
ParameterDescr1=Fax print information
ParameterName2=FaxJobId
ParameterType2=LPDWORD
ParameterDescr2=Job id of the resulting print job
ParameterName3=FaxDeviceContext
ParameterType3=HDC *
ParameterDescr3=Points to the Handle to the newly created device context
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\frd.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Email Template Title _PID_GUIDEmail Template C. Brent Thomas Email.dot C. Brent Thomas Microsoft Word 8.03WJA|3WJA|28 May, 1997 Rev 0 Fax API Browser Functional Requirements This document lists the requirements for the Fax API Browser. The Fax API Browser shall present information related to the calling conventions for each Fax API function to the user. At any time, the Fax API Browser user shall be able to choose a single Fax API function about which the following information shall be presented: Return Value If the selected Fax API function returns a value the following information shall be presented at the time that the Fax API function is selected: The data type of the value returned by the selected Fax API function shall be presented. Return Value Description A textual description of the value returned by the selected Fax API function shall be presented. Fax API Function Parameters If the selected Fax API function accepts parameters the following information shall be presented at the time that the Fax API function is selected: Parameter Names The Fax API Browser shall present a list of all parameter names for the selected Fax API function. At any time, the Fax API Browser user shall be able to select a single parameter about which the following information shall be presented. The data type of the selected parameter shall be presented. Value The value of the selected parameter shall be presented. Valid Range The range of valid values for the selected parameter shall be presented. Description A textual description of the selected parameter shall be presented. At any time the Fax API Browser user shall be able to select a single Fax API function and cause it to be executed. Before Execution of the Fax API function Fax API Function Parameters Supplied by User If the selected Fax API function accepts parameters, the user shall be able to supply parameter values for each execution of the selected Fax API function. Default If the selected Fax API function accepts parameters and the user elects not to supply a value for any parameter for any execution of any Fax API function, a default value shall be supplied for that parameter. After Execution of the Fax API function The Fax API Browser shall display the value returned by each Fax API function. The Fax API Browser shall display any parameters modified by a call to each Fax API function.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxsiren\readme.txt ===
This is a fax routing extension SDK sample.  To make this routing extension work, you should:

1) copy the executable faxsiren.dll to %systemroot%\system32
2) execute "regsvr32 %systemroot%\system32\faxsiren.dll"

This routing extension contains one routing method which copies a file to a specified directory, sets a 
named event, and then beeps.  An application running in a different process could wait on this named event
to be signalled and then do something.  This illustrates one possible framework to do tasks in the execution context
of the fax service as well as out of it's execution context.

Note that this extension doesn't save per-device configuration information, or persistent global routing information
for that matter.  It is recommended that if you have per device configuration which you want the user to modify, then
you allow provide an MMC snapin extension which extends the fax service device node with a property sheet.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\readme.txt ===
this is a sample fax service provider that allows
faxes to be sent and received thru a netcentric
fax service.

to build this code it is assumed that you have
microsoft vc++ version 4.x or 5.0, microsoft
win32 sdk, and the netcentric fax sdk.  before
you run nmake you must have run the setenv.bat
file in your mstools directory and you must have
an environment variable named ncsdk set to the
root of your netcentric sdk installation.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\newfsp.txt ===
newfsp.dll is a sample Windows NT Fax virtual service provider.


How to install:
"regsvr32 newfsp.dll"


Configuration:
The newfsp configuration settings are found under 
"NewFsp: Sample Windows NT Fax Service Provider" 
in the registry under the Fax Device Providers key.

The available configuration settings are:
 - LoggingEnabled:   0 - logging disabled, 1 - logging enabled
      This is initially set to 0
 - LoggingDirectory: A valid directory
      This is initially set to the directory from which
      "regsvr32 newfsp.dll" was run

The newfsp device settings are found under
"Devices\<Device Id>" in the registry under the
newfsp key.

The available configuration settings are:
 - Directory: A valid directory
      This is initially set to the directory from which
      "regsvr32 newfsp.dll" was run


To send a fax:
Set the fax number to "Dial exactly as typed" and
specify a valid directory; e.g. "C:\temp".  The fax
will be copied to that directory.


To receive a fax:
Change the file attributes of a file in the directory
associated with the device.  The first tiff file found
in that directory will be copied to the received fax.


Limitations:
There is minimal directory validation.
There is no tiff validation.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\readme.txt ===
newfsp.dll is a sample Windows NT Fax virtual service provider.


How to install:
"regsvr32 newfsp.dll"


Configuration:
The newfsp configuration settings are found under 
"NewFsp: Sample Windows NT Fax Service Provider" 
in the registry under the Fax Device Providers key.

The available configuration settings are:
 - LoggingEnabled:   0 - logging disabled, 1 - logging enabled
      This is initially set to 0
 - LoggingDirectory: A valid directory
      This is initially set to the directory from which
      "regsvr32 newfsp.dll" was run

The newfsp device settings are found under
"Devices\<Device Id>" in the registry under the
newfsp key.

The available configuration settings are:
 - Directory: A valid directory
      This is initially set to the directory from which
      "regsvr32 newfsp.dll" was run


To send a fax:
Set the fax number to "Dial exactly as typed" and
specify a valid directory; e.g. "C:\temp".  The fax
will be copied to that directory.


To receive a fax:
Change the file attributes of a file in the directory
associated with the device.  The first tiff file found
in that directory will be copied to the received fax.


Limitations:
There is minimal directory validation.
There is no tiff validation.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\simple\readme.txt ===
simple
======
This C/C++ sample illustrates the use of FaxConnectFaxServer, FaxCompleteJobParams, 
and FaxSendDocument.

Furthermore, it illustrates the use of an IO Completion Port to retrieve real-time status
for a fax server.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\readme.txt ===
PrintSdi -- this sample illustrates how you can use the fax api in a typical 
SDI MFC application.  Note that File/Fax is an over-ride for File/Print, with a
simpler dialog than the complete send wizard.

This illustrates the use of FaxStartPrintJob.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\stress\faxstres.ini ===
[General]
MessageType=Printer

[Documents]
Document1=faxstres.txt

[Receipient1]
Name=wesw,foobar
Number=65745,65738
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\stress\faxstres.txt ===
This is a test document.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\testprov\readme.txt ===
this directory contains code for a test device provider.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\faxprob.txt ===
Microsoft Personal Fax Technology Preview for Windows NT(TM) Workstation 4.0
Problem Report Template	        
(Please see instructions below to submit this report) 

Name                           : 
Company                        : 
Area Code & Phone              : 

Email Address                  :
Country (if outside the U.S.)  :
Language Version               :

***** PROBLEM INFORMATION ******

Product Release      :  
(Type "winver" at the command line while Windows NT is running.)

Install Type         : < >Upgrade from: 
		       < >Clean Install


PROBLEM TITLE: 
[Please replace this line with a one-line summary of the issue]

PROBLEM DESCRIPTION: Please provide a complete description of 
the problem, circumstances, and any actions you may have taken.
----------------------------------------------------------------------




PROBLEM OCCURS: 
< >Always < >Sometimes < >Didn't happen again < >Didn't try it again

STEP BY STEP INSTRUCTIONS we can follow to reproduce the problem here:
Please be explicit and complete, if we cannot reproduce the problem
here, the issue may not be resolved in the next release.
  1. 
  2. 
  3.
  4.



**** BASIC CONFIGURATION ****

Computer brand & model			    :
  Bus Architecture (check all that apply)			                           
  < >ISA < >EISA < >MCA < >VESA < >PCI 
  < >RISC < > PCMCIA (PC CARD) < >Other:

System BIOS (manufacturer & version/date)   : 
CPU(s) (type, speed and manufacturer)       : 
Memory (RAM)                                : 
Mouse model & type (PS-2/serial/bus) (COM/IRQ)  : 
Sound Card (model/address/IRQ)              : 
Communications Modem (model/address/IRQ)    : 
Other adapters (scanner/PC CARD)            : 


****** FAX/MODEM CONFIGURATION *****
Fax/Modem manufacturer <                  >
Fax/Modem model        <                  >

Fax Board
< > None  < > Brooktrout < > GammaLink
< > Natural Microsystems < > PureData
<            > Other

****** VIDEO CONFIGURATION ******
Video adapter                   : 
  < > ISA  < > EISA  < > PCI  < > VESA  < > MCA
Video memory
  < > 512Kb  < > 1Mb  < > 2Mb  < > 4Mb  < > 8Mb
Video driver                    :
Video resolution                : < >640x480    < >800x600 
				  < >1024x768   < >1280x1024
				  < > Other: 
Color depth                     : < >16 colors  < >256 colors 
				  < >64K        < >16.7 million
				  < >True color < >Other: 


****** HARD DISK CONFIGURATION ******
For each hard drive, list the following:

Drive:
   < >IDE  [Enter model name] 
     < > Master  < > Slave
     < > Primary IDE channel  < > Secondary
   < >SCSI [Enter model name & SCSI id #]
     Disk controller:
  Partitions:
    Letter:     File System: < > Fat < > NTFS  Size: 
    Letter:     File System: < > Fat < > NTFS  Size:
  
****** CD-ROM CONFIGURATION ******
CD-ROM drive brand & model   : 
Is this a CD changer? < >  # of discs:____

  < > SCSI  [ID#] < > OTHER 
      Terminated < > Yes  < > No

  < > IDE/ATAPI
     < > Master  < > Slave
     < > Primary IDE channel  < > Secondary

Controlling adapter (Address and IRQ): 


****** NETWORK CONFIGURATION ******
Network card type, IRQ & address: 
Network protocol(s)             : 

Network cabling                 : 
Novell Server version           :       number of users:

****** PRINTER CONFIGURATION ******
Printer brand & model           : 
Printer Port: < >LPT1 < >LPT2 < >COM1 < >COM2 < >File < >Network
Driver                          :
Memory                          :
Printer cartridges              : 


How To Submit This Report
=========================
Please e-mail this form to ntbug@microsoft.com and use the word FAX on the subject line.
Note: this is not a support mechanism, and you are not guaranteed a response.
Please send mail to ntbug@microsoft.com if you require an ftp location, 
or have any other questions or comments regarding the problem report process.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\faxinfo.txt ===
----------------------------------------------------------
            Microsoft Personal Fax for Windows
                      October 1996
----------------------------------------------------------
        (c) Copyright Microsoft Corporation, 1996


Contents
   What Is Personal Fax for Windows?
   Sending Faxes
   Receiving Faxes
   Setting Up Your Modem and Configuring Your Workstation Fax
   Where Do I Go From Here?
   Getting Help

----------------------------------------------------------
What Is Personal Fax for Windows?
----------------------------------------------------------

Personal Fax for Windows is a program you use to send and 
receive faxes from a computer running Windows NT Workstation. 
Personal Fax for Windows converts all outgoing and incoming 
faxes to .TIF-formatted files, which you can print or view 
and store online.
 
Think of your fax modem or other fax device as a printer. 
You send faxes in the same way you print ordinary documents.
 
Note: Personal Fax for Windows supports one fax device at 
a time. Other networked users cannot send or receive faxes 
through your computer.

----------------------------------------------------------
Sending Faxes
----------------------------------------------------------

You can send a fax in any of three ways:

x	You can fax an open document directly from its 
	application simply by selecting your fax printer as 
	your target printer. On the File menu of the application, 
	click Print (or Send), and the Fax Send Utility opens 
	to guide you through each step. Its easy.

x	You can use the Fax Send Utility (Start/Programs/Fax) to
	create your fax on-the-fly. Use this method only when you do 
	not need to include file attachments.

x	You can send a fax from Exchange using special fax 
	addresses you define in your personal address book. When you 
	select a recipient whose address is a fax address, the e-mail 
	that you type becomes your fax. Using Exchange, you can 
	simultaneously send a message to both fax and e-mail 
	recipients. You can also include file attachments within the 
	messages. A copy of each fax you send is stored in the Sent 
	folder, just as e-mail messages are.

Regardless of the method you use to send your fax, youll 
automatically be notified by e-mail whether or not your fax 
transmission was successful.

You can also archive copies of all outgoing faxes in a designated 
folder on your hard disk. 

Personal Fax for Windows provides several standard cover pages and 
a handy cover-page editor you can use to create or modify your own. 

----------------------------------------------------------
Receiving Faxes
----------------------------------------------------------

To view a received fax online, use the Fax Document Viewer 
(Start/Programs/Fax). You can combine any of the following methods 
for dealing with the faxes you receive.

x	You can automatically route all incoming faxes to a folder on 
	your computer or on another networked computer.

x	You can automatically print each fax upon arrival.

x	You can automatically receive faxes as mail messages in your 
	Exchange Inbox.

----------------------------------------------------------
Setting Up Your Modem and Configuring Your Workstation Fax
----------------------------------------------------------

First, install your fax modem in your computer according to the 
manufacturers instructions. Please see the release notes for 
a list of supported modems.

Personal Fax For Windows adds a Fax properties application to your 
Control Panel (Start/Settings/Control Panel).
 
Next, use the Fax properties application to specify fax settings, 
such as:

x	Your name, fax number, and other personal information you 
	want to include on the cover pages of outgoing faxes.

x	Paper size, image quality, and page orientation.

x	The number of times you want the modem to redial after 
	an unsuccessful call attempt, and the interval between 
	redials.

x	How you want to handle incoming faxes.

x	Whether to send the fax immediately or at another time, 
	such as during off-peak hours when usage and long-distance 
	phone rates are lower.

x	The cover page you want to use. 

x	The logging-priority level for successful and unsuccessful 
	fax events. You can view fax events in the Event Viewer, 
	which you can find under Start/Programs/Administrator Tools.

----------------------------------------------------------
Where Do I Go From Here?
----------------------------------------------------------

Setting up Personal Fax for Windows adds the following items to 
your Start menu, under Programs in a new Fax group:

x	Cover Page Editor
x	Fax Configuration
x	Fax Document Viewer
x	Fax Send Utility
x	Help
x	Problem Reporting Form
x	Read Me First
x	Release Notes

Setup also adds the Fax properties application to your Control 
Panel.

>>>	To start the Fax properties application

	1.	Click Start, point to Programs, and then point to Fax.
	2.	Click Configuration.

	Note: You can also double-click Fax in 
	Control Panel.

----------------------------------------------------------
Getting Help
----------------------------------------------------------

Personal Fax for Windows provides two ways to get help: a 
complete online Help system and context-sensitive Help.

Online Help provides step-by-step guidance for faxing tasks.

>>>  To open online Help
	1.	On the desktop, double-click My Computer.
	2.	On the Help menu, click Help Topics.
	3.	Click the Index tab.
	4.	Type:
		fax procedures
	5.	Click OK.

Context-sensitive Help explains options in the Fax Configuration 
utility interface.

>>>  To use context-sensitive Help
	1.	If necessary, click Start, point to Settings, and 
		click Control Panel; then double-click Fax 
		Configuration.
	2.	Click the ? button in the upper-right corner of the 
		dialog box.
	3.	Point to the item in the dialog you want described 
		and click.

	Note: You can also right-click the item and then click 
	Whats This?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\faxeula.txt ===
IMPORTANT. This license agreement supersedes any other license agreement provided with the software.

Read this Microsoft License Agreement before installing this software.  By installing this software, you indicate your acceptance of this Microsoft License Agreement.

MICROSOFT LICENSE AGREEMENT
Microsoft Fax Beta Code for Microsoft Windows NT Workstation version 4.0

        1.      LICENSE RIGHTS AND RESTRICTIONS. Microsoft Corporation ("Microsoft") grants to you the non-exclusive, non-assignable right to use the enclosed Microsoft beta software in object code form (the "MS Code") only in conjunction with validly licensed copies of Microsoft Windows NT version 4.0 solely for your internal use and evaluation.  You may make copies for use on all computers on your premises for which you have licensed Microsoft Windows NT 4.0 as described above. The MS Code shall not be copied or used for any other purpose.  You may not reverse engineer, decompile, or disassemble the MS Code, except to the extent that the foregoing restriction is expressly prohibited by applicable law.  You may not rent or lease the MS Code, or otherwise transfer the MS Code and accompanying written materials.  You may not disclose the results of any benchmark testing of the MS Code to any third party without Microsoft's prior written permission.  All rights not expressly granted are reserved by Microsoft.

        2.      PRELIMINARY CODE.  The MS Code provided herein is beta code and not at the level of functionality, performance and compatibility of the final, generally available product offering.  The code may be substantially modified prior to first commercial shipment.

        3.      NO WARRANTIES.   The MS Code and accompanying written materials are provided "as is", without warranty of any kind.  To the maximum extent permitted by law, Microsoft disclaims all warranties, either express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose and noninfringment. The entire risk arising out of the use or performance of the MS Code and any accompanying written materials remains with you.

        4.      NO LIABILITY FOR CONSEQUENTIAL DAMAGES.  To the maximum extent permitted by applicable law: in no event shall Microsoft or its suppliers be liable for any damages whatsoever (including, without limitation, damages for loss of business profits, business interruption, loss of business information, or other pecuniary loss) arising out of the use of or inability to use the MS Code, even if Microsoft has been advised of the possibility of such damages.  Because some states/jurisdictions do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to you.

        5.      TERMINATION.  Microsoft may terminate this agreement in writing at any time with or without cause.  This Agreement shall terminate without notice upon the commercial release of the MS Code.  Upon termination of this Agreement for any reason, you shall immediately return, or certify destruction of, all full or partial copies of the MS Code and all other materials provided by Microsoft.

        6.      MISCELLANEOUS.  If you acquired this product in the United States, this Agreement is governed by the laws of the State of Washington.  If you acquired this product outside the United States, local law may apply.  If either party employs attorneys to enforce any rights arising out of or relating to this Agreement, the prevailing party shall be entitled to recover reasonable attorneys fees, costs and expenses.

        7.      U.S. GOVERNMENT RESTRICTED RIGHTS.  Any software and documentation provided under this Agreement is provided with RESTRICTED RIGHTS.  Use, duplication, or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial Computer Software -- Restricted Rights at 48 CFR 52.227-19, as applicable.  Manufacturer is Microsoft Corporation, One Microsoft Way, Redmond, WA  98052-6399.

        8.      EXPORT RESTRICTIONS. You agree that you will not export or re-export the MS Code to any country, person, entity or end user subject to U.S.A. export restrictions.  Restricted countries currently include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Syria, and the Federal Republic of Yugoslavia (Serbia and Montenegro, U.N. Protected Areas and areas of Republic of Bosnia and Herzegovina under the control of Bosnian Serb forces).  You warrant and represent that neither the U.S.A. Bureau of Export Administration nor any other federal agency has suspended, revoked or denied your export privileges.

02/23/94    LE930320.008

^
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\unattend.txt ===
[version]
signature="$WINDOWS NT$"

;
;-------------------------------------------------------------------------------
; Sample Fax Unattend File
;-------------------------------------------------------------------------------
;
; Valid Keywords:
;
;     FaxPrinterName    Name of the local fax printer (string)
;     FaxNumber         Fax phone number (string)
;     RoutePrinterName  Printer name to print received faxes (string)
;     RouteProfileName  Outlook profile to store received faxes (string)
;     RouteFolderName   Folder to store received faxes (string)
;     Csid              Calling station identifier (string)
;     Tsid              Transmitting station identifier (string)
;     Rings             Number of ring before answering fax call (integer)
;     RouteToPrinter    Should received faxes be printed? (boolean)
;     RouteToInbox      Should received faxes be stored in outlook? (boolean)
;     RouteToFolder     Should received faxes be stored in a folder? (boolean)
;
; Data Types:
;
;     string            text, should be bounded by double quotes
;     integer           positive number
;     boolean           yes/no or true/false
;
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
;


[Fax Unattend]
FaxPrinterName="My Fax Printer"
FaxNumber="(425) 555-1212"
RoutePrinterName="Printer Name"
RouteProfileName="Profile"
RouteFolderName="Folder"
Csid="Fax"
Tsid="fax"
Rings=2
RouteToPrinter=false
RouteToInbox=false
RouteToFolder=yes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\setup\faxeula.txt ===
IMPORTANT. This license agreement supersedes any other license agreement provided with the software.

Read this Microsoft License Agreement before installing this software.  By installing this software, you indicate your acceptance of this Microsoft License Agreement.

MICROSOFT LICENSE AGREEMENT
Microsoft Fax Beta Code for Microsoft Windows NT Workstation version 4.0

        1.      LICENSE RIGHTS AND RESTRICTIONS. Microsoft Corporation ("Microsoft") grants to you the non-exclusive, non-assignable right to use the enclosed Microsoft beta software in object code form (the "MS Code") only in conjunction with validly licensed copies of Microsoft Windows NT version 4.0 solely for your internal use and evaluation.  You may make copies for use on all computers on your premises for which you have licensed Microsoft Windows NT 4.0 as described above. The MS Code shall not be copied or used for any other purpose.  You may not reverse engineer, decompile, or disassemble the MS Code, except to the extent that the foregoing restriction is expressly prohibited by applicable law.  You may not rent or lease the MS Code, or otherwise transfer the MS Code and accompanying written materials.  You may not disclose the results of any benchmark testing of the MS Code to any third party without Microsoft's prior written permission.  All rights not expressly granted are reserved by Microsoft.

        2.      PRELIMINARY CODE.  The MS Code provided herein is beta code and not at the level of functionality, performance and compatibility of the final, generally available product offering.  The code may be substantially modified prior to first commercial shipment.

        3.      NO WARRANTIES.   The MS Code and accompanying written materials are provided "as is", without warranty of any kind.  To the maximum extent permitted by law, Microsoft disclaims all warranties, either express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose and noninfringment. The entire risk arising out of the use or performance of the MS Code and any accompanying written materials remains with you.

        4.      NO LIABILITY FOR CONSEQUENTIAL DAMAGES.  To the maximum extent permitted by applicable law: in no event shall Microsoft or its suppliers be liable for any damages whatsoever (including, without limitation, damages for loss of business profits, business interruption, loss of business information, or other pecuniary loss) arising out of the use of or inability to use the MS Code, even if Microsoft has been advised of the possibility of such damages.  Because some states/jurisdictions do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to you.

        5.      TERMINATION.  Microsoft may terminate this agreement in writing at any time with or without cause.  This Agreement shall terminate without notice upon the commercial release of the MS Code.  Upon termination of this Agreement for any reason, you shall immediately return, or certify destruction of, all full or partial copies of the MS Code and all other materials provided by Microsoft.

        6.      MISCELLANEOUS.  If you acquired this product in the United States, this Agreement is governed by the laws of the State of Washington.  If you acquired this product outside the United States, local law may apply.  If either party employs attorneys to enforce any rights arising out of or relating to this Agreement, the prevailing party shall be entitled to recover reasonable attorneys fees, costs and expenses.

        7.      U.S. GOVERNMENT RESTRICTED RIGHTS.  Any software and documentation provided under this Agreement is provided with RESTRICTED RIGHTS.  Use, duplication, or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial Computer Software -- Restricted Rights at 48 CFR 52.227-19, as applicable.  Manufacturer is Microsoft Corporation, One Microsoft Way, Redmond, WA  98052-6399.

        8.      EXPORT RESTRICTIONS. You agree that you will not export or re-export the MS Code to any country, person, entity or end user subject to U.S.A. export restrictions.  Restricted countries currently include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Syria, and the Federal Republic of Yugoslavia (Serbia and Montenegro, U.N. Protected Areas and areas of Republic of Bosnia and Herzegovina under the control of Bosnian Serb forces).  You warrant and represent that neither the U.S.A. Bureau of Export Administration nor any other federal agency has suspended, revoked or denied your export privileges.

02/23/94    LE930320.008

^
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\common\baseaddr.txt ===
; COMPONENT	BASE ADDRESS	SIZE
awadpr32.exe	0x69000000	0x40000
awbmsc32.dll	0x69040000	0x40000
awbtrv32.dll	0x69080000	0x40000
awcapi32.dll	0x690C0000	0x40000
awcl1_32.dll	0x69100000	0x40000
awcl2_32.dll	0x69140000	0x40000
awcodc32.dll	0x69180000	0x40000
awdcxc32.dll	0x691C0000	0x40000
awdevl32.dll	0x69200000	0x40000
rndsrv32.dll	0x69240000	0x40000
awfext32.dll	0x69280000	0x40000
awfmon32.dll	0x692C0000	0x40000
awfr32.dll	0x69300000	0x40000
awfxab32.dll	0x69340000	0x40000
awfxcg32.dll	0x69380000	0x40000
awfxex32.exe	0x693C0000	0x40000
awfxio32.dll	0x69400000	0x40000
awfxrn32.dll	0x69440000	0x40000
awkrnl32.dll	0x69480000	0x40000
awlft332.dll	0x694C0000	0x40000
awlhut32.dll	0x69500000	0x40000
awlinz32.dll	0x69540000	0x40000
awlzrd32.dll	0x69580000	0x40000
awnfax32.dll	0x695C0000	0x40000
awpwd32.dll	0x69600000	0x40000
awramb32.dll	0x69640000	0x40000
awrbae32.dll	0x69680000	0x40000
awresx32.dll	0x696C0000	0x40000
awrndr32.dll	0x69700000	0x40000
awschd32.dll	0x69740000	0x40000
awsnto32.exe	0x69780000	0x40000
awsrvr32.dll	0x697C0000	0x40000
awt30_32.dll	0x69800000	0x40000
awutil32.dll	0x69840000	0x40000
awview32.dll	0x69880000	0x40000
faxcover.exe	0x698C0000	0x40000
faxview.exe	0x69900000	0x40000
awfaxp32.dll	0x69940000	0x50000

; IFAX Connectivity Components
awmon32.dll	0x69C00000	0x40000
awnp32.dll	0x69C40000	0x40000
awpp32.dll	0x69C80000	0x40000
awnet32.dll	0x69CC0000	0x40000
awrpc32.dll	0x69D00000	0x40000
psicomm32.dll	0x69D40000	0x40000

; Test applications we might build but don't ship...
awbrowse.exe	0x10000000	0x40000
generic.exe	0x10000000	0x40000
rendtest.exe	0x10000000	0x40000
tatemsg.exe	0x10000000	0x40000
uitest32.exe	0x10000000	0x40000
testapp.exe	0x10000000	0x40000
rbavu32.exe	0x10000000	0x40000
lztest32.exe	0x10000000	0x40000
awmcfg32.dll	0x10000000	0x40000
awtest.exe	0x10000000	0x40000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\placefil.txt ===
migrate.dll     win9xmig\fax
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\faxrelnt.txt ===
----------------------------------------------------
Release Notes for Microsoft Personal Fax for Windows
October, 1996
----------------------------------------------------

CONTENTS

1. Using the same modem for a Remote Access Server and Faxing
2. If You've Changed Your Fax Administrator Account Password
3. To Disable Event Logging for Fax Events
4. "Could Not Process All Attachments" Error Message
5. If You Can't Fax After Replacing or Reinstalling Your Modem
6. If Windows Messaging Stops Responding After You've Installed Microsoft
7. If You Don't Receive An Expected Fax
8. No "Paste" Command Available in Cover Page Editor
9. No Fax Status Email for Send Fax Utility or Application Faxing
10. To Report Bugs
11. List of Tested Modems


----------------------------------------------------------------
1. Using the same modem for a Remote Access Server and Faxing
----------------------------------------------------------------
   You can use the same modem for both a Remote Access Server (RAS) and Fax
transmissions as long as the modem supports a feature called "Adaptive
Answer." If your modem doesn't support Adaptive Answer, you can still use the
same modem for dialing out both RAS and Fax transmissions. You won't, however,
be able to receive both faxes and dial-in RAS calls. To receive dial-in RAS
calls on a non-Adaptive Answer modem, disable Fax Receive.

>>>>> To disable Fax Receive:
      1. Click Start, point to Settings, and then click Control Panel.
      2. Double-click Fax.
      3. Click the Receive tab.
      4. In Device Name, click the box next to the name of your modem to
remove the check mark.
      5. Click OK.


-----------------------------------------------------
2. If You've Changed Your Fax Administrator Account Password
-----------------------------------------------------
   If you've changed the password for your Fax Administrator account (the
account specified during setup), you will also need to change the password
for your Fax Service to match.

>>>>> To change your Fax Service password:
      1. Click Start, point to Settings, and then click Control Panel.
      2. Double-click Services.
      3. Click Microsoft Fax Service, and then click the Startup button.
      4. In Log On As, type the new password in the Password box.
      5. Type the new password again in the Confirm Password box.
      6. Click OK in each dialog box.


---------------------------------------
3. To Disable Print Spooler Event Logging for Fax Events
---------------------------------------
   If you prefer not to log print spooler fax events, you can disable this
by disabling print system event logging.  Please note that this will also
disable all events logged by the print spooler.

>>>>> To disable print system event logging:
      1. Click Start, point to Settings, and then click Printers.
      2. On the File menu, click Server Properties.
      3. Click the Advanced tab.
      4. Click the box next to Log Spooler Information Events to remove the
check mark.
      5. Click OK.


-------------------------------------------------
4. "Could Not Process All Attachments" Error Message
-------------------------------------------------
   If you receive this message after sending a fax from Windows Messaging,
you've attached a file from an application that does not support this
function.
   To fax a file from an application that doesn't support file attachments
when faxing from Windows Messaging, send the file from the application
directly.

>>>>> To fax a file from an application:
      1. Within the application, select your fax printer as your target
printer.
      2. On the File menu, click Print or Send.
      3. Follow the instructions in the Send Fax Utility.


-----------------------------------------------------------
5. If You Can't Fax After Replacing or Reinstalling Your Modem
-----------------------------------------------------------

   If you have problems faxing after replacing or reinstalling your modem,
restart Windows NT 4.0. If that doesn't clear up the problem, reinstall
Microsoft Personal Fax for Windows.


----------------------------------------------------------------------
6. If Windows Messaging Stops Responding After You've Installed Microsoft
Personal Fax for Windows
----------------------------------------------------------------------

   If, after installing Microsoft Personal Fax for Windows, Windows Messaging
does nothing when you try to open it, restart Windows NT 4.0. After this, open
Control Panel by clicking Start, pointing to Settings, and clicking Control
Panel. Double-click Mail, and click on Show Profiles.  Select the profile that
you specified during fax setup and click Properties.  Select Fax Mail Transport
and click Remove.  You will be able to open Windows Messaging, but you won't
be able to send faxes from it. To send faxes, use the Send Fax Utility or fax
documents directly from their applications.


------------------------------------
7. If You Don't Receive An Expected Fax
------------------------------------

There are two possible reasons you may not receive an expected fax.  In both
cases, you should correct the problem and then have the fax resent.

1.   Microsoft Personal Fax for Windows has a feature called "Persistent
Routing." This feature causes the Windows NT Workstation 4.0 computer to
persist in routing a received fax to its destination even if the destination
is not available when the fax arrives. For example, if you've set up received
faxes to print, but the server for the printer you selected is not
functioning, faxes will continue to be sent to the printer until it is
received by the spooler.
    Currently, this feature is not functional. It will be fully functional in
the next release.

2.   The drive where your Windows NT system files reside is at or near
capacity. The Fax Service will attempt to answer an incoming fax transmission,
but will immediately stop. The fax is not received and no event is generated.
    To resume receiving faxes, delete some files to free some space.


-------------------------------------------------
8. No "Paste" Command Available in Cover Page Editor
-------------------------------------------------

   The cover page editor allows you to have one Note field for each cover
page. If you try to copy and paste items, including a Note field, into a cover
page already containing a Note field, the Paste command will be unavailable.
to solve this, first select the Note field already in the cover page and
delete it. The Paste command will now be available.


--------------------------------------------------------------
9. No Fax Status Email for Send Fax Utility or Application Faxing
--------------------------------------------------------------

   For this technology preview release, a fax status email is sent only
when you fax using Windows Messaging. To learn the status of sent faxes
using the Fax Send Utility or when faxing from an application, you'll need
to monitor the fax printer. To find out if you've received a fax, you'll
need to monitor the destination you set up for receiving faxes, such as a
folder or printer.


--------------
10. To Report Bugs
--------------

   On your Fax Start menu, you'll find the Problem Reporting Form by clicking
Start and Selecting Programs and then Fax.  This is a form for you to fill
out and email to ntbug@microsoft.com


------------------------
11. List of Tested Modems
------------------------

The following list of modems have been tested with the Microsoft Personal Fax
for Windows product.  Other modems may also work.

Hayes:
    Optima          External    Optima 288 V.34/V.FC+fax+Voice
   *Accura          External    288 V.FC+FAX (Model 5205AM).
   *Accura          External    14400 FAX144  (Model 5105AM)
MaxTech:
    Internal    XM288i
    External    28800 Fax Modem
Megahertz:
    PCMCIA      XJ-CC4288
Motorola:
    Premier         Internal    33.6 PnP
    Premier         External    33.6 Desktop
    ModemSURFR      Internal    28.8 PnP
    Lifestyle       External    288
    CELLect         PCMCIA      14.4
    LifeStyle       PCMCIA      14.4
    Premier         External    336
Practical Peripheral:
    PM 288MT        External    II V.34
   *PM288MT II      External    V.34
Supra:
    Express         Internal    336i PnP
    Express         External    144LC
    External    FaxModem 144LC
US Robotics:
    Total Control   External    rack mount / Quad V.34 Card
    Courier v.erythiExternal    V.everything
    Sportster       External    28800
    Sportster       Internal    288-336 Internal
    Sportster       External    288-336 External
    Sportster       Internal    14400 FAX PC
    Sportster       External    14400 FAX
    Courier         PCMCIA      V.everything
    Courier         External    Terbo V.32bis Fax
Zoom:
    VFX             External    V.34X
    VFP             Internal    14.4i
    VFX             External    14.4
    VFP             Internal    14.4VH
    VFP             Internal    14.4V

* These devices have been tested for the adaptive answer
  required for Fax/RAS interoperability.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\unattend.txt ===
[Fax]
Mode=New
SetupType=Workstation
FaxPrinterName=Fax
FaxNumber=868-7779
UseExchange=Yes
ProfileName=fax
RouteMail=Yes
RouteProfileName=fax
Platforms=i386
RoutePrint=Yes
RoutePrintername=p1
AccountName=weswhome\wesw
Password=
FaxPhone=868-7779
RouteFolder=Yes
FolderName=c:\tmp
ServerName=weswhome
SenderName=Wesley Witt
SenderFaxAreaCode=206
SenderFaxNumber=868-7779
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\shellext\desktop.ini ===
[.ShellClassInfo]
UICLSID={7f9609be-af9a-11d1-83e0-00c04fb6e984}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\shellext\notes.txt ===
dependencies:

\nt\private\shell\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\faxvrfy.ini ===
[Fax]
SendNumber=
ReceiveNumber=
[RAS]
Enabled=0
UserName=
Domain=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\help\faxvrfy.err ===
Microsoft (R) Help Compiler
HCRTF 4.03.0002
Copyright (c) Microsoft Corp 1990 - 1995. All rights reserved.
faxvrfy.hpj
18	Topics
18	Jumps
0	Keywords
0	Bitmaps


Created F:\nt\private\fax\test\FaxVrfy\help\faxvrfy.hlp, 11,850 bytes
Hall+Zeck compression decreased help file by 5,491 bytes.
Compile time: 0 minutes, 0 seconds
0 notes, 0 warnings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\help\faxvrfy.rtf ===
{\rtf1\ansi \deff7\deflang1033{\fonttbl{\f7\fswiss\fcharset0\fprq2 MS Sans Serif{\*\falt Arial};}{\f11\fmodern\fcharset0\fprq1 Courier New;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255; \red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0; \red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 \snext0 Normal;}{\s1\li115\ri130\sb280\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \sbasedon0\snext0 heading 1;}{ \s2\li115\ri130\sb120\sl-240\slmult0\widctlpar \b\f7\fs16 \sbasedon0\snext0 heading 2;}{\s3\li115\ri130\sb120\sa60\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext0 heading 3;}{\s4\fi-245\li360\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16  \sbasedon0\snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}{\s15\fi-187\li274\ri130\sb80\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f7\fs16 \sbasedon0\snext0 a/k link;}{\*\cs16 \additive\cf6 \sbasedon10 annotation reference;} {\s17\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext17 annotation text;}{\s18\li115\ri130\sb120\sa120\widctlpar \f7\fs16 \snext0 bitmap;}{\s19\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext0 Context;}{\*\cs20  \additive\up6 \sbasedon10 footnote reference;}{\s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext0 footnote text;}{\s22\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext22 Jl;}{ \s23\fi-187\li302\ri130\sb80\sl-240\slmult0\widctlpar\tx302 \f7\fs16 \sbasedon0\snext24 Lb1;}{\s24\fi-187\li302\ri130\sb48\sl-240\slmult0\widctlpar\tx302 \f7\fs16 \sbasedon23\snext24 Lb2;}{\s25\fi-158\li461\ri130\sb48\sl-240\slmult0\widctlpar\tx461  \f7\fs16 \sbasedon24\snext25 Lb3;}{\s26\li302\ri130\sb60\sl-240\slmult0\widctlpar\tx302 \f7\fs16 \sbasedon24\snext24 Lp1;}{\s27\li720\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext0 Normal Indent;}{\s28\fi-187\li274\ri130\sl-120\slmult0 \widctlpar\tx302 \f7\fs16 \sbasedon15\snext28 oem a/k link;}{\s29\fi-302\li418\ri86\sa120\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext29 oem button;}{\s30\fi-302\li418\ri86\sb160\sa120\sl-240\slmult0\widctlpar\tx720 \f7\fs16 \sbasedon29\snext30  oem button1;}{\s31\fi-187\li302\sb160\sl-240\slmult0\widctlpar\tx302 \f7\fs16 \sbasedon0\snext31 oem Lb1;}{\s32\li115\ri130\sb160\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext32 oem normal;}{\s33\li115\ri2160\sb160\sl-240\slmult0\widctlpar \f7\fs16  \sbasedon0\snext33 oem popup;}{\s34\ri2160\widctlpar \f7\fs12 \sbasedon33\snext34 oem popup end;}{\s35\fi-187\li302\ri2160\sb160\sl-240\slmult0\widctlpar\tx302 \f7\fs16 \sbasedon31\snext35 oem popup Lb1;}{\s36\li115\sb240\sl-240\slmult0\widctlpar  \b\f7\fs16 \sbasedon0\snext36 oem proc head;}{\s37\li115\ri86\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext0 oem tb text;}{\s38\li58\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon0\snext38 oem tb text 2;}{\s39\fi-187\li245\sb80\sl-240\slmult0 \widctlpar\tx245\tx302 \f7\fs16 \sbasedon23\snext39 oem tb text 2 Lb1;}{\s40\fi-187\li245\sb48\sl-240\slmult0\widctlpar\tx245\tx302 \f7\fs16 \sbasedon24\snext40 oem tb text 2 Lb2;}{\s41\fi-158\li403\sb48\sl-240\slmult0\widctlpar\tx403\tx461 \f7\fs16  \sbasedon25\snext41 oem tb text 2 Lb3;}{\s42\li115\ri130\sb80\widctlpar \f7\fs16 \sbasedon0\snext42 Pop-up;}{\s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \snext23 proc head;}{\s44\li115\ri86\sb280\sl-240\slmult0\widctlpar \f7\fs16  \sbasedon29\snext29 table top;}{\s45\li58\sb280\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon44\snext38 table top 2;}{\s46\fi-317\li432\ri130\sb120\sl-240\slmult0\widctlpar\tx432\tx576 \f7\fs16 \sbasedon24\snext46 Tbr1;}{\s47\li115\ri130\sb80\sl-240\slmult0 \widctlpar \f7\fs16 \sbasedon0\snext0 Tech Rev;}{\s48\li58\sb80\sl-240\slmult0\widctlpar \f7\fs16 \sbasedon44\snext48 vertrule;}{\s49\fi-302\li388\ri130\sb80\sl-240\slmult0\widctlpar\tqr\tx274\tx389 \f7\fs16 \sbasedon23\snext49 Lb1a;}{ \s50\fi-302\li388\ri130\sb48\sl-240\slmult0\widctlpar\tqr\tx274\tx389 \f7\fs16 \sbasedon49\snext50 Lb2a;}{\s51\fi-547\li662\ri187\sb60\sa60\sl240\slmult0\nowidctlpar\tx660 \f7\fs16 \sbasedon0\snext51 Np;}{\s52\li115\ri130\sb80\sl-240\slmult0\widctlpar  \f11\fs16 \sbasedon0\snext0 Code;}{\*\cs53 \additive\cf12 \sbasedon10 HTML;}{\*\cs54 \additive\b \sbasedon10 UI;}{\*\cs55 \additive\scaps\fs14 \sbasedon10 Smallcaps;}}{\info{\title Create Help files for Winhelp 4.0}{\author Steven Kehrli} {\doccomm Version of what7.dot specific for NT project\'0d\'0d\'0d\'0dModifications:\'0d\'0d6/11/96  Term and Def styles added\'0d\'0d5/14/96  Code and Np styles added}{\operator Steven Kehrli}{\creatim\yr1998\mo6\dy24\hr23\min47} {\revtim\yr1999\mo2\dy1\hr9\min15}{\version4}{\edmins5}{\nofpages18}{\nofwords1071}{\nofchars6106}{\*\company Microsoft}{\vern57443}}\margl1440\margr1440 \widowctrl\ftnbj\aenddoc\hyphcaps0\formshade \fet0{\*\template C:\\MSOffice\\Winword\\what7.dot} \sectd \linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\cs20\b0\up6 #{\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_0}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} Overview}}{\b0\up6  }Overview \par \pard\plain \li180\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 This application examines the ability of a modem  to work with the Windows NT Fax software.  It tests the Fax capability and, optionally, the Adaptive Answer capability of the modem.  The modem is Fax capable if it can receive and send a 5-page CCITT Group 4 (2d) Fax.  The modem is Adaptive Answer capabl e if it can receive a data call and receive and send a 5-page CCITT Group 4 (2d) Fax. \par  \par {\uldb Fax Test}{\v\cf6 HID_faxvrfy_1} \par {\uldb Adaptive Answer Test}{\v\cf6 HID_faxvrfy_3} \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_1}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} Fax Test}}{\b0\up6  }Fax Test \par \pard\plain \li180\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 This test verifies the ability of the Test Fax modem to receive and send  a 5-page CCITT Group 4 (2d) Fax.  The fax is sent from the Reference Fax modem to the Test Fax modem, the Test Fax modem sends the fax back to the Reference Fax modem, and the two steps are repeated. \par  \par The Reference Fax modem is the USR Courier V.Everything. \par  \par {\uldb Step by Step Instructions}{\v\cf6 HID_faxvrfy_2} \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_2}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} Fax Test - Step by Step Instructions}}{\b0\up6  }Fax Test - Step by Step Instructions \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 {\b On the Server machine:} \par {\pntext\pard\plain\f7\fs16 1.\tab}\pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450{\*\pn \pnlvlbody\pndec\pnstart1\pnindent187\pnhang{\pntxta .}}Install the Test Fax modem. \par {\pntext\pard\plain\f7\fs16 2.\tab}Start the FaxVrfy test application. \par {\pntext\pard\plain\f7\fs16 3.\tab}Verify the FaxVrfy test application is configured for receive (Options Receive). \par {\pntext\pard\plain\f7\fs16 4.\tab}Click the \ldblquote Start\rdblquote  button. \par \pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450  \par {\b On the Client machine:} \par {\pntext\pard\plain\f7\fs16 1.\tab}\pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450{\*\pn \pnlvlbody\pndec\pnstart1\pnindent187\pnhang{\pntxta .}}Install the Reference Fax modem. \par {\pntext\pard\plain\f7\fs16 2.\tab}Start the FaxVrfy test application. \par {\pntext\pard\plain\f7\fs16 3.\tab}Verify the application is configured for send (Options Send). \par {\pntext\pard\plain\f7\fs16 4.\tab}Provide the phone number of the Test Fax modem in the \ldblquote Send to:\rdblquote  field. \par {\pntext\pard\plain\f7\fs16 5.\tab}Provide the phone number of the Reference Fax modem in the \ldblquote Receive on:\rdblquote  field. \par {\pntext\pard\plain\f7\fs16 6.\tab}Click the \ldblquote Start\rdblquote  button. \par \pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450  \par \pard\plain \li180\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 The results will be displayed within the Status section and logged to faxvrfy.txt. \par  \par {\uldb Troubleshooting}{\v\cf6 HID_faxvrfy_5} \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_3}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} Adaptive Answer Test}}{\b0\up6  }Adaptive Answer Test \par \pard\plain \li180\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16  This test verifies the ability of the Test Fax modem to receive a data call and receive and send a 5-page CCITT Group 4 (2d) Fax.  The data call is sent from the Reference Fax modem to the Test Fax modem, the fax is sent from the Reference Fax modem to th e Test Fax modem, the Test Fax modem sends the fax back to the Reference Fax modem, and the three steps are repeated. \par  \par The Reference Fax modem is the USR Courier V.Everything. \par  \par {\uldb Step by Step Instructions}{\v\cf6 HID_faxvrfy_4} \par  \par \page {\cs20\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_4}}{\up6  }{\cs20\up6 ${\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $}  Adaptive Answer Test - Step by Step Instructions}}{\up6  }{\b Adaptive Answer Test - Step by Step Instructions} \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 {\b On the Server machine:} \par {\pntext\pard\plain\f7\fs16 1.\tab}\pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450{\*\pn \pnlvlbody\pndec\pnstart1\pnindent187\pnhang{\pntxta .}}Install the Test Fax modem. \par {\pntext\pard\plain\f7\fs16 2.\tab}Open the Control Panel.  To access the Control Panel, click {\b Start}, point to {\b Settings}, and then click {\b Control Panel}. \par {\pntext\pard\plain\f7\fs16 3.\tab}Double-click the \ldblquote Network and Dial-up Connections\rdblquote  icon. \par {\pntext\pard\plain\f7\fs16 4.\tab}Double-click the \ldblquote Make New Connection\rdblquote  icon.  The \ldblquote Network Connection Wizard\rdblquote  will start. \par {\pntext\pard\plain\f7\fs16 5.\tab}Click \ldblquote Next\rdblquote  to continue. \par {\pntext\pard\plain\f7\fs16 6.\tab}Select \ldblquote Accept incoming connections\rdblquote  and click the \ldblquote Next\rdblquote  button to continue. \par {\pntext\pard\plain\f7\fs16 7.\tab}Verify the Test modem is enabled to receive incoming calls and click the \ldblquote Next\rdblquote  button to continue. \par {\pntext\pard\plain\f7\fs16 8.\tab}Select \ldblquote Do not allow virtual connections\rdblquote  and click the \ldblquote Next\rdblquote  button to continue. \par {\pntext\pard\plain\f7\fs16 9.\tab}Select a user account to be allowed access and click the \ldblquote Next\rdblquote  button to continue.  As an example, use the \ldblquote Administrator\rdblquote  user account.  If the machine name is \ldblquote  TESTMACHINE,\rdblquote  the fully qualified user account is \ldblquote TESTMACHINE\\Administrator\rdblquote  where \ldblquote TESTMACHINE\rdblquote  is the domain of the user account. \par {\pntext\pard\plain\f7\fs16 10.\tab}Click the \ldblquote Next\rdblquote  button to continue. \par {\pntext\pard\plain\f7\fs16 11.\tab}Click the \ldblquote Finish\rdblquote  button to complete the \ldblquote Network Connection Wizard.\rdblquote  \par {\pntext\pard\plain\f7\fs16 12.\tab}Start the FaxVrfy test application. \par {\pntext\pard\plain\f7\fs16 13.\tab}Verify the application is configured for receive (Options Receive). \par {\pntext\pard\plain\f7\fs16 14.\tab}Click the \ldblquote Start\rdblquote  button. \par \pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450  \par {\b On the Client machine:} \par {\pntext\pard\plain\f7\fs16 1.\tab}\pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450{\*\pn \pnlvlbody\pndec\pnstart1\pnindent187\pnhang{\pntxta .}}Install the Test Fax modem. \par {\pntext\pard\plain\f7\fs16 2.\tab}Start the FaxVrfy test application. \par {\pntext\pard\plain\f7\fs16 3.\tab}Verify the application is configured for send (Options Send). \par {\pntext\pard\plain\f7\fs16 4.\tab}Provide the phone number of the Test Fax modem in the \ldblquote Send to:\rdblquote  field. \par {\pntext\pard\plain\f7\fs16 5.\tab}Provide the phone number of the Reference Fax modem in the \ldblquote Receive on:\rdblquote  field. \par {\pntext\pard\plain\f7\fs16 6.\tab}Click the RAS \ldblquote Enabled\rdblquote  check-box. \par {\pntext\pard\plain\f7\fs16 7.\tab}Provide the name of the user account in the \ldblquote User Name:\rdblquote  field.  Continuing the example, this would be \ldblquote Administrator.\rdblquote  \par {\pntext\pard\plain\f7\fs16 8.\tab}Provide the password of the user account in the \ldblquote Password:\rdblquote  field. \par {\pntext\pard\plain\f7\fs16 9.\tab}Provide the domain of the user account in the \ldblquote Domain:\rdblquote  field.  Continuing the example, this would be \ldblquote TESTMACHINE.\rdblquote  \par {\pntext\pard\plain\f7\fs16 10.\tab}Click the \ldblquote Start\rdblquote  button. \par \pard \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450  \par \pard\plain \li180\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 The results will be displayed within the Status section and logged to faxvrfy.txt. \par  \par {\uldb Troubleshooting}{\v\cf6 HID_faxvrfy_5} \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_5}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} Troubleshooting}}{\b0\up6  }Troubleshooting \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 {\uldb \ldblquote Cannot initialize the FaxRcv Routing Extension\rdblquote }{\v\cf6 HID_faxvrfy_6} \par {\uldb \ldblquote There are no Fax Ports installed\rdblquote }{\v\cf6 HID_faxvrfy_7} \par {\uldb \ldblquote No Dial Tone\rdblquote }{\v\cf6 HID_faxvrfy_8} \par {\uldb \ldblquote Busy\rdblquote }{\v\cf6 HID_faxvrfy_9} \par {\uldb \ldblquote No Answer\rdblquote }{\v\cf6 HID_faxvrfy_10} \par {\uldb \ldblquote Fatal Error\rdblquote }{\v\cf6 HID_faxvrfy_11} \par {\uldb \ldblquote Unexpected State\rdblquote }{\v\cf6 HID_faxvrfy_12} \par {\uldb \ldblquote Device Powered Off\rdblquote }{\v\cf6 HID_faxvrfy_13} \par {\uldb \ldblquote Device Powered On\rdblquote }{\v\cf6 HID_faxvrfy_14} \par {\uldb \ldblquote There are no Fax Ports available\rdblquote }{\v\cf6 HID_faxvrfy_15} \par {\uldb \ldblquote Fax Service Stopped\rdblquote }{\v\cf6 HID_faxvrfy_16} \par {\uldb \ldblquote Invalid Fax\rdblquote }{\v\cf6 HID_faxvrfy_17} \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_6}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Cannot initialize the FaxRcv Routing Extension\rdblquote }}{\b0\up6  }\ldblquote Cannot initialize the FaxRcv Routing Extension\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 Verify faxrcv.dll is in the same directory as faxvrfy.exe. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_7}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote There are no Fax Ports installed\rdblquote }}{\b0\up6  }\ldblquote There are no Fax Ports installed\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 Verify the modem is installed correctly. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_8}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote No Dial Tone\rdblquote }}{\b0\up6  }\ldblquote No Dial Tone\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 Verify a working phone line is plugged into the modem. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_9}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Busy\rdblquote }}{\b0\up6  }\ldblquote Busy\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 Verify the \ldblquote Send to:\rdblquote  and \ldblquote Receive on:\rdblquote  phone numbers are correct. \par Verify the phone numbers are not busy. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_10}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote No Answer\rdblquote }}{\b0\up6  }\ldblquote No Answer\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 Verify the \ldblquote Send to:\rdblquote  and \ldblquote Receive on:\rdblquote  phone numbers are correct. \par Verify the correct phone lines are plugged into the correct modems. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_11}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Fatal Error\rdblquote }}{\b0\up6  }\ldblquote Fatal Error\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the fax registry keys specified in the .INF file. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_12}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Unexpected State\rdblquote }}{\b0\up6  }\ldblquote Unexpected State\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the fax registry keys specified in the .INF file. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_13}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Device Powered Off\rdblquote }}{\b0\up6  }\ldblquote Device Powered Off\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the fax registry keys specified in the .INF file. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_14}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Device Powered On\rdblquote }}{\b0\up6  }\ldblquote Device Powered On\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the fax registry keys specified in the .INF file. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_15}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote There are no Fax Ports available\rdblquote }}{\b0\up6  }\ldblquote There are no Fax Ports available\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the fax registry keys specified in the .INF file. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_16}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Fax Service Stopped\rdblquote }}{\b0\up6  }\ldblquote Fax Service Stopped\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the fax registry keys specified in the .INF file. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par \pard\plain \s43\li180\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \page {\cs20\b0\up6 #{\footnote \pard\plain \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 #} HID_faxvrfy_17}}{\b0\up6  }{\cs20\b0\up6 ${\footnote \pard\plain  \s21\li115\ri130\sb80\sl-240\slmult0\widctlpar \f7\fs16 {\cs20\up6 $} \ldblquote Invalid Fax\rdblquote }}{\b0\up6  }\ldblquote Invalid Fax\rdblquote  \par \pard\plain \s23\fi-270\li450\ri130\sb80\sl-240\slmult0\widctlpar\tx450 \f7\fs16 This error most likely indicates an error in the test setup or the fax registry keys specified in the .INF file. \par Verify the FaxVrfy test application is setup and running correctly on both the Server and Client machines. \par Review the Microsoft Windows 98 and Windows NT 5.0 Modem Development Kit (MDK) and Microsoft Windows 98 and Windows NT 5.0 Modem Registry Reference. \par Verify CINF reported no fax errors and no fax warnings. \par  \par }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\buildnum.txt ===
Equivalent to build #1776 of Haifa Whistler Fax.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\fxsperf.ini ===
[info]
drivername=fax
symbolfile=fxscount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Shared Fax Service
FAXOBJ_009_HELP=Shared Fax Service
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages

[objects]
FAXOBJ_009_NAME=Shared Fax Service
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\fxsperf.ini ===
[info]
drivername=fax
symbolfile=fxscount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Shared Fax Service
FAXOBJ_009_HELP=Shared Fax Service
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages

[objects]
FAXOBJ_009_NAME=Shared Fax Service
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\i386\chk\fxsperf.ini ===
[info]
drivername=fax
symbolfile=fxscount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Fax Services
FAXOBJ_009_HELP=Fax Services
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages

[objects]
FAXOBJ_009_NAME=Fax Services
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\i386\fre\fxsperf.ini ===
[info]
drivername=fax
symbolfile=fxscount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Fax Services
FAXOBJ_009_HELP=Fax Services
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages

[objects]
FAXOBJ_009_NAME=Fax Services
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\mantis\placefil.txt ===
Fax_Pro_{24E11320-676A-44AF-A19C-74A7879C6167}.sld			mantis
Fax_Srv_{D996F47A-98B4-4D5E-BF21-106A888844D6}.sld			mantis
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\nt_coffbase.txt ===
;
; fax dlls
;

usermode    0x01000000  0x60000000
faxab32     0x64000000  0x000c0000
fxscfg      0x640c0000  0x000c0000
fxsst       0x641c0000  0x00120000
fxsdrv      0x64200000  0x000c0000
fxsext32    0x642c0000  0x000c0000
fxsmon      0x64300000  0x000c0000
fxsperf     0x643c0000  0x000c0000
fxst30      0x644c0000  0x16000000
fxsui       0x64500000  0x000f0000
fxswiz      0x645c0000  0x000c0000
fxsxp32     0x64600000  0x10000000
winfax      0x646c0000  0x000c0000
fxstiff     0x64700000  0x11000000
fxsroute    0x64800000  0x000c0000
fxsevent    0x648c0000  0x000c0000
winfaxp     0x64900000  0x000c0000
faxcfgd     0x649c0000  0x000c0000
faxitg      0x64a00000  0x000c0000
fxscom      0x64ac0000  0x000c0000
faxisapi    0x64b00000  0x000c0000
faxxp32w    0x64bc0000  0x10000000
faxab32w    0x64c00000  0x000c0000
faxocm      0x64cc0000  0x000c0000
fxsadmin    0x64d00000  0x00300000
fax         0x64dc0000  0x000c0000
routeext    0x64e00000  0x000c0000
fspext      0x64ec0000  0x000c0000
fxsctxt     0x64f00000  0x000c0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\coffbase.txt ===
;
; fax dlls
;

usermode    0x01000000  0x60000000
faxab32     0x64000000  0x000c0000
fxscfg      0x640c0000  0x000c0000
fxsdrv      0x64200000  0x000c0000
fxsext32    0x642c0000  0x000c0000
fxsmon      0x64300000  0x000c0000
fxsperf     0x643c0000  0x000c0000
fxst30      0x644c0000  0x000c0000
fxsui       0x64500000  0x000c0000
fxswiz      0x645c0000  0x000c0000
fxsxp32     0x64600000  0x000c0000
winfax      0x646c0000  0x000c0000
fxstiff     0x64700000  0x000c0000
fxsmapi     0x647c0000  0x000c0000
fxsroute    0x64800000  0x000c0000
fxsevent    0x648c0000  0x000c0000
winfaxp     0x64900000  0x000c0000
faxcfgd     0x649c0000  0x000c0000
faxitg      0x64a00000  0x000c0000
fxscom      0x64ac0000  0x000c0000
faxisapi    0x64b00000  0x000c0000
faxxp32w    0x64bc0000  0x000c0000
faxab32w    0x64c00000  0x000c0000
faxocm      0x64cc0000  0x000c0000
fxsadmin    0x64d00000  0x000c0000
fax         0x64dc0000  0x000c0000
routeext    0x64e00000  0x000c0000
fspext      0x64ec0000  0x000c0000
fxsctxt     0x64f00000  0x000c0000
fxsfsput    0x64fc0000  0x000c0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\nt_placefil.txt ===
;
; fax binaries
;

confdent.cov            retail
faxpatch.exe            retail
fxsadmin.dll            retail
fxsadmin.msc            retail
fxsclnt.inf             retail
fxscom.dll              retail
fxscomex.dll            retail
fxscount.h              retail
faxreg.h                retail
fxsapip.h               retail
fxscover.exe            retail
fxsdrv16.drv            retail
fxsdrv.dll              retail
fxsdrv4.dll             retail
fxsevent.dll            retail
fxsext.ecf              retail
fxsmon.dll              retail
fxsocm.dll              retail
fxsocm.inf              retail
fxsperf.dll             retail
fxsperf.ini             retail
fxsroute.dll            retail
fxssend.exe             retail
fxssvc.exe              retail
fxst30.dll              retail
fxstiff.dll             retail
fxsst.dll               retail
fxsui.dll               retail
fyi.cov                 retail
generic.cov             retail
layout.exe              retail
urgent.cov              retail
fxsserv.msc             retail
fxsptprt.dll            retail
fxsprint.inf            retail
fxswzrd.dll             retail
fxscfgwz.dll            retail
fxsxp32.dll             retail
fxsext32.dll            retail
fxsapi.dll              retail
fxsdrv32.dll            retail
unidrv.dll              retail
ICONLIB.DLL             retail
unidrv.hlp              retail
CLNTCUSA.dll            retail
CLNTCUSU.dll            retail
FxsRtExt.dll            retail
FxsRtMtd.dll            retail
fxsres.dll              retail
FxsClnt.exe             retail
FxsClntR.dll            retail:..\clients\WIN9X
FXST30P.dll             retail
winfax.dll              retail
setup.exe		retail

;
; Help files
;
fxscover.chm            help
fxsshare.chm            help
fxs_art.chm             help
fxsadmin.chm            help
fxsadmin.hlp            help
fxsclnt.chm             help
fxsclnt.hlp             help
;
; Public headers
;
WINFAX.H                sdk
FAXDEV.H                sdk
FAXMMC.H                sdk
FAXEXT.H                sdk
FAXROUTE.H              sdk
FAXCOM.H                sdk
FAXCOM_I.C              sdk
FAXCOMEX.H              sdk
FAXCOMEX_I.C            sdk
FaxControl.h            sdk
FaxControl_i.c          sdk
;
; Private headers
;
FXSAPIP.H               sdk\internal
;
; Public libs
;
WINFAX.LIB              sdk
;
; Private libs
;
FXSAPI.LIB              sdk\internal
;

; test binaries
faxrcv.dll              dump
faxvrfy.exe             dump
faxvrfy.cnt             dump
faxvrfy.hlp             dump
faxvrfy.ini             dump
faxbvt.tif              dump
faxwhql.tif             dump

;
; Install Script
;
Setup.cmd                ..\setup
ChkDbg.exe               ..\setup
faxoc.inf                ..\setup
FaxOff.reg               ..\setup
install.inf              ..\setup
uninstall.inf            ..\setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\build\32bit_buildbreak.txt ===
This is a fax Whistler build break on 32bit, look at the build error files for more refrence
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\build\64bit_buildbreak.txt ===
This is a fax Whistler build break on 64Bit, look at the build error files for more refrence
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\build\build.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft How to set a build machine: Title _PID_HLINKSHow to set a build machine: Guy Merin Normal.dot Guy Merin Microsoft Word 9.080cm>Mt3bjbjU How to set a build machine: Create a Razzle environment: Create the following Directories: nt, nt\private, nt\public, nt\public.nt4 Copy to nt\public the public of the desired build (i.e. NT build 2092 etc). Copy to nt\public.nt4 the public of NT4 (can be taken from the build machine at:   HYPERLINK "\\\\bos-x86\\nt_chk\\public.nt4"  \\bos-x86\nt_chk\public.nt4 Create nt\private\developer and nt\private\developer\<Your username>, copy the file setenv.cmd from the build machine:  HYPERLINK "\\\\bos-x86\\nt_chk\\private\\developer\\SBO\\setenv.cmd"  \\bos-x86\nt_chk\private\developer\SBO\setenv.cmd Enlist the projects: Create nt\private\SBS (or any other directory name) and enlist the Common project (enlist   HYPERLINK "\\\\haifaslm\\slmcomet"  \\haifaslm\slmcomet  -p CommonTel) Create nt\private\SBS\Fax and enlist the fax project (enlist   HYPERLINK "\\\\haifaslm\\slmcomet"  \\haifaslm\slmcomet  -p Fax) Create nt\private\SBS\MP and enlist the Modem Sharing project (enlist   HYPERLINK "\\\\haifaslm\\slmsam"  \\haifaslm\slmsam  -p NetCom) SSYNC the project, this can be done using  ssync   on the root directory, which will ssync all projects. If this build machine is for your own use: Edit the setenv.cmd and set the following: _NT_DRIVE and _NT_ROOT to your created directories (bullet #1 and 2) set NTDEBUG=ntsdnodbg if you want FRE build or set NTDEBUG=ntsd if you want CHK build. set _NT386TREE to the directory you want the Bin placing to occur in. Run the batch: BosBuildAll.cmd If this is   build machine, you have to enlist the project twice: The above enlistment on drive d (hard coded) is for CHK builds . Enlist the project again (repeat steps #1 and 2) on drive e (hard coded) for FRE builds. How to run the build: You can use several batches as utilities: BosUpdateVersion.cmd This batch will increase the project build number, it will add 1 to the build define in CometVer.h (under inc), all the project RC files (resource files) should include this header and fetch the build number from it. BosBuildAll.cmd Build all platforms (currently alpha isn t built, so only build FRE and CHK versions). The build is by default a clean build without SSYNC the project. The batch supports 2 params: bosbuildall.cmd <SSYNC> <NoClean> SSYNC: if given then a SSYNC  R is executed before the build. NoClean: If supported then a Non clean build is executed. BosPropagate.cmd Propagates the FRE and CHK binaries to the drop location, it creates a subdirectory according to the build number. If we re repropagating the same build then a new directory will be created XXX.1 XXX.2 etc. The propagation process also create a symbol directory which can be used for SYMPATH (at <\\BOS-X86\drop\XXX\USA\CHK\Symbols>) and creates a SRC directory which can be used for source level debugging (at <\\BOS-X86\drop\XXX\SRC>) BosWaitToPropagate.cmd Waits till the FRE and CHK builds are finished and then runs the BosPropagate.cmd batch Labels all the source code with the build number (SLM release) Sends a mail to the group ( Modem Sharing checking  and  Comet Fax checking ) stating the build result
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\build\spfiles.txt ===
Add the list of affected binaries to this text file.
In order to install the latest Fax SP build you need to install a clean XP RTM
and replace the files below.

List of Fax SP binaries:
------------------------
FXSWZRD.DLL
FXSSVC.EXE
FXSCOVER.EXE
FXSCLNT.EXE
FXSEXT32.DLL
FXSTIFF.DLL
FXSXP32.DLL
FXSAPI.DLL
FXST30.DLL
FXSCOMEX.DLL
FXSOCM.INF
FXSOCM.DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\faxext.ini ===
\registry\machine\software\microsoft\exchange\client\extensions
    FaxExtensions = 4.0;d:\winnt\system32\faxext32.dll;1;00000100000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bin\elle.ini ===
[Elle]
HeaderPath=
SuiteName=Test suite
Version=3
DetailBuffer=0

[Viewport]
Enabled=1
LogLevel=3
DetailLevel=9
ErrorRpt=1
ClearEachSuite=1
HideWhenDone=0

[File]
Enabled=1
LogLevel=9
DetailLevel=9
AppendMode=0
FileName=FaxBVT.log                                                                                                                                                                                                                             
          

[Comm]
Enabled=0
LogLevel=3
DetailLevel=9
CommPort=0

[SQL]
Enabled=0
Direct=0
Server=
Database=
Table=
UserID=
Password=
Parse=1
FileName=elle.sql
RunWndLeft=0
RunWndTop=456
RunWndRight=1024
RunWndBottom=684
SQLAppX=-4
SQLAppY=-4
SQLAppCX=1032
SQLAppCY=776

[Custom Header Fields]
Tester=your name
Environment=machine configuration
MachineID=your machine
Revision=04.00.0950
Language=USA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bin\mtview.ini ===
[Viewport]
X=206
Y=194
Width=975
Height=643
CmdShow=1
Facename=Courier
Point=8
Weight=400
Italic=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\nt_placefil.txt ===
FaxBvt.exe			retail
TiffTools.dll		retail
elle.dll			retail
elle.ini			retail
Faxes				retail
mtview.exe			retail
MTVIEW.ini			retail
params.ini.example	retail
t3run32.dll			retail
file.bmp			Faxes
file.doc			Faxes
file.htm			Faxes
file.txt			Faxes
SubNote.COV			Faxes
TC3.tif			Faxes
VbTestIt.exe		Tools
TestIt.exe			Tools
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bin\faxes\file.txt ===
Fax Service BVT

Goal:
To verify that the Fax Server can correctly perform the basic functions required.

Test Areas:
Send a fax (with/without CP, single/broadcast, from applications/wizard/API).
Receive a fax (verify bit map, banner, number of pages).
Automated image verification is not implemented.
Abort an outgoing/incoming fax (while pending, sending, receiving).
Inbound Routing (to Folder, to printer, to mail).
Testing of inbound to mail is not implemented.
Simultaneous use of multiple devices (for send/receive).
Test not implemented (due to 2 device limit => needs 2 machines)
Fax Management settings (device settings, user profile, routing).
Test not implemented.

Pre-requisites:
In order to run this BVT a machine with the build in question must be properly installed. 
Two modems must be installed on the machine (device#1 and device#2).
A printer must be installed on the machine.
See additional BVT setup information in appendix A. 
Any test case specific setup is described in the "Setup" section of each test case.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bin\faxes\file.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Fax Service BVT TitleFax Service BVT Guy Merin Normal.dot Guy Merin Microsoft Word 9.0bjbjU Fax Service BVT Goal: To verify that the Fax Server can correctly perform the basic functions required. Test Areas: Send a fax (with/without CP, single/broadcast, from applications/wizard/API). Receive a fax (verify bit map, banner, number of pages). Automated image verification is not implemented. Abort an outgoing/incoming fax (while pending, sending, receiving). Inbound Routing (to Folder, to printer, to mail). Testing of inbound to mail is not implemented. Simultaneous use of multiple devices (for send/receive). Test not implemented (due to 2 device limit => needs 2 machines) Fax Management settings (device settings, user profile, routing). Test not implemented. Pre-requisites: In order to run this BVT a machine with the build in question must be properly installed.  Two modems must be installed on the machine (device#1 and device#2). A printer must be installed on the machine. See additional BVT setup information in appendix A.  Any test case specific setup is described in the "Setup" section of each test case.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\params.ini ===
[ G e n e r a l ] 
 
 b o s b v t s r v 1 
 
 1 3 6 3 
 
 1 3 6 4 
 
 t e s t . t i f Qm
 
 f : \ b v t \ f a x b v t \ s u b n o t e . c o v 
 
 f : \ b v t \ f a x b v t \ f a x e s \ 1 3 6 4 R e c e i v e 
 
 f : \ b v t \ f a x b v t \ f a x e s \ S e n t F a x e s 
 
 f : \ b v t \ f a x b v t \ f a x e s \ I n b o x A r c h i v e   
 
 f : \ b v t \ f a x b v t \ f a x e s \ R e f e r e n c e 
 
 f : \ b v t \ f a x b v t 
 
 
 
 [ R e c i p i e n t s ] 
 
 R e c i p i e n t 1 
 
 R e c i p i e n t 2 
 
 R e c i p i e n t 3 
 
 
 
 [ R e c i p i e n t 1 ] 
 
 N a m e   =   R e c i p i e n t   N u m b e r 1 
 
 F a x N u m b e r   = 
 
 C o m p a n y   =   R e c i p i e n t   N u m b e r 1   C o m p a n y                   
 
 S t r e e t A d d r e s s   =   R e c i p i e n t   N u m b e r 1   C o m p a n y                   
 
 C i t y   =   R e c i p i e n t   N u m b e r 1   C i t y                 
 
 S t a t e   =   R e c i p i e n t   N u m b e r 1   S t a t e                       
 
 Z i p   =   R e c i p i e n t   N u m b e r 1   Z i p                   
 
 C o u n t r y   =   R e c i p i e n t   N u m b e r 1   C o u n t r y                       
 
 T i t l e   =   R e c i p i e n t   N u m b e r 1   T i t l e                   
 
 D e p a r t m e n t   =   R e c i p i e n t   N u m b e r 1   D e p a r t m e n t             
 
 O f f i c e L o c a t i o n   =   R e c i p i e n t   N u m b e r 1   O f f i c e L o c a t i o n                               
 
 H o m e P h o n e   =   R e c i p i e n t   N u m b e r 1   H o m e P h o n e                               
 
 O f f i c e P h o n e   =   R e c i p i e n t   N u m b e r 1   O f f i c e P h o n e                             
 
 E m a i l   =   R e c i p i e n t   N u m b e r 1   E m a i l                               
 
 B i l l i n g C o d e   =   R e c i p i e n t   N u m b e r 1   B i l l i n g C o d e                               
 
 T S I D   =   R e c i p i e n t   N u m b e r 1   T S I D 
 
 
 
 [ R e c i p i e n t 2 ] 
 
 
 
 [ R e c i p i e n t 3 ] 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\vbtestit\readme.txt ===
VBTestit is a version of Testit.exe that also saves the test results to file testit.out
This is for use from VB tests (that require comparing tiff files), because we were not able to make a VB call into tifftolls.dll itself.

Note that this is a VC project only (no razzle) because currently no VB for 64bit exists.
We may add a razzle project later.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\nt_placefil.txt ===
faxbvt.tif	retail
faxrcv.dll	retail
faxvrfy.cnt	retail
faxvrfy.exe	retail
faxvrfy.hlp	retail
faxvrfy.ini	retail
faxwhql.tif	retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\faxvrfy.ini ===
[Fax]
SendNumber=
ReceiveNumber=
[RAS]
Enabled=0
UserName=
Domain=
[Device]
Name=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\help\install.txt ===
Last Revision Date 4/1/1997 - John Mikesell

Location: \\orville\razzle\src\fax\help\install.txt

This install.txt file provides file locations, installation instructions, and uninstall instructions for Windows NT fax help, Windows 95 and WFG/3.11 Fax Clients help.

*** WHAT'S NEW ***
4/1/97
    1. RELEASE folder removed.
    2. WFW, W95 relnotes & readme files renamed
    3. WFW, W95 relnotes & readme placeholder files added

3/28/97
    1. Notes/readme files added to each build folder and install instructions.
    3. Fax client hlp/cnt files added to SERVER installation.
    4. Instructions added for Win95
    5. Headings added for 3.11/WFW (F-G) install/uninstall instructions.
    6. Faxview cnt/hlp files removed.
    7. Fax0.hlp added, notation in NT Windows.Cnt changed :Index fax.hlp -> fax0.hlp.
       See note H.1 at end of this file.

*** CONTENTS ***
    A. Locations of Help files in SLM fax project
    B. Windows NT Installation Instructions
       1. For all Windows NT installations
       2. Files for NT Server installations
       3. Files for NT Client installations
       4. Files for NT Personal Fax installations
    C. Windows NT Uninstall Instructions
       1. For all Windows NT installations
       2. Files removed for NT Server installations
       3. Files removed for NT Client installations
       4. Files removed for NT Personal Fax installations
    D. Windows 95 Fax Client Install
    E. Windows 95 Fax Client Uninstall
    F. Windows WFW and 3.11 Fax Client Install
    G. Windows WFW and 3.11 Fax Client Uninstall
    H. Notes

A. Locations of All Help files in SLM fax project

\\orville\razzle\src\fax\help\.

Copy files for Fax Server/Clients help from these locations only. No other locations are guaranteed to have the latest help files for Fax Server & Clients. 

Release (REMOVED)
   RELEASE NOTES AND README ARE NOW IN BUILD FOLDERS.

.\
   Install.txt - this file

.\Build
   Fax0.hlp  (called from windows.hlp contents)
   Fax.hlp
   Fax.cnt
   Faxcover.hlp
   Faxcover.cnt
   Faxui.hlp

.\Build.Srv
   Faxsrv.hlp
   Faxsrv.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.Clt
   Faxclt.hlp
   Faxclt.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.Wks  (Personal Fax)
   Faxwks.hlp
   Faxwks.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.WFW
   Fax3.hlp
   faxinf3.txt
   faxrel3.txt

.\Build.95
   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   faxinf4.txt
   faxrel4.txt

B. Windows NT Installation Instructions:

HLP and CNT files should go into the sysroot\help folder.

B.1. For all Windows NT installations

The following entry should be inserted in alphabetical order in the text file sysroot\system32\windows.cnt if not already inserted:

    :Index Fax Help=fax0.hlp

The following files should be deleted from  the sysroot\system32 folder, if they are present:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

Files to be added for ALL installations
   Fax0.hlp
   Fax.hlp
   Fax.cnt
   Faxcover.hlp
   Faxcover.cnt
   Faxui.hlp

B.2. Files for NT Server installations
   Faxsrv.hlp
   Faxsrv.cnt
   Faxclt.hlp
   Faxclt.cnt
   faxinfos.txt
   faxrelnts.txt

B.3. Files for NT Client installations
   Faxclt.hlp
   Faxclt.cnt
   faxinfoc.txt
   faxrelntc.txt

B.4. Files for NT Personal Fax installations
   Faxwks.hlp
   Faxwks.cnt
   faxinfo.txt
   faxrelnt.txt

C. Windows NT Uninstall Instructions:

Note: These instructions apply completely only if all installations (client, server, & workstation) are being removed. * marks items that don't apply if one is being removed and another one left on.

C.1. For all Windows NT installations

* The following entry should be removed from the text file sysroot\system32\windows.cnt file. This actually won't affect program operation if it is left in and fax.hlp isn't there.

    :Index Fax Help=fax.hlp

* The following files should be deleted from  the sysroot\system32 folder:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

* Files to be removed if all installations (server, workstation and client) are removed:

   Fax0.hlp
   Fax.hlp
   Fax.cnt
   Fax.gid
   Fax.fts
   Fax.ftg
   Faxcover.hlp
   Faxcover.cnt
   Faxcover.gid
   Faxcover.fts
   Faxcover.ftg
   Faxui.hlp
   Faxview.hlp
   Faxview.cnt
   Faxview.gid
   Faxview.fts
   Faxview.ftg

C.2. Files removed for NT Server installations

   Faxsrv.hlp
   Faxsrv.cnt
   Faxsrv.gid
   Faxsrv.fts
   Faxsrv.ftg
   Faxclt.hlp
   Faxclt.cnt
   Faxclt.gid
   Faxclt.fts
   Faxclt.ftg
   faxinfos.txt
   faxrelnts.txt

C.3. Files removed for NT Client installations

   Faxclt.hlp
   Faxclt.cnt
   Faxclt.gid
   Faxclt.fts
   Faxclt.ftg
   faxinfoc.txt
   faxrelntc.txt

C.4. Files removed for NT Personal Fax installations

   Faxwks.hlp
   Faxwks.cnt
   Faxwks.gid
   Faxwks.fts
   Faxwks.ftg
   faxinfo.txt
   faxrelnt.txt

D. Windows 95 Install

HLP and CNT files should go into the sysroot\help folder.

The following entry should be inserted in alphabetical order in the text file sysroot\help\windows.cnt if not already inserted:

    :Index Fax Help=fax40.hlp

The following files should be deleted from  the sysroot\system32 folder, if they are present:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

The following files should be installed:

   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   Faxui.hlp
   faxinfo4.txt
   faxrelnt4.txt

E. Windows 95 Uninstall

The following entry should be removed from the text file sysroot\system32\windows.cnt file. This actually won't affect program operation if it is left in and fax.hlp isn't there.

    :Index Fax Help=fax40.hlp

The following files should be deleted from  the sysroot\system32 folder:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

The following files should be removed:

   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   Fax4.gid
   Fax4.fts
   Fax4.ftg
   Faxui.hlp
   faxinfo4.txt
   faxrelnt4.txt

F. Windows WFG and 3.11 Install
   Fax3.hlp
   Faxui.hlp
   faxinfo3.txt
   faxrelnt3.txt

G. Windows WFG and 3.11 Uninstall (tentative)
   Fax3.hlp
   Faxui.hlp
   faxinfo3.txt
   faxrelnt3.txt

H. NOTES

H.1 Right now we reference fax.hlp in the NT Windows.Cnt by adding an ":Index Fax0.Hlp" (changed from Fax.hlp in 3/28/97 version of install instructions). This file has a topic which creates entries for "fax procedures" in the Windows.Hlp index users open on the start menu. If installing (Personal, Client/Server) fax becomes standard in any release of Windows NT, then this should be added to the Windows.Cnt file, and steps for inserting it here should be removed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\lib\ia64\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\mantis\placefil.txt ===
Fax_Pro_{24E11320-676A-44AF-A19C-74A7879C6167}.sld			mantis
fax_srv_{d996f47a-98b4-4d5e-bf21-106a888844d6}.sld 			mantis
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\lib\i386\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\lib\win95\i386\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\perfmon\faxperf.ini ===
[info]
drivername=fax
symbolfile=faxcount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Shared Fax Service
FAXOBJ_009_HELP=Shared Fax Service
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\perfmon\fxsperf.ini ===
[info]
drivername=fax
symbolfile=fxscount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Fax Services
FAXOBJ_009_HELP=Fax Services
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages

[objects]
FAXOBJ_009_NAME=Fax Services
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\runcodes.txt ===
Table 1a. Terminating White Codes
Code            Lng     Run
---------------------------
00110101        8       0
000111          6       1
0111            4       2
1000            4       3
1011            4       4
1100            4       5
1110            4       6
1111            4       7
10011           5       8
10100           5       9
00111           5       10
01000           5       11
001000          6       12
000011          6       13
110100          6       14
110101          6       15
101010          6       16
101011          6       17
0100111         7       18
0001100         7       19
0001000         7       20
0010111         7       21
0000011         7       22
0000100         7       23
0101000         7       24
0101011         7       25
0010011         7       26
0100100         7       27
0011000         7       28
00000010        8       29
00000011        8       30
00011010        8       31
00011011        8       32
00010010        8       33
00010011        8       34
00010100        8       35
00010101        8       36
00010110        8       37
00010111        8       38
00101000        8       39
00101001        8       40
00101010        8       41
00101011        8       42
00101100        8       43
00101101        8       44
00000100        8       45
00000101        8       46
00001010        8       47
00001011        8       48
01010010        8       49
01010011        8       50
01010100        8       51
01010101        8       52
00100100        8       53
00100101        8       54
01011000        8       55
01011001        8       56
01011010        8       57
01011011        8       58
01001010        8       59
01001011        8       60
00110010        8       61
00110011        8       62
00110100        8       63
11011           5       64
10010           5       128
010111          6       192
0110111         7       256
00110110        8       320
00110111        8       384
01100100        8       448
01100101        8       512
01101000        8       576
01100111        8       640
011001100       9       704
011001101       9       768
011010010       9       832
011010011       9       896
011010100       9       960
011010101       9       1024
011010110       9       1088
011010111       9       1152
011011000       9       1216
011011001       9       1280
011011010       9       1344
011011011       9       1408
010011000       9       1472
010011001       9       1536
010011010       9       1600
011000          6       1664
010011011       9       1728
00000001000     11      1792
00000001100     11      1856
00000001101     11      1920
000000010010    12      1984
000000010011    12      2048
000000010100    12      2112
000000010101    12      2176
000000010110    12      2240
000000010111    12      2304
000000011100    12      2368
000000011101    12      2432
000000011110    12      2496
000000011111    12      2560


Table 2a. Terminating Black Codes
Code            Lng     Run
---------------------------
0000110111      10      0
010             3       1
11              2       2
10              2       3
011             3       4
0011            4       5
0010            4       6
00011           5       7
000101          6       8
000100          6       9
0000100         7       10
0000101         7       11
0000111         7       12
00000100        8       13
00000111        8       14
000011000       9       15
0000010111      10      16
0000011000      10      17
0000001000      10      18
00001100111     11      19
00001101000     11      20
00001101100     11      21
00000110111     11      22
00000101000     11      23
00000010111     11      24
00000011000     11      25
000011001010    12      26
000011001011    12      27
000011001100    12      28
000011001101    12      29
000001101000    12      30
000001101001    12      31
000001101010    12      32
000001101011    12      33
000011010010    12      34
000011010011    12      35
000011010100    12      36
000011010101    12      37
000011010110    12      38
000011010111    12      39
000001101100    12      40
000001101101    12      41
000011011010    12      42
000011011011    12      43
000001010100    12      44
000001010101    12      45
000001010110    12      46
000001010111    12      47
000001100100    12      48
000001100101    12      49
000001010010    12      50
000001010011    12      51
000000100100    12      52
000000110111    12      53
000000111000    12      54
000000100111    12      55
000000101000    12      56
000001011000    12      57
000001011001    12      58
000000101011    12      59
000000101100    12      60
000001011010    12      61
000001100110    12      62
000001100111    12      63
0000001111      10      64
000011001000    12      128
000011001001    12      192
000001011011    12      256
000000110011    12      320
000000110100    12      384
000000110101    12      448
0000001101100   13      512
0000001101101   13      576
0000001001010   13      640
0000001001011   13      704
0000001001100   13      768
0000001001101   13      832
0000001110010   13      896
0000001110011   13      960
0000001110100   13      1024
0000001110101   13      1088
0000001110110   13      1152
0000001110111   13      1216
0000001010010   13      1280
0000001010011   13      1344
0000001010100   13      1408
0000001010101   13      1472
0000001011010   13      1536
0000001011011   13      1600
0000001100100   13      1664
0000001100101   13      1728
00000001000     11      1792
00000001100     11      1856
00000001101     11      1920
000000010010    12      1984
000000010011    12      2048
000000010100    12      2112
000000010101    12      2176
000000010110    12      2240
000000010111    12      2304
000000011100    12      2368
000000011101    12      2432
000000011110    12      2496
000000011111    12      2560
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\comm\special.txt ===
MODEMS REQUIRING SPECIAL SETTINGS (not yet on awmodem.inf)
	---------------------------------

Anderson Jacobson 1446 FX. Snowball SetupCommand=AT*LG1 (See pcfax bug 84).

Intel  High-Speed External Faxmodem 144/144e. Needs to be forced to be Class2
(pfcax bug 1510).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\headers\readme.txt ===
--------------------------------------
		COMMON directory for LocalFax Modules
		--------------------------------------

defs.h	Common defines
lpc.h   Interface to home-brew local RPC.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t.txt ===
C/C++ COMPILER OPTIONS

                              -OPTIMIZATION-

/O1 minimize space                       /Op[-] improve floating-pt consistency
/O2 maximize speed                       /Os favor code space
/Oa assume no aliasing                   /Ot favor code speed
/Ob<n> inline expansion (default n=0)    /Ow assume cross-function aliasing
/Od disable optimizations (default)      /Ox maximum opts. (/Ogityb1 /Gs)
/Og enable global optimization           /Oy[-] enable frame pointer omission
/Oi enable intrinsic functions

                             -CODE GENERATION-

/G3 optimize for 80386                   /Ge enable stack checking calls
/G4 optimize for 80486                   /Gs[num] disable stack checking calls
/G5 optimize for Pentium                 /Gh enable hook function call
/G6 optimize for Pentium Pro             /GR[-] enable C++ RTTI
/GB optimize for blended model (default) /GX[-] enable C++ EH (same as /EHsc)
/Gd __cdecl calling convention           /Gi[-] enable incremental compilation
/Gr __fastcall calling convention        /Gm[-] enable minimal rebuild
/Gz __stdcall calling convention         /EHs enable synchronous C++ EH
/GA optimize for Windows Application     /EHa enable asynchronous C++ EH
/GD optimize for Windows DLL             /EHc extern "C" defaults to nothrow
/Gf enable string pooling                /QIfdiv[-] enable Pentium FDIV fix 
/GF enable read-only string pooling      /QI0f[-] enable Pentium 0x0f fix
/Gy separate functions for linker

                              -OUTPUT FILES-

/Fa[file] name assembly listing file     /Fo<file> name object file
/FA[sc] configure assembly listing       /Fp<file> name precompiled header file
/Fd[file] name .PDB file                 /Fr[file] name source browser file
/Fe<file> name executable file           /FR[file] name extended .SBR file
/Fm[file] name map file

                              -PREPROCESSOR-

/C don't strip comments                  /FI<file> name forced include file
/D<name>{=|#}<text> define macro         /U<name> remove predefined macro
/E preprocess to stdout                  /u remove all predefined macros
/EP preprocess to stdout, no #line       /I<dir> add to include search path
/P preprocess to file                    /X ignore "standard places"

                                -LANGUAGE-

/vd{0|1} disable/enable vtordisp         /Za disable extensions (implies /Op)
/vm<x> type of pointers to members       /Ze enable extensions (default)
/Zi generate debugging information       /Zg generate function prototypes
/Z7 generate old-style debug info        /Zl omit default library name in .OBJ
/Zd line number debugging info only      /Zs syntax check only
/Zp[n] pack structs on n-byte boundary   /noBool disable "bool" keyword

                              -MISCELLANEOUS-

/?, /help print this help message        /V<string> set version string
/c compile only, no link                 /w disable all warnings
/H<num> max external name length         /W<n> set warning level (default n=1)
/J default char type is unsigned         /WX treat warnings as errors
/nologo suppress copyright message       /Yc[file] create .PCH file
/Tc<source file> compile file as .c      /Yd put debug info in every .OBJ
/Tp<source file> compile file as .cpp    /Yu[file] use .PCH file
/TC compile all files as .c              /YX[file] automatic .PCH
/TP compile all files as .cpp            /Zm<n> max memory alloc (% of default)

                                 -LINKING-

/MD link with MSVCRT.LIB                 /MDd link with MSVCRTD.LIB debug lib
/ML link with LIBC.LIB                   /MLd link with LIBCD.LIB debug lib
/MT link with LIBCMT.LIB                 /MTd link with LIBCMTD.LIB debug lib
/LD Create .DLL                          /F<num> set stack size
/LDd Create .DLL debug libary            /link [linker options and libraries]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\bin\cl.err ===
2001	"too many symbols predefined with /D"
2002    "memory-model conflict"
2003    "missing source filename"
2005    "%s requires /vmg"
2008	"limit of %s exceeded at '%s'"
2011	"only one floating-point option allowed"
2012	"too many linker arguments"
2013    "incomplete model specification"
2016    "%s and %s command-line options are incompatible"
2018	"cannot create linker response file"
2019	"cannot overwrite source or object file '%s'"
2020	"%s option requires extended keywords to be enabled (/Ze)"
2021	"invalid numeric argument '%s'"
2022	"cannot open '%s'"
2023    "invalid model specification - flat model only"
2027	"cannot execute '%s'"
2028    "too many open files; cannot redirect '%s'"
2030	"internal compiler error in '%s'"
2031    "too many command-line options"
2000	"unknown command-line error"

				

4001	"listing overrides assembly output"
4002	"ignoring unknown option '%s'"
4003	"processor-option conflict"
4004	"/G3 only available in optimizing compiler; assuming /G2"
4005	"cannot find '%s';\nPlease enter new filename (full path) or CTRL+C to quit: "
4007	"'%s' requires '%s'; option ignored"
4009	"threshold only for far or huge data; ignored"
4011	"preprocessing overrides source listing"
4012	"function declarations override source listing"
4013	"combined listing overrides object listing"
4014	"invalid value '%d' for '%s'; assuming '%d'"
4018	".DEF files supported for segmented executable files only"
4019	"string too long; truncated to %d characters"
4020    "'%s' : missing argument; option ignored"
4021    "no action performed"
4022	"option '%s' invalid for %d-bit target"
4023	"option '%s' forces use of optimizing compiler"
4000	"unknown command-line warning"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\bin\stress.ini ===
[STRESS]
; Initialization file for Stress.exe.  Must live in Windows directory to be
; have it's setting take affect. All settings (and ini file) are optional.
; For more information see the on-line Stress help file.

; Fixed settings, if ALLOCATIONS=Fixed set
GLOBAL=1500
USER=500
GDI=500
DISK=5
HANDLES=2

; Fixed or Random
ALLOCATIONS=random

; 1 - 4
STRESS_LEVEL=1

; Any #
SEED=17890

; disk gdi user kernel handles
RESOURCES=disk gdi user kernel handles

; 1 - 120 
TIME_INTERVAL=2

; Messages: WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, WM_SYSKEYDOWN, WM_CHAR,  ; WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK, WM_RBUTTONDOWN, ;WM_RBUTTONUP, WM_RBUTTONDBLCLK, 
MESSAGE=WM_LBUTTONDOWN

; Filename or filename with path
FILENAME=c:\win31\mystress.log

; Log to a file? yes or no
FILE_ON=yes

; 1 - 4
COM=1

; yes or no
EXECUTER_ON=no

; Stress Levels for Executor mode: 
; LEVELn=GlobalMin GlobalMax UserMin UserMax GDIMin GDIMax DiskMin DiskMax FilesMin 
; FilesMax.  Disk is in Mb. Everything else in bytes. 
LEVEL1=0 1500 0 500 0 500 0 1 0 1
LEVEL2=0 2000 0 1000 0 1000 0 1 0 2
LEVEL3=100 10000 100 8000 100 8000 0 1 0 3
LEVEL4=500 32000 500 16000 500 16000 0 1 0 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\bin\c1.err ===
4001	"nonstandard extension 'single line comment' was used"
4002	"too many actual parameters for macro '%s'"
4003	"not enough actual parameters for macro '%s'"
4004	"incorrect construction after 'defined'"
4005	"'%Fs' : macro redefinition"
4006	"#undef expected an identifier"
4007	"'%Fs' : must be '%Fs'"
4008	"'%Fs' : '%Fs' attribute ignored"
4009	"string too big; trailing characters truncated"
4010	"single-line comment contains line-continuation character"
4011	"'%Fs' : identifier was truncated to '%d' characters"
4012	"float constant in a cross compilation" 
4013	"'%Fs' undefined; assuming extern returning int"
4014	"concatenating mismatched wide strings"
4015	"'%Fs' : type of bit field must be integral"
4016	"'%s' : no function return type; using 'int' as default" 
4017	"cast of 'int' expression to far pointer"
4018	"'%Fs' : signed/unsigned mismatch"
4019	"empty statement at global scope"
4020	"'%Fs' : too many actual parameters"
4021	"'%Fs' : too few actual parameters"
4022	"'%Fs' : pointer mismatch for actual parameter %d"
4023	"'%Fs' : based pointer passed to unprototyped function : parameter %d"
4024	"'%Fs' : different types for formal and actual parameter %d"
4025	"'%Fs' : based pointer passed to function with variable arguments: parameter %d"
4026	"function declared with formal parameter list"
4027	"function declared without formal parameter list"
4028	"formal parameter %d different from declaration"
4029	"declared formal parameter list different from definition"
4030	"first formal parameter list longer than the second list"
4031	"second formal parameter list longer than the first list"
4032	"formal parameter %d has different type when promoted"
4033	"'%Fs' must return a value"
4034	"sizeof returns 0"
4035	"'%Fs' : no return value"
4036	"unnamed %Fs as actual parameter"
4037	"conflicting ambient class modifiers"
4038	"'%Fs' : illegal ambient class modifier"
4039	"ambient class modifier on reference ignored"
4040	"memory attribute on '%Fs' ignored"
4041	"compiler limit : terminating browser output"
4042	"'%Fs' : has bad storage class"
4043	"function specifier used more than once"
4044	"specifier __huge on '%Fs' ignored; can only be applied to array"
4045	"'%Fs' : array bounds overflow"
4046	"'%Fs' : unsized array treated as %Fs"
4047	"'%Fs' : different levels of indirection"
4048	"different declared array subscripts"
4049	"'%Fs' : indirection to different types"
4050	"'%Fs' : different code attributes"
4051	"type conversion; possible loss of data"
4052	"function declarations different; one contains variable arguments"
4053	"one void operand for '?:'"
4054	"'%Fs' : from function pointer '%Fs' to data pointer '%Fs'"
4055	"'%Fs' : from data pointer '%Fs' to function pointer '%Fs'"
4056	"overflow in floating-point constant arithmetic"
4057	"'%Fs' : indirection to slightly different base types"
4058	"unions are now aligned on alignment requirement, not size"
4059	"pascal string too big, length byte is length % 256"

4060	"switch statement contains no 'case' or 'default' labels"
4061	"enumerate '%Fs' in switch of enum '%Fs' is not explicitly handled by a case label"
4062	"enumerate '%Fs' in switch of enum '%Fs' is not handled"
4063	"case '%ld' is not a valid value for switch of enum '%Fs'"
4064	"switch of incomplete enum '%Fs'"
4065	"switch statement contains 'default' but no 'case' labels"

4067	"unexpected characters following '%Fs' directive - newline expected"
4068	"unknown pragma"
4069	"long double is the same precision as double"
4070	"return of a 'void' expression"
4071	"'%Fs' : no function prototype given"
4072	"'%Fs' : no function prototype on __fastcall function"
4073	"initializers put in library initialization area"
4074	"initializers put in compiler reserved initialization area"
4075	"initializers put in unrecognized initialization area"
4076	"'%Fs' : can be used on integral types only"
4077	"unknown check_stack option"
4078	"case constant '%ld' too big for the type of the switch expression"
4079	"unexpected token '%Fs'"
4080	"expected identifier for segment name; found '%Fs'"
4081	"expected a comma; found '%Fs'"
4082	"expected an identifier; found '%Fs'"
4083	"expected '('; found '%Fs'"
4084	"expected a pragma directive; found '%Fs'"
4085	"expected pragma parameter to be 'on' or 'off'"
4086	"expected pragma parameter to be '1', '2', '4', '8', or '16'"
4087	"'%Fs' : declared with 'void' parameter list"
4088	"'%Fs' : pointer mismatch in actual parameter %d, formal parameter %d"
4089	"'%Fs' : different types in actual parameter %d, formal parameter %d"
4090	"'%Fs' : different const or volatile qualifiers"
4091	"no symbols were declared"
4092	"sizeof returns 'unsigned long'"
4093	"unescaped newline in character constant in inactive code"
4094	"untagged '%Fs' declared no symbols"
4095	"expected ')'; found '%Fs'"
4096	"'%Fs' must be used with '%Fs'"
4097	"nonstandard extension : typedef-name '%Fs' used as synonym for class-name '%Fs'"
4098	"'%Fs' : 'void' function returning a value"
4099	"'%Fs' : type name first seen using '%Fs' now seen using '%Fs'"
4100	"'%Fs' : unreferenced formal parameter"
4101	"'%Fs' : unreferenced local variable"
4102	"'%Fs' : unreferenced label"
4103	"'%Fs' : used #pragma pack to change alignment"
4104	"'%Fs' : near data in same_seg pragma; ignored"
4105	"'%Fs' : code modifiers only on function or pointer to function"
4106	"pragma requires an integer between 1 and 127"
4107	"pragma requires an integer between 15 and 255"
4108	"pragma requires an integer between 79 and 132"
4109	"unexpected identifier '%Fs'"
4110	"unexpected token 'number'"
4111	"unexpected token 'string'"
4112	"#line requires an integer between 1 and 32767"
4113	"function parameter lists differed"
4114	"same type qualifier used more than once"
4115	"'%Fs' : named type definition in parentheses"
4116	"unnamed type definition in parentheses"
4117	"macro name '%Fs' is reserved, '%Fs' ignored"
4118	"pragma not supported during fast compile"
4119	"different bases '%Fs' and '%Fs' specified"
4120	"based/unbased mismatch"
4121	"'%Fs' : alignment of a member was sensitive to packing"
4122	"'%Fs' : alloc_text applicable only to functions with C linkage"
4123	"different base expressions specified"
4124	"__fastcall with stack checking is inefficient"
4125	"decimal digit terminates octal escape sequence"
4126	"'%c' : unknown memory-model command-line option"
4127	"conditional expression is constant"
4128	"storage-class specifier after type"
4129	"'%c' : unrecognized character escape sequence"
4130	"'%Fs' : logical operation on address of string constant"
4131	"'%Fs' : uses old-style declarator"
4132	"'%Fs' : const object should be initialized"
4133	"'%Fs' : incompatible types - pointer to 'void' combined with pointer to type"
4134	"conversion between pointers to members of same class"
4135	"conversion between different integral types"
4136	"conversion between different floating-point types"
4137	"'%Fs' : no return value from floating-point function"
4138	"'*/' found outside of comment"
4139	"'0x%lx' : hex escape sequence is out of range"
4140	"'%Fs' : redefined, preceding references may be invalid"  
4141	"'%Fs' : used more than once"
4142	"benign redefinition of type"
4143	"pragma 'same_seg' not supported; use __based allocation"
4144	"'%Fs' : relational expression as switch expression"
4145	"'%Fs' : relational expression as switch expression; possible confusion with '%Fs'"
4146	"unary minus operator applied to unsigned type, result still unsigned"
4147	"'%Fs' : '%Fs' ignored on pointer and reference declarations"
4148	"'%Fs' : DS != SS for '__near' '%Fs'"
4149	"'%Fs' : different ambient model than base class '%Fs'"
4150	"deletion of pointer to incomplete type '%Fs'; no destructor called"
4151	"'%Fs' : operator should be explicitly '%Fs'"
4152	"nonstandard extension, function/data pointer conversion in expression"
4153	"function/data pointer conversion in expression"
4154	"deletion of an array expression; conversion to pointer supplied"
4155	"deletion of an array expression without using the array form of 'delete'"
4156	"deletion of an array expression without using the array form of 'delete'; array form substituted"
4157	"pragma was ignored by C compiler"
4158	"assuming #pragma pointers_to_members(full_generality, %Fs_inheritance)"

4184	"near call to thunk for '%Fs' in a different segment"

4200	"nonstandard extension used : zero-sized array in struct/union"
4201	"nonstandard extension used : nameless struct/union"
4202	"nonstandard extension used : '...': prototype parameter in name list illegal"
4203	"nonstandard extension used : union with static member variable"
4204	"nonstandard extension used : non-constant aggregate initializer"
4205	"nonstandard extension used : static function declaration in function scope"
4206	"nonstandard extension used : translation unit is empty"
4207	"nonstandard extension used : extended initializer form"
4208	"nonstandard extension used : delete [exp] - exp evaluated but ignored"
4209	"nonstandard extension used : benign typedef redefinition"
4210	"nonstandard extension used : function given file scope"
4211	"nonstandard extension used : redefined extern to static"
4212	"nonstandard extension used : function declaration used ellipsis"
4213	"nonstandard extension used : cast on l-value"
4214	"nonstandard extension used : bit field types other than int"
4215	"nonstandard extension used : long float"
4216	"nonstandard extension used : float long"
4217	"nonstandard extension used : function declaration from a previous block"
4218	"nonstandard extension used : must specify at least a storage class or a type"
4219	"nonstandard extension used : trailing ',' used for variable argument list"
4220	"varargs matches remaining parameters"
4221	"nonstandard extension used : '%Fs' : cannot be initialized using address of automatic variable '%Fs'"
4222	"nonstandard extension used : '%Fs' : 'static' should not be used on member functions defined at file scope"
4223	"nonstandard extension used : non-lvalue array converted to pointer"

4241	"'%Fs' : member access is restricted"

4243	"%Fs conversion from '%Fs' to '%Fs' exists, but is inaccessible"

4245	"'friend' specified for nonexistent function '%Fs'"

4247	"'%Fs' not accessible because '%Fs' uses '%Fs' to inherit from '%Fs'"
4248	"'%Fs' : cannot access %Fs %Fs declared in class '%Fs'"
4249	"'%Fs' : no path to %Fs %Fs declared in virtual base '%Fs'"
4250	"'%Fs' : inherits '%Fs::%Fs' via dominance"
4251	"'%Fs' : base type '%Fs' should be exported to export %Fs '%Fs'"
4252	"'%Fs' is not defined; cannot specify CodeView information"

4260	"no override, '%Fs::%Fs' has %Fs 'this' memory model whereas '%Fs::%Fs' has %Fs 'this' memory model"
4261	"no override, '%Fs::%Fs' has %Fs calling convention whereas '%Fs::%Fs' has %Fs calling convention"
4262	"no override, '%Fs::%Fs' has %Fs 'this' whereas '%Fs::%Fs' has %Fs 'this'"

4270	"'%Fs' : do not initialize a non-const '%Fs' with a non-lvalue '%Fs' function return"

4300	"conversion of pointer to nonintegral type"

4305	"'%Fs' : truncation from '%Fs' to '%Fs'"
4306	"'%Fs' : conversion from '%Fs' to '%Fs' of greater size"
4307	"'%Fs' : integral constant overflow"
4308	"negative integral constant converted to unsigned type"
4309	"'%Fs' : truncation of constant value"

4341	"'%Fs' : signed value is out of range for enum constant"
4342	"precision lost in initialization of enum constant"

4354	"'%Fs' : initialization of reference to member requires a temporary variable"
4355	"'this' : used in base member initializer list"

4385	"%Fs the '%Fs' in base '%Fs'"
4386	"%Fs to the '%Fs' in base '%Fs'"
4387	"'%Fs' : was considered"

4401	"'%Fs' : member is bit field"
4402	"must use PTR operator"
4403	"illegal PTR operator"
4404	"period on directive ignored"
4405	"'%Fs' : identifier is reserved word"
4406	"operand on directive ignored"

4409	"illegal instruction size"
4410	"illegal size for operand"
4411	"'%Fs' : symbol resolves to displacement register"

4414	"'%Fs' : short jump to function converted to near"

4500	"'%Fs' : class has private/protected data members; user-defined constructor advised"
4501	"'%Fs' : use of '::' unnecessary here"
4502	"'linkage' requires use of keyword 'extern'"

4504	"type still ambiguous after parsing %d tokens, assuming declaration"
4505	"'%Fs' : unreferenced local function has been removed"
4506	"no definition for inline function '%Fs'"
4507	"explicit linkage specified after default linkage was used"
4508	"'%Fs' : function should return a value; 'void' return type assumed"

4510	"'%Fs' : default constructor could not be generated"
4511	"'%Fs' : copy constructor could not be generated"
4512	"'%Fs' : assignment operator could not be generated"
4513	"'%Fs' : destructor could not be generated"

4520	"'%Fs' : multiple default constructors specified"
4521	"'%Fs' : multiple copy constructors specified"
4522	"'%Fs' : multiple assignment operators specified"
4523	"'%Fs' : multiple destructors specified"
4524	"'%Fs' : redundant use of 'friend' on destructor"
4525	"'%Fs' : redundant use of 'friend' on constructor"

4527	"instances of %Fs '%Fs' can never be destroyed - user-defined destructor required"
4528	"illegal 'pure' syntax, must be '= 0'"

4607	"'%Fs' : must be initialized in constructor base/member initializer list"

4610	"%Fs '%Fs' can never be instantiated - user defined constructor required"

4612	"bad #pragma syntax, pragma ignored"
4613	"'%Fs' : class of segment cannot be changed"
4614	"'%Fs' : varargs parameters with this type were promoted"	
4615	"#pragma warning : unknown user warning type"
4616	"#pragma warning : warning number '%d' out of range, must be between '%d' and '%d'"
4617	"#pragma warning : invalid warning number"

4620	"no postfix form of 'operator ++' found for type '%Fs', using prefix form"
4621	"no postfix form of 'operator --' found for type '%Fs', using prefix form"
4622	"overwriting debug information formed during creation of the precompiled header in object file: '%s'"

4630	"'%Fs' : '%Fs' storage-class specifier illegal on member definition"

4650	"debugging information not in precompiled header; only global symbols from the header will be available"
4651	"'/D%s' specified for precompiled header but not for current compile"
4652	"command-line option '%Fs' inconsistent with precompiled header; precompiled header option ignored"

4699	"Note: %Fs"

4706	"assignment within conditional expression" 

4710	"'%Fs' : function not expanded" 

4726	"'%c' : unknown memory model command-line option"
4727	"conditional expression is constant"

4741	"/Oq option ignored for __fastcall function '%Fs'"

4746	"'%Fs' : unsized array given size %Fs"

4756	"overflow in constant arithmetic"	

4758	"address of automatic (local) variable taken, DS != SS" 
4759	"segment lost in conversion"	
4760	"'%Fs' : segment lost in initialization"	

4761	"integral size mismatch in argument : conversion supplied"	
4762	"near/far mismatch in argument : conversion supplied"	

4769	"conversion of near pointer to long integer"	

4785	"near call to '%Fs' in different segment" 

4788	"'%Fs' : identifier was truncated to '%d' characters"

4793	"native code generated for p-code function '%Fs' with inline assembly"

4900	"intermediate language mismatch between '%s' version '%ld' and '%s' version '%ld'"

4000	"UNKNOWN WARNING\n\t\tContact Microsoft Product Support Services"
						

2001	"newline in constant"
2002	"invalid wide-character constant"
2003	"expected 'defined id'"
2004	"expected 'defined(id)'"
2005	"#line expected a line number, found '%Fs'"
2006	"#include expected a filename, found '%Fs'"
2007	"#define syntax"
2008	"'%c' : unexpected in macro definition"
2009	"reuse of macro formal '%Fs'"
2010	"'%c' : unexpected in macro formal parameter list"
2011	"'%Fs' : '%Fs' type redefinition"
2012	"missing name following '<'"
2013	"missing '>'"
2014	"preprocessor command must start as first nonwhite space"
2015	"too many characters in constant"
2016	"no closing single quotation mark"
2017	"illegal escape sequence"
2018	"unknown character '0x%x'"
2019	"expected preprocessor directive, found '%c'"
2020	"'%Fs' : '%Fs' member redefinition"
2021	"expected exponent value, not '%c'"
2022	"'%ld' : too big for character"
2023	"divide by 0"
2024	"mod by 0"
2025	"'%s' : enum/struct/union type redefinition"		
2026	"string too big, trailing characters truncated"
2027	"use of undefined type '%Fs'"
2028	"struct/union member must be inside a struct/union"
2029	"left of '%s' specifies undefined class/struct/union '%Fs'"
2030	"'%Fs' : struct/union member redefinition"		
2031	"'%Fs' : function cannot be struct/union member"	
2032	"'%Fs' : function cannot be member of %Fs '%Fs'"
2033	"'%Fs' : bit field cannot have indirection"
2034	"'%Fs' : type of bit field too small for number of bits"
2035	"struct/union '%Fs' : unknown size"			
2036	"'%Fs' : unknown size"
2037	"left of '%s' specifies undefined struct/union '%Fs'"
2038	"'%s' : not struct/union member"			
2039	"'%Fs' : is not a member of '%Fs'"
2040	"'%Fs' : different levels of indirection"
2041	"illegal digit '%c' for base '%d'"
2042	"signed/unsigned keywords mutually exclusive"
2043	"illegal break"
2044	"illegal continue"
2045	"'%Fs' : label redefined"
2046	"illegal case"
2047	"illegal default"
2048	"more than one default"
2049	"case value '%ld' already used"
2050	"switch expression not integral"
2051	"case expression not constant"
2052	"case expression not integral"
2053	"'%Fs' : wide string mismatch"
2054	"expected '(' to follow '%Fs'"
2055	"expected formal parameter list, not a type list"
2056	"illegal expression"
2057	"expected constant expression"
2058	"constant expression is not integral"
2059	"syntax error : '%Fs'"
2060	"syntax error : end of file found"
2061	"syntax error : identifier '%Fs'"
2062	"type '%Fs' unexpected"
2063	"'%Fs' : not a function"
2064	"term does not evaluate to a function"
2065	"'%Fs' : undeclared identifier"
2066	"cast to function type is illegal"
2067	"cast to array type is illegal"
2068	"illegal cast from '%Fs' to '%Fs'"
2069	"cast of 'void' term to non-'void'"
2070	"illegal sizeof operand"
2071	"'%Fs' : illegal storage class"
2072	"'%Fs' : initialization of a function"
2073	"'%Fs' : partially initialized array requires a default constructor"
2074	"'%Fs' : '%Fs' initialization needs curly braces"
2075	"'%Fs' : array initialization needs curly braces"
2076	"'%Fs' : struct/union initialization needs curly braces" 
2077	"nonscalar field initializer '%Fs'"
2078	"too many initializers"
2079	"'%Fs' uses undefined class/struct/union '%Fs'"
2080	"illegal __far __fastcall function or __saveregs function"
2081	"'%Fs' : name in formal parameter list illegal"
2082	"redefinition of formal parameter '%Fs'"
2083	"%Fs comparison illegal"
2084	"function '%Fs' already has a body"
2085	"'%Fs' : not in formal parameter list"
2086	"'%Fs' : redefinition"
2087	"'%Fs' : missing subscript"
2088	"'%Fs' : illegal for %Fs"
2089	"'%Fs' : '%Fs' too large"
2090	"function returns array"
2091	"function returns function"
2092	"array element type cannot be function"
2093	"'%Fs' : cannot be initialized using address of automatic variable '%Fs'"
2094	"label '%Fs' was undefined"
2095	"'%Fs' : actual parameter has type 'void' : parameter %d"
2096	"struct/union comparison illegal"		
2097	"illegal initialization"
2098	"expression is not an address"
2099	"initializer is not a constant"
2100	"illegal indirection"
2101	"'%Fs' on constant"
2102	"'%Fs' requires l-value"
2103	"'%Fs' on register variable"
2104	"'%Fs' on bit field ignored"
2105	"'%Fs' needs l-value"
2106	"'%Fs' : left operand must be l-value"
2107	"illegal index, indirection not allowed"
2108	"subscript is not of integral type"
2109	"subscript requires array or pointer type"
2110	"cannot add two pointers"
2111	"pointer addition requires integral operand"
2112	"pointer subtraction requires integral or pointer operand"
2113	"pointer can only be subtracted from another pointer"
2114	"'%Fs' : pointer on left; needs integral value on right"
2115	"'%Fs' : incompatible types"
2116	"function parameter lists differed"
2117	"'%Fs' : array bounds overflow"
2118	"negative subscript"
2119	"typedef types both define indirection"
2120	"'void' illegal with all types"
2121	"'%Fs' : bad %Fs operand"
2122	"'%Fs' : prototype parameter in name list illegal"
2123	"'%Fs' : cannot call __fastcall function '%Fs' from p-code"
2124	"divide or mod by zero"
2125	"'%Fs' : allocation exceeds 64K"	
2126	"'%Fs' : incorrect operand"
2127	"parameter allocation exceeds 32K"	
2128	"'%Fs' : alloc_text/same_seg applicable only to functions with C linkage"
2129	"static function '%Fs' declared but not defined"
2130	"#line expected a string containing the filename, found '%Fs'"
2131	"more than one memory attribute"
2132	"syntax error : unexpected identifier"
2133	"'%Fs' : unknown size"
2134	"'%Fs' : struct/union too large"	
2135	"'%Fs' : illegal bit field operation"
2136	"'%Fs' : prototype must have parameter types"
2137	"empty character constant"
2138	"illegal to define an enumeration without any members"
2139	"type following '%s' is illegal"
2140	"parameter cannot be function type"
2141	"value out of range for enum constant"
2142	"function declarations differ, variable parameters specified only in one of them"
2143	"syntax error : missing '%Fs' before '%Fs'"
2144	"syntax error : missing '%Fs' before type '%Fs'"
2145	"syntax error : missing '%Fs' before identifier"
2146	"syntax error : missing '%Fs' before identifier '%Fs'"
2147	"'%Fs' : const array must be fully initialized"
2148	"array too large"
2149	"'%Fs' : named bit field cannot have zero width"
2150	"'%Fs' : bit field must have type 'int', 'signed int', or 'unsigned int'"
2151	"more than one language attribute"
2152	"'%Fs' : pointers to functions with different attributes"
2153	"hex constants must have at least one hex digit"
2154	"'%Fs' : does not refer to a segment name"
2155	"'?' : invalid left operand, expected arithmetic or pointer type"
2156	"pragma must be outside function"
2157	"'%Fs' : must be declared before use in pragma list"
2158	"'%Fs' : is a function"
2159	"more than one storage class specified"
2160	"'##' cannot occur at the beginning of a macro definition"
2161	"'##' cannot occur at the end of a macro definition"
2162	"expected macro formal parameter"
2163	"'%Fs' : not available as an intrinsic function"
2164	"'%Fs' : intrinsic function not declared"
2165	"'%Fs' : cannot modify pointers to data"
2166	"l-value specifies const object"
2167	"'%Fs' : too many actual parameters for intrinsic function"
2168	"'%Fs' : too few actual parameters for intrinsic function"
2169	"'%Fs' : intrinsic function, cannot be defined"
2170	"'%Fs' : not declared as a function, cannot be intrinsic"
2171	"'%Fs' : illegal operand"
2172	"'%Fs' : actual parameter is not a pointer : parameter %d"
2173	"'%Fs' : actual parameter is not a pointer : parameter %d, parameter list %d"
2174	"'%Fs' : actual parameter has type 'void' : parameter %d, parameter list %d"
2175	"'%Fs' : invalid locale"
2176	"static huge data not supported by '%Fs'"	 
2177	"constant too big"
2178	"'%Fs' : storage class for same_seg variables must be extern"
2179	"'%Fs' : was used in same_seg, but storage class is no longer extern"
2180	"controlling expression has type 'void'"
2181	"illegal else without matching if"
2182	"'%Fs' : has type 'void'"
2183	"syntax error: translation unit is empty"
2184	"illegal return of a 'void' value"
2185	"'%Fs' : illegal based allocation"
2186	"'%Fs' : illegal operand of type 'void'"
2187	"cast of near function pointer to far function pointer"
2188	"'%ld' : too big for wide character"
2189	"#error : %Fs"
2190	"first parameter list longer than second"
2191	"second parameter list longer than first"
2192	"parameter '%d' declaration different"
2193	"'%Fs' : already in a segment"
2194	"'%Fs' : is a text segment"
2195	"'%Fs' : is a data segment"
2197	"'%Fs' : too many actual parameters"
2198	"'%Fs' : too few actual parameters"
2199	"syntax error : found '%Fs (' at global scope (was a declaration intended?)"
2200	"'%Fs' : function has already been defined"
2201	"'%Fs' : cannot export static declarations"
2202	"'%Fs' : not all control paths return a value"
2203	"delete operator cannot specify bounds for an array"
2204	"'%Fs' : type definition found within parentheses"
2205	"'%Fs' : cannot initialize extern variables with block scope"
2206	"'%Fs' : typedef cannot be used for function definition"
2207	"'%Fs' in struct/union '%Fs' has a zero-sized array"	
2208	"'%Fs' : no members defined using this type"
2209	"type cast in __based construct must be (__segment)"
2210	"'%Fs' : must be near/far data pointer"
2211	"(__segment) applied to function identifier '%Fs'"
2212	"'%Fs' : __based not available for pointers to functions"
2213	"'%Fs' : illegal argument to __based"
2214	"pointers based on 'void' require the use of :>"
2215	"':>' operator only for objects based on 'void'"
2216	"'%Fs' cannot be used with '%Fs'"
2217	"'%Fs' must be used with '%Fs'"
2218	"type in __based construct must be 'void'"
2219	"syntax error : type qualifier must be after '*'"
2220	"warning treated as error - no object file generated"
2221	"'.' : left operand points to class/struct/union, use '->'" 
2222	"'->' : left operand has struct/union type, use '.'"	
2223	"left of '->%Fs' must point to class/struct/union"
2224	"left of '.%Fs' must have class/struct/union type"
2225    "'%Fs' : function allocation must be in a named segment"
2226	"syntax error : unexpected type '%Fs'"
2227	"left of '->%Fs' must point to class/struct/union"
2228	"left of '.%Fs' must have class/struct/union type"
2229	"%Fs '%Fs' has an illegal zero-sized array"
2230	"'%Fs' : indirection to different types"
2231	"'.' : left operand points to '%Fs', use '->'"
2232	"'->' : left operand has '%Fs' type, use '.'"
2233	"'%Fs' : arrays of objects containing zero-size arrays are illegal"
2234	"arrays of references are illegal"
2235	"';' in formal parameter list"
2236	"unexpected '%Fs' '%Fs'"
2237	"unexpected %Fs '%Fs'"
2238	"unexpected token[s] preceding '%s'"
2239	"unexpected token '%Fs' following declaration of '%Fs'"
2240	"unexpected '%Fs' following formal list (only modifiers are allowed)"
2241	"'%Fs' : member access is restricted"
2242	"typedef name cannot follow class/struct/union"
2243	"%Fs conversion from '%Fs' to '%Fs' exists, but is inaccessible"
2244	"'%Fs' : unable to resolve function overload"
2245	"nonexistent function '%Fs' specified as friend"
2246	"'%Fs' : illegal static data member in locally defined class"
2247	"'%Fs' not accessible because '%Fs' uses '%Fs' to inherit from '%Fs'"
2248	"'%Fs' : cannot access %Fs %Fs declared in class '%Fs'"
2249	"'%Fs' : no accessible path to %Fs %Fs declared in virtual base '%Fs'"
2250	"'%Fs' : ambiguous inheritance of '%Fs::%Fs'"
2251	"'%Fs' : defined but not declared"
2252	"'%Fs' : pure specifier can only be specified for functions"
2253	"'%Fs' : pure specifier only applies to virtual function - specifier ignored"
2254	"'%Fs' : pure specifier not allowed on friend functions"
2255	"'%Fs' : a friend function can only be declared in a class"
2256	"illegal use of friend specifier on '%Fs'"
2257	"p-code generation pragma not allowed without /Oq"
2258	"illegal pure syntax, must be '= 0'"
2259	"'%Fs' : illegal attempt to instantiate abstract class"
2260	"function pointer cast to a data pointer"
2261	"data pointer cast to a function pointer"
2262	"'%Fs' : cannot be destroyed"
2263	"function returns pointer based on __self"
2264	"'%Fs' : error in function definition or declaration; function not called"
2265	"'%Fs' : reference to a zero-sized array is illegal"
2266	"'%Fs' : reference to a nonconstant bounded array is illegal"
2267	"'%Fs' : static functions with block scope are illegal"
2268	"'%Fs' : different const or volatile qualifiers"
2269	"'%Fs' : different ambient model than base class '%Fs'"
2270	"'%Fs' : modifiers not allowed on nonmember functions"
2271	"'%Fs' : new/delete cannot have formal list modifiers"
2272	"'%Fs' : modifiers not allowed on static member functions"
2273	"'%Fs' : illegal as right side of '->' operator"
2274	"'%Fs' : illegal as right side of '.' operator"
2275	"'%Fs' : illegal use of this type as an expression"
2276	"'%Fs' : illegal operation on bound member function expression"
2277	"'%Fs' : cannot take the address of a constructor"
2278	"'%Fs' : no function with C linkage found"
2279	"cannot use braces to initialize default arguments"
2280	"missing '{' before identifier '%Fs'?"
2281	"'%Fs' : is not a function, but contains <function returning>; '%Fs' is unexpected"
2282	"'%Fs' is followed by '%Fs' (missing ','?)"
2283	"'%Fs' : pure specifier not allowed on unnamed %Fs"
2284	"unbalanced parenthesis found while processing a member function"
2285	"pointers to members representation has already been determined - pragma ignored"
2286	"pointers to members of '%Fs' representation is already set to %s inheritance - declaration ignored"
2287	"'%Fs': inheritance representation: '%Fs' is less general than the required '%Fs'"
2288	"typedef has a trailing __based which cannot be applied to the symbol's indirection"
2289	"same type qualifier used more than once"
2290	"C++ '%Fs' syntax is reserved for future use"
2291	"'%Fs' : illegal modifier '%Fs' for 'this' pointer"
2292	"'%Fs': best case inheritance representation: '%Fs' declared but '%Fs' required"
2293	"'%Fs': illegal to have a non-static member variable as a __based specifier"

2300	"'%Fs' : class does not have a destructor called '~%Fs'"
2301	"left of '->~%Fs' must point to class/struct/union"
2302	"left of '.~%Fs' must have class/struct/union type"

2350	"'%Fs' is not a static member"
2351	"obsolete C++ constructor initialization syntax"
2352	"'%Fs::%Fs' : illegal call of nonstatic member function"
2353	"'%Fs' : improper use of constructor initializers"
2354	"'%Fs' : initialization of reference member requires a temporary variable"
2355	"'this' : can only be referenced inside nonstatic member functions"
2356	"initialization segment must not change during translation unit"

2360	"initialization of '%Fs' is skipped by 'case' label"
2361	"initialization of '%Fs' is skipped by 'default' label"
2362	"initialization of '%Fs' is skipped by 'goto %Fs'"

2369	"'%Fs' : redefinition; different subscripts"
2370	"'%Fs' : redefinition; different storage class"
2371	"'%Fs' : redefinition; different basic types"
2372	"'%Fs' : redefinition; different types of indirection"
2373	"'%Fs' : redefinition; different type modifiers"
2374	"'%Fs' : redefinition; multiple initialization"
2375	"'%Fs' : redefinition; different linkage"
2376	"'%Fs' : redefinition; different based allocation"
2377	"'%Fs' : redefinition; typedef cannot be overloaded with any other symbol"
2378	"'%Fs' : redefinition; symbol cannot be overloaded with a typedef"
2379	"formal parameter %d has different type when promoted"
2380	"type[s] preceding '%Fs' (constructor with return type, or illegal redefinition of current class-name?)"

2385	"'%Fs::%Fs' is ambiguous"
2386	"ambiguous conversion from '%Fs*' to '%Fs*'"
2387	"ambiguous conversion from '%Fs&' to '%Fs&'"

2390	"'%Fs' : incorrect storage class '%Fs'"
2391	"'%Fs' : 'friend' cannot be used during type definition"

2400	"inline syntax error in '%Fs'; found '%Fs'"
2401	"'%Fs' : register must be base in '%Fs'"
2402	"'%Fs' : register must be index in '%Fs'"
2403	"'%Fs' : register must be base/index in '%Fs'"
2404	"'%Fs' : illegal register in '%Fs'"
2405	"illegal short forward reference with offset"
2406	"'%Fs' : name undefined in '%Fs'"
2407	"illegal 'float' register in '%Fs'"
2408	"illegal type on PTR operator in '%Fs'"
2409	"illegal type used as operator in '%s'"
2410	"'%Fs' : ambiguous member name in '%Fs'"
2411	"'%Fs' : illegal struct/union member in '%Fs'"
2412	"'%Fs' : case-insensitive label redefined"
2413	"'%Fs' : illegal align size"
2414	"illegal number of operands"
2415	"improper operand type"
2416	"'%Fs' : illegal opcode for processor"
2417	"divide by zero in '%Fs'"
2418	"'%Fs' : not in a register"
2419	"mod by zero in '%Fs'"
2420	"'%Fs' : illegal symbol in %Fs"
2421	"PTR operator used with register in '%Fs'"
2422	"illegal segment override in '%Fs'"
2423	"'%ld' : illegal scale"
2424	"'%Fs' : improper expression in '%Fs'"
2425	"'%Fs' : nonconstant expression in '%Fs'"
2426	"'%Fs' : illegal operator in '%Fs'"
2427	"'%Fs' : jump referencing label is out of range"	

2429	"'%Fs' : illegal far label reference"
2430	"more than one index register in '%Fs'"
2431	"illegal index register in '%Fs'"
2432	"illegal reference to 16-bit data in '%Fs'"
2433	"'%Fs' : '%Fs' not permitted on data declarations"
2434	"'%Fs' : cannot convert default argument from '%Fs' to '%Fs'"
2435	"'%Fs' : function called before default arguments were resolved"
2436	"'%Fs' : cannot initialize member functions"
2437	"'%Fs' : already initialized"
2438	"'%Fs' : cannot initialize static class data via constructor"
2439	"'%Fs' : member could not be initialized"
2440	"'%Fs' : cannot convert from '%Fs' to '%Fs'"
2441	"function call through pointer before default arguments were resolved"
2442	"p-code expression too complex for setjmp or Catch"
2443	"operand size conflict"

2446	"'%Fs' : no conversion from '%Fs' to '%Fs'"
2447	"missing function header (old-style formal list?)"
2448	"'%Fs' : function-style initializer appears to be a function definition"
2449	"found '{' at file scope (missing function header?)"
2450	"switch expression of type '%Fs' is illegal"
2451	"conditional expression of type '%Fs' is illegal"
2452	"array bound expression of type '%Fs' is illegal"
2453	"array bound expression uses function name"

2458	"'%Fs' : redefinition within definition"
2459	"'%Fs' : is being defined; cannot add as an anonymous member"
2460	"'%Fs' : uses '%Fs', which is being defined"
2461	"'%Fs' : constructor syntax missing formal parameters"
2462	"'%Fs' : cannot define a type in a 'new-expression'"
2463	"cannot define an anonymous type in a 'new-expression'"
2464	"'%Fs' : cannot use 'new' to allocate a reference"
2465	"cannot define an anonymous type inside parentheses"
2466	"cannot allocate an array of constant size 0"
2467	"illegal declaration of anonymous '%Fs'"
2468	"'new' : cannot allocate 'const'/'volatile' objects (type is '%Fs')"
2470	"cannot open database '%Fs'"
2471	"cannot update database '%Fs'"

2500	"'%Fs' : '%Fs' is already a direct base class"
2501	"'%Fs' : missing decl-specifiers"
2502	"'%Fs' : too many access modifiers on the base class"
2503	"'%Fs' : base classes cannot contain zero-sized arrays"
2504	"'%Fs' : base class undefined"
2505	"'%Fs' : is not a legal base class"
2506	"'%Fs' : ambiguous"
2507	"'%Fs' : too many virtual modifiers on the base class"
2508	"'%Fs' : access denied"
2509	"'%Fs' : member function not declared in '%Fs'"
2510	"'%Fs' : left of '::' must be a class/struct/union"
2511	"'%Fs' : overloaded member function not found in '%Fs'"
2512	"'%Fs' : no appropriate default constructor available"
2513	"'%Fs' : decl-specifier is missing a declarator before '='"
2514	"'%Fs' : class has no constructors"
2515	"'%Fs' : not in class '%Fs'"

2517	"'%Fs' : right of '::' is undefined"

2519	"cannot convert '%Fs *' to '%Fs *'"

2523	"'%Fs::~%Fs' : destructor tag mismatch"
2524	"'%Fs' : destructors must have a 'void' formal parameter list"
2525	"'%Fs' : explicit destructor is named but not called"

2527	"'%Fs' : array of references must be fully initialized"
2528	"illegal pointer to reference"
2529	"illegal reference to a reference"
2530	"'%Fs' : references must be initialized"
2531	"'%Fs' : reference to a bit field illegal"
2532	"'%s' : cannot modify references"
2533	"'%Fs' : constructors not allowed a return type"
2534	"'%Fs' : constructor cannot return a value"
2535	"'%Fs' : member function already defined or declared"
2536	"'%Fs::%Fs' : cannot specify explicit initializer for arrays"
2537	"'%Fs' : illegal linkage specification"
2538	"new : cannot specify initializer for arrays"
2539	"new : '%Fs' no default constructor to initialize arrays of objects"
2540	"nonconstant expression as array bound"
2541	"delete : cannot delete objects that are not pointers"
2542	"'%Fs' : class object has no constructor for initialization"
2543	"expected ']' for operator '[]'"
2544	"expected ')' for operator '()'"
2545	"'%Fs' : unable to find overloaded operator"
2546	"'%Fs' : illegal mix of 'void' pointer with pointer to type"
2547	"illegal cast of overloaded function"
2548	"'%Fs' : missing default parameter for parameter %s"
2549	"user-defined conversion cannot specify a return type"
2550	"'%Fs' : constructor initializer lists are only allowed on constructor definitions"
2551	"'void *' type needs explicit cast"
2552	"'%Fs' : nonaggregates cannot be initialized with initializer list"
2553	"no legal conversion of return value to return type '%Fs'"
2555	"'%Fs::%Fs' : overriding virtual function differs from '%Fs::%Fs' only by return type"
2556	"'%Fs' : overloaded functions only differ by return type"
2557	"'%Fs' : private and protected members cannot be initialized without a constructor"
2558	"'%Fs' : no copy constructor available"
2559	"'%Fs' : no match for specified operator"
2560	"'%Fs' : overloaded function differs only by calling convention/memory model"
2561	"'%Fs' : function must return a value"
2562	"'%Fs' : 'void' function returning a value"
2563	"mismatch in formal parameter list"
2564	"formal/actual parameters mismatch in call through pointer to function"
2565	"'::%Fs' was previously declared as a global function"
2566	"overloaded function in conditional expression"
2567	"'%Fs' : intrinsic function must have prototypes when using C++"
2568	"'%Fs' : unable to resolve function overload '%Fs'"
2569	"'%Fs' : union cannot be used as a base class"
2570	"'%Fs' : union cannot have base classes"
2571	"'%Fs' : union cannot have virtual function '%Fs'"
2572	"'%Fs' : redefinition of default parameter : parameter %s"
2573	"'%Fs' : simple type cast must have exactly one expression"
2574	"'%Fs' : illegal static destructor declaration"
2575	"'%Fs' : only member functions and bases can be virtual"
2576	"'%Fs' : virtual used for static member function"
2577	"'%Fs' : destructor cannot return a value"

2579	"'%Fs::%Fs(%s)' : parameter list not sufficiently different to '%Fs::%Fs(%s)'"
2580	"redefinition of class name '%Fs'"
2581	"'%Fs' : static 'operator =' function is illegal"
2582	"'%Fs' : 'operator =' function is unavailable"
2583	"'%Fs' : illegal const/volatile 'this' pointer used for constructors/destructors"
2584	"'%Fs' : direct base '%Fs' is inaccessible; already a base of '%Fs'"
2585	"explicit conversion to '%Fs' is ambiguous"
2586	"incorrect user-defined conversion syntax : illegal indirections"
2587	"'%Fs' : illegal use of local variable as default parameter"
2588	"'::~%Fs' : illegal global destructor"
2589	"'%Fs' : illegal token on right side of '::'"
2590	"'%Fs' : ambiguous user-defined conversions in switch expression"
2591	"'%Fs' : ambiguous user-defined conversions in conditional expression"
2592	"no legal conversion of initialization expression to type '%Fs'"
2593	"'operator %Fs' is ambiguous"
2594	"'%Fs' : ambiguous conversions from '%Fs' to '%Fs'"
2595	"'%Fs' : qualified name already has a constructor"
2596	"'%Fs' : qualified name already has a destructor"
2597	"'%Fs' : does not specify an object"
2598	"linkage specification must be at global scope"
2599	"'%Fs' : local functions are not supported"
2601	"functions cannot be defined in local classes"
2602	"'%Fs::%Fs' is not a member of a base of '%Fs'"
2603	"illegal access declaration: '%Fs' is not a direct base of '%Fs'"
2604	"cannot declare %Fs access to %Fs member '%Fs::%Fs'"
2605	"overloaded functions '%Fs::%Fs' do not have same access"
2606	"'%Fs::%Fs': illegal private access declaration"
2607	"'%Fs' : cannot implicitly convert a '%Fs' to a '%Fs' that is not const"
2608	"illegal reference cast - operand not an l-value"
2609	"'%Fs' : cannot implicitly convert a non-lvalue '%Fs' function return to a '%Fs' that is not const"
2610	"%Fs '%Fs' can never be instantiated; user-defined constructor is required"
2611	"'%Fs' : illegal following '~' (expected identifier)"
2612	"trailing '%Fs' illegal in base/member initializer list"
2613	"trailing '%Fs' illegal in base class list"
2614	"'%Fs' : illegal member initialization: '%Fs' is not a base or member"
2615	"memory attribute must appear before class name in pointer to member"
2617	"'%Fs' : inconsistent return statement"
2618	"'%Fs' : inconsistent return statement"
2619	"union '%Fs' : cannot have static member variable '%Fs'"
2620	"union '%Fs' : member '%Fs' has default constructor"
2621	"union '%Fs' : member '%Fs' has copy constructor"
2622	"union '%Fs' : member '%Fs' has assignment operator"
2623	"union '%Fs' : member '%Fs' has destructor"
2624	"'%Fs' : references to 'void' are illegal"
2625	"anonymous union did not declare any data members"
2626	"anonymous union defines %Fs member '%Fs'"
2627	"member function defined in unnamed class"
2628	"'%Fs' followed by '%Fs' is illegal (did you forget a ';'?)"
2629	"unexpected '%s ('"
2630	"'%Fs' found in what should be a comma-separated list"
2631	"'%Fs' : destructors not allowed a return type"
2632	"'%Fs' followed by '%Fs' is illegal"
2633	"'%Fs' : 'inline' is the only legal storage class for constructors"
2634	"'&%Fs::%Fs' : pointer to reference member is illegal"
2635	"cannot convert a '%Fs*' to a '%Fs*'; conversion from a virtual base class is implied"
2636	"pointer to reference member is illegal"
2637	"'%s' : cannot modify pointers to data members"
2638	"'%Fs' : memory model modifier illegal on pointer to data member"
2639	"compiler generated %Fs required by unnamed class"

2641	"illegal pointer to member cast across virtual inheritance path"
2642	"cast to pointer to member must be from related pointer to member"
2643	"illegal cast from pointer to member"
2644	"basis class '%Fs' for pointer to member has not been defined"
2645	"no qualified name for pointer to member (found ':: *')"
2646	"global anonymous unions must be declared static"
2647	"'%Fs' : cannot dereference a '%Fs' on a '%Fs'"
2648	"'%Fs' : use of member as default parameter requires static member"
2649	"'%Fs' : is not a '%Fs'"
2650	"'%Fs' : cannot be a virtual function"

2652	"'%Fs' : illegal copy constructor: first parameter must not be a '%Fs'"
2653	"'%Fs' : is not a class name"
2654	"'%Fs' : attempt to access member outside a member function"
2655	"'%Fs' : definition or redeclaration illegal in current scope"
2656	"'%Fs' : function not allowed as a bit field"
2657	"'%Fs::*' found at the start of a statement (did you forget to specify a type?)"
2658	"multiple conversions : %Fs(%Fs) and %Fs::operator %Fs()"
2659	"'%Fs' : overloaded function as left operand"
2660	"'%Fs' : function does not take %d parameters"
2661	"'%Fs' : no overloaded function takes %d parameters"
2662	"'%Fs' : cannot convert 'this' pointer from '%Fs' to '%Fs'"
2663	"'%Fs' : %d overloads have no legal conversion for 'this' pointer"
2664	"'%Fs' : cannot convert parameter %d from '%Fs' to '%Fs'"
2665	"'%Fs' : %d overloads have no legal conversion for parameter %d"
2666	"'%Fs' : %d overloads have similar conversions"
2667	"'%Fs' : none of %d overload have a best conversion"
2668	"'%Fs' : ambiguous call to overloaded function"

2671	"'%Fs' : static member functions do not have 'this' pointers"
2672	"'%Fs' : new/delete member functions do not have 'this' pointers"
2673	"'%Fs' : global functions do not have 'this' pointers"
2674	"'%Fs' : no acceptable conversions from '%Fs' to '%Fs'"
2675	"unary '%Fs' : '%Fs' does not define this operator or a conversion to a type acceptable to the predefined operator"
2676	"binary '%Fs' : '%Fs' does not define this operator or a conversion to a type acceptable to the predefined operator"
2677	"binary '%Fs' : no global operator defined which takes type '%Fs' (or there is no acceptable conversion)"

2701	"'%Fs' : __oldcall function defined with varargs"	
2702	" __try may not appear in termination block"	
2703	"illegal __leave statement"
2704	"'%Fs' : __va_start intrinsic only allowed in varargs"	
2705	"'%Fs' : illegal jump into __try scope"	

2707	"'%Fs' : bad context for intrinsic function"	
2708	"'%Fs' : actual parameters length in bytes differs from previous call or reference"
2709	"'%Fs' : formal parameters length in bytes differs from previous declaration"
2710	"cannot delete a pointer to a const object"
2711	"cannot delete a pointer to a function"

2720	"'%Fs' : '%Fs' storage-class specifier illegal on members"
2721	"'%Fs' : storage-class specifier illegal between operator keyword and type"
2722	"'::%Fs' : illegal following operator command; use 'operator %Fs'"
2723	"'%Fs' : '%Fs' storage-class specifier illegal on function definition"
2724	"'%Fs' : 'static' should not be used on member functions defined at file scope"

2730	"'%Fs' : cannot be a base class of itself"
2731	"'%Fs' : function cannot be overloaded"
2732	"linkage specification contradicts earlier specification for %Fs"
2733	"second C linkage of overloaded function '%Fs' not allowed"
2734	"'%Fs' : const object must be initialized if not extern"
2735	"'%Fs' keyword is not permitted in formal parameter type specifier"
2736	"'%Fs' keyword is not permitted in cast"
2737	"'%Fs' : base class '%Fs' must be exported"

2750	"'%Fs' : 'const T' to 'T' : '%Fs' to '%Fs'"
2751	"'%Fs' : 'volatile T' to 'T' : '%Fs' to '%Fs'"
2752	"'%Fs' : 'const T *' to 'T *' : '%Fs' to '%Fs'"
2753	"'%Fs' : 'volatile T *' to 'T *' : '%Fs' to '%Fs'"
2754	"'%Fs' : 'const T **' to 'T **' : '%Fs' to '%Fs'"
2755	"'%Fs' : 'volatile T **' to 'T **' : '%Fs' to '%Fs'"
2756	"'%Fs' : 'memory model mismatch' : '%Fs' to '%Fs'"
2757	"'%Fs' : 'language modifier mismatch: '%Fs' to '%Fs'"
2758	"'%Fs' : must be initialized in constructor base/member initializer list"

2800	"'operator %Fs' cannot be overloaded"
2801	"'operator %Fs' must be a %Fs member"
2802	"static member 'operator %Fs' has no formal parameters"
2803	"'operator %Fs' must have at least one formal parameter of class type"
2804	"binary 'operator %Fs' has too many parameters"
2805	"binary 'operator %Fs' has too few parameters"
2806	"'operator %Fs' has too many formal parameters"
2807	"the second formal parameter to postfix 'operator %Fs' must be 'int'"
2808	"unary 'operator %Fs' has too many formal parameters"
2809	"'operator %Fs' has no formal parameters"
2810	"second formal parameter for 'operator delete' must be 'unsigned int'"
2811	"too many formal parameters for based form of 'operator delete'"
2812	"second formal parameter required for based form of 'operator delete'"
2813	"too many formal parameters for 'operator delete'"
2814	"second actual parameter for based form of 'operator delete' must be '__based(void)*'"
2815	"first actual parameter for based form of 'operator delete' must be '__segment'"
2816	"alternative form of 'operator delete' must be a member"
2817	"return type for 'operator delete' must be 'void'"
2818	"incorrect return type for 'operator ->'"
2819	"recursive return type for 'operator ->'"
2820	"second formal parameter required for based form of 'operator new'"
2821	"first formal parameter to 'operator new' must be 'unsigned int'"
2822	"second formal parameter for huge form of 'operator new' must be 'unsigned int'"
2823	"return type for based form of 'operator new' must be 'void __based(void)*'"
2824	"return type for 'operator new' must be 'void *'"
2825	"first formal parameter for huge form of 'operator new' must be 'unsigned long'"
2826	"second formal parameter required for huge form of 'operator new'"
2827	"'operator %s' cannot be globally overridden with unary form"
2828	"'operator %s' cannot be globally overridden with binary form"
2829	"'operator %Fs' cannot have a variable parameter list"
2830	"only placement parameters to 'operator new' can have default values"
2831	"'operator %Fs' cannot have default parameters"
2832	"'%Fs' form of 'operator %Fs' cannot be a member"
2833	"'operator %Fs' is not a recognized operator or type"
2834	"'operator %Fs' must be globally qualified"
2835	"user-defined conversion '%Fs' takes no formal parameters"
2836	"cannot export '%Fs': a previous declaration did not export it"
2837	"'%Fs' : illegal local static variable in exported inline function"
2838	"illegal qualified name in member declaration"

2850	"#pragma hdrstop cannot be nested in a function or definition"
2851	"#pragma hdrstop required for /Yu command-line option without filename"
2852	"'%Fs' is not a valid precompiled header file"
2853	"'%Fs' is not a precompiled header file created with this compiler"
2854	"syntax error in #pragma hdrstop"
2855	"command-line option '%Fs' inconsistent with precompiled header"
2856	"#pragma hdrstop cannot be inside an #if block"
2857	"'#include' statement specified with the /Yc%Fs command-line option was not found in the source file"

2900	"'%Fs' : huge array cannot be aligned to segment boundary"

2910	"cannot call function from p-code with more than 255 bytes of arguments"
2911	"cannot define p-code function with more than 255 bytes of parameters"

2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

		

1001	"internal compiler error\n\t\t(compiler file '%s', line %d)"

1003	"error count exceeds %d; stopping compilation"
1004	"unexpected end of file found"
1005	"string too big for buffer"
1006	"write error on compiler-generated file"
1007	"unrecognized flag '%Fs' in '%Fs'"
1008	"no input file specified"
1009	"compiler limit : macros nested too deeply"
1010	"unexpected end of file while looking for precompiled header directive"
1011	"compiler limit : '%Fs' : macro definition too big"
1012	"unmatched parenthesis : missing '%c'"
1013	"compiler limit : too many open parentheses"
1014	"too many include files : depth = %d"
1015	"compiler limit : too many segments"
1016	"#if[n]def expected an identifier"
1017	"invalid integer constant expression"
1018	"unexpected #elif"
1019	"unexpected #else"
1020	"unexpected #endif"
1021	"invalid preprocessor command '%Fs'"
1022	"expected #endif"
1023	"cannot open source file '%Fs'"
1024	"cannot open include file '%Fs'"
1025	"compiler terminated by user"	
1026	"parser stack overflow, program too complex"
1027	"DGROUP data allocation exceeds 64K"	
1028	"'%s' : segment allocation exceeds 64K" 
1029	"there are more than 512 bytes of arguments"
1030	"there are more than 512 bytes of local variables"
1031	"compiler limit : function calls nested too deeply"	
1032	"cannot open object code listing file '%s'"	

1034	"%Fs: no include path set"
1035	"expression too complex; simplify expression"	

1037	"cannot open object file '%s'"	
1038	"compiler limit : '%Fs' : control flow state too complex; simplify function"

1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"compiler limit : linkage specifications nested too deeply"
1046	"compiler limit : %Fs nested too deeply"
1047	"limit of %Fs exceeded at '%Fs'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1050	"'%Fs' : code segment too large"

1052	"compiler limit : #if or #ifdef blocks nested too deeply"
1053	"compiler limit : struct/union nested too deeply"	
1054	"compiler limit : initializers nested too deeply"
1055	"compiler limit : out of keys"
1056	"compiler limit : out of macro expansion space"
1057	"unexpected end of file in macro expansion"
1058	"compiler limit : too many formal arguments"
1059	"compiler is out of near heap space"
1060	"compiler is out of far heap space"
1061	"compiler limit : blocks nested too deeply"	
1062	"error while writing to preprocessor output file"
1063	"compiler limit : compiler stack overflow"
1064	"compiler limit : token overflowed internal buffer"
1065	"compiler limit : out of tags"
1066	"compiler limit : decorated name length exceeded"

1068	"cannot open file '%Fs'"
1069	"write error on file '%s'"	
1070	"mismatched #if/#endif pair in file '%Fs'"
1071	"unexpected end of file found in comment"
1072	"'%Fs' : cannot read file"

1082	"Cannot close %Fs file: '%Fs': %Fs (%Fs:%ld)"
1083	"Cannot open %Fs file: '%Fs': %Fs"
1084	"Cannot read %Fs file: '%Fs': %Fs"
1085	"Cannot write %Fs file: '%Fs': %Fs (%Fs:%ld)"
1086	"Cannot seek %Fs file: '%Fs': %Fs (%Fs:%ld)"
1087	"Cannot tell %Fs file: '%Fs': %Fs (%Fs:%ld)"
1088	"Cannot flush %Fs file: '%Fs': %Fs (%Fs:%ld)"

1090	"data allocation exceeds 64K"		

1126	"'%Fs' : automatic allocation exceeds %s" 
1127	"'%Fs' : segment redefinition"

1500	"'%Fs' : cannot open inline function definition file"
1501	"compiler limit : too many temporary variables"
1502	"inline member-function definition missing '}'"
1503	"default parameter definition missing ',' or ')'"
1504	"type still ambiguous after parsing %d tokens, unable to recover"
1505	"unrecoverable parser look-ahead error"
1506	"unrecoverable block scoping error"
1507	"previous user errors and subsequent error recovery halt further compilation"

1700	"%Fs compiler is out of far heap space" 

1852	"'%Fs' is not a valid precompiled header file"
1853	"'%Fs' is not a precompiled header file created with this compiler"
1855	 "command-line option '%Fs' inconsistent with precompiled header"

1900	"Il mismatch between '%s' version '%ld' and '%s' version '%ld'"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\bin\hc31.err ===
/***************************************
*
*  File problems
*
***************************************/
1019	"Project file extension cannot be .HLP or .PH."
1030	"File name exceeds limit of 259 characters."
1079	"Out of file handles."

1100	"Cannot open file '%s':  permission denied."

1150	"Cannot overwrite file '%s'."
1170	"File '%s' is a directory."

1190	"Cannot use reserved MS-DOS file name '%s'."

1230	"File '%s' not found."

1292	"File '%s' is not a valid bitmap."

1319	"Disk full."

1513	"Bitmap name '%s' duplicated."

1536	"Not enough memory to compress bitmap '%s'."

1000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"


/***************************************
*
*  General HPJ problems
*
***************************************/
2010	"Include statements nested more than 5 deep."

/* Syntax */
2030	"Comment starting at line %d of file '%s' unclosed at end of file."
2050	"Invalid #include syntax."
2091	"Bracket missing from section heading [%s]."
2111	"Section heading missing."
2131	"Invalid OPTIONS syntax: 'option=value' expected."
2141	"Invalid ALIAS syntax: 'context=context' expected."
2151	"Incomplete line in [%s] section."
2171	"Unrecognized text."
2191	"Section heading [%s] unrecognized."
2214	"Line in .HPJ file exceeds length limit of 2047 characters."

/* general section problems */
2273	"[OPTIONS] should precede [FILES] and [BITMAPS] for all options to take effect."
2291	"Section [%s] previously defined."
2305	"No valid files in [FILES] section."

/* Alias/Map problems */
2322	"Context string '%s' cannot be used as alias string."
2331	"Context number already used in [MAP] section."
2341	"Invalid or missing context string."
2351	"Invalid context identification number."
2362	"Context string '%s' already assigned an alias."
2372	"Alias string '%s' already assigned."

/* Window section problems */

2391	"Limit of 6 window definitions exceeded."
2401	"Window maximization state must be 0 or 1."
2411	"Invalid syntax in window color."
2421	"Invalid window position."
2431	"Missing quote in window caption."
2441	"Window name '%s' is too long."
2451	"Window position value out of range 0..1023."
2461	"Window name missing."
2471	"Invalid syntax in [WINDOWS] section."
2481	"Secondary window position required."
2491	"Duplicate window name '%s'."
2501	"Window caption '%s' exceeds limit of 50 characters."

/***************************************
*
*  OPTIONS section problems
*
***************************************/
2511	"Unrecognized option '%s' in [OPTIONS] section."
2532	"Option '%s' previously defined."

/* root */
2550	"Invalid path '%s' in %s option."
2570	"Path in %s option exceeds %d characters."

/* Font range */
2591	"Invalid MAPFONTSIZE option."
2612	"Maximum of 5 font ranges exceeded."
2632	"Current font range overlaps previously defined range."

/* Force font */
2651	"Font name exceeds limit of 20 characters."
2672	"Unrecognized font name '%s' in FORCEFONT option."

/* Multikey */
2691	"Invalid MULTIKEY option."
2711	"Maximum of 5 keyword tables exceeded."
2732	"Character already used."
2752	"Characters 'K' and 'k' cannot be used."

/* other */
2771	"REPORT option must be 'ON' or 'OFF'."

2811	"OLDKEYPHRASE option must be 'ON' or 'OFF'."
2832	"COMPRESS option must be 'OFF', 'MEDIUM', or 'HIGH'."
2842	"OPTCDROM option must be 'TRUE' or 'FALSE'."
2852	"Invalid TITLE option."
2872	"Invalid LANGUAGE option."
2893	"WARNING option must be 1, 2, or 3."
2911	"Invalid icon file '%s'."
2932	"Copyright string exceeds limit of 50 characters."


2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

/***************************************
*
*  Build tag/expression problems
*
***************************************/
3011	"Maximum of 32 build tags exceeded."
3031	"Build tag length exceeds 32 characters."
3051	"Build tag '%s' contains invalid characters."
3076	"[BUILDTAGS] section missing."
3096	"Build expression too complex."
3116	"Invalid build expression."
3133	"Duplicate build tag in [BUILDTAGS] section."

3152	"Build tag '%s' not defined in [BUILDTAGS] section."
3178	"Build expression missing from project file."


/***************************************
*
*  Macro errors
*
***************************************/

3511	"Macro '%s' exceeds limit of 254 characters."
3532	"Undefined function in macro '%s'."
3552	"Undefined variable in macro '%s'."
3571	"Wrong number of parameters to function in macro '%s'."
3591	"Syntax error in macro '%s'."
3611	"Function parameter type mismatch in macro '%s'."
3631	"Bad macro prototype."
3652	"Empty macro string."
3672	"Macro '%s' nested too deeply."

3000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"


/***************************************
*
*  Context string problems
*
***************************************/
4011	"Context string '%s' already used."
4031	"Invalid context string '%s'."
4056	"Unresolved context string specified in CONTENTS option."
4072	"Context string exceeds limit of 255 characters."
4098	"Context string(s) in [MAP] section not defined in any topic."
4113	"Unresolved jump or popup '%s'."
4131	"Hash conflict between '%s' and '%s'."
4151	"Invalid secondary window name '%s'."
4171	"Cannot use secondary window with popup."
4196	"Jumps and lookups not verified."

/***************************************
*
*  Footnote problems
*
***************************************/
4211	"Footnote text exceeds limit of 1023 characters."

/* browse */
4251	"Browse sequence not in first paragraph."
4272	"Empty browse sequence string."
4292	"Missing sequence number."
4312	"Browse sequence already defined."

/* title */
4331	"Title not in first paragraph."
4352	"Empty title string."
4372	"Title defined more than once."
4393	"Title exceeds limit of 128 characters."

/* keyword */
4412	"Keyword string exceeds limit of 255 characters."
4433	"Empty keyword string."
4452	"Keyword(s) defined without title."

/* build */
4471	"Build tag footnote not at beginning of topic."
4492	"Build tag exceeds limit of 32 characters."

/* entry macro */
4551	"Entry macro not in first paragraph."


/***************************************
*
*  RTF problems
*
***************************************/
4616	"File '%s' is not a valid RTF topic file."
4639	"Error in file '%s' at byte offset 0x%lX."
4649	"File '%s' contains more than 32767 topics."
4652	"Table formatting too complex."
4662	"Side by side paragraphs not supported."
4671	"Table contains more than 32 columns."
4680	"Font %d in file '%s' not in RTF font table."
4692	"Unrecognized graphic format."
4733	"Hidden page break."
4753	"Hidden paragraph."
4763	"Hidden carriage return."
4774	"Paragraph exceeds limit of 64K."
4792	"Non-scrolling region defined after scrolling region."
4813	"Non-scrolling region crosses page boundary."

4000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

/***************************************
*
*  Miscellaneous
*
***************************************/
5035	"File '%s' not created."
5059	"Not enough memory to build help file."
5075	"Help Compiler corrupted.  Please reinstall HC.EXE."
5098	"Using old key-phrase table."
5115	"Write failed."
5139	"Aborted by user."

5000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\bin\c23.err ===
1001	"internal compiler error\n\t\t(compiler file '%s', line %d)"
1002	"compiler is out of heap space in pass 2"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected end-of-file found"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1013	"cannot open source file '%s'"
1015	"compiler limit : too many segments"
1027	"DGROUP data allocation exceeds 64K"
1029	"there are > 512 bytes of arguments"
1030	"there are > 512 bytes of local variables"
1032	"cannot open object listing file '%s'"
1033	"cannot open assembly language output file '%s'"
1035	"expression too complex, please simplify"
1036	"cannot open source listing file '%s'"
1037	"cannot open object file '%s'"
1039	"unrecoverable heap overflow in pass 3"
1040	"unexpected end-of-file in source file '%s'"
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating-point overflow"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1050	"'%s' : code segment too large"

1055	"compiler limit : out of keys"
1067	"intrinsic not implemented"
1073	"bad '%s' flag, would overwrite '%s' with '%s'"
1074	"too many '%s' flags, '%s'"
1083	"Cannot open %Fs file: '%Fs': %Fs"
1084	"Cannot read %Fs file: '%Fs': %Fs"
1085	"Cannot write %Fs file: '%Fs': %Fs"
1090	"'%s' data allocation exceeds 64K"
1126	"'%s' : automatic allocation exceeds %s"
1127	"'%s' : segment redefinition"
1900	"Il mismatch between '%s' version '%ld' and '%s' version '%ld'"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Product Support Services"

						
	
2125	"'%s' : allocation exceeds 64K"
2127	"parameter allocation exceeds 32K"
2129	"static function '%s' not found"
2220	"warning treated as error - no object file generated"
2374    "'%s' redefinition; multiple initialization"
2418	"'%s' : not in a register"
2427	"'%s' : jump referencing label is out of range"
2900	"'%s' : huge array cannot be aligned to segment boundary"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

						
	
4700	"local variable '%s' used without having been initialized"
4701	"local variable '%s' may be used without having been initialized"
4702	"unreachable code"
4703	"'%s' : function too large for global optimizations"
4704	"'%s' : in-line assembler precludes global optimizations"
4705	"statement has no effect"
4706	"assignment within conditional expression"
4707	"'%s' : function too large for global optimizations (%s)"  
4708	"ran out of heap at: %s"  
4709	"comma operator within array index expression"
4710	"function '%s' not expanded"
4711	"function '%s' selected for automatic inline expansion"
4712	"'%s' : used as register - loss of debugging information"
4713	"%s: internal compiler error; restarting\n\t\t(compiler file '%s', line %d)"
4723	"potential divide by 0"
4724	"potential mod by 0"
4726	"'%c' : unknown memory-model command-line option"
4727	"conditional expression is constant"
4746	"'%s' : unsized array treated as '%s'"
4756	"overflow in constant arithmetic"
4757	"overflow in constant multiplication"
4758	"address of automatic (local) variable taken, DS != SS"
4759	"segment lost in conversion"
4760	"'%Fs' : segment lost in initialization"
4761	"integral size mismatch in argument; conversion supplied"
4762	"near/far mismatch in argument : conversion supplied"
4763	"'%s' : function too large for post-optimizer"
4765	"recoverable heap overflow in post-optimizer - some optimizations may be missed"
4766	"local symbol table overflow - some local symbols may be missing in listings"
4769	"conversion of near pointer to long integer"
4772	"'%s' : too many debug entry points, maximum %d"
4773	"scoping too deep, deepest scoping merged when debugging"
4785	"near call to '%s' in different segment"
4786	"string too long - truncated to %d characters"
4787	"unprototyped function '%s' called in exception"
4788	"'%Fs' : identifier was truncated to '%d' characters"
4790	"insufficient memory to process debugging information"
4791	"loss of debugging information caused by optimization"
4792	"long double type not supported by alternate math library"
4900	"Il mismatch between '%s' version '%ld' and '%s' version '%ld'"

4000	"UNKNOWN WARNING\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\faxinfo.txt ===
----------------------------------------------------------
            Microsoft Personal Fax for Windows
                      October 1996
----------------------------------------------------------
        (c) Copyright Microsoft Corporation, 1996


Contents
   What Is Personal Fax for Windows?
   Sending Faxes
   Receiving Faxes
   Setting Up Your Modem and Configuring Your Workstation Fax
   Where Do I Go From Here?
   Getting Help

----------------------------------------------------------
What Is Personal Fax for Windows?
----------------------------------------------------------

Personal Fax for Windows is a program you use to send and 
receive faxes from a computer running Windows NT Workstation. 
Personal Fax for Windows converts all outgoing and incoming 
faxes to .TIF-formatted files, which you can print or view 
and store online.
 
Think of your fax modem or other fax device as a printer. 
You send faxes in the same way you print ordinary documents.
 
Note: Personal Fax for Windows supports one fax device at 
a time. Other networked users cannot send or receive faxes 
through your computer.

----------------------------------------------------------
Sending Faxes
----------------------------------------------------------

You can send a fax in any of three ways:

x	You can fax an open document directly from its 
	application simply by selecting your fax printer as 
	your target printer. On the File menu of the application, 
	click Print (or Send), and the Fax Send Utility opens 
	to guide you through each step. Its easy.

x	You can use the Fax Send Utility (Start/Programs/Fax) to
	create your fax on-the-fly. Use this method only when you do 
	not need to include file attachments.

x	You can send a fax from Exchange using special fax 
	addresses you define in your personal address book. When you 
	select a recipient whose address is a fax address, the e-mail 
	that you type becomes your fax. Using Exchange, you can 
	simultaneously send a message to both fax and e-mail 
	recipients. You can also include file attachments within the 
	messages. A copy of each fax you send is stored in the Sent 
	folder, just as e-mail messages are.

Regardless of the method you use to send your fax, youll 
automatically be notified by e-mail whether or not your fax 
transmission was successful.

You can also archive copies of all outgoing faxes in a designated 
folder on your hard disk. 

Personal Fax for Windows provides several standard cover pages and 
a handy cover-page editor you can use to create or modify your own. 

----------------------------------------------------------
Receiving Faxes
----------------------------------------------------------

To view a received fax online, use the Fax Document Viewer 
(Start/Programs/Fax). You can combine any of the following methods 
for dealing with the faxes you receive.

x	You can automatically route all incoming faxes to a folder on 
	your computer or on another networked computer.

x	You can automatically print each fax upon arrival.

x	You can automatically receive faxes as mail messages in your 
	Exchange Inbox.

----------------------------------------------------------
Setting Up Your Modem and Configuring Your Workstation Fax
----------------------------------------------------------

First, install your fax modem in your computer according to the 
manufacturers instructions. Please see the release notes for 
a list of supported modems.

Personal Fax For Windows adds a Fax properties application to your 
Control Panel (Start/Settings/Control Panel).
 
Next, use the Fax properties application to specify fax settings, 
such as:

x	Your name, fax number, and other personal information you 
	want to include on the cover pages of outgoing faxes.

x	Paper size, image quality, and page orientation.

x	The number of times you want the modem to redial after 
	an unsuccessful call attempt, and the interval between 
	redials.

x	How you want to handle incoming faxes.

x	Whether to send the fax immediately or at another time, 
	such as during off-peak hours when usage and long-distance 
	phone rates are lower.

x	The cover page you want to use. 

x	The logging-priority level for successful and unsuccessful 
	fax events. You can view fax events in the Event Viewer, 
	which you can find under Start/Programs/Administrator Tools.

----------------------------------------------------------
Where Do I Go From Here?
----------------------------------------------------------

Setting up Personal Fax for Windows adds the following items to 
your Start menu, under Programs in a new Fax group:

x	Cover Page Editor
x	Fax Configuration
x	Fax Document Viewer
x	Fax Send Utility
x	Help
x	Problem Reporting Form
x	Read Me First
x	Release Notes

Setup also adds the Fax properties application to your Control 
Panel.

>>>	To start the Fax properties application

	1.	Click Start, point to Programs, and then point to Fax.
	2.	Click Configuration.

	Note: You can also double-click Fax in 
	Control Panel.

----------------------------------------------------------
Getting Help
----------------------------------------------------------

Personal Fax for Windows provides two ways to get help: a 
complete online Help system and context-sensitive Help.

Online Help provides step-by-step guidance for faxing tasks.

>>>  To open online Help
	1.	On the desktop, double-click My Computer.
	2.	On the Help menu, click Help Topics.
	3.	Click the Index tab.
	4.	Type:
		fax procedures
	5.	Click OK.

Context-sensitive Help explains options in the Fax Configuration 
utility interface.

>>>  To use context-sensitive Help
	1.	If necessary, click Start, point to Settings, and 
		click Control Panel; then double-click Fax 
		Configuration.
	2.	Click the ? button in the upper-right corner of the 
		dialog box.
	3.	Point to the item in the dialog you want described 
		and click.

	Note: You can also right-click the item and then click 
	Whats This?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\faxprob.txt ===
Microsoft Personal Fax Technology Preview for Windows NT(TM) Workstation 4.0
Problem Report Template	        
(Please see instructions below to submit this report) 

Name                           : 
Company                        : 
Area Code & Phone              : 

Email Address                  :
Country (if outside the U.S.)  :
Language Version               :

***** PROBLEM INFORMATION ******

Product Release      :  
(Type "winver" at the command line while Windows NT is running.)

Install Type         : < >Upgrade from: 
		       < >Clean Install


PROBLEM TITLE: 
[Please replace this line with a one-line summary of the issue]

PROBLEM DESCRIPTION: Please provide a complete description of 
the problem, circumstances, and any actions you may have taken.
----------------------------------------------------------------------




PROBLEM OCCURS: 
< >Always < >Sometimes < >Didn't happen again < >Didn't try it again

STEP BY STEP INSTRUCTIONS we can follow to reproduce the problem here:
Please be explicit and complete, if we cannot reproduce the problem
here, the issue may not be resolved in the next release.
  1. 
  2. 
  3.
  4.



**** BASIC CONFIGURATION ****

Computer brand & model			    :
  Bus Architecture (check all that apply)			                           
  < >ISA < >EISA < >MCA < >VESA < >PCI 
  < >RISC < > PCMCIA (PC CARD) < >Other:

System BIOS (manufacturer & version/date)   : 
CPU(s) (type, speed and manufacturer)       : 
Memory (RAM)                                : 
Mouse model & type (PS-2/serial/bus) (COM/IRQ)  : 
Sound Card (model/address/IRQ)              : 
Communications Modem (model/address/IRQ)    : 
Other adapters (scanner/PC CARD)            : 


****** FAX/MODEM CONFIGURATION *****
Fax/Modem manufacturer <                  >
Fax/Modem model        <                  >

Fax Board
< > None  < > Brooktrout < > GammaLink
< > Natural Microsystems < > PureData
<            > Other

****** VIDEO CONFIGURATION ******
Video adapter                   : 
  < > ISA  < > EISA  < > PCI  < > VESA  < > MCA
Video memory
  < > 512Kb  < > 1Mb  < > 2Mb  < > 4Mb  < > 8Mb
Video driver                    :
Video resolution                : < >640x480    < >800x600 
				  < >1024x768   < >1280x1024
				  < > Other: 
Color depth                     : < >16 colors  < >256 colors 
				  < >64K        < >16.7 million
				  < >True color < >Other: 


****** HARD DISK CONFIGURATION ******
For each hard drive, list the following:

Drive:
   < >IDE  [Enter model name] 
     < > Master  < > Slave
     < > Primary IDE channel  < > Secondary
   < >SCSI [Enter model name & SCSI id #]
     Disk controller:
  Partitions:
    Letter:     File System: < > Fat < > NTFS  Size: 
    Letter:     File System: < > Fat < > NTFS  Size:
  
****** CD-ROM CONFIGURATION ******
CD-ROM drive brand & model   : 
Is this a CD changer? < >  # of discs:____

  < > SCSI  [ID#] < > OTHER 
      Terminated < > Yes  < > No

  < > IDE/ATAPI
     < > Master  < > Slave
     < > Primary IDE channel  < > Secondary

Controlling adapter (Address and IRQ): 


****** NETWORK CONFIGURATION ******
Network card type, IRQ & address: 
Network protocol(s)             : 

Network cabling                 : 
Novell Server version           :       number of users:

****** PRINTER CONFIGURATION ******
Printer brand & model           : 
Printer Port: < >LPT1 < >LPT2 < >COM1 < >COM2 < >File < >Network
Driver                          :
Memory                          :
Printer cartridges              : 


How To Submit This Report
=========================
Please e-mail this form to ntbug@microsoft.com and use the word FAX on the subject line.
Note: this is not a support mechanism, and you are not guaranteed a response.
Please send mail to ntbug@microsoft.com if you require an ftp location, 
or have any other questions or comments regarding the problem report process.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\faxeula.txt ===
IMPORTANT. This license agreement supersedes any other license agreement provided with the software.

Read this Microsoft License Agreement before installing this software.  By installing this software, you indicate your acceptance of this Microsoft License Agreement.

MICROSOFT LICENSE AGREEMENT
Microsoft Fax Beta Code for Microsoft Windows NT Workstation version 4.0

        1.      LICENSE RIGHTS AND RESTRICTIONS. Microsoft Corporation ("Microsoft") grants to you the non-exclusive, non-assignable right to use the enclosed Microsoft beta software in object code form (the "MS Code") only in conjunction with validly licensed copies of Microsoft Windows NT version 4.0 solely for your internal use and evaluation.  You may make copies for use on all computers on your premises for which you have licensed Microsoft Windows NT 4.0 as described above. The MS Code shall not be copied or used for any other purpose.  You may not reverse engineer, decompile, or disassemble the MS Code, except to the extent that the foregoing restriction is expressly prohibited by applicable law.  You may not rent or lease the MS Code, or otherwise transfer the MS Code and accompanying written materials.  You may not disclose the results of any benchmark testing of the MS Code to any third party without Microsoft's prior written permission.  All rights not expressly granted are reserved by Microsoft.

        2.      PRELIMINARY CODE.  The MS Code provided herein is beta code and not at the level of functionality, performance and compatibility of the final, generally available product offering.  The code may be substantially modified prior to first commercial shipment.

        3.      NO WARRANTIES.   The MS Code and accompanying written materials are provided "as is", without warranty of any kind.  To the maximum extent permitted by law, Microsoft disclaims all warranties, either express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose and noninfringment. The entire risk arising out of the use or performance of the MS Code and any accompanying written materials remains with you.

        4.      NO LIABILITY FOR CONSEQUENTIAL DAMAGES.  To the maximum extent permitted by applicable law: in no event shall Microsoft or its suppliers be liable for any damages whatsoever (including, without limitation, damages for loss of business profits, business interruption, loss of business information, or other pecuniary loss) arising out of the use of or inability to use the MS Code, even if Microsoft has been advised of the possibility of such damages.  Because some states/jurisdictions do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to you.

        5.      TERMINATION.  Microsoft may terminate this agreement in writing at any time with or without cause.  This Agreement shall terminate without notice upon the commercial release of the MS Code.  Upon termination of this Agreement for any reason, you shall immediately return, or certify destruction of, all full or partial copies of the MS Code and all other materials provided by Microsoft.

        6.      MISCELLANEOUS.  If you acquired this product in the United States, this Agreement is governed by the laws of the State of Washington.  If you acquired this product outside the United States, local law may apply.  If either party employs attorneys to enforce any rights arising out of or relating to this Agreement, the prevailing party shall be entitled to recover reasonable attorneys fees, costs and expenses.

        7.      U.S. GOVERNMENT RESTRICTED RIGHTS.  Any software and documentation provided under this Agreement is provided with RESTRICTED RIGHTS.  Use, duplication, or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial Computer Software -- Restricted Rights at 48 CFR 52.227-19, as applicable.  Manufacturer is Microsoft Corporation, One Microsoft Way, Redmond, WA  98052-6399.

        8.      EXPORT RESTRICTIONS. You agree that you will not export or re-export the MS Code to any country, person, entity or end user subject to U.S.A. export restrictions.  Restricted countries currently include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Syria, and the Federal Republic of Yugoslavia (Serbia and Montenegro, U.N. Protected Areas and areas of Republic of Bosnia and Herzegovina under the control of Bosnian Serb forces).  You warrant and represent that neither the U.S.A. Bureau of Export Administration nor any other federal agency has suspended, revoked or denied your export privileges.

02/23/94    LE930320.008

^
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\ism\eula.rtf ===
{\rtf1\fbidis\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}} {\stylesheet{ Normal;}{\s1 heading 1;}} \viewkind4\uc1\pard\ltrpar\qc\ul\b\f0\fs44\par \pard\ltrpar\keepn\s1\qc This is the EULA place holder\par \pard\ltrpar\qc\fs24\par Do check in this files as well\par CLIENT\par
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\unattend.txt ===
[version]
signature="$WINDOWS NT$"

;
;-------------------------------------------------------------------------------
; Sample Fax Unattend File
;-------------------------------------------------------------------------------
;
; Valid Keywords:
;
;     FaxPrinterName    Name of the local fax printer (string)
;     FaxNumber         Fax phone number (string)
;     RoutePrinterName  Printer name to print received faxes (string)
;     RouteProfileName  Outlook profile to store received faxes (string)
;     RouteFolderName   Folder to store received faxes (string)
;     Csid              Calling station identifier (string)
;     Tsid              Transmitting station identifier (string)
;     Rings             Number of ring before answering fax call (integer)
;     RouteToPrinter    Should received faxes be printed? (boolean)
;     RouteToInbox      Should received faxes be stored in outlook? (boolean)
;     RouteToFolder     Should received faxes be stored in a folder? (boolean)
;
; Data Types:
;
;     string            text, should be bounded by double quotes
;     integer           positive number
;     boolean           yes/no or true/false
;
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
;


[Fax Unattend]
FaxPrinterName="My Fax Printer"
FaxNumber="(425) 555-1212"
RoutePrinterName="Printer Name"
RouteProfileName="Profile"
RouteFolderName="Folder"
Csid="Fax"
Tsid="fax"
Rings=2
RouteToPrinter=false
RouteToInbox=false
RouteToFolder=yes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\test\guimodesetup.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Installing Whistler Fax as part of a clean install of W2K/Whistler: TitleInstalling Whistler Fax as part of a clean install of W2K/Whistler: Oren Rosenbloom Normal.dot Oren Rosenbloom Microsoft Word 9.0Installing Whistler Fax as part of a clean install of W2K/Whistler (note: This is specific to build 2217 of Whistler): NOTE: The GUIMode.zip file contains INF files specific to build 2217 of Whistler, which is the latest Whistler IDW as of 18-Apr-2000.  If you wish to install on a different build, make sure that you use the layout.inf, dosnet.inf, txtsetup.sif, syssetup.inf, drvindex.inf from your build.  Note that you will need to make appropriate changes to these files in order for Whistler fax to properly install.  See below for instructions on required changes. Create a subdirectory  c:\bin  (this can be any directory path you wish) Copy all the latest fax binary files to  c:\bin .  See the file list in  StandAloneSetup.doc  for a list of expected files. Unzip the GUIMode.zip file into  c:\bin Whistler setup will look in  c:\bin  first before installing from the Whistler source.  If the file exists in  c:\bin , it will use it instead of the one at the source.  This is good. Open a DOS window (cmd.exe), and execute the following command line (without the quotes):  deltacat.cmd c:\bin deltacat.cmd  can be found in %SDXROOT%\tools. This will create a file  delta.cat  file in c:\bin. Copy  nt5cat.in_  to c:\bin.  Do NOT expand this file.  This file is found in the i386 subdirectory of your Whistler source path. From your DOS window, execute the following command line (without the quotes):  infsign c:\bin infsign.cmd  can be found in %SDXROOT%\tools, and uses  updcat.exe  found in %SDXROOT%\tools\x86. You are now ready to begin your Whistler installation.  Remember that this should be a clean install, not an upgrade. From the i386 directory in your Whistler source path, type  winnt32 /m:c:\bin. The /m tells setup to copy replacement files from an alternate location, namely  c:\bin .  For more info on command line options, type  winnt32 /? Let setup complete (this can take about 1 hour) To confirm fax has been set up, ensure a fax printer exists, the fax service has been started, and the  Microsoft Fax  program group exists in the start menu. You can now attempt to send a fax by printing to the fax printer. If any part of the fax setup failed, you can look at the file %systemroot%\faxocm.log.  This file contains the log of all fax setup events, and will note all failures that occurred during the install phase.  For further info, you can refer to %systemroot%\setupapi.log and %systemroot%\setuperr.log.  These log files are generated by the entire setup routine. How to modify layout.inf, dosnet.inf, txtsetup.sif, syssetup.inf and drvindex.inf if you wish to install a build other than build #2217: Layout.inf and TxtSetup.sif: These INF list all the files in the Whistler product.  They tell setup at what phase of the setup process a file is copied.  For example, some files are copied during the text mode setup as they are needed in every SKU of Windows (e.g. kernel32.dll) .  Other files implement optional components, therefore the user is given the option of installing the specific feature during the GUI phase of the setup process, so should not be copied automatically.  Layout.inf is used by the GUI phase of setup, used by the various OCM components.  TxtSetup.sif is used in the text phase of setup.  Modify both files. Search for each file listed in the files section of the  StandAloneSetup.doc  document. If the file is found in layout.inf, make sure that the last two digits on that line for that file are  .  In the example below,   indicates source media location,  491520  is the size of the faxadmin.dll file, and   indicate that in both the clean install and upgrade scenarios, this file is copied during the GUI phase of the install process by a separate INF file (faxsetup.inf in our case). E.g.: faxadmin.dll = 1,,491520,,,,,,3,3. Make sure that  winfax.dll  shows   for its two last digits.  This indicates that the file should be copied during the text phase of the setup (i.e. during the blue screen text mode). Dosnet.inf: This INF lists what files are used in the first phase of setup.  The first phase of setup copies the files listed in Dosnet.inf to c:\$WIN_NT$.~ls (if you are installing from a network share), or verifies that the files listed in Dosnet.inf exist on the media disk (if installing from a CD).  Thus, if your files are not listed in this INF, the faxocm setup will never find the needed fax files. Search for each file listed in the files section of the  StandAloneSetup.doc  document. If the file is not found in dosnet.inf, the go to the [Files] section, go the alphabetically sorted location your file would go under, and enter the following line (without the quotes):  d1,<filename> , where <filename> should be the name of your file.   Repeat this for each file listed in the  StandAloneSetup.doc  document. SysSetup.inf: This INF file lists all the product files copied during text mode setup that need to be registered as COM servers.  All fax files (with the exception of winfax.dll) are copied during the GUI phase, therefore do not need to be listed in syssetup.inf. Remove the following lines from syssetup.inf: 11,,faxadmin.dll,1 11,,routeext.dll,1 11,,faxcom.dll,1 11,,faxshell.dll,1 DrvIndex.inf: This INF file lists all the driver files found in Driver.cab.   This should not require modification.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\test\standalonesetup.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Setting up Whistler Fax on a machine with W2K or Whistler already installed (i TitleSetting up Whistler Fax on a machine with W2K or Whistler already installed (i Oren Rosenbloom Normal.dot Oren Rosenbloom Microsoft Word 9.0Setting up Whistler Fax on a machine with W2K or Whistler already installed (i.e. Standalone mode): Make sure you have disabled Windows File Protection.  If you do not, setup will copy the new binaries and delete any old ones, but they will promptly be replaced to the originals by windows File Protection. Make sure you have the following four files in the %systemroot%\system32 directory.  If you do not, registering the COM servers during setup will fail. mfco42ud.dll mfc42ud.dll msvcrtd.dll msvcp5d.dll Create a subdirectory  c:\bin  (this can be any directory path you wish) Copy all the latest fax binary files to  c:\bin .  See the file list below for a list of expected files. Unzip the ocm.zip file into  c:\bin .  This will add the following files: faxocm.dll faxsetup.inf faxoc.inf faxoff.reg faxon.reg Confirm that all the files listed below are in this directory. Open a DOS window (cmd.exe) and change to your directory  c:\bin Run setup.cmd (command line:  setup.cmd This will make a registry modification that will  uncheck  the fax option when the Add/Remove dialog pops up.  This is required because fax is installated automatically in both W2K and current builds of Whistler. This will also run  sysocmgr.exe  which is the stand alone equivalent to  Add/Remove  programs, but will only show   as the install option. In the dialog that pops up,  check  the checkbox next to  .  Press  In the next dialog asking for the location of the binary files, type  c:\bin Note that this dialog will NOT pop up in the full Whistler install. One or more dialogs may pop up asking if you wish to replace the specified file with an older file.  Answer   to each prompt. If a reboot is required, reboot as prompted. Once setup is complete (or your machine has rebooted), open Notepad, type something, and attempt to print to the fax printer. If you go to Start->Microsoft Fax->Fax Client, you should see your fax in the  outbox  folder. If you have any problems, feel free to contact Oren Rosenbloom (orenr) 425-705-7146. Expected File List: The following files must be in your  c:\bin  directory (with the exception of those marked by the *) basenote.cov faxadmin.dll ***faxcom.dll ; doesn't exist yet ***faxcomex.dll ; new to Whistler - doesn't exist yet faxclnt.dll faxclnt.exe faxcount.h faxcover.exe faxevent.dll faxext32.dll faxfsput.dll faxmapi.dll faxocm.dll faxperf.dll faxperf.ini faxres.dll faxroute.dll faxrtext.dll faxrtmtd.dll faxsend.exe ***faxserv.msc ;doesn't exist yet faxsvc.exe faxt30.dll faxt30p.dll faxtiff.dll faxxp32.dll msfaxmon.dll faxocm.dll winfax.dll faxdrv.dll faxui.dll faxwzrd.dll faxsetup.inf faxext.ecf confdent.cov fyi.cov generic.cov urgent.cov layout.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\awd\awdvstub\placefil.txt ===
migrate.dll     win9xmig\fax
awdvstub.exe     win9xmig\fax
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\win9xupg\migrate\placefil.txt ===
migrate.dll     win9xmig\fax
awdvstub.exe     win9xmig\fax
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\bin\mtview.ini ===
[Viewport]
X=206
Y=194
Width=975
Height=643
CmdShow=1
Facename=Courier
Point=8
Weight=400
Italic=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\bin\elle.ini ===
[Elle]
HeaderPath=
SuiteName=Test suite
Version=3
DetailBuffer=0

[Viewport]
Enabled=1
LogLevel=3
DetailLevel=9
ErrorRpt=1
ClearEachSuite=1
HideWhenDone=0

[File]
Enabled=1
LogLevel=9
DetailLevel=9
AppendMode=0
FileName=FaxBVT.log                                                                                                                                                                                                                             
          

[Comm]
Enabled=0
LogLevel=3
DetailLevel=9
CommPort=0

[SQL]
Enabled=0
Direct=0
Server=
Database=
Table=
UserID=
Password=
Parse=1
FileName=elle.sql
RunWndLeft=0
RunWndTop=456
RunWndRight=1024
RunWndBottom=684
SQLAppX=-4
SQLAppY=-4
SQLAppCX=1032
SQLAppCY=776

[Custom Header Fields]
Tester=your name
Environment=machine configuration
MachineID=your machine
Revision=04.00.0950
Language=USA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\ad-hoc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Ad-Hoc Title _PID_GUIDAd-Hoc micky snir Normal.dot micky snir Microsoft Word 8.0Ad-Hoc This document is just a list of ideas for ad-hoc testing. Print huge documents.  DOC, PPT, XLS etc. Embedded documents. Print concurrently from several applications. Cancel printing. While an app prints a huge doc, click the cancel button. What are the properties of a newly installed modem? MMC refresh. Will it show a newly added device? Will it update the device s status? Change settings while sending receiving. CoExist with previous fax installations   you have a local fax-modem and you want to fax with it. Receive. Can you connect to more than 1 fax server? This is  manual  LCR! Answer a fax manually. Also if it is not a fax call! Verify that unrelated operations are unrelated, like pausing a sent fax does not affect an incoming fax. Inbound routing errors:  Print to printer, but there s a printer error   must notify a lost fax!  Same for save in folder!  Same for email. Try to cancel a job twice. Really quick (. Verify that all modems are used if the queue is not empty. Pause jobs, and reboot. Will the jobs resume? Will they be paused? Pause a job. Will other jobs be blocked by it? Can the fax server be used when no one is logged in? Send a huge fax. I mean huge! Thousands of pages! Send an empty fax. More than 9999 fax jobs! Beware of disk space. Install a modem with wrong INF. All we expect is the fax service not to hang nor except. Mess with the fax folders   change permissions of folders and files, change attributes to read-only. Verify the all s as expected. Disabling (?) jobs. Pausing jobs. Open MMC, stop fax service, and close MMC. Purge print document in the fax printer icon. Disconnect while sending or receiving by:  developing a deformed FSP that will hang-up on the other side.  kill tapisrv.  kill faxsrv.  net stop fax. Multihomed server. Can it serve client from both networks? Security? CRM hands-off a call to an app that is not running. All callback functions must be exception protected. RAS calls back, but fails to allocate a line for the call. Service in non-system account   denying access from files, changing the password from another wks, and see how it accesses network resources. {skc[SKC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\aatc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot micky snir Microsoft Word 9.03F$4:fbjbjU CometFax Adaptive Answering Test Cases: Preface  It is not yet decided whether AA will be tested, and to what extent. This document assumes that AA will be fully tested, although this is not the current plan. Current plan is to disable AA by default, and to enable it only via our FSP UI. The UI should offer the choice only if the AA keys exist. Only class 1 AA of our UNIMODEM FSP is tested (fax board FSP may implement AA, but it is highly unlikely). All following test cases refer to the modems installed on the server machine and should be run on NT5 server platform. Test Strategy: AA Test Suite  will run on the  Modems Machine  (see  Modem Compatibility Test Cases For every possible pair of modems on the machine an  AA Receive Test  will be invoked, where one modem is generating calls and the other is being tested. AA Receive Test  will use the  Call Generator  tool to create fax and data calls from the first modem. It will also verify the second modem s responses to these calls, using the  Service Monitor  tool and specific tests. Test the server Adaptive Answering capabilities using the MedetectStub: This tool will simulate a receiving modem, will simulate a ring and will simulate modem responses to different AT command, including adaptive answering responses (i.e. Data/Fax detected etc.), This way we can simulate many modem  types  without actually having the modems. Issues: Modems may remain off hook if they fail to correctly respond. How can we automatically detect an  off hook  situation? sanity check  after every step is too costly. Will most probably have to use multi threading, to create  first modem  and  second modem  corresponding behavior and tests. Only modems with AA INF support will be tested for AA. The rest of the modems will also be tested, but are expected to report an error if a voice call comes in. Implementation Strategy: Implementation will be incremental. Run FaxVrfy.exe test as is on a   of modems as a minimal  AA Test Implement an  INF Checker  tool that receives an INF filename and checks for Fax and AA entries. Tool will  report  whether Fax and AA are correctly supported. Call Generator  tool to implement fax and data call test cases. Service Monitor  as further verification. Implement  second modem  (tested modem) complete verification, for each corresponding  first modem  call. Automate the iteration over all possible modem pairs and INF files. Test Categories: Fax INF support. Verify that the modem INF file has the required Fax keys with valid values. Adaptive Answering INF support. Verify that the modem INF file has all required AA keys with valid values. Installation. Verify that AA supporting devices are correctly recognized by the CometFax service. Default device settings for AA supporting modems. Service sets  receive  to enabled for AA supporting devices. Fax Calls. Outgoing and incoming fax calls succeed regardless of RAS or AA. E.g. verify that a fax call is successfully received while RAS is stopped \ started. Data Calls. AA supporting devices hand them off to RAS successfully. Data calls to Non-AA supporting modems. Modems should hang-up and continue to function correctly. * Make sure that device has no trouble receiving a fax call after a failed data call. Status of AA devices. Make sure that an AA device that answered a data call and successfully handed it to RAS has the correct status at every stage. That is,  Answered Not a Fax Call , (something like)  Handing off to RAS  and then (something like)  Receiving Data * Make sure that CometFax will not attempt to use a device that is busy receiving data to send a fax. Status of Non-AA devices. Make sure that a Non-AA device that answered a data call has the correct status at every stage. That is,  Answered Not a Fax Call , and (something like)  Reception Error  CometFax integration. Make sure that when RAS is using a modem for an outbound call, CometFax is aware that the device is busy and will use another device to send faxes. RAS settings. Investigate whether any RAS settings may affect the CometFax service or its integration with RAS. Invalid Data Calls (?). Such calls should (at some point) be recognized as invalid and device should hang-up with a  Reception Error  status. * AA supporting modems should hand them off to RAS and RAS will fail call? * Make sure device can receive a fax call after such a failed data call. Adaptive Answering test parameters: Modem AA support. Modem does \ doesn t support AA. Modem device is \ isn t in Hard-Coded AA device list. This is a list of modems for which the AA commands are hard coded in the CometFax code. Modem Send \ Receive settings. Modem class. Hardware settings. E.g. volume, dial control, port speed. Fax Call Data  E.g. empty document, complex image (very long page), many pages, etc. Data Call data. Device (port) has \ has not previously been opened by service. CometFax adds registry entries for devices (under the  CometFax\Devices  key) the first time that device is used (and not at service start up). Current and Previous call type. Fax or data call. [TBD] CometFax Adaptive Answering Test Cases  TIME \@ "d-MMM-yy"  6-Oct-99 Microsoft Confidential Sigalit Bar (sigalitb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\adminuispec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot miris Microsoft Word 9.0q@+6x Z:&I*:F)bjbjU SBS Fax Admin UI Test Specification Preface  This document specifies the testing that will be performed on the Fax Service Admin MMC SnapIn.  Development spec:  Test Strategy Ad-hoc & Manual testing.  UI automation is dangerous because   It may miss simple bugs that the eye catches easily.  UI may change, thus tests need to be changed accordingly.  Ad hoc is the best in UI testing. Test the APIs layer separately from the UI layer. Strive to automatically test the UI all the way from the GUI to the verify functionality. Use visual test to automate test cases. Compose a  Behavior Verification Test  suite that verifies the service behaves according to the objects  settings. Test cases will be property specific, that is, each test case will set a single object property and verify its affect on service behavior.  If time permits we will also implement more complex test cases. Issues For the next approaching BOS/SBS milestone (3/1/2000) we will not support admin COM interface but public C APIs only. However this might be changing in the next coming up milestones. Any test tools developing should be guided by the possibility of supporting COM interface in the future and test should be designed to replace the C API with COM interface in minimum cost.   Implementation Strategy Implementation will be incremental. Implement the basic  Set-Get Test  suite. Due to vast scope of the  Behavior Verification Test  suite we will first determine the properties more crucial (important and higher risk) for testing and the extent of coverage each should receive. We will compose a fully detailed test case list for each property (in addition to this document). For testing the UI functionality use existing tools:  SendBroadcastFax for sending a broadcast fax (service configuration affects).  Our implemented VFSP/EFSP, enhance them to support any number of devices per provider. The C API framework (service configuration affects). For testing the UI functionality write the following: - Routing extension providers with many methods. Write a test using visual test to check components existence and hidden AV when stressing the UI with many mouse actions / displays selection etc. Test Categories: Testing will be divided into two areas: UI Shallow Tests UI Shallow test will cover those test cases that will test the Admin MMC components existence, minimal functionality and proper display. UI Functionality Tests UI Functionality tests will cover the cases that test the Admin MMC functionality. UI Shallow Tests Connecting the admin snap in. Connecting from the local machine. Connecting from remote machine. Connecting from the Start/Programs menu. Use the Active Directory Users and Computers management application to invoke the server s MMC. Start concurrent admin sessions. We accept inconsistencies due to concurrent sessions, but we do not accept AV s, unstable COM objects etc. Verify that concurrent admin sessions of completely different areas are successful   if they were not concurrent. Verify that concurrent admin sessions that should have been mutually exclusive leave the admin in a stable and coherent state. UI Components and Display Check for existence and proper naming of all menu(Action, View). UI Refresh. Verify all menu items defined for the selected object appear in the Actions and view menus. Check UI Right Click Menu items. Verify all menu items defined for the selected object appear in the  Right Click  menu. Check UI enabled \ disabled menu items. Verify that menu items are enabled or disabled according to the state of the selected object. The tool tip Moving up/down prioritized items. Status bar. Miscellaneous Reading from registry / saving to registry Settings persistence after restarting the service / reinstalling / upgrading. Persistence of properties sheets and settings when saving / applying /switching pages views. Setting minimum/maximum/valid/invalid values of edit boxes. UI Functionality Tests Fax Device settings. Verify devices answer calls and send faxes according to send \ receive settings. Verify setting of a device s priority affects the priorities of all other devices. Verify that service correctly enumerates all devices that support fax. Add \ remove devices while service is down, and verify Admin objects and UI are correctly refreshed at service start up. Device send /read enabled/disabled settings are actually carried out. Number of rings before answer. Proper device status displaying. Server settings. Verify sending behaves according to server settings. Make sure faxes scheduled for sending during discount rates are sent according to server  Discount Time  settings. Check that queued  discount  documents are rescheduled when  discount  setting change. Queued jobs are rescheduled according to  Retries  and  Retry Delay Verify a banner is printed according to  Branding  property settings. Verify an unsent job (regular \ broadcast) is kept in queue for  Dirty Days  days before it is removed. Also verify removal of job is logged. Enable / disable user s cover page. Stopping and starting the server. [TBD] Inbound Routing Methods. Verify that for every device object the proper routing provider object is displayed at service start up and it contains all installed Inbound Routing Extensions  routing methods. Verify that routing methods are invoked according to routing method priority. Verify that changing the priority of a routing method affects the priorities of all other routing methods on that server.Verify that routing is carried out according to the routing method settings (for instance, the fax is routed to the folder defined in the settings).  Outbound Routing. Verify default rules cannot be deleted. Verify an outbound call is handled by the desired FSP, as indicated by the  Device Type  property of the corresponding outgoing rule. Verify selection of the device within above FSP is according to device priority, unless the rule indicates a specific device. Creating new groups / Deleting groups. Adding rules. Removing rules and how does this reflects in the group. Creating overlapping groups / group with common devices. Adding new FSP, the new devices should appear in the all devices group. Modifying the rules while the device is sending. For detailed spec refer the document OutRout_spec.doc. Managing the Outbox. Specified in QfunctionalitySpec.doc. Managing the Inbox. Controlling the quota limit. Quota is exceeded a warning to the log event is sent. Dirty days. Scenario: service was disabled. Dirty days had passed. Service is enabled. What happens? Blocking the inbox. Jobs icons displayed in correlation with jobs status. Folder operations. Check the view of the jobs in queue from the client UI (archive box is not checked). Verify deleted faxes can be found in the recycle bin. Managing the Sent Items. Controlling the quota limit. Quota is exceeded a warning to the log event is sent. Dirty days. Jobs icons displayed in correlation with jobs status. Folder operations. Check the view of the jobs in queue from the client UI (archive box is not checked). Configuring Server Printer Share [TBD] Inbound and Outbound Activity Log. [TBD] Security Issues. Specified in FaxSecuritySpec.doc. Cover Pages. Add existing cover page. Create a new cover page. Modify cover page. Delete a cover page. Verify cover page actions (Open\ Delete \ Rename) are correctly carried-out. Activity Reports. Verify that reports reflect correct data\ measurements. Outgoing Faxes   status distribution. Incoming Faxes   status distribution. Outgoing/Incoming faxes   24hrs stress distribution. Outgoing faxes   Sender distribution. Outgoing faxes   Recipient Information. SBS Admin UI Test Spec  TIME \@ "d-MMM-yy"  10-Oct-99  PAGE   out of   NUMPAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\appprint_spec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0+!1yJf 2$:&q::Printing from Applications Test Specification   Revision 0.1 Preface The goal of these tests is to verify that applications can successfully print to the CometFax printer. This includes: Verifying that the Comet Fax printer driver and monitor function correctly on all platforms. Verifying that TIFF rendering of documents is performed correctly on all platforms. Test Strategy Run the existing PCT suite on the CometFax printer, using an existent registry hack to prevent the CometFax Send Wizard from popping-up. Add support for a similar registry hack on CometFax Client machines, so that PCT may also run on clients (in all platforms). For each application prepare a fixed set of TIFF files for reference testing. The PCT result TIFF files will be compared with the reference files using  TiffCompare Issues Comet Fax server must be configured with Branding = FALSE to prevent printing of banner. The banner includes date and time, which will interfere with fax image verification ( TiffCompare Similarly the cover page templates should not contain date or time fields. Because it is too costly to integrate using a different cover page for each document in the PCT suite, all the tests will use the same cover page template.  We will use the  FakeCoverPage  registry hack to indicate that every document printed to the CometFax printer will be printed with the  AllFields  cover page template (a template containing all non time-date fields). Revision Information Revision Author Description 4-Oct-99 Sigalit Bar Initial version Applications  Following is the list of the application we are planning to test with PCT: MS Word 2000. MS Excel 2000. MS Access 2000. MS FrontPage 2000. MS PowerPoint 2000. MS Outlook 2000. MS Publisher 98. MS Works 97. MS IE. MS Notepad. MS Wordpad. MS Paint. Wang Imaging. Visio 5. Other non-MS applications that can be tested via PCT but require license: (Lotus) AmiPro 3.1 (Micrografix) Designer 7.0 (Macromedia) FreeHand 7.0 (Macromedia) FreeHand 8.0 (Lotus) Freelance 2.1 Harvard Graphics 3.0  (Adobe) Illustrator 7.0 (Aldus or Adobe) PageMaker 5.0a (Adobe) PageMaker 6.5 (Adobe) Persuasion 3.0 (Corel) Presentation 8.0 (Adobe) Photoshop 5.0 Quark XPress 4.0 Word Perfect 6.1 (Corel) Word Perfect 8.0 Platforms  Following is the list of the platforms we are planning to run PCT on: Comet Fax Server on Win2000 fre.srv. Comet Fax Client on Win2000 fre.srv. Comet Fax Client on Win2000 fre.wks. Comet Fax Client on NT4 fre.srv. Comet Fax Client on NT4 fre.wks. Comet Fax Client on Win95. Comet Fax Client on Win98. Printing from Applications Test Specification Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  7-Oct-99 zuplgb]U zwog_WOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\bosinteg_spec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0+!1yJfBOS \ SBS Integration Test Specification   Revision 0.1 Preface The goal of this set of tests is to verify that CometFax is correctly integrated with BOS \ SBS. Test Strategy Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5 Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Issues Currently it is not clear which upgrade scenarios of SBS we can commit to supporting. Thus the  Upgrade  section below should be considered as an initial assessment. We also suspect that further integration issues may arise as our work with BOS continues. Revision Information Revision Author Description 5-Oct-99 Sigalit Bar Initial version 22-Nov-99 Sigalit Bar Added  Server Upgrade Paths Client Upgrade Paths  and  OS Upgrade Paths  to section   REF _Ref467900405 \w \h  Test Categories   Setup Server Setup Test CometFax server via Cartman setup \ uninstall. Check complete (all components including CometFax) installation of BOS \ SBS Server. Run BOS \ SBS Server installation with only the CometFax component. CometFax install \ uninstall from  Add \ Remove programs Client Setup Check complete (all components including CometFax Client) installation of BOS \ SBS Client. Run BOS \ SBS Client installation with only the CometFax Client component. CometFax Client install \ uninstall from  Add \ Remove programs Upgrade Server Migration of server cover page files. Migration of archived faxes (sent and received). Migration of device settings. Migration of FSPs. Migration of Routing Extensions. Client Migration of personal cover page files. Migration of user information. Migration of last Send Fax Wizard settings. Server Upgrade Paths SBS 4.0 Server -> SBS 5.0 Server ? SBS 4.5 Server -> SBS 5.0 Server SBS 4.5 Server -> BOS 5.0 Server SBS 4.5 Server -> BOS 4.5 Server (has Fax) -> BOS 5.0 Server BOS 4.5 Server (no Fax) -> BOS 5.0 Server Client Upgrade Paths SBS 4.0 Client (on NT4) -> SBS 5.0 Client (on NT4) ? SBS 4.0 Client (on Win9x) -> SBS 5.0 Client (on Win9x) ? SBS 4.5 Client (on NT4) -> SBS 5.0 Client (on NT4) SBS 4.5 Client (on Win9x) -> SBS 5.0 Client (on Win9x) SBS 4.5 Client (on NT4) -> BOS 5.0 Client (on NT4) SBS 4.5 Client (on Win9x) -> BOS 5.0 Client (on Win9x) BOS 4.5 Client (on NT4 no Fax) -> BOS 5.0 Client (on NT4) BOS 4.5 Client (on Win9x no Fax) -> BOS 5.0 Client (on Win9x) BOS 4.5 Client (on NT4 & has Fax) -> BOS 5.0 Client (on NT4) BOS 4.5 Client (on Win9x & has Fax) -> BOS 5.0 Client (on Win9x) OS Upgrade Paths Due to OS upgrade on an SBS\BOS client or server we need to support upgrade of NT5 SBS\BOS client or server.  E.g. for an SBS 4.5 client (on NT4) that upgrades the OS to NT5 (is now a broken NT5 SBS 4.5 client), we need to support an upgrade of this client to an (NT5) SBS 5.0 client. See OsUpgrade_spec.doc Management MMC snapins Local CometFax Admin MMC should be available from the Computer Management Console. Re-targeting the Computer Management Console should implicitly connect our Admin MMC snapin to the CometFax server on that computer. Our Admin MMC should not be available when the Computer Management Console is connected to a machine with no CometFax server. DS integration CometFax printer should be published in the DS. BOS \ SBS Integration Test Specification Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  22-Nov-99 {wrmh^Z wogaYQIC pb\TLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\clientsdktestspec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Title _PID_GUID _PID_HLINKSmicky snir Normal.dot micky snir Microsoft Word 8.0Client SDK Test Spec. This document describes the tests and the cases that we will run in order to test the Comet fax client SDK. Todo: Update this document to match the new client API functionality, since we do not support anymore backward compatibility, and the C interface becomes private, and the public interface is a COM object. Document History/Revision This file is located at   HYPERLINK \\\\haifaslm\\slmcomet\\src\\fax\\faxtest\\docs\\SDKTestSpec.doc  \\haifaslm\slmcomet\src\fax\faxtest\docs\SDKTestSpec.doc *1 Topic should be addressed in each project test plan Micky Snir (MickyS)   July 25, 1998   1st version. Draft. General The fax SDK includes the following interfaces: Client C API (fxsapi.dll). Client COM interface (FxsCom.dll) Methodology All APIs. Each API will be called to check at least for its existence (ANSI & UNICODE). Illegal parameters. Each API will be called with illegal parameters. We define level-2 parameters as members of structs that are level-1 parameters. Illegal level-2 parameters will be tested as well. The number of combinations of illegal parameters is very big. Therefor, we will test only combinations of only 1 illegal parameter at a time. More complex scenarios will be tested only if they seem  logical  combinations, i.e. users are likely to call the function with this combination of illegal parameters. Error messages. We strive to get every possible error return value. This bullet overrides restrictions in previous bullet. Success. We must call each API at least once with success. Success should be verified besides the actual return value. Multithreading. Each API will be called simultaneously from different threads. Different APIs will be called from different threads. We have too many combinations here, so we will chooses only the important combinations. I consider the most important cases the ones in which a fax handle is closed while another thread uses it, or aborting jobs. Multithreading bugs are usually time-dependent on context switches. Therefore most multithreading cases should run many times (in stress mode) and on multiprocessor machines. Canceling. This item may be considered as a subset of Multithreading and/or States but I give this item special attention because it is a very fruitful one (bug-wise). The general idea is to cancel jobs, close handles while performing operations with them and specifically: terminating treads (TerminateThred()) and canceling IO (CancelIo()). TerminateThred() should be performed with caution to prevent test-resource leaks. States. We will define interesting scenarios that will exercise the APIs in different states. Low memory. We will hog memory and call the APIs. We strive for the out-of-memory error. These cases should be designed in such a way that they will be able to make the API call fail on different allocations (don t always make the API fail on the 1st allocation). Important points:  Stress an API that fails due to out of memory condition because it may find memory leaks. It is a common bug to forget to de-allocate resources.  Perform a sanity check after an API-call on low memory. The reasons are that 1) the call may succeed but an allocation actually failed, and 2) the call failed but resources where not properly released.  A sanity check is performed after releasing the hogged memory. Memory leaks. Check for memory leaks by stressing API calls and keeping track of the working set. The most promising API calls are the ones that fail. Stress. Each case will have a corresponding stress mode in which the case is executed many times. Executing concurrently independent test cases may save time as well as find new bugs. Verification. We should verify each and every operation. One of the challenges is to verify that sent faxes have reached their destination in high quality. The challenge arises from the distributed nature of the operation. Same for aborted faxes. Note that there is some overlapping among the items above, e.g. multithreading is a kind of state. We should not have the same test case for each item. Client C API (fxsapi.dll) General This API allows any application to send faxes, query and change fax jobs, query and change fax server configurations. Each API test will be provided as a DLL and a DLL wrapper that will allow each case to be run via a DTM agent. TBD: is the Win9X and WfW interface different? Probably so since it s 16 bit. This means that we need to develop different API tests for these platforms. Test cases Illegal parameters TBD: for each API list the illegal parameter(s) and the expected result. Question: should we enumerate the test cases to match their case number in the actual test? Error messages TBD: for each API list each error message, and how to make the API return it. Question: should we enumerate the test cases to match their case number in the actual test? Success TBD: for each API write a common scenario in which the API succeeds and the success can be verified. We should define several main-stream scenarios that will catch all the APIs instead of defining a scenario per API. Question: should we enumerate the test cases to match their case number in the actual test? Multithreading TBD: invoke each API concurrently from several threads. If the concurrent invocation makes sense, verify the return values and the functionality. If the concurrent invocation does not make sense, verify that the client is stable after the invocation, i.e. perform sanity check. TBD: list the APIs that should be invoked concurrently with each other. Give special attention to aborting and closing while performing, and make sure these are stresses in order to catch the critical sections. Question: should we enumerate the test cases to match their case number in the actual test? Canceling States This section requires special attention, as there are infinite scenarios, and we should try and find the equivalence classes, and within them the important ones. TBD: list the scenarios and the expected results. Question: should we enumerate the test cases to match their case number in the actual test? Low memory These cases should be designed carefully, for example the test itself should not fail due to lack of memory. The general idea is to repeatedly allocate memory until we fail and then to call an API. One possible parameter is the quanta that we allocate until we fail. A special challenge is to concurrently call an API and allocate memory, in order to cause a memory allocation failure within the API, but not on its 1st allocation call. A sanity check must be performed even if a call succeeds, because the API may have returned a success value wrongfully. TBD: list the cases. Question: should we enumerate the test cases to match their case number in the actual test? Memory leaks Memory leaks will be found by stressing API calls and monitoring the PeakWorkingSetSize with calls to GetProcessMemoryInfo(). TBD: list the cases. Question: should we enumerate the test cases to match their case number in the actual test? Stress Stress only those APIs / scenarios that were not stressed in previous cases. TBD: list the cases. Question: should we enumerate the test cases to match their case number in the actual test? Client COM interface General We will test this interface via C++, VB and VBS. The common cases will be listed only once. TBD: what are the important cases when testing COM interface. Like reference counting etc. Test cases Illegal parameters TBD: for each API, list the illegal parameter(s) and the expected result. Question: should we enumerate the test cases to match their case number in the actual test? Error messages TBD: for each API, list each error message, and how to make the API return it. Question: should we enumerate the test cases to match their case number in the actual test? Success TBD: for each API, write a common scenario in which the API succeeds and the success can be verified. We should define several mainstream scenarios that will catch all the APIs instead of defining a scenario per API. Question: should we enumerate the test cases to match their case number in the actual test? Multithreading C++ only. TBD: invoke each API concurrently from several threads. If the concurrent invocation makes sense, verify the return values and the functionality. If the concurrent invocation does not make sense, verify that the client is stable after the invocation, i.e. perform sanity check. TBD: list the APIs that should be invoked concurrently with each other. Give special attention to aborting and closing while performing, and make sure these are stresses in order to catch the critical sections. Question: should we enumerate the test cases to match their case number in the actual test? Canceling States This section requires special attention, as there are infinite scenarios, and we should try and find the equivalence classes, and within them the important ones. TBD: list the scenarios and the expected results. Question: should we enumerate the test cases to match their case number in the actual test? Low memory C++ only. These cases should be designed carefully, for example the test itself should not fail due to lack of memory. The general idea is to repeatedly allocate memory until we fail and then to call an API. One possible parameter is the quanta that we allocate until we fail. A special challenge is to concurrently call an API and allocate memory, in order to cause a memory allocation failure within the API, but not on its 1st allocation call. A sanity check must be performed even if a call succeeds, because the API may have returned a success value wrongfully. TBD: list the cases. Question: should we enumerate the test cases to match their case number in the actual test? Memory leaks C++ only. Memory leaks will be found by stressing API calls and monitoring the PeakWorkingSetSize with calls to GetProcessMemoryInfo(). TBD: list the cases. Question: should we enumerate the test cases to match their case number in the actual test? Stress Stress only those APIs / scenarios that were not stressed in previous cases. TBD: list the cases. Question: should we enumerate the test cases to match their case number in the actual test? SDK Test Spec Microsoft Confidential Page   PAGE   DATE  03/18/99 |tlda^[S |yspm xurli
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\broadcasttc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server Title _PID_GUIDCover Page Rendering On Server Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0Broadcast Test Cases: Preface  All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). Every test case below must be invoked using the CometFax APIs and again using the Print mechanism. Test Strategy: Create tools similar to Micky s enhanced Simple.exe but for broadcast, and use these tools to automatically invoke broadcast job behavior. Verification  Successfully completed jobs  images will be TiffCompare d against a Reference image directory. Thus making sure that jobs have completed and the images were correctly rendered. State correctness will be monitored using an enhanced version of Micky Service Monitor  tool. We will investigate options for automating tests for broadcasting via the printing mechanism, but may settle for manual testing if cost is too high or time is short. Issues: Fax servers must be configured with Branding = FALSE to prevent printing of banner. The banner includes date and time, which will interfere with fax image verification ( TiffCompare We need to better define equivalence classes for testing actions on a child \ parent job in context of the states of other child jobs of the same parent. Implementation Strategy: Implementation will be incremental. Write a tool similar to Simple.exe that sends a broadcast (using FaxSendDocumentEx) and monitors the fax events (on the IO completion port). Enhance above tool to allow for performing actions (Cancel \ Zap \ Delete \ Pause \ Resume \ Restart) on the parent job (after X seconds \ after random time). Enhance above tool to allow for performing actions (Cancel \ Zap \ Delete \ Pause \ Resume \ Restart) on N child jobs (after X seconds \ after random time). Enhance  Service Monitor  tool to include the New Job Status States Model (see  Comet Enhanced Fax Client API , Figure 1, page 10). Compose a test suite using the above tools. We will manually go over all received faxes to verify the images are correct and will create a Reference directory containing these images. Further enhance above suite to include a  TiffCompare  test of all Received and Sent faxes against the Reference images. Implement specific test cases, which cannot be covered by above tools, using the Enhanced Client APIs. Test Categories: Broadcast via FaxSendDocumentEx API with single and multiple recipients (most important). Broadcast (just a CP) via  Fax Send Wizard  with multiple recipients. Broadcast via printing architecture (documents with \ with out CP). Broadcast via MAPI extension with multiple fax recipients. Broadcast via FaxSendDocumentForBroadcast API (backward compatibility). * FaxSendDocumentForBroadcast allows a different CP for each recipient. Since added support for broadcasting involves a change in the job management design (shifting to a parent and child job model) even non-broadcast jobs may be affected => Check sending to a single recipient   use the  Cover Page Rendering  test suite as a regression suite. Calculation  of parent job queue fields, such as  Status  and  Device Duration a broadcast job is kept in outgoing queue. E.g. check that it is moved to  Sent Archive  only after all child jobs completed successfully. E.g. check that it remains on Outing queue as long as any of its child jobs are in a non-finite status. Parent job parameters, such as CP, scheduled time, receipt type. Make sure they apply to all child jobs. Actions on Parent job (Cancel \ Zap \ Delete \ Pause \ Resume \ Restart). Make sure they can be performed only when allowed. Make sure they affect all child jobs. Actions on Child job (Cancel \ Zap \ Delete \ Pause \ Resume \ Restart). Make sure they can be performed only when allowed. Make sure they affect only the specific child job (may also lead to change in state of the parent job, e.g. lead to completion). Make sure that parent job description still includes the child job (e.g. after we abort a child job, it should still appear in the parent job but change status to "Canceled"). Delivery Receipt type (none, email, inbox, msg box) and grouping (per child or for all). Number of recipients in a parent job (single \ many \ a whole lot). Address Book and recipient profile information (when broadcast is via  Fax Send Wizard Make sure that when a recipient is selected from the Address Book its profile contains the information from the Address Book. * Send a broadcast where some of the recipients are taken from Address Book and some not. New Job Status States Model (see  Comet Enhanced Fax Client API , Figure 1, page 10). Verify that all states and events during a broadcast are consistent with model (enhance Service Monitor tool). Broadcast Job test parameters: Document   type, size and number of pages. Sender Profile fields. * No Sender information is available (all fields empty). * Missing mandatory fields (such as the fax number). * Some sender information is available. * Very long values in sender information fields. Number of recipients. Recipient Profile fields. * Recipient is in Address Book (Personal \ Global \ etc). * Recipient is not in Address Book. * No recipient information (all fields empty). * Missing mandatory fields (such as the fax number). * Some recipient information (some optional fields have values and some not). * Very long values in recipient information fields. Scheduled time. Delivery receipt type and profile. State of related child jobs on queue. Broadcast Test Cases  TIME \@ "d-MMM-yy"  23-Mar-99 Microsoft Confidential Sigalit Bar (sigalitb) }urolf^V aaaaaaa_\_a
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\clientuispec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot miris Microsoft Word 9.0b>tv~: ^0fA* eDvJTbjbjU SBS Fax Client UI Test Specification Preface  This document specifies the testing that will be performed on the Fax Client UI.  Development spec: Test Strategy Ad-hoc & Manual testing.  UI automation is dangerous because -  It may miss simple bugs that the eye catches easily.  UI may change, thus tests need to be changed accordingly.  Ad hoc is the best in UI testing. Test the underlying C APIs. Use the C APIs based tools to automate the UI functionality test cases. Use visual test to automate UI shallow test cases. Issues For the next approaching BOS/SBS milestone (3/1/2000) we will not support client COM interface but public C APIs only. However this might be changing in the next coming up milestones. Any test tools developing should be guided by the possibility of supporting COM interface in the future and test should be designed to replace the C API with COM interface in minimum cost.   Implementation Strategy For manual testing we will compose a detailed specification for all test cases, including instructions explaining how to carry out each test case and a description of each test case s expected results. For testing the UI functionality use existing tools:  SendBroadcastFax for sending a broadcast fax.  Our implemented VFSP/EFSP, enhance them to support any number of devices per provider. The C API framework for sending jobs, invoking client operations and monitoring the jobs state. Client Stress manager to perform test in extreme conditions such as the outbound queue view on huge jobs number. Write a test using visual test to check components existence and hidden AV when stressing the UI with many mouse actions / displays selection etc. Test Categories All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). All following test cases should be run once when client is running under administrator account and once when client is running under user account. Testing will be divided into two areas: UI Shallow Tests UI Shallow test will cover those test cases that will test the Admin MMC components existence, minimal functionality and proper view. UI Functionality Tests UI Functionality tests will cover the cases that test the client MMC functionality. UI Shallow Tests Connection. Several printers installed on same client machine. Verify UI can  connect  to all installed printers. Co-existence with other MS fax applications UI Components and Display Check for existence, menu items defined and proper naming of all menu (Action, View). UI Refresh. Check UI Right Click Menu items. Verify all menu items defined for the selected object appear in the  Right Click  menu. Check UI enabled \ disabled menu items. Verify that menu items are enabled or disabled according to the state of the selected object. Same for fields in property pages and wizard. Verify columns selection. UI Layout.  Verify all UI entities are of correct size, color, font, etc. The tool tip. Status bar. Miscellaneous Verify settings persistence after closing and restarting the client application. Persistence of properties sheets and settings when saving / applying /switching pages views. Setting minimum/maximum/valid/invalid values of edit boxes. UI Functionality Tests Connecting \ Disconnecting from printer Connecting to a printer from: Root, right click menu -> Add new fax printer. File menu -> Add new fax printer. Many printers are connected. Verify that a proper indication exists for any unavailable installed server. Printer s property sheet is displayed correctly. Import server CP from many different servers, some can t be connected due to network problems or service is not strted. Fax Send Wizard Activating the wizard from File menu ->Send a new fax. New button on menu bar. Outbox, right click ->Send a new fax. Printer connection, right click menu -> Send a new fax. Cover page, right click menu -> Send. Verify all installed printers are enumerated on  Select Printer  page (1st page). Verify proper enforcement of canonical number. Verify proper interaction with  Address book  of default email provider. Verify all server \ personal cover pages are enumerated on the wizard Select Cover Page  page. Verify that many recipients can be  Added  and  Removed  to create a broadcast fax. Verify all information the user specifies in the wizard is passed on correctly. E.g. the send job is scheduled correctly; the correct cover page is used, etc. Verify the wizard allows going to the next page, only after all required (non-optional) information in current page has been set. [TBD] Outbox. Verify that broadcast recipient jobs are displayed as independent jobs. Verify job states are correctly (and automatically) updated. Verify jobs are displayed in correct order. For a non-administrator user verify that only the user s jobs are displayed. For an administrator user all jobs should be displayed. Verify job actions (Cancel \ Pause \ Resume \ Restart\ Print) are correctly carried-out. Verify jobs are removed from Outbox as soon as they complete.  Especially check broadcast jobs where some recipients were canceled, others failed, and some succeeded. Dirty days. Icons match the job s state. Appropriate Outbox icon when queue is paused or blocked. Properties sheet fields are displayed correctly. All columns information is correct Cancel all faxes from Outbox, right click menu. For further outbox functionality refer to QfunctionalitySpec.doc. Inbox. Verify all incoming and archived jobs are enumerated. Verify that received job status is correctly displayed. Verify that processed incoming jobs are archived in the queue. Verify job actions (View \ Delete \ Copy \ Print\ Mail to) are correctly carried out. Blocking and unblocking the queue from Inbox, right click menu. Dirty days Verify all columns data is displayed correctly. Icons match the job s state. Appropriate Inbox icon when queue blocked. Properties sheet fields are displayed correctly. Sent Items. For a non-administrator user logged on: verify that all sent items of logged on user on all installed servers (printers) are enumerated. For an administrator user logged on: verify that all sent items of all users on server are enumerated. Verify that successfully concluded broadcast jobs and failed / canceled jobs are correctly displayed. Verify job actions (View\ Copy \ Delete \ Print\ Mail to) are correctly carried-out. Dirty days. Verify all columns data is displayed correctly. Icons match the job s state. Properties sheet fields are displayed correctly. Personal Cover Pages. Verify all logged on user personal cover pages are enumerated according if  Allow Personal Cover Pages  server is set to TRUE. Set personal cover page to a non-existing directory. Delete a personal cover page. Add an existing personal cover page. Add a new personal cover page. Import from server a cover page. Verify cover page actions (Open\ Delete \ Rename) are correctly carried-out. Miscellaneous. User Info. [TBD] Security Issues. Specified in FaxSecuritySpec.doc. SBS Client UI Test Spec  TIME \@ "d-MMM-yy"  10-Oct-99  PAGE   out of   NUMPAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\coexisttc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server Title _PID_GUIDCover Page Rendering On Server Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0CometFax Co-Existence with Other Fax Apps Test Cases: Preface  All following test cases refer to a client server constellation (client is NT5 \ Win9x \ NT4). Other Fax applications may be installed on the server where the CometFax service and the modem devices used by the service are installed.  Other fax applications may also be installed on the client. These may be using any locally installed modem. Test Strategy: We will install other Fax applications and local modems on  Scale Lab  machines. Testing will be mostly manual. Issues: [TBD] Implementation Strategy: Implementation is straightforward. Test Categories: MSFax Comet Server Setup. Verify that MSFax service is disabled after Comet Server setup completes. Verify that if user manually enables MSFax at any point in the future a warning stating that both services should not be active simultaneously is issued. * In a clean install do we copy MSFax settings? Do we copy CPs? FSPs? Routing Extensions?  Registry Entries. Verify that CometFax entry values are used by the CometFax service and not the values of MSFax entries EXEs and DLLs. Verify that all CometFax EXE and DLL files use only CometFax entities. This is a high-risk area since we copied the MSFax code, therefor we want to make sure all GUIDs, includes and such were correctly changed. Cover Page directory and Cover Page files (on Comet Server). Verify that we use separate CometFax directories for Server and Personal CPs, also verify that the CometFax SendWizard enumerates CPs from these directories (and not MSFax CPE and Kodak Imaging Apps. Both services use them (on Comet Server and on Client). Verify there are no version differences. MAPI Add-In. Verify that when a message is recognized as a MSFax message only the MSFax Add-In menu item is available; similarly when the message is a CometFax message only the CometFax Add-In menu is available.  MAPI extension (transport provider). Verify that CometFax is used to send a message when the CometFax syntax is used and MSFax when the MSFax is used. Known Issue   both extensions use a FAX: type address in the Address Book. So which provider will be used to send the message when a recipient is chosen from the Address Book? Enabled MSFax on a Comet Server. A less likely scenario. Verify both can send and receive faxes (even simultaneously if using different modems). Make sure that when both services set the same device to receive, the user will be notified that the other service is already set to answer calls for that device. Other Fax Apps Any Fax Printer. When other Fax printers are installed (local \ remote) on the server. Make sure that the CometFax MS Inbound Routing Extension  Print  routing method GUI does not allow choosing one as the printer to route incoming faxes to. CometFax SendWizard. Verify that when more than one fax printer (of any kind) is installed on a Comet Client, wizard enumerates only CometFax printers. NT4 WinFax (on Comet Client). Verify that faxes can be sent and received using WinFax and the local modems. Win 9X PersonalFax (on Comet Client). Verify that faxes can be sent and received using PersonalFax and the local modems. MAPI and Address Book integration of above apps. Requires further investigation. Other CometFax printers (on an NT5 Comet Client). Co-Existence test parameters: Co-existence on server or on client. What other fax software is installed. MSFax \ WinFax \ PersonalFax \ other. Time other fax app is installed. E.g. install Win 9X PersonalFax after \ before CometFax client is installed. Installation of app extensions. E.g. CometFax MAPI Ext. [TBD] CometFax Co-Existence Test Cases  TIME \@ "d-MMM-yy"  23-Mar-99 Microsoft Confidential Sigalit Bar (sigalitb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\com_api_issues.doc ===
Microsoft Word Document MSWordDoc Word.Document.8COM Interface Issues: Title _PID_GUIDCOM Interface Issues: Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0_>U]FCOM Interface Issues Preface: This is a draft document. This document points out problematic issues regarding the existing NT5 Fax Service COM API. Issues: Lack of C API FaxInitializeEventQueue() equivalent => no notifications of fax events via a completion port. Error notifications  VB gets error information via Err object (Description and Number). Err.Number<>0 indicates error and the specific number distinguishes between errors (to allow specific treatment of specific errors). Today COM interfaces return same error number for different reasons of failure (across errors and across objects). Constants  while C interface provides winfax.h and thus all written applications   all the Fax constants definitions, how does VB compare the device status to  Available If someone writes an application do they have to first sit down and re-write all the constants in a VB file? Data Types  there are some discrepancies between some C/C++ types and VB types (e.g. BOOL, VB True is  1 not every <>0). So both DWORD and BOOL map to Long. => Harder to understand property logic and looses VB code readability (True False keywords cannot be used with these properties, rather <>0). What about UNICODE vs. ANSI? Does VB support it? How does COM map from VB? How does COM DLL know switches _UNICODE or _MBCS? Connection to server  in C   HANDLE hFax = NULL; FaxConnectFaxServer(NULL,hFax); =>          if (NULL!=hFax) {//server connected} in VB -  Dim myFaxServer As FaxServer            Set myFaxServer = Nothing            Set myFaxServer = CreateObject( FaxServer.FaxServer             here myFaxServe <> Nothing but not connected            Set myFaxServer.Connect( SIGALITB1             now myFaxServer is connected => how do I know when disconnection is needed?      Disconnection method fails if the object is not connected Sending a document  myFaxServer   connected     Dim myFaxDoc As FaxDoc     Set myFaxDoc = myFaxServer.CreateDocument( d:\myfile.txt     myFaxDoc.FaxNumber =      Dim myJobId As Long      myJobId = myFaxDoc.Send Why is document created by server? Why does it have a FaxNumber property? Why not myJobId = myFaxServer.Send(myFaxDoc,myFaxNumber)? JobId as key for jobs  COM can only enumarate jobs (GetJobs()) there is no efficient way to get the job you want according to its key (JobId), you have to go over all the jobs yourself. C interface has FaxGetJob(hFaxHandle,dwJobId, ), COM is missing it. IRoutingMethods design  installation API missing (C s FaxRegisterRoutingExtension()). FSPs  There is no FSP registration API (C s FaxRegisterServiceProvider). Bugs  * IFaxTiff non initialized string properties return  Unavailable  instead of  * IFaxRoutingMethod.RoutingData is read-only, should be R/W             COM Interface Issues Page   PAGE   NUMPAGES  Microsoft Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  5-Jan-99
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\cprendertc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server Title _PID_GUIDCover Page Rendering On Server Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0Cover Page Rendering Test Cases: Preface  All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). Every test case below must be run once when the CP is a Personal CP and again when it is a Server CP. Every test case below must be invoked using the CometFax APIs and again using the Print mechanism. Test Strategy: Use the qFax.exe tool to send a matrix of files and cover pages.  CP files to be used for test are described below.  Documents to be used in test are those used in the PCT tests. We will run the same test sequence for CometFax and for MSFax, and will compare the resulting tif files of the two sequences   they should match. Furthermore we will go over the results of the first run visually ( manually ) and create a reference directory to which we will compare every subsequent CometFax run. Issues: Fax servers must be configured with Branding = FALSE. Some PCT files have date fields. Either these will be removed or the CometFax and MSFax test sequences must be conducted on the same date. Otherwise tif comparison will fail. * Make sure there are no time fields in documents. Run above under different sender information settings. Sender information fields empty.  Some sender information fields have values and some are empty. All sender information fields have values. All sender information fields have very long values. * How do we automatically verify that CP has correct Sender information? Implementation Strategy: Implementation of the test suite will be incremental. First stage  -  Only APIs will be used, the printing mechanism will not be invoked. All the CPs (detailed below) will run with a sub-set of the PCT files (all without date & time fields).  The Sender and Recipient information will be hard coded. Overall suite will be implemented as a batch file that invokes qCometFax.exe calls (with the appropriate cover pages and files) and compares all the files in the received files directory to the reference directory. Similarly for MSFax (using qNT5Fax.exe). Second stage -   Printing mechanism still not invoked. Sender and Recipient information will be loaded from file. qCometFax.exe and  qNT5Fax.exe will be enhanced to load information from above file (filename will be a command line parameter). Suite batch file will run the 1st stage batch file several times, each time with a different Sender & Recipient information file. Third stage -   Printing mechanism tests implementation. Test Categories: Send a file without a CP. Send a file with CP. Send just a CP. Use invalid CPs. Use valid CPs but invalid document files (?). Use SBS CPs. Sender information  * CometFax Control Panel applet information. * No sender information (all fields empty). * Some sender information. * Very long values in sender information fields. Recipient information  * Recipient is in Address Book (Personal \ Global \ etc). * Recipient is not in Address Book. * No recipient information (all fields empty). * Some Recipient information (values for fields that are not in CP). * Very long values in recipient information fields. Consistency  * Make sure that CP information is consistent when Sender information is changed while a CP is being printed. (? How?) * Make sure that CP information is consistent when an Address Book entry of a recipient is changed \ deleted as the CP is being printed. (? How?) Broadcast (?)  * FaxSendDocumentForBroadcast allows a different CP for each recipient. * FaxSendDocumentEx with single \ many recipient. * FaxSendDocumentEx with many recipients where an optional information field     (e.g. recipient address) is supplied for some of the recipients and for some not. * Some of the broadcast recipients are in Address Book and some not. Cover Page test parameters: Fields   what fields, amount of fields, fields that are empty, size of fields, repetition, fields information available but no such field in CP, field appears in CP but its information is not available (e.g. recipient address field appears on CP but not given in API call). paper size, orientation, margins text   fonts, format, amount Anything that can be pasted to file (bmp, text, ? ) Cover Pages to be used in Test Cases: Empty CP. CP with subject field only. CP with note field only. CP with a subject and a note filed. CP with all possible fields where all values are empty (i.e. no user settings in the CometFax Control Panel applet and no recipient information either). CP with all possible fields where all values are set. CP with all possible fields where some values are set and some are not. CP with drawing objects only. CP with every thinkable thing (fields, text, drawings, anything that can be pasted). CP with font that is not available on server. Landscape CPs in all paper sizes (size and orientation of CP different than that of file). Portrait CPs in all paper sizes (size and orientation of CP different than that of file). CP with 0 margins CP with very large margins CP with 0 top and bottom margins but large left and right margins. CP with large top and bottom margins but 0 left and right margins. CP with very small field size (i.e. every field has room for just 1 char) CP with very large field size (i.e. every field has room for 100 chars, note & subject even more). CP where format (size) of field text is too big to fit in field. CP with all text formats, in plain text and in fields. Existing  server side  SBS CPs. Server side CPs which are provided with CometFax. Personal CPs created on non-NT5 clients. Invalid CPs (e.g. rename a file.doc as file.cov and attempt to use it as a CP). Implemented Test Cases: 10-Mar-99  None as yet. 11-Mar-99 Created CPs 1 through 12 Cover Page Test Cases  TIME \@ "d-MMM-yy"  11-Mar-99 Microsoft Confidential Sigalit Bar (sigalitb) zrjb^V }umeb_\VN wog_WOL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\efsp_acceptance_tests.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Title _PID_GUID _PID_HLINKSSigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0PPhotoshop 3.0 8BIM' Adobe 7GWgw 8HXhx )9IYiy *:JZjz 'dtU7 8HXhx 9IYiy *:JZjz f? 1W ZSzTUW ,e[GI ?9[Gu $j Y} -mV_2 :l{@J_! jhVOTu <3@Y& )~nYy geQs4Q @~zAa cIYUY ommm$ w8i0a53 H#oie> K}AXwK K~gIq HoRkS4KO /2y|q s"3#)dp 5_5j: 0#cB6 ZZF4O. 5"_Ye:_ 4%G~6 dS[_[ -A^Q: =X"T;Hn ~K~bjSy T23GS t31.h #IFf&@h =>)lG m89{747 u_$^[ ]^-Lx wODl+ 6./0+ PX3(* wVe#$ nfHI5 %"f^D(r OLa';7& ?3~_y e@Czs "82O. o ERS9M_ {o=y. U~UGq -#xsd }^mMo kgFwAl 4K/.@ 5o0~v )AV^P[ c. H>O ??4?,< C8=ZU j{$La 8uf&x o>i6Ws C'"DQ ;LZMN/ Z{cH# :f>?e Cd{_I H NLiW` Z>lREQ* 5dy`V =.OJh] 8n.T* BCs[p 9GgvF /e;N' :;8Z1o ~Z~DZ o6yKJ :=^xh Qx)[h ef,_H d32/^ 6y6?1<7p\ e3@uX &FYXr -z95O 5~vjWS &O28# 'riRw9Comet Fax Server Extended Fax Service Provider  Test Specification  Revision 0.1 Last Updated On:   SAVEDATE  \* MERGEFORMAT  12/17/99 10:40 AM By: Sigalit Bar Copyright   by Microsoft Corporation ALL RIGHTS RESERVED Note    This documentation is an early release of the final product documentation and is only for limited distribution outside of Microsoft and not for redistribution. It is meant to accompany software still in development. Some of the information in the documentation may be inaccurate or may not be an accurate representation of the functionality in the final released product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. This is a preliminary document and may be changed substantially prior to final commercial release. This document is provided for informational purposes only and Microsoft Corporation makes no warranties, either express or implied, in this document. The entire risk of the use or the results of the use of this document remains with the user. Companies, names, and data used in examples herein are fictitious unless otherwise noted. No part of this document may be reproduced or transmitted in any form or by any means, electronic or mechanical, for any purpose, without the express written permission of Microsoft Corporation. Microsoft may have patents, patent applications, trademarks, copyrights, or other intellectual property rights covering subject matter in this document. The furnishing of this document does not give you any license to these patents, trademarks, copyrights, or other intellectual property.  1999 Microsoft Corporation. All rights reserved. Microsoft, MS, MS-DOS, Visual Basic, Win32, and Windows are registered trademarks, and Visual C++ and Windows NT are trademarks of Microsoft Corporation in the U.S.A. and other countries. Unicode is a trademark of Unicode, Incorporated. All other trademarks are the property of their respective owners.  TOC  \* MERGEFORMAT  Scope  PAGEREF _Toc473103929 \h  Revision Information  PAGEREF _Toc473103930 \h  References  PAGEREF _Toc473103931 \h  Overview  PAGEREF _Toc473103932 \h  Test Objectives and Strategy  PAGEREF _Toc473103933 \h  Component Tests  PAGEREF _Toc473103934 \h  Exported Functions  PAGEREF _Toc473103935 \h  6.1.1 FSP Exported Functions  PAGEREF _Toc473103936 \h  6.1.1.1 Test Case   An FSP exports all mandatory functions  PAGEREF _Toc473103937 \h  6.1.1.2 Test Case   A Virtual FSP exports the FaxDevVirtualDeviceCreation API  PAGEREF _Toc473103938 \h  6.1.1.3 Test Case   An FSP supporting device configuration exports the FaxDevConfigure API  PAGEREF _Toc473103939 \h  6.1.2 EFSP Exported Functions  PAGEREF _Toc473103940 \h  6.1.2.1 Test Case   An EFSP exports all mandatory functions  PAGEREF _Toc473103941 \h  6.1.2.2 Test Case   A Virtual EFSP exports the FaxDevEnumerateDevices API  PAGEREF _Toc473103942 \h  6.1.2.3 Test Case   An EFSP supporting logging exports the FaxDevGetLogData API  PAGEREF _Toc473103943 \h  6.1.2.4 Test Case   An EFSP supporting job context reestablishment exports the FaxDevReestablishJobContext API  PAGEREF _Toc473103944 \h  Invalid API Parameters  PAGEREF _Toc473103945 \h  6.2.1 FSP APIs   Invalid Out Parameters  PAGEREF _Toc473103946 \h  6.2.1.1 Test Case   FSP FaxDevInitialize correctly handles NULL out parameters  PAGEREF _Toc473103947 \h  6.2.1.2 Test Case   FSP FaxDevVirtualDeviceCreation correctly handles NULL out parameters  PAGEREF _Toc473103948 \h  6.2.1.3 Test Case   FSP FaxDevReportStatus correctly handles NULL out parameters  PAGEREF _Toc473103949 \h  6.2.2 FSP APIs   Invalid In Parameters  PAGEREF _Toc473103950 \h  6.2.2.1 Test Case   FSP FaxDevInitialize correctly handles NULL in parameters  PAGEREF _Toc473103951 \h  6.2.2.2 Test Case   FSP FaxDevVirtualDeviceCreation correctly handles NULL in parameters  PAGEREF _Toc473103952 \h  6.2.2.3 Test Case   FSP FaxDevSend correctly handles NULL in parameters  PAGEREF _Toc473103953 \h  6.2.2.4 Test Case   Non-Virtual FSP FaxDevSend correctly handles a NULL FaxSendCallback in parameter  PAGEREF _Toc473103954 \h  6.2.2.5 Test Case   FSP FaxDevSend correctly handles an invalid FaxSend.FileName in parameter  PAGEREF _Toc473103955 \h  6.2.2.6 Test Case   FSP FaxDevSend correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103956 \h  6.2.2.7 Test Case   FSP FaxDevReportStatus correctly handles NULL in parameters  PAGEREF _Toc473103957 \h  6.2.2.8 Test Case   FSP FaxDevReportStatus correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103958 \h  6.2.3 EFSP APIs   Invalid Out Parameters  PAGEREF _Toc473103959 \h  6.2.3.1 Test Case   EFSP FaxDevInitializeEx correctly handles NULL out parameters  PAGEREF _Toc473103960 \h  6.2.3.2 Test Case   Virtual EFSP FaxDevEnumerateDevices correctly handles NULL out parameters  PAGEREF _Toc473103961 \h  6.2.3.3 Test Case   EFSP FaxDevSendEx correctly handles NULL out parameters  PAGEREF _Toc473103962 \h  6.2.3.4 Test Case   FaxDevSendEx of an EFSP that supports job context reestablishment correctly handles NULL out parameters  PAGEREF _Toc473103963 \h  6.2.3.5 Test Case   FaxDevSendEx of an EFSP that supports job context reestablishment correctly handles a zero value in the FSPI_MESSAGE_ID.dwIdSize out parameter  PAGEREF _Toc473103964 \h  6.2.3.6 Test Case   EFSP FaxDevReportStatusEx correctly handles NULL out parameters  PAGEREF _Toc473103965 \h  6.2.3.7 Test Case   EFSP FaxDevGetLogData correctly handles NULL out parameters  PAGEREF _Toc473103966 \h  6.2.3.8 Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles NULL out parameters  PAGEREF _Toc473103967 \h  6.2.4 EFSP APIs   Invalid In Parameters  PAGEREF _Toc473103968 \h  6.2.4.1 Test Case   EFSP FaxDevInitializeEx correctly handles NULL in parameters  PAGEREF _Toc473103969 \h  6.2.4.2 Test Case   EFSP FaxDevSendEx correctly handles NULL in parameters  PAGEREF _Toc473103970 \h  6.2.4.3 Test Case   EFSP FaxDevSendEx correctly handles in parameters indicating non existent filenames  PAGEREF _Toc473103971 \h  6.2.4.4 Test Case   EFSP FaxDevSendEx correctly handles in parameters indicating invalid files  PAGEREF _Toc473103972 \h  6.2.4.5 Test Case   EFSP FaxDevSendEx correctly handles an invalid dwDeviceId in parameter  PAGEREF _Toc473103973 \h  6.2.4.6 Test Case   EFSP FaxDevSendEx correctly handles an invalid FSPI_COVERPAGE_INFO.dwCoverPageFormat in parameter  PAGEREF _Toc473103974 \h  6.2.4.7 Test Case   EFSP FaxDevReportStatusEx correctly handles NULL in parameters  PAGEREF _Toc473103975 \h  6.2.4.8 Test Case   EFSP FaxDevReportStatusEx correctly handles an invalid hJob in parameter  PAGEREF _Toc473103976 \h  6.2.4.9 Test Case   EFSP FaxDevGetLogData correctly handles NULL in parameters  PAGEREF _Toc473103977 \h  6.2.4.10 Test Case   EFSP FaxDevGetLogData correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103978 \h  6.2.4.11 Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles NULL in parameters  PAGEREF _Toc473103979 \h  6.2.4.12 Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles an invalid FSPI_MESSAGE_ID in parameter  PAGEREF _Toc473103980 \h  6.2.4.13 Test Case   FaxDevReestablishJobContext of a Non-Virtual EFSP that supports job context reestablishment correctly handles NULL in parameters  PAGEREF _Toc473103981 \h  6.2.4.14 Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles an invalid dwDeviceId in parameter  PAGEREF _Toc473103982 \h  6.2.5 Common APIs   Invalid Out Parameters  PAGEREF _Toc473103983 \h  6.2.5.1 Test Case   FaxDevStartJob correctly handles NULL out parameters  PAGEREF _Toc473103984 \h  6.2.5.2 Test Case   FaxDevReceive of an FSP or EFSP that supports T.Routing correctly handles NULL out parameters  PAGEREF _Toc473103985 \h  6.2.6 Common APIs   Invalid In Parameters  PAGEREF _Toc473103986 \h  6.2.6.1 Test Case  FaxDevStartJob correctly handles NULL in parameters  PAGEREF _Toc473103987 \h  6.2.6.2 Test Case   FaxDevEndJob correctly handles NULL in parameters  PAGEREF _Toc473103988 \h  6.2.6.3 Test Case   FaxDevEndJob correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103989 \h  6.2.6.4 Test Case   FaxDevReceive correctly handles NULL in parameters  PAGEREF _Toc473103990 \h  6.2.6.5 Test Case   FaxDevReceive of a Non-Virtual FSP or Non-Virtual EFSP correctly handles NULL in parameters  PAGEREF _Toc473103991 \h  6.2.6.6 Test Case   FaxDevReceive correctly handles a FaxReceive.FileName in parameter indicating a non-existent filename  PAGEREF _Toc473103992 \h  6.2.6.7 Test Case   FaxDevReceive correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103993 \h  6.2.6.8 Test Case   FaxDevAbortOperation correctly handles NULL in parameters  PAGEREF _Toc473103994 \h  6.2.6.9 Test Case   FaxDevAbortOperation correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103995 \h  6.2.6.10 Test Case   LineCallbackFunction of a Non-Virtual FSP or EFSP correctly handles NULL in parameters  PAGEREF _Toc473103996 \h  6.2.6.11 Test Case   LineCallbackFunction of a Non-Virtual FSP or EFSP correctly handles an invalid FaxHandle in parameter  PAGEREF _Toc473103997 \h  6.2.6.12 Test Case   LineCallbackFunction of a Non-Virtual FSP or EFSP correctly handles an invalid dwMessage in parameter  PAGEREF _Toc473103998 \h  6.2.6.13 Test Case   FaxExtInitializeConfig of an FSP or EFSP correctly handles NULL in parameters  PAGEREF _Toc473103999 \h  Valid API Parameters  PAGEREF _Toc473104000 \h  6.3.1 FSP APIs   Valid Parameters  PAGEREF _Toc473104001 \h  6.3.1.1 Test case   FSP FaxDevInitialize correctly sets out parameters  PAGEREF _Toc473104002 \h  6.3.1.2 Test case   Virtual FSP FaxDevVirtualDeviceCreation correctly sets out parameters  PAGEREF _Toc473104003 \h  6.3.1.3 Test Case   FSP FaxDevReportStatus correctly sets out parameters  PAGEREF _Toc473104004 \h  6.3.2 EFSP APIs   Valid Parameters  PAGEREF _Toc473104005 \h  6.3.2.1 Test Case   EFSP FaxDevInitializeEx correctly sets out parameters  PAGEREF _Toc473104006 \h  6.3.2.2 Test Case   EFSP FaxDevSendEx correctly sets out parameters  PAGEREF _Toc473104007 \h  6.3.2.3 Test Case   EFSP FaxDevSendEx correctly handles FAT and NTFS files  PAGEREF _Toc473104008 \h  6.3.2.4 Test Case   EFSP FaxDevReportStatusEx correctly sets out parameters  PAGEREF _Toc473104009 \h  6.3.2.5 Test Case   Virtual EFSP FaxDevEnumerateDevices correctly sets out parameters  PAGEREF _Toc473104010 \h  6.3.2.6 Test Case   EFSP FaxDevGetLogData correctly sets out parameters  PAGEREF _Toc473104011 \h  6.3.3 Common APIs   Valid Parameters  PAGEREF _Toc473104012 \h  6.3.3.1 Test Case   FaxDevStartJob correctly sets out parameters  PAGEREF _Toc473104013 \h  6.3.3.2 Test Case   FaxDevReceive correctly sets out parameters  PAGEREF _Toc473104014 \h  6.3.3.3 Test Case   FaxDevReceive correctly handles FAT and NTFS files  PAGEREF _Toc473104015 \h  Service Callbacks  PAGEREF _Toc473104016 \h  6.4.1 FSP properly invokes Service Callbacks  PAGEREF _Toc473104017 \h  6.4.1.1 Test Case   FSP never invokes FaxServiceCallback  PAGEREF _Toc473104018 \h  6.4.1.2 Test Case   FaxDevSend of Non-Virtual FSP correctly invokes FaxSendCallback  PAGEREF _Toc473104019 \h  6.4.1.3 Test Case   FaxDevSend of Non-Virtual FSP correctly behaves according to return value of FaxSendCallback  PAGEREF _Toc473104020 \h  6.4.2 EFSP properly invokes Service Callbacks  PAGEREF _Toc473104021 \h  6.4.2.1 Test Case   EFSP FaxDevSendEx correctly invokes FaxServiceCallbackEx  PAGEREF _Toc473104022 \h  6.4.2.2 Test Case   EFSP FaxDevSendEx correctly handles return values of  FaxServiceCallbackEx  PAGEREF _Toc473104023 \h  6.4.2.3 Test Case   EFSP FaxDevReceive correctly invokes FaxServiceCallbackEx  PAGEREF _Toc473104024 \h  6.4.2.4 Test Case   EFSP FaxDevReceive correctly handles return values of  FaxServiceCallbackEx  PAGEREF _Toc473104025 \h  6.4.3 FSP \ EFSP properly invoke FaxExt Service Callbacks  PAGEREF _Toc473104026 \h  6.4.3.1 Test Case   return values of FaxExtGetExtensionData are handled correctly  PAGEREF _Toc473104027 \h  6.4.3.2 Test Case   return values of FaxExtSetExtensionData are handled correctly  PAGEREF _Toc473104028 \h  6.4.3.3 Test Case   return values of FaxExtRegisterForExtensionEvents are handled correctly  PAGEREF _Toc473104029 \h  6.4.3.4 Test Case   return values of FaxExtUnregisterForExtensionEvents are handled correctly  PAGEREF _Toc473104030 \h  EFSP Implementation According to Capabilities  PAGEREF _Toc473104031 \h  6.5.1 Broadcast  PAGEREF _Toc473104032 \h  6.5.1.1 Test Case   FaxDevSendEx of an EFSP that supports FSPI_CAP_BROADCAST correctly handles a multi-recipient broadcast job.  PAGEREF _Toc473104033 \h  6.5.1.2 Test Case   FaxDevSendEx of an EFSP that does not support FSPI_CAP_BROADCAST correctly fails a multi-recipient broadcast job.  PAGEREF _Toc473104034 \h  6.5.1.3 Test Case   EFSP FaxDevReportStatusEx correctly handles parent job handle.  PAGEREF _Toc473104035 \h  6.5.1.4 Test Case   EFSP FaxDevGetLogData correctly handles parent job handle.  PAGEREF _Toc473104036 \h  6.5.2 Multi-Send  PAGEREF _Toc473104037 \h  6.5.2.1 Test Case   FaxDevSendEx of an EFSP that supports FSPI_CAP_MULTISEND correctly handles concurrent send jobs.  PAGEREF _Toc473104038 \h  6.5.2.2 Test Case   FaxDevSendEx of an EFSP that does not support FSPI_CAP_MULTISEND correctly handles concurrent send jobs.  PAGEREF _Toc473104039 \h  6.5.3 Scheduling  PAGEREF _Toc473104040 \h  6.5.4 Abort  PAGEREF _Toc473104041 \h  6.5.4.1 Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_RECIPIENT correctly handles a valid recipient job hFaxHandle.  PAGEREF _Toc473104042 \h  6.5.4.2 Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_RECIPIENT correctly handles a valid recipient job hFaxHandle already in FSPI_JS_ABORTING status.  PAGEREF _Toc473104043 \h  6.5.4.3 Test Case   FaxDevAbortOperation of an EFSP that does not support FSPI_CAP_ABORT_RECIPIENT correctly handles a valid recipient job hFaxHandle.  PAGEREF _Toc473104044 \h  6.5.4.4 Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_PARENT correctly handles a valid parent job hFaxHandle.  PAGEREF _Toc473104045 \h  6.5.4.5 Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_PARENT correctly handles a valid parent job hFaxHandle already in FSPI_JS_ABORTING status.  PAGEREF _Toc473104046 \h  6.5.4.6 Test Case   FaxDevAbortOperation of an EFSP that does not support FSPI_CAP_ABORT_PARENT correctly handles a valid parent job hFaxHandle.  PAGEREF _Toc473104047 \h  6.5.5 Auto-Retry  PAGEREF _Toc473104048 \h  6.5.5.1 Test Case   FaxDevSendEx of an EFSP that supports FSPI_CAP_AUTO_RETRY correctly retries a recipient job.  PAGEREF _Toc473104049 \h  6.5.6 Job Context Reestablishment  PAGEREF _Toc473104050 \h  6.5.6.1 Test Case   FaxDevInitializeEx of an EFSP that supports job context reestablishment correctly sets the lpdwMaxMessageIdSize out parameter  PAGEREF _Toc473104051 \h  6.5.6.2 Test Case   FaxDevInitializeEx of an EFSP that does not support job context reestablishment correctly sets the lpdwMaxMessageIdSize out parameter  PAGEREF _Toc473104052 \h  6.5.6.3 Test Case   FaxDevSendEx of an EFSP that supports job context reestablishment correctly sets message id out parameters  PAGEREF _Toc473104053 \h  6.5.6.4 Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly sets out parameters  PAGEREF _Toc473104054 \h  6.5.7 Branding  PAGEREF _Toc473104055 \h  6.5.7.1 Test Case   FaxDevSendEx of an EFSP that supports branding correctlly renders the fax  PAGEREF _Toc473104056 \h  6.5.7.2 Test Case   FaxDevSendEx of an EFSP that does not support branding correctlly renders the fax  PAGEREF _Toc473104057 \h  API Sequence  PAGEREF _Toc473104058 \h  6.6.1 EFSP Initialization Sequence  PAGEREF _Toc473104059 \h  6.6.1.1 Test case   FaxDevEnumerateDevices may be invoked again any time after a successful initialization sequence  PAGEREF _Toc473104060 \h  6.6.2 Send \ Receive Sequence (FSP and EFSP)  PAGEREF _Toc473104061 \h  6.6.2.1 Test case   FaxDevEndJob of job in non-final state should succeed.  PAGEREF _Toc473104062 \h  6.6.2.2 Test case   FaxDevAbortOperation of job in final state should fail.  PAGEREF _Toc473104063 \h  API Concurrency  PAGEREF _Toc473104064 \h  6.7.1 Common APIs  PAGEREF _Toc473104065 \h  6.7.1.1 Test case   concurrent calls to FaxDevAbortOperation with same job handle, all calls should succeed.  PAGEREF _Toc473104066 \h  6.7.1.2 Test case   call to FaxDevAbortOperation before FaxDevReceive of same job handle starts execution, should succeed.  PAGEREF _Toc473104067 \h  6.7.1.3 Test case   call to FaxDevAbortOperation while FaxDevReceive of same job handle is executing should succeed.  PAGEREF _Toc473104068 \h  6.7.1.4 Test case   call to FaxDevAbortOperation while FaxDevEndJob of same job handle is executing should fail.  PAGEREF _Toc473104069 \h  6.7.1.5 Test case   concurrent calls to FaxDevStartJob on different devices, all calls should succeed.  PAGEREF _Toc473104070 \h  6.7.1.6 Test case   concurrent calls to FaxDevReceive with different job handles on different devices, all calls should succeed.  PAGEREF _Toc473104071 \h  6.7.1.7 Test case   concurrent calls to FaxDevEndJob with different job handles, all calls should succeed.  PAGEREF _Toc473104072 \h  6.7.1.8 Test case   For a Virtual FSP or Virtual EFSP, concurrent calls to LineCallbackFunction should succeed.  PAGEREF _Toc473104073 \h  6.7.2 FSP APIs  PAGEREF _Toc473104074 \h  6.7.2.1 Test case   concurrent calls to FaxDevSend with different job handles on different devices, all calls should succeed.  PAGEREF _Toc473104075 \h  6.7.2.2 Test case   concurrent calls to FaxDevReportStatus with different job handles, all calls should succeed.  PAGEREF _Toc473104076 \h  6.7.2.3 Test case   concurrent calls to FaxDevReportStatus with same job handle, all calls should succeed.  PAGEREF _Toc473104077 \h  6.7.3 EFSP APIs  PAGEREF _Toc473104078 \h  6.7.3.1 Test case   concurrent calls to FaxDevSendEx on different devices, all calls should succeed.  PAGEREF _Toc473104079 \h  6.7.3.2 Test case   on EFSP that supports FSPI_CAP_MULTISEND, all concurrent calls to FaxDevSendEx on same device should succeed.  PAGEREF _Toc473104080 \h  6.7.3.3 Test case   concurrent calls to FaxDevReportStatusEx with different job handles, all calls should succeed.  PAGEREF _Toc473104081 \h  6.7.3.4 Test case   concurrent calls to FaxDevReportStatusEx with same job handle, all calls should succeed.  PAGEREF _Toc473104082 \h  6.7.3.5 Test case   concurrent calls to FaxDevReestablishJobContext with different message ids, all calls should succeed.  PAGEREF _Toc473104083 \h  6.7.3.6 Test case   concurrent calls to FaxDevGetLogData, all calls should succeed.  PAGEREF _Toc473104084 \h  6.7.3.7 Test case   shutdown while FaxDevStartJob is executing should succeed.  PAGEREF _Toc473104085 \h  6.7.3.8 Test case   shutdown while FaxDevReceive is executing should succeed.  PAGEREF _Toc473104086 \h  6.7.3.9 Test case   shutdown while FaxDevEndJob is executing should succeed.  PAGEREF _Toc473104087 \h  6.7.3.10 Test case   shutdown while FaxDevReportStatusEx is executing should succeed.  PAGEREF _Toc473104088 \h  6.7.3.11 Test case   shutdown while FaxDevSendEx is executing should succeed.  PAGEREF _Toc473104089 \h  6.7.3.12 Test case   shutdown while FaxDevReestablishJobContext is executing should succeed.  PAGEREF _Toc473104090 \h  6.7.3.13 Test case   shutdown while FaxDevGetLogData is executing should succeed.  PAGEREF _Toc473104091 \h  6.7.3.14 Test case   shutdown while FaxDevInitializeEx is executing should succeed.  PAGEREF _Toc473104092 \h  6.7.3.15 Test case   shutdown while FaxDevEnumerateDevices is executing should succeed.  PAGEREF _Toc473104093 \h  Low Memory Conditions  PAGEREF _Toc473104094 \h  6.8.1 FSP APIs function in Low Memory Conditions  PAGEREF _Toc473104095 \h  6.8.1.1 Test case   FSP FaxDevInitalize functions correctly in low memory conditions  PAGEREF _Toc473104096 \h  6.8.1.2 Test case   Virtual-FSP FaxDevVirtualDeviceCreation functions correctly in low memory conditions  PAGEREF _Toc473104097 \h  6.8.1.3 Test case   FSP FaxDevSend functions correctly in low memory conditions  PAGEREF _Toc473104098 \h  6.8.1.4 Test case   FSP FaxDevReportStatus functions correctly in low memory conditions  PAGEREF _Toc473104099 \h  6.8.2 EFSP APIs function in Low Memory Conditions  PAGEREF _Toc473104100 \h  6.8.2.1 Test case   EFSP FaxDevInitalizeEx functions correctly in low memory conditions  PAGEREF _Toc473104101 \h  6.8.2.2 Test case   Virtual EFSP FaxDevEnumerateDevices functions correctly in low memory conditions  PAGEREF _Toc473104102 \h  6.8.2.3 Test case   EFSP FaxDevSendEx functions correctly in low memory conditions  PAGEREF _Toc473104103 \h  6.8.2.4 Test case   EFSP FaxDevReportStatusEx functions correctly in low memory conditions  PAGEREF _Toc473104104 \h  6.8.2.5 Test case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment, functions correctly in low memory conditions  PAGEREF _Toc473104105 \h  6.8.2.6 Test case   EFSP FaxDevGetLogData functions correctly in low memory conditions  PAGEREF _Toc473104106 \h  6.8.3 Common APIs function in Low Memory Conditions  PAGEREF _Toc473104107 \h  6.8.3.1 Test case   FSP FaxDevStartJob functions correctly in low memory conditions  PAGEREF _Toc473104108 \h  6.8.3.2 Test case    FaxDevEndJob functions correctly in low memory conditions  PAGEREF _Toc473104109 \h  6.8.3.3 Test case   FSP FaxDevAbortOperation functions correctly in low memory conditions  PAGEREF _Toc473104110 \h  6.8.3.4 Test case   FaxDevReceive functions correctly in low memory conditions  PAGEREF _Toc473104111 \h  6.8.3.5 Test case   FaxExtInitializeConfig functions correctly in low memory conditions  PAGEREF _Toc473104112 \h  6.8.3.6 Test case   FaxExtConfigChange functions correctly in low memory conditions  PAGEREF _Toc473104113 \h  Driver Verifier  PAGEREF _Toc473104114 \h  6.9.1 Third Party Drivers Integrity  PAGEREF _Toc473104115 \h  6.9.2 Handling Third Party and System Drivers Failures  PAGEREF _Toc473104116 \h  Integration Tests  PAGEREF _Toc473104117 \h  Setup and Configuration  PAGEREF _Toc473104118 \h  7.1.1 Setup  PAGEREF _Toc473104119 \h  7.1.1.1 Test case   FSP / EFSP setup on server machine fails if service is down  PAGEREF _Toc473104120 \h  7.1.1.2 Test case   FSP / EFSP is successfully setup on server machine while service is up  PAGEREF _Toc473104121 \h  7.1.1.3 Test case   FSP / EFSP is successfully uninstalled from server machine while service is down  PAGEREF _Toc473104122 \h  7.1.1.4 Test case   FSP / EFSP cannot be uninstalled from server machine while service is up  PAGEREF _Toc473104123 \h  7.1.2 Configuration  PAGEREF _Toc473104124 \h  7.1.2.1 Test case   FSP / EFSP is successfully configured via the local Comet Fax Service Admin Console  PAGEREF _Toc473104125 \h  7.1.2.2 Test case   FSP / EFSP is successfully configured via a remote Comet Fax Service Admin Console  PAGEREF _Toc473104126 \h  Initialization  PAGEREF _Toc473104127 \h  7.2.1 FSP Initialization  PAGEREF _Toc473104128 \h  7.2.1.1 Test case   FSP is successfully loaded and initialized when there are no modems installed on server machine  PAGEREF _Toc473104129 \h  7.2.1.2 Test case   FSP is successfully loaded and initialized when there are modems installed on server machine  PAGEREF _Toc473104130 \h  7.2.2 EFSP Initialization  PAGEREF _Toc473104131 \h  7.2.2.1 Test case   EFSP is successfully loaded and initialized when there are no modems installed on server machine  PAGEREF _Toc473104132 \h  7.2.2.2 Test case   EFSP is successfully loaded and initialized when there are modems installed on server machine  PAGEREF _Toc473104133 \h  Sending  PAGEREF _Toc473104134 \h  7.3.1 Fax Pages  PAGEREF _Toc473104135 \h  7.3.1.1 Test case   Single Page Fax without a cover page is successfully sent  PAGEREF _Toc473104136 \h  7.3.1.2 Test case   Single Page Fax with a cover page is successfully sent  PAGEREF _Toc473104137 \h  7.3.1.3 Test case   A Cover page fax is successfully sent  PAGEREF _Toc473104138 \h  7.3.1.4 Test case   A multiple page fax without a cover page is successfully sent  PAGEREF _Toc473104139 \h  7.3.1.5 Test case   A multiple page fax with a cover page is successfully sent  PAGEREF _Toc473104140 \h  7.3.2 Fax Session  PAGEREF _Toc473104141 \h  7.3.2.1 Test case   Sending a fax to a busy line  PAGEREF _Toc473104142 \h  7.3.2.2 Test case   Sending a fax to a no-answer line  PAGEREF _Toc473104143 \h  7.3.2.3 Test case   Sending a fax to a line that will disconnect in the middle of the fax session  PAGEREF _Toc473104144 \h  7.3.2.4 Test case   Sending a fax to a non-fax line that will answer and disconnect  PAGEREF _Toc473104145 \h  7.3.2.5 Test case   Sending a fax when there is no dial tone  PAGEREF _Toc473104146 \h  7.3.3 Concurrency  PAGEREF _Toc473104147 \h  7.3.3.1 Test case   Send faxes concurrently on all FSP s or EFSP s devices  PAGEREF _Toc473104148 \h  7.3.3.2 Test case   Send faxes concurrently using a single EFSP device that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104149 \h  7.3.3.3 Test case   Send a fax on an already receiving device of an EFSP that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104150 \h  Receiving  PAGEREF _Toc473104151 \h  7.4.1 Fax Pages  PAGEREF _Toc473104152 \h  7.4.1.1 Test case   Single Page Fax is successfully received  PAGEREF _Toc473104153 \h  7.4.1.2 Test case   A multiple page fax is successfully received  PAGEREF _Toc473104154 \h  7.4.2 Fax Session  PAGEREF _Toc473104155 \h  7.4.2.1 Test case   Receiving a fax from a line that will disconnect before the first page is received  PAGEREF _Toc473104156 \h  7.4.2.2 Test case   Receiving a fax from a line that will disconnect after the first page is received  PAGEREF _Toc473104157 \h  7.4.2.3 Test case   Receiving a non-fax call  PAGEREF _Toc473104158 \h  7.4.3 Concurrency  PAGEREF _Toc473104159 \h  7.4.3.1 Test case   Receive faxes concurrently on all FSP s or EFSP s devices  PAGEREF _Toc473104160 \h  7.4.3.2 Test case   Receive faxes concurrently using a single EFSP device that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104161 \h  7.4.3.3 Test case   Receive a fax on an already sending device of an EFSP that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104162 \h  Aborting  PAGEREF _Toc473104163 \h  7.5.1 Fax Pages  PAGEREF _Toc473104164 \h  7.5.1.1 Test case   Aborting an inbound fax before the first page is received  PAGEREF _Toc473104165 \h  7.5.1.2 Test case   Aborting an inbound fax after the first page is received  PAGEREF _Toc473104166 \h  7.5.1.3 Test case   Aborting an inbound fax after the 45th page is received  PAGEREF _Toc473104167 \h  7.5.1.4 Test case   Aborting an inbound fax after N milliseconds  PAGEREF _Toc473104168 \h  7.5.1.5 Test case   Aborting an outbound fax before the first page is sent  PAGEREF _Toc473104169 \h  7.5.1.6 Test case   Aborting an outbound fax after the first page is sent  PAGEREF _Toc473104170 \h  7.5.1.7 Test case   Aborting an outbound fax after the 45th page is sent  PAGEREF _Toc473104171 \h  7.5.1.8 Test case   Aborting an outbound fax after N milliseconds  PAGEREF _Toc473104172 \h  7.5.2 Concurrency  PAGEREF _Toc473104173 \h  7.5.2.1 Test case   Abort multiple inbound jobs simultaneously on all FSP s or EFSP s devices  PAGEREF _Toc473104174 \h  7.5.2.2 Test case   Abort multiple inbound jobs simultaneously on a single EFSP device that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104175 \h  7.5.2.3 Test case   Abort an inbound job on a sending and receiving device of  an EFSP that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104176 \h  7.5.2.4 Test case   Abort multiple outbound jobs simultaneously on all FSP s or EFSP s devices  PAGEREF _Toc473104177 \h  7.5.2.5 Test case   Abort multiple outbound jobs simultaneously on a single EFSP device that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104178 \h  7.5.2.6 Test case   Abort an inbound job on a sending and receiving device of  an EFSP that supports FSPI_CAP_MULTISEND  PAGEREF _Toc473104179 \h  Cover Pages  PAGEREF _Toc473104180 \h  7.6.1 Default Server Cover Pages  PAGEREF _Toc473104181 \h  7.6.1.1 Test case   Server Cover Page CONFDENT.COV is successfully sent  PAGEREF _Toc473104182 \h  7.6.1.2 Test case   Server Cover Page FYI.COV is successfully sent  PAGEREF _Toc473104183 \h  7.6.1.3 Test case   Server Cover Page GENERIC.COV is successfully sent  PAGEREF _Toc473104184 \h  7.6.1.4 Test case   Server Cover Page URGENT.COV is successfully sent  PAGEREF _Toc473104185 \h  7.6.2 Personal Cover Pages  PAGEREF _Toc473104186 \h  7.6.2.1 Test case   Personal Cover Page containing all fields is successfully sent  PAGEREF _Toc473104187 \h  7.6.2.2 Test case   Personal Cover Page containing no fields is successfully sent  PAGEREF _Toc473104188 \h  7.6.2.3 Test case   Personal Cover Page containing only a subject is successfully sent  PAGEREF _Toc473104189 \h  7.6.2.4 Test case   Personal Cover Page containing only a note is successfully sent  PAGEREF _Toc473104190 \h  Shutdown  PAGEREF _Toc473104191 \h  7.7.1 Common  PAGEREF _Toc473104192 \h  7.7.1.1 Test case   FSP\EFSP successfully shutsdown while device is sending  PAGEREF _Toc473104193 \h  7.7.1.2 Test case   FSP\EFSP successfully shutsdown while device is receiving  PAGEREF _Toc473104194 \h  7.7.1.3 Test case   FSP\EFSP successfully shutsdown while aborting an outbound job  PAGEREF _Toc473104195 \h  7.7.1.4 Test case   FSP\EFSP successfully shutsdown while aborting an inbound job  PAGEREF _Toc473104196 \h  7.7.1.5 Test case   FSP\EFSP successfully shutsdown while starting a job (FaxDevStartJob)  PAGEREF _Toc473104197 \h  7.7.1.6 Test case   FSP\EFSP successfully shutsdown while ending a job (FaxDevEndJob)  PAGEREF _Toc473104198 \h  7.7.2  PAGEREF _Toc473104199 \h  7.7.2.1 Test case   EFSP successfully shutsdown while reporting status (FaxDevReportStatusEx)  PAGEREF _Toc473104200 \h  7.7.2.2 Test case   EFSP that supports job context reestablishment successfully shutsdown while reestablishing job context (FaxDevReestablishJobContext)  PAGEREF _Toc473104201 \h  7.7.2.3 Test case   EFSP successfully shutsdown while enumerating devices (FaxDevEnumerateDevices)  PAGEREF _Toc473104202 \h  7.7.2.4 Test case   EFSP successfully shutsdown while initializing (FaxDevInitializeEx)  PAGEREF _Toc473104203 \h  7.7.2.5 Test case   EFSP successfully shutsdown while getting log data (FaxDevGetLogData)  PAGEREF _Toc473104204 \h  7.7.3  PAGEREF _Toc473104205 \h  7.7.3.1 Test case   FSP successfully shutsdown while reporting status (FaxDevReportStatus)  PAGEREF _Toc473104206 \h  Stress  PAGEREF _Toc473104207 \h  7.8.1.1 Test case   Many sends receives and aborts on all FSP\EFSP devices simultaneously  PAGEREF _Toc473104208 \h  Specific Tests  PAGEREF _Toc473104209 \h  Implementation of the T30 Protocol  PAGEREF _Toc473104210 \h  Implementation using a Network  PAGEREF _Toc473104211 \h  Implementation delegating work to another Server  PAGEREF _Toc473104212 \h  Test Tools  PAGEREF _Toc473104213 \h  FSP Tester  PAGEREF _Toc473104214 \h  EFSP Tester  PAGEREF _Toc473104215 \h  Hogger  PAGEREF _Toc473104216 \h  Driver Verifier  PAGEREF _Toc473104217 \h  SendBroadcastFax  PAGEREF _Toc473104218 \h  Abort Tool  PAGEREF _Toc473104219 \h  Cover Pages Arsenal  PAGEREF _Toc473104220 \h  Scope This document describes the tests that Extended Fax Service Provider (EFSP) components must undergo in order to assure sufficient quality and proper integration with the Microsoft  Windows NT  Fax Service.  Microsoft  strongly urges any party implementing an Extended Fax Service Provider to carry out each and every one of the tests detailed in this document, and verify that the EFSP behaves as expected. Any deviance from the expected EFSP behavior described in this document should be considered a bug and appropriate measures should be taken to fix the EFSP code. Revision Information Revision Author Description 23-Jan-2000 Sigalit Bar Initial version References Comet Fax Server   Extended Fax Service Provider Interface (Version 0.8 Microsoft Corporation) The Extended Fax SDK NT 5.0 Fax SDK Documentation Microsoft Fax Cover Page Template File Format (Version 2.0 Microsoft Corporation) Overview The Fax Service Provider API was first published in the NT 5.0 Fax SDK to allow 3rd parties to integrate fax devices and Fax Services to the Microsoft  Windows NT  Fax Service. The EFSPI is an extended version of this API that was designed to better support Fax over IP services and efficient fax broadcasting. This document first gives an overview of the test objectives and the strategy used to achieve these objectives, describing the three categories of tests that will be applied for testing an Extended Fax Service Provider. The document then goes into every test category detailing the test areas that it covers, specifying all the tests that should be carried out and the expected Extended Fax Service Provider behavior for each test. Lastly this document lists test tools that Microsoft  has made available for 3rd party Extended Fax Service Provider developers to aid them in carrying out these tests. This document is intended to be read by application programmers that are familiar with fax technologies, the NT 5.0 Fax Service Provider Interface and the Comet Fax Extended Fax Service Provider Interface. Test Objectives and Strategy The tests described in this document are designed to assure that an Extended Fax Service Provider component is of sufficient quality and is properly integrated with the Microsoft  Windows NT  Fax Service.  The tests are aimed at three major objectives: Testing correct implementation of the required Extended Fax Service Provider APIs (parameters, error values, etc.) Testing correct behavior of an Extended Fax Service Provider under Microsoft  Windows NT  Fax Service user scenarios (such as sending, receiving, aborting, broadcast, multi-send, etc.) Testing specific Extended Fax Service Provider implementations (such as over a network, using telephony devices, using device boards, etc.) This document divides the tests into three categories - Component tests, Integration tests and Specific tests; each category corresponds to one of the objectives accordingly. Component Tests The following Component Tests invoke the APIs outside of the Microsoft  Windows NT  Fax Service context. The tests look at the Fax Service Provider or Extended Fax Service Provider as an independent component that exports the FSPI or EFSPI, verifying that the Fax Service Provider or Extended Fax Service Provider DLL has implemented the functionality of the API as specified by the FSPI and EFSPI documentation. Exported Functions The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL exports a valid set of functions. Section 6.2.1 lays out the tests for a Fax Service Provider, while section 6.2.2 does so for an Extended Fax Service Provider. FSP Exported Functions  Test Case   An FSP exports all mandatory functions This test case verifies that a Fax Service Provider DLL has exported all the mandatory  (non-optional) functions. Scenario  Verify that the DLL is successfully loaded by a call to the Win32 API LoadLibrary, and that the handle returned from the call (marked hLib) does not equal NULL. Use the handle hLib to get a pointer to the FSP s FaxDevInitialize function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevInitialize ) returns a non-NULL pointer of type PFAXDEVINITIALIZE. Use the handle hLib to get a pointer to the FSP s FaxDevStartJob function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevStartJob ) returns a non-NULL pointer of type PFAXDEVSTARTJOB. Use the handle hLib to get a pointer to the FSP s FaxDevEndJob function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevEndJob ) returns a non-NULL pointer of type PFAXDEVENDJOB. Use the handle hLib to get a pointer to the FSP s FaxDevSend function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevSend ) returns a non-NULL pointer of type PFAXDEVSEND. Use the handle hLib to get a pointer to the FSP s FaxDevReceive function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevReceive ) returns a non-NULL pointer of type PFAXDEVRECEIVE. Use the handle hLib to get a pointer to the FSP s FaxDevReportStatus function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevReportStatus ) returns a non-NULL pointer of type PFAXDEVREPORTSTATUS. Use the handle hLib to get a pointer to the FSP s FaxDevAbortOperation function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevAbortOperation ) returns a non-NULL pointer of type PFAXDEVABORTOPERATION. Test Case   A Virtual FSP exports the FaxDevVirtualDeviceCreation API This test case verifies that a Virtual Fax Service Provider DLL exports the FaxDevVirtualDeviceCreation API. Scenario  Verify that the DLL is successfully loaded by a call to the Win32 API LoadLibrary, and that the handle returned from the call (marked hLib) does not equal NULL. Use the handle hLib to get a pointer to the FSP s FaxDevVirtualDeviceCreation function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevVirtualDeviceCreation ) returns a non-NULL pointer of type PFAXDEVVIRTUALDEVICECREATION. Note that a Virtual FSP must also export all the mandatory APIs (as tested in 6.2.1.1). Test Case   An FSP supporting device configuration exports the FaxDevConfigure API This test case verifies that a Fax Service Provider DLL that supports device configuration exports the FaxDevConfigure API. Scenario  Verify that the DLL is successfully loaded by a call to the Win32 API LoadLibrary, and that the handle returned from the call (marked hLib) does not equal NULL. Use the handle hLib to get a pointer to the FSP s FaxDevConfigure function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevConfigure ) returns a non-NULL pointer of type PFAXDEVCONFIGURE. Note that an FSP that supports device configuration must also export all the mandatory APIs (as tested in 6.2.1.1). EFSP Exported Functions  Test Case   An EFSP exports all mandatory functions This test case verifies that an Extended Fax Service Provider DLL has exported all the mandatory  (non-optional) functions. Scenario  Verify that the DLL is successfully loaded by a call to the Win32 API LoadLibrary, and that the handle returned from the call (marked hLib) does not equal NULL. Use the handle hLib to get a pointer to the EFSP s FaxDevInitializeEx function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevInitializeEx ) returns a non-NULL pointer of type PFAXDEVINITIALIZEEX. Use the handle hLib to get a pointer to the FSP s FaxDevStartJob function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevStartJob ) returns a non-NULL pointer of type PFAXDEVSTARTJOB. Use the handle hLib to get a pointer to the FSP s FaxDevEndJob function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevEndJob ) returns a non-NULL pointer of type PFAXDEVENDJOB. Use the handle hLib to get a pointer to the FSP s FaxDevSendEx function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevSendEx ) returns a non-NULL pointer of type PFAXDEVSENDEX. Use the handle hLib to get a pointer to the FSP s FaxDevReceive function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevReceive ) returns a non-NULL pointer of type PFAXDEVRECEIVE. Use the handle hLib to get a pointer to the FSP s FaxDevReportStatusEx function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevReportStatusEx ) returns a non-NULL pointer of type PFAXDEVREPORTSTATUSEX. Use the handle hLib to get a pointer to the FSP s FaxDevAbortOperation function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevAbortOperation ) returns a non-NULL pointer of type PFAXDEVABORTOPERATION. Use the handle hLib to get a pointer to the FSP s FaxDevShutdown function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevShutdown ) returns a non-NULL pointer of type PFAXDEVSHUTDOWN. Test Case   A Virtual EFSP exports the FaxDevEnumerateDevices API This test case verifies that a Virtual Extended Fax Service Provider DLL exports the FaxDevEnumerateDevices API. Scenario  Verify that the DLL is successfully loaded by a call to the Win32 API LoadLibrary, and that the handle returned from the call (marked hLib) does not equal NULL. Use the handle hLib to get a pointer to the FSP s FaxDevEnumerateDevices function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevEnumerateDevices ) returns a non-NULL pointer of type PFAXDEVENUMERATEDEVICES. Note that a Virtual EFSP must also export all the mandatory APIs (as tested in 6.2.2.1). Test Case   An EFSP supporting logging exports the FaxDevGetLogData API [TBD] FaxDevGetLogData is not supported in this release. Test Case   An EFSP supporting job context reestablishment exports the FaxDevReestablishJobContext API This test case verifies that a Fax Service Provider DLL that supports device configuration exports the FaxDevReestablishJobContext API. Scenario  Verify that the DLL is successfully loaded by a call to the Win32 API LoadLibrary, and that the handle returned from the call (marked hLib) does not equal NULL. Use the handle hLib to get a pointer to the FSP s FaxDevReestablishJobContext function. That is, verify that a call to the Win32 API GetProcAddress(hLib,  FaxDevReestablishJobContext ) returns a non-NULL pointer of type PFAXDEVREESTABLISHJOBCONTEXT. Note that an EFSP that supports job context reestablishment must also export all the mandatory APIs (as tested in 6.2.2.1). Invalid API Parameters The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL implementation of the required APIs correctly handles invalid parameters. Sections   REF _Ref465677689 \w \h  6.2.1  and   REF _Ref465677715 \w \h  6.2.2  lay out the tests for a Fax Service Provider, sections   REF _Ref465677753 \w \h  6.2.3  and   REF _Ref465677762 \w \h  6.2.4  do so for an Extended Fax Service Provider, and sections   REF _Ref465677846 \w \h  6.2.5  and   REF _Ref465677820 \w \h  6.2.6  deal with APIs common to both Fax Service Providers and Extended Fax Service Providers. FSP APIs   Invalid Out Parameters  Test Case   FSP FaxDevInitialize correctly handles NULL out parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevInitialize to fail, returning FALSE when invoked with NULL out parameters. Scenario  Invoke the Fax Service Provider s FaxDevInitialize with the LineCallbackFunction out parameter set to NULL, as follows: BOOL fRetVal = FaxDevInitialize( LineAppHandle, HeapHandle, NULL, FaxServiceCallback ); Where, LineAppHandle is a handle to the fax service's registration with TAPI, HeapHandle is a valid heap handle, and FaxServiceCallback is a pointer of type PFAX_SERVICE_CALLBACK pointing to an existent function of that type. Verify that FaxDevInitialize sets the above fRetVal to FALSE. Test Case   FSP FaxDevVirtualDeviceCreation correctly handles NULL out parameters This test case verifies that a Virtual Fax Service Provider DLL has implemented FaxDevVirtualDeviceCreation to fail, returning FALSE when invoked with NULL out parameters. Scenario  Invoke the Virtual Fax Service Provider s FaxDevVirtualDeviceCreation with the DeviceCount out parameter set to NULL, as follows: BOOL fRetVal1 = FaxDevVirtualDeviceCreation( NULL, DeviceNamePrefix, DeviceIdPrefix, CompletionPort, CompletionKey ); Where, DeviceNamePrefix is a valid (non-NULL) pointer to a WSTR, DeviceIdPrefix is a valid (non-NULL) pointer to a DWORD, CompletionPort is a valid handle to an I/O Completion Port that can receive LINEMESSAGE packets from the FSP, and CompletionKey is a valid completion key. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal1 to FALSE. Invoke the Virtual Fax Service Provider s FaxDevVirtualDeviceCreation with the DeviceNamePrefix out parameter set to NULL, as follows: BOOL fRetVal2 = FaxDevVirtualDeviceCreation( DeviceCount, NULL, DeviceIdPrefix, CompletionPort, CompletionKey ); Where, DeviceCount is a valid (non-NULL) pointer to a DWORD, DeviceIdPrefix is a valid (non-NULL) pointer to a DWORD, CompletionPort is a valid handle to an I/O Completion Port that can receive LINEMESSAGE packets from the FSP, and CompletionKey is a valid completion key. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal2 to FALSE. Invoke the Virtual Fax Service Provider s FaxDevVirtualDeviceCreation with the DeviceIdPrefix out parameter set to NULL, as follows: BOOL fRetVal3 = FaxDevVirtualDeviceCreation( DeviceCount, DeviceNamePrefix , NULL, CompletionPort, CompletionKey ); Where, DeviceCount is a valid (non-NULL) pointer to a DWORD, DeviceNamePrefix is a valid (non-NULL) pointer to a WSTR, CompletionPort is a valid handle to an I/O Completion Port that can receive LINEMESSAGE packets from the FSP, and CompletionKey is a valid completion key. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal3 to FALSE. Test Case   FSP FaxDevReportStatus correctly handles NULL out parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to fail, returning FALSE when invoked with NULL out parameters. Scenario  Invoke the Fax Service Provider s FaxDevReportStatus with the FaxStatus, FaxStatusSize and FaxStatusSizeRequired set to NULL, as follows: BOOL fRetVal = FaxDevReportStatus(FaxHandle, NULL, 0, NULL); And where, all the other parameters of FaxDevReportStatus are valid as documented in the NT5 Fax SDK. Verify that FaxDevReportStatus sets the above fRetVal to FALSE. FSP APIs   Invalid In Parameters  Test Case   FSP FaxDevInitialize correctly handles NULL in parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevInitialize to fail, returning FALSE when invoked with NULL in parameters. Notice that we only check for the imperative in parameters, which the FSP cannot do without. Scenario  Invoke the Fax Service Provider s FaxDevInitialize with the HeapHandle in parameter set to NULL, as follows: BOOL fRetVal1 = FaxDevInitialize( LineAppHandle,  NULL, LineCallbackFunction, FaxServiceCallback ); Where, LineAppHandle is a handle to the fax service's registration with TAPI, LineCallbackFunction is a valid (non-NULL) pointer to a PFAX_LINECALLBACK, and FaxServiceCallback is a pointer of type PFAX_SERVICE_CALLBACK pointing to an existent function of that type. Verify that FaxDevInitialize sets the above fRetVal1 to FALSE. Test Case   FSP FaxDevVirtualDeviceCreation correctly handles NULL in parameters This test case verifies that a Virtual Fax Service Provider DLL has implemented FaxDevVirtualDeviceCreation to fail, returning FALSE when invoked with NULL in parameters. Notice that we only check for the imperative in parameters, which the FSP cannot do without. Scenario  Invoke the Virtual Fax Service Provider s FaxDevVirtualDeviceCreation with the CompletionPort in parameter set to NULL, as follows: BOOL fRetVal1 = FaxDevVirtualDeviceCreation( DeviceCount, DeviceNamePrefix, DeviceIdPrefix, NULL, CompletionKey ); Where, DeviceCount is a valid (non-NULL) pointer to a DWORD, DeviceNamePrefix is a valid (non-NULL) pointer to a WSTR, DeviceIdPrefix is a valid (non-NULL) pointer to a DWORD, and CompletionKey is a valid completion key. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal1 to FALSE. Invoke the Virtual Fax Service Provider s FaxDevVirtualDeviceCreation with the CompletionPort in parameter set to NULL, as follows: BOOL fRetVal2 = FaxDevVirtualDeviceCreation( DeviceCount, DeviceNamePrefix, DeviceIdPrefix, CompletionPort, NULL ); Where, DeviceCount is a valid (non-NULL) pointer to a DWORD, DeviceNamePrefix is a valid (non-NULL) pointer to a WSTR, DeviceIdPrefix is a valid (non-NULL) pointer to a DWORD, and CompletionPort is a valid handle to an I/O Completion Port that can receive LINEMESSAGE packets from the FSP. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal2 to FALSE. Test Case   FSP FaxDevSend correctly handles NULL in parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevSend to fail, returning FALSE when invoked with NULL in parameters. Notice that we only check for the imperative in parameters, which the FSP cannot do without. Scenario  Invoke the Fax Service Provider s FaxDevSend with the FaxHandle in parameter set to NULL, as follows: BOOL fRetVal1 = FaxDevSend( NULL, FaxSend, FaxSendCallback ); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal1 to FALSE. Invoke the Fax Service Provider s FaxDevSend with the FaxSend in parameter set to NULL, as follows: BOOL fRetVal2 = FaxDevSend(FaxHandle, NULL, FaxSendCallback ); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal2 to FALSE. Invoke the Fax Service Provider s FaxDevSend with the FaxSend.FileName in parameter set to NULL, as follows: BOOL fRetVal3 = FaxDevSend(FaxHandle, FaxSend, FaxSendCallback ); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal3 to FALSE. Invoke the Fax Service Provider s FaxDevSend with the FaxSend.ReceiverNumber and FaxSend.CallHandle in parameters are both set to NULL, as follows: BOOL fRetVal4 = FaxDevSend(FaxHandle, FaxSend, FaxSendCallback ); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal4 to FALSE. Test Case   Non-Virtual FSP FaxDevSend correctly handles a NULL FaxSendCallback in parameter This test case verifies that a Non-Virtual Fax Service Provider DLL has implemented FaxDevSend to fail, returning FALSE when invoked with a NULL FaxSendCallback in parameter. Scenario  Invoke the Fax Service Provider s FaxDevSend with the FaxSendCallback in parameter set to NULL, as follows: BOOL fRetVal = FaxDevSend( FaxHandle, FaxSend, NULL ); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal to FALSE. Test Case   FSP FaxDevSend correctly handles an invalid FaxSend.FileName in parameter This test case verifies that a Fax Service Provider DLL has implemented FaxDevSend to fail, returning FALSE when invoked with an invalid FaxSend.FileName in parameter. Scenario  Invoke the Fax Service Provider s FaxDevSend with the FaxSend.FileName in parameter set to a non-existent filename, as follows: BOOL fRetVal1 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal1 to FALSE. Invoke the Fax Service Provider s FaxDevSend with the FaxSend.FileName in parameter set to a filename of an existent file with an invalid TIF format, as follows: BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback); And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal2 to FALSE. Test Case   FSP FaxDevSend correctly handles an invalid FaxHandle in parameter This test case verifies that a Fax Service Provider DLL has implemented FaxDevSend to fail, returning FALSE when invoked with an invalid FaxHandle in parameter. Scenario  Invoke the Fax Service Provider s FaxDevSend, as follows: BOOL fRetVal = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback); Where, FaxHandle is a non-zero value that was not obtained via a prior call to the FSP s FaxDevStartJob API, and is thus invalid. And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal to FALSE. Test Case   FSP FaxDevReportStatus correctly handles NULL in parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to fail, returning FALSE when invoked with NULL in parameters. Scenario  Invoke the Fax Service Provider s FaxDevReportStatus with the FaxHandle set to NULL, as follows: BOOL fRetVal1 = FaxDevReportStatus( NULL, FaxStatus, FaxStatusSize, FaxStatusSizeRequired ); And where, all the other parameters of FaxDevReportStatus are valid as documented in the NT5 Fax SDK. Verify that FaxDevReportStatus sets the above fRetVal1 to FALSE. Invoke the Fax Service Provider s FaxDevReportStatus with the FaxStatusSize set to zero, as follows: BOOL fRetVal2 = FaxDevReportStatus(FaxHandle, FaxStatus, 0, FaxStatusSizeRequired ); Where, FaxStatus is not NULL. And where, all the other parameters of FaxDevReportStatus are valid as documented in the NT5 Fax SDK. Verify that FaxDevReportStatus sets the above fRetVal2 to FALSE. Test Case   FSP FaxDevReportStatus correctly handles an invalid FaxHandle in parameter This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to fail, returning FALSE when invoked with an invalid FaxHandle in parameter. Scenario  Invoke the Fax Service Provider s FaxDevReportStatus, as follows: BOOL fRetVal = FaxDevReportStatus( FaxHandle, FaxStatus, FaxStatusSize, FaxStatusSizeRequired ); Where, FaxHandle is a non-zero value that was not obtained via a prior call to the FSP s FaxDevStartJob API, and is thus invalid. And where, all the other parameters of FaxDevReportStatus are valid as documented in the NT5 Fax SDK. Verify that FaxDevReportStatus sets the above fRetVal to FALSE. EFSP APIs   Invalid Out Parameters  Test Case   EFSP FaxDevInitializeEx correctly handles NULL out parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevInitializeEx to fail, returning FSPI_E_FAILED when invoked with NULL out parameters. Scenario  Invoke the Extended Fax Service Provider s FaxDevInitializeEx with the LineCallbackFunction out parameter set to NULL, as follows: HRESULT hr1 = FaxDevInitializeEx( hFsp, LineAppHandle, NULL, FaxServiceCallbackEx, lpdwMaxMessageIdSize ); Where, hFsp is a valid handle, LineAppHandle is a handle to the fax service's registration with TAPI, FaxServiceCallbackEx is a pointer of type PFAX_SERVICE_CALLBACK_EX pointing to an existent function of that type, and lpdwMaxMessageIdSize is a valid (non-NULL) pointer to a DWORD. Verify that FaxDevInitializeEx sets the above hr1 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevInitializeEx with the lpdwMaxMessageIdSize out parameter set to NULL, as follows: HRESULT hr2 = FaxDevInitializeEx( hFsp, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, NULL ); Where, hFsp is a valid handle, LineAppHandle is a handle to the fax service's registration with TAPI, LineCallbackFunction  is a valid (non-NULL) pointer to a PFAX_LINECALLBACK and FaxServiceCallbackEx is a pointer of type PFAX_SERVICE_CALLBACK_EX pointing to an existent function of that type. Verify that FaxDevInitializeEx sets the above hr2 to FSPI_E_FAILED. Test Case   Virtual EFSP FaxDevEnumerateDevices correctly handles NULL out parameters This test case verifies that a Virtual Extended Fax Service Provider DLL has implemented FaxDevEnumerateDevices to fail, returning FSPI_E_FAILED when invoked with NULL out parameters. Scenario  Invoke the Extended Fax Service Provider s FaxDevEnumerateDevices with the lpdwDeviceCount out parameter set to NULL, as follows: HRESULT hr = FaxDevEnumerateDevices ( dwDeviceIdBase, NULL, lpDevices ); Where, lpDevices is a valid (non-NULL) pointer to an FSPI_DEVICE_INFO. And where, all the other parameters of FaxDevEnumerateDevices are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevEnumerateDevices sets the above hr to FSPI_E_FAILED. Notice that it is valid to invoke FaxDevEnumerateDevices with lpDevices=NULL when lpdwDeviceCount is a valid (non-NULL) pointer to a DWORD. Test Case   EFSP FaxDevSendEx correctly handles NULL out parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked with NULL out parameters. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx with the lphRecipientJobs out parameter set to NULL, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, NULL, lpParentMessageId, lphParentJob ); Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx with the lphParentJob out parameter set to NULL, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, NULL ); Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_E_FAILED. Test Case   FaxDevSendEx of an EFSP that supports job context reestablishment correctly handles NULL out parameters This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked with NULL message id out parameters. Note that this test case only verifies correct handling of lpRecipientMessageIds=NULL and lpParentMessageId=NULL. An EFSP supporting job context reestablishment must also successfully handle other NULL out parameters as indicated in test case 6.3.3.3. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx with the lpRecipientMessageIds out parameter set to NULL, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, NULL, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx with the lpParentMessageId out parameter set to NULL, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, NULL, lphParentJob ); Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_E_FAILED. Test Case   FaxDevSendEx of an EFSP that supports job context reestablishment correctly handles a zero value in the FSPI_MESSAGE_ID.dwIdSize out parameter This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked with a zero FSPI_MESSAGE_ID.dwIdSize value. Please note that the EFSP should similarly handle a FSPI_MESSAGE_ID.dwIdSize value that is smaller then the value the EFSP reported in the lpdwMaxMessageIdSize out parameter of FaxDevInitializeEx. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpRecipientMessageIds is a valid pointer to an array of dwNumRecipients FSPI_MESSAGE_ID structures with their FSPI_MESSAGE_ID.dwIdSize member set to zero.  And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpParentMessageId is a valid pointer to a FSPI_MESSAGE_ID structure with its FSPI_MESSAGE_ID.dwIdSize member set to zero.  And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_E_FAILED. Test Case   EFSP FaxDevReportStatusEx correctly handles NULL out parameters This test case is covered by   REF _Ref465576299 \h  Test Case   EFSP FaxDevReportStatusEx correctly handles NULL in parameters  sub-clauses 3 and 4. Test Case   EFSP FaxDevGetLogData correctly handles NULL out parameters [TBD] FaxDevGetLogData is not supported in this release. Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles NULL out parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReestablishJobContext to fail, returning the appropriate error value, when invoked with NULL out parameters. Notice that we only check for the imperative in parameters, which the EFSP cannot do without. Scenario  Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the lpRecipientJobs out parameter set to NULL, as follows: HRESULT hr1 = FaxDevReestablishJobContext(hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, lpcRecipientMessageIds, NULL ); Where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr1 to FSPI_E_FAILED. For an EFSP that support job context reestablishment at the parent job level, also check the above for the lphParentJob out parameter. EFSP APIs   Invalid In Parameters  Test Case   EFSP FaxDevInitializeEx correctly handles NULL in parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevInitializeEx to fail, returning FSPI_E_FAILED when invoked with NULL in parameters.  Notice that we only check for the imperative in parameters, which the EFSP cannot do without. Scenario  Invoke the Extended Fax Service Provider s FaxDevInitializeEx with the LineCallbackFunction out parameter set to NULL, as follows: HRESULT hr = FaxDevInitializeEx( hFsp, LineAppHandle, LineCallbackFunction, NULL, lpdwMaxMessageIdSize ); Where, hFsp is a valid handle, LineAppHandle is a handle to the fax service's registration with TAPI, LineCallbackFunction  is a valid (non-NULL) pointer to a PFAX_LINECALLBACK, and lpdwMaxMessageIdSize is a valid (non-NULL) pointer to a DWORD. Verify that FaxDevInitializeEx sets the above hr to FSPI_E_FAILED. Test Case   EFSP FaxDevSendEx correctly handles NULL in parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked with NULL in parameters. Notice that we only check for the imperative in parameters, which the EFSP cannot do without. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx with the lpcwstrBodyFileName and lpcCoverPageInfo in parameters both set to NULL, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, NULL, NULL, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, NULL, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpcCoverPageInfo.lpwstrCoverPageFileName is set to NULL. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx with the dwNumRecipients in parameter set to zero, as follows: HRESULT hr3 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, 0, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr3 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx with the lpcRecipientProfiles in parameter set to NULL and the dwNumRecipients in parameter set to non-zero, as follows: HRESULT hr4 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, NULL, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr4 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx with the lpcRecipientProfiles in parameter set to NULL and the dwNumRecipients in parameter set to non-zero, as follows: HRESULT hr5 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where lpcRecipientProfiles is a valid pointer to an array of dwNumRecipients FSPI_PERSONAL_PROFILE structures with their lpwstrFaxNumber member set to NULL. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr5 to FSPI_E_FAILED. Test Case   EFSP FaxDevSendEx correctly handles in parameters indicating non existent filenames This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked with in parameters indicating non-existent filenames. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpcwstrBodyFileName contains the name of a non-existent TIF file, and  lpcCoverPageInfo.lpwstrCoverPageFileName contains the name of an existent cover page file. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that  either - FaxDevSendEx sets the above hr1 to FSPI_E_FAILED; or - FaxDevSendEx completes successfully (setting the above hr1 to FSPI_S_OK), but later reports a FSPI_MSG_JOB_STATUS message (via FaxServiceCallbackEx) with status FSPI_JS_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpcwstrBodyFileName contains the name of a existent TIF file, and  lpcCoverPageInfo.lpwstrCoverPageFileName contains the name of a non-existent cover page file. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that  either - FaxDevSendEx sets the above hr2 to FSPI_E_FAILED; or - FaxDevSendEx completes successfully (setting the above hr2 to FSPI_S_OK), but later reports a FSPI_MSG_JOB_STATUS message (via FaxServiceCallbackEx) with status FSPI_JS_FAILED. Test Case   EFSP FaxDevSendEx correctly handles in parameters indicating invalid files This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked with in parameters indicating invalid files. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpcwstrBodyFileName contains the name of a file with invalid TIF format (e.g a   document renamed as InvalidTiff.tif). And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that  either - FaxDevSendEx sets the above hr1 to FSPI_E_FAILED; or - FaxDevSendEx completes successfully (setting the above hr1 to FSPI_S_OK), but later reports a FSPI_MSG_JOB_STATUS message (via FaxServiceCallbackEx) with status FSPI_JS_FAILED. Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpcCoverPageInfo.lpwstrCoverPageFileName contains the name of an existent file with an invalid cover page format (e.g a   document renamed as InvalidCP.cov). And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that  either - FaxDevSendEx sets the above hr2 to FSPI_E_FAILED; or - FaxDevSendEx completes successfully (setting the above hr2 to FSPI_S_OK), but later reports a FSPI_MSG_JOB_STATUS message (via FaxServiceCallbackEx) with status FSPI_JS_FAILED. Test Case   EFSP FaxDevSendEx correctly handles an invalid dwDeviceId in parameter This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to fail, returning the appropriate error value, when invoked with an invalid dwDeviceId in parameter. Note that if the EFSP is Non-Virtual the dwDeviceId must be set to an invalid TAPI permanent device id. In case the EFSP is virtual, the dwDeviceId must be set to an invalid EFSP device id. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx API with the dwDeviceId in parameter set to an invalid device id, as follows: HRESULT hr = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr to FSPI_E_FAILED. Test Case   EFSP FaxDevSendEx correctly handles an invalid FSPI_COVERPAGE_INFO.dwCoverPageFormat in parameter  This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to fail, returning FSPI_E_FAILED when invoked an invalid FSPI_COVERPAGE_INFO.dwCoverPageFormat in parameter. Scenario  Invoke the Extended Fax Service Provider s FaxDevSendEx as follows: HRESULT hr = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob ); Where, lpcCoverPageInfo.dwCoverPageFormat is set to a non-zero value other than FSPI_COVER_PAGE_FMT_COV. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that  either - FaxDevSendEx sets the above hr to FSPI_E_FAILED; or - FaxDevSendEx completes successfully (setting the above hr to FSPI_S_OK), but later reports a FSPI_MSG_JOB_STATUS message (via FaxServiceCallbackEx) with status FSPI_JS_FAILED. Test Case   EFSP FaxDevReportStatusEx correctly handles NULL in parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReportStatusEx to fail, returning the appropriate error value, when invoked with NULL in parameters. Notice that we only check for the imperative in parameters, which the EFSP cannot do without. Scenario  Invoke the Extended Fax Service Provider s FaxDevReportStatusEx API with the hJob in parameter set to NULL, as follows: HRESULT hr1 = FaxDevReportStatusEx( NULL, lpStatus, dwStatusSize, lpdwRequiredStatusSize ); Where, all the other parameters of FaxDevReportStatusEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReportStatusEx sets the above hr1 to FSPI_E_INVALID_JOB_HANDLE. Invoke the Extended Fax Service Provider s FaxDevReportStatusEx API with the lpStatus and lpdwRequiredStatusSize in parameters both set to NULL and the dwStatusSize in parameter is set to a non-zero value, as follows: HRESULT hr2 = FaxDevReportStatusEx( hJob, NULL, dwStatusSize, NULL ); Where, all the other parameters of FaxDevReportStatusEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReportStatusEx sets the above hr2 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevReportStatusEx API with the dwStatusSize set to zero, as follows: HRESULT hr3 = FaxDevReportStatusEx( hJob, lpStatus, 0, lpdwRequiredStatusSize ); Where, all the other parameters of FaxDevReportStatusEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReportStatusEx sets the above hr3 to FSPI_E_BUFFER_OVERFLOW. Test Case   EFSP FaxDevReportStatusEx correctly handles an invalid hJob in parameter This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReportStatusEx to fail, returning the appropriate error value, when invoked with an invalid hJob in parameter. Scenario  Invoke the Extended Fax Service Provider s FaxDevReportStatusEx API, as follows: HRESULT hr1 = FaxDevReportStatusEx( hJob, lpStatus, dwStatusSize, lpdwRequiredStatusSize ); Where, hJob is a non-zero value that was not obtained via a prior call to the EFSP s FaxDevSendEx API or the EFSP s FaxDevStartJob API, and is thus invalid.  And where, all the other parameters of FaxDevReportStatusEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReportStatusEx sets the above hr1 to FSPI_E_INVALID_JOB_HANDLE. Test Case   EFSP FaxDevGetLogData correctly handles NULL in parameters [TBD] FaxDevGetLogData is not supported in this release. Test Case   EFSP FaxDevGetLogData correctly handles an invalid FaxHandle in parameter [TBD] FaxDevGetLogData is not supported in this release. Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles NULL in parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReestablishJobContext to fail, returning the appropriate error value, when invoked with NULL in parameters. Notice that we only check for the imperative in parameters, which the EFSP cannot do without. Scenario  Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the dwRecipientCount in parameter set to zero, as follows: HRESULT hr1 = FaxDevReestablishJobContext(hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, 0, lpcRecipientMessageIds, lpRecipientJobs ); Where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr1 to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the lpcRecipientMessageIds in parameter set to NULL and the dwRecipientCount set to a non-zero value, as follows: HRESULT hr2 = FaxDevReestablishJobContext(hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, NULL, lpRecipientJobs ); Where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr2 to FSPI_E_FAILED. Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles an invalid FSPI_MESSAGE_ID in parameter This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReestablishJobContext to fail, returning the appropriate error value, when invoked with an invalid FSPI_MESSAGE_ID in parameter. Scenario  Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the lpcRecipientMessageIds in parameter set to point at an array of FSPI_MESSAGE_ID structures with their dwIdSize members set to zero, as follows: HRESULT hr = FaxDevReestablishJobContext(hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, lpcRecipientMessageIds, lpRecipientJobs ); Where, lpcRecipientMessageIds[i].dwIdSize=0, for i between 0 and (dwRecipientCount  And where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr to FSPI_E_FAILED. Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the lpcRecipientMessageIds in parameter set to point at an array of FSPI_MESSAGE_ID structures with their lpbId members pointing to invalid message ids, as follows: HRESULT hr = FaxDevReestablishJobContext(hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, lpcRecipientMessageIds, lpRecipientJobs ); Where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr to FSPI_E_FAILED. For an EFSP that support job context reestablishment at the parent job level also check the above for the lpcParentMessageId in parameter. Test Case   FaxDevReestablishJobContext of a Non-Virtual EFSP that supports job context reestablishment correctly handles NULL in parameters This test case verifies that a Non-Virtual Extended Fax Service Provider DLL has implemented FaxDevReestablishJobContext to fail, returning the appropriate error value, when invoked with NULL in parameters. Notice that a non-virtual EFSP that supports job context reestablishment must also successfully pass test case 6.3.4.7. Scenario  Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the hTapiLine in parameter set to NULL, as follows: HRESULT hr = FaxDevReestablishJobContext( NULL, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, lpcRecipientMessageIds, lpRecipientJobs ); Where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr to FSPI_E_FAILED. Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly handles an invalid dwDeviceId in parameter This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReestablishJobContext to fail, returning the appropriate error value, when invoked with an invalid dwDeviceId in parameter. Note that if the EFSP is Non-Virtual the dwDeviceId must be set to an invalid TAPI permanent device id. In case the EFSP is virtual, the dwDeviceId must be set to an invalid EFSP device id. Scenario  Invoke the Extended Fax Service Provider s FaxDevReestablishJobContext API with the dwDeviceId in parameter set to an invalid device id, as follows: HRESULT hr = FaxDevReestablishJobContext(hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, lpcRecipientMessageIds, lpRecipientJobs ); Where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr to FSPI_E_FAILED. Common APIs   Invalid Out Parameters  Test Case   FaxDevStartJob correctly handles NULL out parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevStartJob to fail, returning FALSE when invoked with NULL out parameters.  Scenario  Invoke FaxDevStartJob with the FaxHandle out parameter set to NULL, as follows: BOOL fRetVal = FaxDevStartJob( LineHandle, DeviceId, NULL, CompletionPortHandle, CompletionKey ); Where, all the other parameters of FaxDevStartJob are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal to FALSE. Test Case   FaxDevReceive of an FSP or EFSP that supports T.Routing correctly handles NULL out parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevReceive to fail, returning FALSE when invoked with NULL out parameters.  Scenario  Invoke FaxDevReceive with the FaxReceive.ReceiverNumber out parameter set to NULL, as follows: BOOL fRetVal = FaxDevReceive( FaxHandle, CallHandle, FaxReceive); Where, all the other parameters of FaxDevReceive are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevReceive sets the above fRetVal to FALSE. Common APIs   Invalid In Parameters  Test Case  FaxDevStartJob correctly handles NULL in parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevStartJob to fail, returning FALSE when invoked with NULL in parameters. Scenario  Invoke the Fax Service Provider s FaxDevStartJob with the LineHandle in parameter set to NULL, as follows: BOOL fRetVal1 = FaxDevStartJob( NULL, DeviceId, FaxHandle , CompletionPortHandle, CompletionKey ); Where, DeviceId is the TAPI line device identifier associated with the fax job, FaxHandle is a valid (non-NULL) pointer to a HANDLE, CompletionPortHandle is a valid handle to an I/O Completion Port to be used by the FSP in calls to PostQueuedCompletionStatus, and CompletionKey is a valid completion key to be used by the FSP in calls to PostQueuedCompletionStatus. Verify that FaxDevStartJob sets the above fRetVal1 to FALSE. Invoke the Fax Service Provider s FaxDevStartJob with the DeviceId in parameter set to NULL, as follows: BOOL fRetVal2 = FaxDevStartJob( LineHandle, NULL,  FaxHandle , CompletionPortHandle, CompletionKey ); Where, LineHandle is a valid handle to the open line device associated with the fax job, FaxHandle is a valid (non-NULL) pointer to a HANDLE, CompletionPortHandle is a valid handle to an I/O Completion Port to be used by the FSP in calls to PostQueuedCompletionStatus, and CompletionKey is a valid completion key to be used by the FSP in calls to PostQueuedCompletionStatus. Verify that FaxDevStartJob sets the above fRetVal2 to FALSE. Invoke the Fax Service Provider s FaxDevStartJob with the CompletionPortHandle in parameter set to NULL, as follows: BOOL fRetVal3 = FaxDevStartJob( LineHandle, DeviceId,  FaxHandle , NULL, CompletionKey ); Where, LineHandle is a valid handle to the open line device associated with the fax job, DeviceId is the TAPI line device identifier associated with the fax job, FaxHandle is a valid (non-NULL) pointer to a HANDLE, and CompletionKey is a valid completion key to be used by the FSP in calls to PostQueuedCompletionStatus. Verify that FaxDevStartJob sets the above fRetVal3 to FALSE. Invoke the Fax Service Provider s FaxDevStartJob with the CompletionPortHandle in parameter set to NULL, as follows: BOOL fRetVal4 = FaxDevStartJob( LineHandle, DeviceId,  FaxHandle , CompletionPortHandle, NULL ); Where, LineHandle is a valid handle to the open line device associated with the fax job, DeviceId is the TAPI line device identifier associated with the fax job, FaxHandle is a valid (non-NULL) pointer to a HANDLE, and CompletionPortHandle is a valid handle to an I/O Completion Port to be used by the FSP in calls to PostQueuedCompletionStatus. Verify that FaxDevStartJob sets the above fRetVal4 to FALSE. Test Case   FaxDevEndJob correctly handles NULL in parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevEndJob to fail, returning FALSE when invoked with NULL in parameters.  Notice that we only check for the imperative in parameters, which the FSP or EFSP cannot do without. Scenario  Invoke FaxDevEndJob with the FaxHandle in parameter set to NULL, as follows: BOOL fRetVal = FaxDevEndJob( NULL ); Verify that FaxDevEndJob sets the above fRetVal to FALSE. Test Case   FaxDevEndJob correctly handles an invalid FaxHandle in parameter This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevEndJob to fail, returning FALSE when invoked with an invalid FaxHandle in parameter.  Scenario  Invoke FaxDevEndJob, as follows: BOOL fRetVal = FaxDevEndJob( FaxHandle )  Where, FaxHandle is a non-zero value that was not obtained via a prior call to the FSP s FaxDevStartJob API or the EFSP s FaxDevSendEx API, and is thus invalid. Verify that FaxDevEndJob sets the above fRetVal to FALSE. Test Case   FaxDevReceive correctly handles NULL in parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevReceive to fail, returning FALSE when invoked with NULL in parameters.  Notice that we only check for the imperative in parameters, which the FSP or EFSP cannot do without. Scenario  Invoke FaxDevReceive with the FaxHandle in parameter set to NULL, as follows: BOOL fRetVal1 = FaxDevReceive( NULL, CallHandle, FaxReceive); Where, all the other parameters of FaxDevReceive are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevReceive sets the above fRetVal1 to FALSE. Invoke FaxDevReceive with the FaxReceive.FileName in parameter set to NULL, as follows: BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive); Where, all the other parameters of FaxDevReceive are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevReceive sets the above fRetVal2 to FALSE. Test Case   FaxDevReceive of a Non-Virtual FSP or Non-Virtual EFSP correctly handles NULL in parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevReceive to fail, returning FALSE when invoked with NULL in parameters.  Note that a Non-Virtual FSP or EFSP must also successfully pass test case   REF _Ref465663374 \w \h  6.2.6.4 Scenario  Invoke FaxDevReceive with the CallHandle in parameter set to NULL, as follows: BOOL fRetVal = FaxDevReceive( FaxHandle, NULL, FaxReceive ); Where, all the other parameters of FaxDevReceive are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevReceive sets the above fRetVal to FALSE. Test Case   FaxDevReceive correctly handles a FaxReceive.FileName in parameter indicating a non-existent filename This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevReceive to fail, returning FALSE when invoked with a FaxReceive.FileName in parameter indicating a non-existent filename.  Scenario  Invoke FaxDevReceive with the FaxReceive.FileName in parameter set to indicate a non-existent filename, as follows: BOOL fRetVal = FaxDevReceive(FaxHandle, CallHandle, FaxReceive); Where, all the other parameters of FaxDevReceive are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevReceive sets the above fRetVal to FALSE. Test Case   FaxDevReceive correctly handles an invalid FaxHandle in parameter This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevReceive to fail, returning FALSE when invoked with an invalid FaxHandle in parameter.  Scenario  Invoke FaxDevReceive, as follows: BOOL fRetVal = FaxDevReceive (FaxHandle, CallHandle, FaxReceive )  Where, FaxHandle is a non-zero value that was not obtained via a prior call to the FSP s FaxDevStartJob API or the EFSP s FaxDevSendEx API, and is thus invalid. And where, all the other parameters of FaxDevReceive are valid as documented in the NT 5.0 Fax SDK. Verify that FaxDevReceive sets the above fRetVal to FALSE. Test Case   FaxDevAbortOperation correctly handles NULL in parameters This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to fail, returning FALSE when invoked with NULL in parameters.  Notice that we only check for the imperative in parameters, which the FSP or EFSP cannot do without. Scenario  Invoke FaxDevAbortOperation with the FaxHandle in parameter set to NULL, as follows: BOOL fRetVal = FaxDevAbortOperation( NULL ); Verify that FaxDevAbortOperation sets the above fRetVal to FALSE. Test Case   FaxDevAbortOperation correctly handles an invalid FaxHandle in parameter This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to fail, returning FALSE when invoked with an invalid FaxHandle in parameter.  Scenario  Invoke FaxDevAbortOperation, as follows: BOOL fRetVal = FaxDevAbortOperation ( FaxHandle );  Where, FaxHandle is a non-zero value that was not obtained via a prior call to the FSP s FaxDevStartJob API or the EFSP s FaxDevSendEx API, and is thus invalid. Verify that FaxDevAbortOperation sets the above fRetVal to FALSE. Test Case   LineCallbackFunction of a Non-Virtual FSP or EFSP correctly handles NULL in parameters This test case verifies that a Non-Virtual Fax Service Provider or a Non-Virtual Extended Fax Service Provider DLL has implemented LineCallbackFunction to fail, returning FALSE when invoked with NULL in parameters.  Scenario  Invoke the FSP s FaxDevInitialize or the EFSP s FaxDevInitializeEx, as follows: BOOL fRetVal1 = FaxDevInitialize(  LineAppHandle, HeapHandle, &LineCallbackFunction, FaxServiceCallback );  HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, &LineCallbackFunction,  FaxServiceCallbackEx, lpdwMaxMessageIdSize ); Where, all parameters of FaxDevInitialize or FaxDevInitializeEx are valid as documented in the NT 5.0 Fax SDK and  Comet Fax Service   Extended Fax Service Provider Interface Verify that the FSP s FaxDevInitialize sets the above fRetVal1 to TRUE or that the EFSP s FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke LineCallbackFunction, as follows: BOOL fRetVal2 = LineCallbackFunction( NULL, hDevice, dwMessage, dwInstance, dwParam1, dwParam2, dwParam3 );  Where, all the other parameters of LineCallbackFunction are valid as documented in the NT 5.0 Fax SDK.  Verify that LineCallbackFunction sets the above fRetVal2 to FALSE. Invoke LineCallbackFunction, as follows: BOOL fRetVal3 = LineCallbackFunction( FaxHandle, hDevice, 0, dwInstance, 0, 0, 0 );  Where, all the other parameters of LineCallbackFunction are valid as documented in the NT 5.0 Fax SDK.  Verify that LineCallbackFunction sets the above fRetVal3 to FALSE. Test Case   LineCallbackFunction of a Non-Virtual FSP or EFSP correctly handles an invalid FaxHandle in parameter This test case verifies that a Non-Virtual Fax Service Provider or a Non-Virtual Extended Fax Service Provider DLL has implemented LineCallbackFunction to fail, returning FALSE when invoked with an invalid FaxHandle in parameter.  Scenario  Invoke the FSP s FaxDevInitialize or the EFSP s FaxDevInitializeEx, as follows: BOOL fRetVal1 = FaxDevInitialize(  LineAppHandle, HeapHandle, &LineCallbackFunction, FaxServiceCallback );  HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, &LineCallbackFunction,  FaxServiceCallbackEx, lpdwMaxMessageIdSize ); Where, all parameters of FaxDevInitialize or FaxDevInitializeEx are valid as documented in the NT 5.0 Fax SDK and  Comet Fax Service   Extended Fax Service Provider Interface Verify that the FSP s FaxDevInitialize sets the above fRetVal1 to TRUE or that the EFSP s FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke LineCallbackFunction, as follows: BOOL fRetVal2 = LineCallbackFunction( FaxHandle, hDevice, dwMessage, dwInstance, dwParam1, dwParam2, dwParam3 );  Where, FaxHandle is a non-zero value that was not obtained via a prior call to the FSP s FaxDevStartJob API or the EFSP s FaxDevSendEx API, and is thus invalid.  Verify that LineCallbackFunction sets the above fRetVal2 to FALSE. Test Case   LineCallbackFunction of a Non-Virtual FSP or EFSP correctly handles an invalid dwMessage in parameter This test case verifies that a Non-Virtual Fax Service Provider or a Non-Virtual Extended Fax Service Provider DLL has implemented LineCallbackFunction to fail, returning FALSE when invoked with an invalid dwMessage in parameter.  Scenario  Invoke the FSP s FaxDevInitialize or the EFSP s FaxDevInitializeEx, as follows: BOOL fRetVal1 = FaxDevInitialize(  LineAppHandle, HeapHandle, &LineCallbackFunction, FaxServiceCallback );  HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, &LineCallbackFunction,  FaxServiceCallbackEx, lpdwMaxMessageIdSize ); Where, all parameters of FaxDevInitialize or FaxDevInitializeEx are valid as documented in the NT 5.0 Fax SDK and  Comet Fax Service   Extended Fax Service Provider Interface Verify that the FSP s FaxDevInitialize sets the above fRetVal1 to TRUE or that the EFSP s FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke LineCallbackFunction, as follows: BOOL fRetVal2 = LineCallbackFunction( FaxHandle, hDevice, dwMessage, dwInstance, dwParam1, dwParam2, dwParam3 );  Where, dwMessage is a non-zero value that is not a valid TAPI line device message (e.g. 0x800).  Verify that LineCallbackFunction sets the above fRetVal2 to FALSE. Test Case   FaxExtInitializeConfig of an FSP or EFSP correctly handles NULL in parameters This test case verifies that a Non-Virtual Fax Service Provider or a Non-Virtual Extended Fax Service Provider DLL has implemented LineCallbackFunction to fail, returning FALSE when invoked with an invalid dwMessage in parameter.  Scenario  Invoke FaxExtInitializeConfig, as follows: HRESULT hr1 = FaxExtInitializeConfig(  NULL, pSetExtData, pRegister, pUnregister, pFreeBuffer );  Where, all other parameters of FaxExtInitializeConfig valid as documented in the  Fax Server Extension Configuration Mechanism  document. Verify that FaxExtInitializeConfig sets the above hr1 to FSPI_E_FAILED. Invoke FaxExtInitializeConfig, as follows: HRESULT hr2 = FaxExtInitializeConfig( pGetExtData, NULL, pRegister, pUnregister, pFreeBuffer );  Where, all other parameters of FaxExtInitializeConfig valid as documented in the  Fax Server Extension Configuration Mechanism  document. Verify that FaxExtInitializeConfig sets the above hr2 to FSPI_E_FAILED. Invoke FaxExtInitializeConfig, as follows: HRESULT hr3 = FaxExtInitializeConfig( pGetExtData, pSetExtData, NULL, pUnregister, pFreeBuffer );  Where, all other parameters of FaxExtInitializeConfig valid as documented in the  Fax Server Extension Configuration Mechanism  document. Verify that FaxExtInitializeConfig sets the above hr3 to FSPI_E_FAILED. Invoke FaxExtInitializeConfig, as follows: HRESULT hr4 = FaxExtInitializeConfig( pGetExtData, pSetExtData, pRegister, NULL, pFreeBuffer );  Where, all other parameters of FaxExtInitializeConfig valid as documented in the  Fax Server Extension Configuration Mechanism  document. Verify that FaxExtInitializeConfig sets the above hr4 to FSPI_E_FAILED. Invoke FaxExtInitializeConfig, as follows: HRESULT hr5 = FaxExtInitializeConfig( pGetExtData, pSetExtData, pRegister, pUnregister, NULL);  Where, all other parameters of FaxExtInitializeConfig valid as documented in the  Fax Server Extension Configuration Mechanism  document. Verify that FaxExtInitializeConfig sets the above hr5 to FSPI_E_FAILED. Valid API Parameters The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL implementation of the required APIs correctly sets all out parameters. Section   REF _Ref465678288 \w \h  6.3.1  lays out the tests for a Fax Service Provider, section   REF _Ref465678300 \w \h  6.3.2  does so for an Extended Fax Service Provider, and section   REF _Ref465678395 \w \h  6.3.3  deals with APIs common to both Fax Service Providers and Extended Fax Service Providers. FSP APIs   Valid Parameters Test case   FSP FaxDevInitialize correctly sets out parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevInitialize to set all out parameters to valid values.  Scenario  Invoke FaxDevInitialize, as follows: BOOL fRetVal = FaxDevInitialize(  LineAppHandle,  HeapHandle, LineCallbackFunction, FaxServiceCallback  );  Where, LineCallbackFunction is a valid pointer to a PFAX_LINECALLBACK variable and *LineCallbackFunction=NULL. And where, all the other parameters of FaxDevInitialize are valid as documented in the NT5 Fax SDK. Verify that FaxDevInitialize sets the above fRetVal to TRUE. Also verify that after the call *LineCallbackFunction!=NULL and points to a valid line callback function. Test case   Virtual FSP FaxDevVirtualDeviceCreation correctly sets out parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevVirtualDeviceCreation to set all out parameters to valid values.  Scenario  Invoke FaxDevVirtualDeviceCreation, as follows: BOOL fRetVal = FaxDevVirtualDeviceCreation(  DeviceCount, DeviceNamePrefix, DeviceIdPrefix, CompletionPort, CompletionKey  );  Where, DeviceCount is a valid pointer to a DWORD and *DeviceCount=0. Where, DeviceIdPrefix is a valid pointer to a DWORD and *DeviceIdPrefix=0. Where, DeviceNamePrefix is a valid pointer to a zeroed WSTR. And where, all the other parameters of FaxDevVirtualDeviceCreation are valid as documented in the NT5 Fax SDK. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal to TRUE. Verify that after the call *DeviceCount!=0 and indicates the correct number of devices exported by the FSP. Verify that *DeviceIdPrefix!=0 and indicates the correct device id prefix that the FSP uses. Also verify that DeviceNamePrefix indicates the correct name prefix that the FSP uses, and that the length of this prefix is shorter than 127 characters. Test Case   FSP FaxDevReportStatus correctly sets out parameters This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to set out parameters to valid values.  Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(  LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey  );  Where, all the other parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Invoke FaxDevSend, as follows: BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback );  Where, FaxHandle is the variable from the previous call to FaxDevStartJob. And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that FaxDevSend sets the above fRetVal2 to TRUE. Invoke FaxDevReportStatus, as follows: BOOL fRetVal3 = FaxDevReportStatus(FaxHandle, NULL, 0, FaxStatusSizeRequired);  Where, FaxHandle is the variable from the previous call to FaxDevSend. And where, FaxStatusSizeRequired is a valid pointer to a DWORD and *FaxStatusSizeRequired=0. Verify that FaxDevReportStatus sets the above fRetVal3 to TRUE. Also verify that *FaxStatusSizeRequired!=0 and is set to the required size for the status buffer. Invoke FaxDevReportStatus, as follows: BOOL fRetVal4 = FaxDevReportStatus(FaxHandle, FaxStatus, FaxStatusSize, FaxStatusSizeRequired2 );  Where, FaxStatusSizeRequired2 is a valid pointer to a DWORD and *FaxStatusSizeRequired2=0. Where, FaxStatusSize=*FaxStatusSizeRequired. And where, FaxHandle is from the previous call to FaxDevReportStatus. Verify that FaxDevReportStatus sets the above fRetVal4 to TRUE. Also verify that after the call * FaxStatusSizeRequired2=0 and FaxStatus indicates the current status of job FaxHandle. EFSP APIs   Valid Parameters Test Case   EFSP FaxDevInitializeEx correctly sets out parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevInitializeEx to set all out parameters to valid values.  Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, LineCallbackFunction is a valid pointer to a PFAX_LINECALLBACK variable and *LineCallbackFunction=NULL. And where, all the other parameters of FaxDevInitializeEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr to FSPI_S_OK. Also verify that after the call *LineCallbackFunction!=NULL and points to a valid line callback function. Test Case   EFSP FaxDevSendEx correctly sets out parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to set all out parameters to valid values.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, * lphParentJob=NULL and lphRecipientJobs is a valid pointer to an array of dwNumRecipients HANDLEs with every lphRecipientJobs[i]=NULL. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr to FSPI_S_OK. Also verify that after the call every lphRecipientJobs[i]!=NULL and contains a valid recipient job handle. And that * lphParentJob!=NULL and contains a valid parent job handle. Note that the EFSP must return a valid parent job handle even if it does not have a use for it. Test Case   EFSP FaxDevSendEx correctly handles FAT and NTFS files This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to set successfully send FAT and NTFS based tif files.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, lpcwstrBodyFileName indicates a full path to a valid tif file that resides on a FAT partition, and lpcCoverPageInfo.lpwstrCoverPageFileName indicates a valid cover page file that resides on a FAT partition. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. And that the fax is successfully sent. Invoke FaxDevSendEx, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, lpcwstrBodyFileName indicates a full path to a valid tif file that resides on a NTFS partition, and lpcCoverPageInfo.lpwstrCoverPageFileName indicates a valid cover page file that resides on a NTFS partition. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_S_OK. And that the fax is successfully sent. Test Case   EFSP FaxDevReportStatusEx correctly sets out parameters This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReportStatusEx to set out parameters to valid values.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevReportStatusEx, as follows: HRESULT hr2 = FaxDevReportStatusEx( hJob, NULL, 0, lpdwRequiredStatusSize );  Where, hJob=lphRecipientJobs[0]. And where, lpdwRequiredStatusSize is a valid pointer to a DWORD and *lpdwRequiredStatusSize=0. Verify that FaxDevReportStatusEx sets the above hr2 to FSPI_S_OK. Also verify that *lpdwRequiredStatusSize!=0 and is set to the required size for the status buffer. Invoke FaxDevReportStatusEx, as follows: HRESULT hr3 = FaxDevReportStatusEx( hJob, lpStatus, dwStatusSize, lpdwRequiredStatusSize2 );  Where, lpdwRequiredStatusSize2 is a valid pointer to a DWORD and *lpdwRequiredStatusSize2=0. Where, dwStatusSize=*lpdwRequiredStatusSize. And where, hJob is from the previous call to FaxDevReportStatusEx. Verify that FaxDevReportStatusEx sets the above hr3 to FSPI_S_OK. Also verify that after the call *lpdwRequiredStatusSize2=0 and lpStatus indicates the current status of job hJob. Test Case   Virtual EFSP FaxDevEnumerateDevices correctly sets out parameters This test case verifies that a Virtual Extended Fax Service Provider DLL has implemented FaxDevEnumerateDevices to set out parameters to valid values.  Scenario  Invoke FaxDevEnumerateDevices, as follows: HRESULT hr1 = FaxDevEnumerateDevices( dwDeviceIdBase, lpdwDeviceCount, NULL );  Where, lpdwDeviceCount is a valid pointer to a DWORD and * lpdwDeviceCount=0. Verify that FaxDevEnumerateDevices sets the above hr1 to FSPI_S_OK. Also verify that * lpdwDeviceCount>0 and  * lpdwDeviceCount<=EFSPI_MAX_DEVICE_COUNT and that it is set to indicate the correct number of devices that the EFSP exports. Invoke FaxDevEnumerateDevices, as follows: HRESULT hr2 = FaxDevEnumerateDevices(dwDeviceIdBase, lpdwDeviceCount, lpDevices );  Where, lpdwDeviceCount is the variable from the previous call.  And where, lpDevices is a valid pointer to an array of *lpdwDeviceCount FSPI_DEVICE_INFO structures where every lpDevices[i].szFriendlyName contains all zeroes and every lpDevices[i].dwId=0. Verify that FaxDevEnumerateDevices sets the above hr2 to FSPI_S_OK. Also verify that the lpDevices array has been filled with correct information of all lpdwDeviceCount EFSP devices. Specifically verify that every lpDevices[i].szFriendlyName is shorter than FSPI_MAX_FRIENDLY_NAME characters, and that every lpDevices[i].dwId is between dwDeviceIdBase and dwDeviceIdBase+ EFSPI_MAX_DEVICE_COUNT-1. Test Case   EFSP FaxDevGetLogData correctly sets out parameters [TBD] FaxDevGetLogData is not supported in this release. Common APIs   Valid Parameters Test Case   FaxDevStartJob correctly sets out parameters This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevStartJob to set out parameters to valid values.  Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the other parameters of FaxDevStartJob are valid as documented the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal to TRUE. Also verify that FaxHandle is a valid job handle that can be used in other API calls that receive a job handle. For an FSP specifically verify that the handle can be used in subsequent calls to   FaxDevSend, FaxDevAbortOperation, FaxDevEndJob and FaxDevReportStatus. For an EFSP specifically verify that the handle can be used in subsequent calls to   FaxDevReceive, FaxDevAbortOperation, FaxDevEndJob, FaxDevReportStatusEx and FaxDevGetLogData. Note that FaxDevGetLogData is not supported in this release. Test Case   FaxDevReceive correctly sets out parameters This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevReceive to set out parameters to valid values.  Scenario  Invoke FaxDevReceive, as follows: BOOL fRetVal1 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive );  Where, all the other parameters of FaxDevReceive are valid as documented the NT5 Fax SDK. Verify that FaxDevReceive sets the above hr1 to FSPI_S_OK. Also verify that FaxReceive->ReceiverNumber and FaxReceive->ReceiverName are set correctly. Specifically verify that the combined size of the strings FaxReceive->FileName,  FaxReceive->ReceiverNumber and FaxReceive->ReceiverName is less than FAXDEVRECEIVE_SIZE. Test Case   FaxDevReceive correctly handles FAT and NTFS files This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevReceive to successfully receive the fax into FAT or NTFS based files.  Scenario  Invoke FaxDevReceive, as follows: BOOL fRetVal1 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive );  Where, FaxReceive.FileName indicates a valid file that resides on a FAT partition. And where, all the other parameters of FaxDevReceive are valid as documented the NT5 Fax SDK. Verify that FaxDevReceive sets the above fRetVal1 to TRUE. And that the fax is successfully received. Invoke FaxDevReceive, as follows: BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive );  Where, FaxReceive.FileName indicates a valid file that resides on a NTFS partition. And where, all the other parameters of FaxDevReceive are valid as documented the NT5 Fax SDK. Verify that FaxDevReceive sets the above fRetVal2 to TRUE. And that the fax is successfully received. Service Callbacks The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL implementation of the required APIs correctly invokes service callbacks. Section   REF _Ref469748894 \r \h  6.4.1  lays out the tests for a Fax Service Provider and section   REF _Ref469748905 \r \h  6.4.2  does so for an Extended Fax Service Provider. FSP properly invokes Service Callbacks  Test Case   FSP never invokes FaxServiceCallback This test case verifies that a Fax Service Provider DLL never invokes the FaxServiceCallback function that it receives via the FaxDevInitialize API.  Scenario  Invoke FaxDevInitialize, as follows: BOOL fRetVal = FaxDevInitialize( LineAppHandle, HeapHandle, LineCallbackFunction, FaxServiceCallback );  Where, all the parameters of FaxDevInitialize are valid as documented in the NT5 Fax SDK. Verify that FaxDevInitialize sets the above fRetVal to TRUE. Verify that Fax Service Provider code never uses the FaxServiceCallback function pointer it received above. Test Case   FaxDevSend of Non-Virtual FSP correctly invokes FaxSendCallback This test case verifies that a Non-Virtual Fax Service Provider DLL has implemented FaxDevSend to correctly invoke the FaxSendCallback function that it receives.  Scenario  Invoke FaxDevSend, as follows: BOOL fRetVal1 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback  );  Where, all the parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that during the execution of FaxDevSend it invokes the FaxSendCallback function, as follows: BOOL fRetVal2 = FaxSendCallback( FaxHandle, CallHandle, 0 , 0 ); Where, FaxHandle is the job handle that the Fax Service Provider received in the above FaxDevSend call, and CallHandle is the call handle that TAPI 2.x assigned for this outgoing call. Test Case   FaxDevSend of Non-Virtual FSP correctly behaves according to return value of FaxSendCallback This test case verifies that a Non-Virtual Fax Service Provider DLL has implemented FaxDevSend to correctly behave according to the return value of the FaxSendCallback function.  Scenario  Invoke FaxDevSend, as follows: BOOL fRetVal1 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback1  );  Where, FaxSendCallback1 is a function that will always return TRUE. And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that during the execution of FaxDevSend it invokes the FaxSendCallback1 function, as follows: BOOL fRetVal2 = FaxSendCallback1( FaxHandle, CallHandle, 0 , 0 ); Where, FaxHandle is the job handle that the Fax Service Provider received in the above FaxDevSend call, and CallHandle is the call handle that TAPI 2.x assigned for this outgoing call. Verify that FaxSendCallback1 sets the above fRetVal2 to TRUE. Also verify that the execution of FaxDevSend continues (the outgoing call is performed). Invoke FaxDevSend, as follows: BOOL fRetVal3 = FaxDevSend( FaxHandle2, FaxSend2, FaxSendCallback2  );  Where, FaxSendCallback2 is a function that will always return FALSE. And where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK. Verify that during the execution of FaxDevSend it invokes the FaxSendCallback2 function, as follows: BOOL fRetVal4 = FaxSendCallback( FaxHandle2, CallHandle2, 0 , 0 ); Where, FaxHandle2 is the job handle that the Fax Service Provider received in the above FaxDevSend call, and CallHandle2 is the call handle that TAPI 2.x assigned for this outgoing call. Verify that FaxSendCallback2 sets the above fRetVal4 to FALSE. Also verify that the execution of FaxDevSend is stopped (the outgoing call is not performed), and that FaxDevSend sets the above fRetVal3 to FALSE. EFSP properly invokes Service Callbacks  Test Case   EFSP FaxDevSendEx correctly invokes FaxServiceCallbackEx This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to correctly invoke the FaxSeerviceCallbackEx function.  Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the parameters of FaxDevInitializeEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevSendEx, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_S_OK. Verify that as the Extended Fax Service Provider DLL is executing the send job it reports all job status changes by invoking the FaxServiceCallbackEx function (that it received from FaxDevInitializeEx above), as follows: HRESULT hr3 = FaxServiceCallbackEx( hFSP, dwMsgType, Param1, Param2, 0 ); Where, hFSP is the handle the Extended Fax Service Provider was given via FaxDevInitializeEx above. Where, dwMsgType=FSPI_MSG_JOB_STATUS, Param1 is the recipient job handle of the job for which the status is reported (one of lphRecipientJobs[i]), and Param2 is a pointer to a valid FSPI_JOB_STATUS structure that contains the reported job status information. Test Case   EFSP FaxDevSendEx correctly handles return values of  FaxServiceCallbackEx This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to correctly handle return values of the FaxServiceCallbackEx function.  Run the following scenario for each one of the following FaxServiceCallbackEx implementations: FaxServiceCallbackEx returns FSPI_E_INVALID_EFSP. FaxServiceCallbackEx returns FSPI_E_INVALID_MSG. FaxServiceCallbackEx returns FSPI_E_INVALID_PARAM1. FaxServiceCallbackEx returns FSPI_E_INVALID_PARAM2. FaxServiceCallbackEx returns FSPI_E_INVALID_PARAM3. FaxServiceCallbackEx returns FSPI_E_NOMEM. FaxServiceCallbackEx returns FSPI_E_FAILED. Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the parameters of FaxDevInitializeEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevSendEx, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_S_OK. Verify that as the Extended Fax Service Provider DLL is executing the send job it reports all job status changes by invoking the FaxServiceCallbackEx function (that it received from FaxDevInitializeEx above), as follows: HRESULT hr3 = FaxServiceCallbackEx( hFSP, dwMsgType, Param1, Param2, 0 ); Where, hFSP is the handle the Extended Fax Service Provider was given via FaxDevInitializeEx above. Where, dwMsgType=FSPI_MSG_JOB_STATUS, Param1 is the recipient job handle of the job for which the status is reported (one of lphRecipientJobs[i]), and Param2 is a pointer to a valid FSPI_JOB_STATUS structure that contains the reported job status information. Verify that hr3 is set according to FaxServiceCallbackEx implementation a through g above. For case f above (FSPI_E_NOMEM) - verify that the Extended Fax Service Provider waits a while and then retries calling FaxServiceCallbackEx, several more times. Attempting to overcome a temporary low memory condition. For all the other cases (a, b, c, d, e, and g) - the Extended Fax Service Provider should continue with the job s execution as usual.  The Extended Fax Service Provider should not (under any circumstances) free any memory related to a  job untill the Comet Fax Service explicitly invokes the Provider s FaxDevEndJob API. All job handles and their related job information should remain valid untill FaxDevEndJob is called. Test Case   EFSP FaxDevReceive correctly invokes FaxServiceCallbackEx This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReceive to correctly invoke the FaxSeerviceCallbackEx function.  Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the parameters of FaxDevInitializeEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); Where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets the above fRetVal1to TRUE. Invoke FaxDevReceive, as follows:  BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive ); Where, FaxHandle is the job handle from the above call to FaxDevStartJob. And where, all the other parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive sets the above fRetVal2 to TRUE. Verify that as the Extended Fax Service Provider DLL is executing the receive job it reports all job status changes by invoking the FaxServiceCallbackEx function (that it received from FaxDevInitializeEx above), as follows: HRESULT hr3 = FaxServiceCallbackEx( hFSP, dwMsgType, Param1, Param2, 0 ); Where, hFSP is the handle the Extended Fax Service Provider was given via FaxDevInitializeEx above. Where, dwMsgType=FSPI_MSG_JOB_STATUS, Param1 is the receive job handle of the job, and Param2 is a pointer to a valid FSPI_JOB_STATUS structure that contains the reported job status information. Test Case   EFSP FaxDevReceive correctly handles return values of  FaxServiceCallbackEx This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReceive to correctly handle return values of the FaxServiceCallbackEx function.  Run the following scenario for each one of the following FaxServiceCallbackEx implementations: FaxServiceCallbackEx returns FSPI_E_INVALID_EFSP. FaxServiceCallbackEx returns FSPI_E_INVALID_MSG. FaxServiceCallbackEx returns FSPI_E_INVALID_PARAM1. FaxServiceCallbackEx returns FSPI_E_INVALID_PARAM2. FaxServiceCallbackEx returns FSPI_E_INVALID_PARAM3. FaxServiceCallbackEx returns FSPI_E_NOMEM. FaxServiceCallbackEx returns FSPI_E_FAILED. Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the parameters of FaxDevInitializeEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); Where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets the above fRetVal1to TRUE. Invoke FaxDevReceive, as follows:  BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive ); Where, FaxHandle is the job handle from the above call to FaxDevStartJob. And where, all the other parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive sets the above fRetVal2 to TRUE. Verify that as the Extended Fax Service Provider DLL is executing the receive job it reports all job status changes by invoking the FaxServiceCallbackEx function (that it received from FaxDevInitializeEx above), as follows: HRESULT hr3 = FaxServiceCallbackEx( hFSP, dwMsgType, Param1, Param2, 0 ); Where, hFSP is the handle the Extended Fax Service Provider was given via FaxDevInitializeEx above. Where, dwMsgType=FSPI_MSG_JOB_STATUS, Param1 is the receive job handle of the job, and Param2 is a pointer to a valid FSPI_JOB_STATUS structure that contains the reported job status information. Verify that hr3 is set according to FaxServiceCallbackEx implementation a through g above. For case f above (FSPI_E_NOMEM) - verify that the Extended Fax Service Provider waits a while and then retries calling FaxServiceCallbackEx, several more times. Attempting to overcome a temporary low memory condition. For all the other cases (a, b, c, d, e, and g) - the Extended Fax Service Provider should continue with the job s execution as usual.  The Extended Fax Service Provider should not (under any circumstances) free any memory related to a  job untill the Comet Fax Service explicitly invokes the Provider s FaxDevEndJob API. All job handles and their related job information should remain valid untill FaxDevEndJob is called. FSP \ EFSP properly invoke FaxExt Service Callbacks  Test Case   return values of FaxExtGetExtensionData are handled correctly This test case verifies that Fax Service Provider DLL or Extended Fax Service Provider DLL code that invokes FaxExtGetExtensionData correctly handles all possible return values.Scenario  Scenario  Verify that any FSP \ EFSP code invoking the FaxExtGetExtensionData service callback correctly handles the following error scenarios: FaxExtGetExtensionData service callback returns ERROR_NOT_FOUND. FaxExtGetExtensionData service callback returns ERROR_INVALID_PARAMETER. FaxExtGetExtensionData service callback returns ERROR_BAD_UNIT. FaxExtGetExtensionData service callback returns ERROR_WMI_GUID_NOT_FOUND. FaxExtGetExtensionData service callback returns ERROR_NOT_ENOUGH_MEMORY. FaxExtGetExtensionData service callback returns ERROR_BAD_DB. FaxExtGetExtensionData service callback returns ERROR_FILE_NOT_FOUND. FaxExtGetExtensionData service callback returns ERROR_GEN_FAILURE. Verify that if the FSP \ EFSP code invoking the above FaxExtGetExtensionData service callback cannot proceed due to the callbacks failure, the code returns a relevant error and fails gracefully (performing any necessary cleanup). Verify that any FSP \ EFSP code invoking the FaxExtGetExtensionData service callback correctly handles the following successful scenario: FaxExtGetExtensionData service callback returns ERROR_SUCCESS. Verify that the FSP \ EFSP code invoking the above FaxExtGetExtensionData service callback completes successfully. Test Case   return values of FaxExtSetExtensionData are handled correctly This test case verifies that Fax Service Provider DLL or Extended Fax Service Provider DLL code that invokes FaxExtRegisterForExtensionEvents correctly handles all possible return values.Scenario  Verify that any FSP \ EFSP code invoking the FaxExtSetExtensionData service callback correctly handles the following error scenarios: FaxExtSetExtensionData service callback returns ERROR_NOT_FOUND. FaxExtSetExtensionData service callback returns ERROR_INVALID_PARAMETER. FaxExtSetExtensionData service callback returns ERROR_BAD_UNIT. FaxExtSetExtensionData service callback returns ERROR_WMI_GUID_NOT_FOUND. FaxExtSetExtensionData service callback returns ERROR_NOT_ENOUGH_MEMORY. FaxExtSetExtensionData service callback returns ERROR_FILE_NOT_FOUND. FaxExtSetExtensionData service callback returns ERROR_GEN_FAILURE. Verify that if the FSP \ EFSP code invoking the above FaxExtSetExtensionData service callback cannot proceed due to the callbacks failure, the code returns a relevant error and fails gracefully (performing any necessary cleanup). Verify that any FSP \ EFSP code invoking the FaxExtSetExtensionData service callback correctly handles the following successful scenario: FaxExtSetExtensionData service callback returns ERROR_SUCCESS. Verify that the FSP \ EFSP code invoking the above FaxExtSetExtensionData service callback completes successfully. Test Case   return values of FaxExtRegisterForExtensionEvents are handled correctly This test case verifies that Fax Service Provider DLL or Extended Fax Service Provider DLL code that invokes FaxExtRegisterForExtensionEvents correctly handles all possible return values. Scenario  Verify that any FSP \ EFSP code invoking the FaxExtRegisterForExtensionEvents service callback correctly handles the following error scenarios: FaxExtRegisterForExtensionEvents service callback returns ERROR_NOT_FOUND. FaxExtRegisterForExtensionEvents service callback returns ERROR_INVALID_PARAMETER. FaxExtRegisterForExtensionEvents service callback returns ERROR_BUSY. FaxExtRegisterForExtensionEvents service callback returns ERROR_ALREADY_ASSIGNED. FaxExtRegisterForExtensionEvents service callback returns ERROR_WMI_GUID_NOT_FOUND. FaxExtRegisterForExtensionEvents service callback returns ERROR_NOT_ENOUGH_MEMORY. FaxExtRegisterForExtensionEvents service callback returns ERROR_GEN_FAILURE. Verify that if the FSP \ EFSP code invoking the above FaxExtRegisterForExtensionEvents service callback cannot proceed due to the callbacks failure, the code returns a relevant error and fails gracefully (performing any necessary cleanup). Verify that any FSP \ EFSP code invoking the FaxExtRegisterForExtensionEvents service callback correctly handles the following successful scenario: FaxExtRegisterForExtensionEvents service callback returns ERROR_SUCCESS. Verify that the FSP \ EFSP code invoking the above FaxExtRegisterForExtensionEvents service callback completes successfully. Test Case   return values of FaxExtUnregisterForExtensionEvents are handled correctly This test case verifies that Fax Service Provider DLL or Extended Fax Service Provider DLL code that invokes FaxExtUnregisterForExtensionEvents correctly handles all possible return values. Scenario  Verify that any FSP \ EFSP code invoking the FaxExtUnregisterForExtensionEvents service callback correctly handles the following error scenarios: FaxExtRegisterForExtensionEvents service callback returns ERROR_NOT_FOUND. FaxExtRegisterForExtensionEvents service callback returns ERROR_INVALID_PARAMETER. FaxExtRegisterForExtensionEvents service callback returns ERROR_NOT_ENOUGH_MEMORY. FaxExtRegisterForExtensionEvents service callback returns ERROR_GEN_FAILURE. Verify that if the FSP \ EFSP code invoking the above FaxExtUnregisterForExtensionEvents service callback cannot proceed due to the callbacks failure, the code returns a relevant error and fails gracefully (performing any necessary cleanup). Verify that any FSP \ EFSP code invoking the FaxExtUnregisterForExtensionEvents service callback correctly handles the following successful scenario: FaxExtUnregisterForExtensionEvents service callback returns ERROR_SUCCESS. Verify that the FSP \ EFSP code invoking the above FaxExtUnregisterForExtensionEvents service callback completes successfully. EFSP Implementation According to Capabilities The following tests strive to verify that an Extended Fax Service Provider DLL has implemented the APIs according to the capabilities it reported during registration. The following sections are divided according to the different capability areas   Broadcasting, Multi-Send, Simultaneous-Send-Receive, Scheduling, Abort and Auto-Retry. The last section deals with Job Context Reestablishment for which the Extended Fax Service Provider indicates support by reporting a non-zero maximum message id size in FaxDevInitializeEx. Please note that each section describes test cases for both Extended Fax Service Providers that do and Extended Fax Service Providers that do not support the specific capability. Broadcast Test Case   FaxDevSendEx of an EFSP that supports FSPI_CAP_BROADCAST correctly handles a multi-recipient broadcast job. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_BROADCAST capability has implemented FaxDevSendEx to correctly handle a multiple recipient broadcast job.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, dwNumRecipients=5 and lpcRecipientProfiles points to an array of 5 different and valid FSPI_PERSONAL_PROFILE structures. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr to FSPI_S_OK. Verify that the Extended Fax Service Provider DLL executes all the 5 recipient send jobs. Test Case   FaxDevSendEx of an EFSP that does not support FSPI_CAP_BROADCAST correctly fails a multi-recipient broadcast job. This test case verifies that an Extended Fax Service Provider DLL that registered without the FSPI_CAP_BROADCAST capability has implemented FaxDevSendEx to fail when invoked with a multiple recipient broadcast job.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, dwNumRecipients=5 and lpcRecipientProfiles points to an array of 5 different and valid FSPI_PERSONAL_PROFILE structures. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr to FSPI_E_FAILED. Test Case   EFSP FaxDevReportStatusEx correctly handles parent job handle. This test case verifies that an Extended Fax Service Provider DLL that registered with or without the FSPI_CAP_BROADCAST capability has implemented FaxDevReportStatusEx to fail when invoked with a parent job handle.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, &hParentJob );  Where, dwNumRecipients=5 and lpcRecipientProfiles points to an array of 5 different and valid FSPI_PERSONAL_PROFILE structures. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevReportStatusEx, as follows: HRESULT hr2 = FaxDevReportStatusEx( hParentJob, lpStatus, dwStatusSize, lpdwRequiredStatusSize );  Where, hParentJob is the parent job handle returned from the above call to FaxDevSendEx. And where, all the other parameters of FaxDevReportStatusEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReportStatusEx sets the above hr2 to FSPI_E_INVALID_JOB_HANDLE. Test Case   EFSP FaxDevGetLogData correctly handles parent job handle. [TBD] FaxDevGetLogData is not supported in this release. Multi-Send Test Case   FaxDevSendEx of an EFSP that supports FSPI_CAP_MULTISEND correctly handles concurrent send jobs. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_MULTISEND capability has implemented FaxDevSendEx to successfully handle concurrent send jobs.  Scenario  Simultaneously perform two invocations of FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName1, lpcCoverPageInfo1, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients1, lpcRecipientProfiles1, lpRecipientMessageIds1, lphRecipientJobs1, lpParentMessageId1, lphParentJob1 );  HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName2, lpcCoverPageInfo2, bAddBranding, tmSchedule, lpcSenderProfile2, dwNumRecipients2, lpcRecipientProfiles2, lpRecipientMessageIds2, lphRecipientJobs2, lpParentMessageId2, lphParentJob2 );  Where, tmSchedule=0 (indicating  now), and both above invocation use the same hTapiLine and dwDeviceId. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that both simultaneous calls to FaxDevSendEx set the above hr1 and hr2 to FSPI_S_OK. Also verify that both calls are carried out and completed successfully. Invoke FaxDevSendEx, as follows: HRESULT hr3 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName1, lpcCoverPageInfo1, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients1, lpcRecipientProfiles1, lpRecipientMessageIds1, lphRecipientJobs1, lpParentMessageId1, lphParentJob1 ); Where, tmSchedule=0 (indicating  And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr3 to FSPI_S_OK. Immediately (before the above call completes), invoke FaxDevSendEx again, as follows: HRESULT hr4 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName2, lpcCoverPageInfo2, bAddBranding, tmSchedule, lpcSenderProfile2, dwNumRecipients2, lpcRecipientProfiles2, lpRecipientMessageIds2, lphRecipientJobs2, lpParentMessageId2, lphParentJob2 );  Where, tmSchedule=0 (indicating  ), and both above invocation use the same hTapiLine and dwDeviceId. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr4 to FSPI_S_OK. Also verify that both above calls are carried out and completed successfully. Test Case   FaxDevSendEx of an EFSP that does not support FSPI_CAP_MULTISEND correctly handles concurrent send jobs. This test case verifies that an Extended Fax Service Provider DLL that registered without the FSPI_CAP_MULTISEND capability has implemented FaxDevSendEx to fail if invoked while another send  job is already in progress on the same device.  Scenario  Simultaneously perform two invocations of FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName1, lpcCoverPageInfo1, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients1, lpcRecipientProfiles1, lpRecipientMessageIds1, lphRecipientJobs1, lpParentMessageId1, lphParentJob1 );  HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName2, lpcCoverPageInfo2, bAddBranding, tmSchedule, lpcSenderProfile2, dwNumRecipients2, lpcRecipientProfiles2, lpRecipientMessageIds2, lphRecipientJobs2, lpParentMessageId2, lphParentJob2 );  Where, tmSchedule=0 (indicating  now), and both above invocation use the same hTapiLine and dwDeviceId. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that one of the above calls to FaxDevSendEx returns FSPI_S_OK and the other returns FSPI_E_FAILED. Also verify that only the call (for which FaxDevSendEx returned FSPI_S_OK) is carried out and completed successfully. Invoke FaxDevSendEx, as follows: HRESULT hr3 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName1, lpcCoverPageInfo1, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients1, lpcRecipientProfiles1, lpRecipientMessageIds1, lphRecipientJobs1, lpParentMessageId1, lphParentJob1 ); Where, tmSchedule=0 (indicating  And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr3 to FSPI_S_OK. Immediately (before the above call completes), invoke FaxDevSendEx again, as follows: HRESULT hr4 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName2, lpcCoverPageInfo2, bAddBranding, tmSchedule, lpcSenderProfile2, dwNumRecipients2, lpcRecipientProfiles2, lpRecipientMessageIds2, lphRecipientJobs2, lpParentMessageId2, lphParentJob2 );  Where, tmSchedule=0 (indicating  ), and both above invocation use the same hTapiLine and dwDeviceId. And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr4 to FSPI_E_FAILED. Also verify that only the call from clause 3 is carried out and completed successfully. Scheduling [TBD] Scheduling is not supported in this release. Abort Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_RECIPIENT correctly handles a valid recipient job hFaxHandle. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_ABORT_RECIPIENT capability has implemented FaxDevAbortOperation to correctly handle the abortion of a valid recipient job. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, tmSchedule=0 indicating  And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. When the Extended Fax Service Provider reports a  sending  status for recipient job lphRecipientJobs[0], invoke FaxDevAbortOperation, as follows: BOOL fRetVal = FaxDevAbortOperation( lphRecipientJobs[0] ); Verify that FaxDevAbortOperation sets the above fRetVal to TRUE. Verify that immediately after FaxDevAbortOperation returns, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_ABORTING status for job lphRecipientJobs[0]. Also verify that when the job is aborted successfully the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a job status of FSPI_JS_ABORTED for job lphRecipientJobs[0]. Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_RECIPIENT correctly handles a valid recipient job hFaxHandle already in FSPI_JS_ABORTING status. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_ABORT_RECIPIENT capability has implemented FaxDevAbortOperation to correctly handle the abortion of a valid recipient job that is already in FSPI_JS_ABORTING status. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, tmSchedule=0 indicating  And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. When the Extended Fax Service Provider reports a  sending  status for recipient job lphRecipientJobs[0], invoke FaxDevAbortOperation, as follows: BOOL fRetVal1 = FaxDevAbortOperation( lphRecipientJobs[0] ); Verify that FaxDevAbortOperation sets the above fRetVal1 to TRUE. Verify that immediately after FaxDevAbortOperation returns, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_ABORTING status for job lphRecipientJobs[0]. While status of job lphRecipientJobs[0] is still FSPI_JS_ABORTING, invoke FaxDevAbortOperation again, as follows: BOOL fRetVal2 = FaxDevAbortOperation( lphRecipientJobs[0] ); Verify that FaxDevAbortOperation sets the above fRetVal2 to TRUE. Verify that when the job is aborted successfully the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a job status of FSPI_JS_ABORTED for job lphRecipientJobs[0]. Test Case   FaxDevAbortOperation of an EFSP that does not support FSPI_CAP_ABORT_RECIPIENT correctly handles a valid recipient job hFaxHandle. This test case verifies that an Extended Fax Service Provider DLL that registered without the FSPI_CAP_ABORT_RECIPIENT capability has implemented FaxDevAbortOperation to fail when invoked with a recipient job handle. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, tmSchedule=0 indicating  And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. When the Extended Fax Service Provider reports a  sending  status for recipient job lphRecipientJobs[0], invoke FaxDevAbortOperation, as follows: BOOL fRetVal = FaxDevAbortOperation( lphRecipientJobs[0] ); Verify that FaxDevAbortOperation sets the above fRetVal to FALSE. Also verify that the call is not aborted. Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_PARENT correctly handles a valid parent job hFaxHandle. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_ABORT_PARENT capability has implemented FaxDevAbortOperation to correctly handle the abortion of a valid parent job. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, &hParentJob );  Where, dwNumRecipients=5 and accordingly lpcRecipientProfiles points to an array of 5 valid personal profile structures. Where, tmSchedule=0 indicating  And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. When the Extended Fax Service Provider reports a  sending  status for some of the recipient jobs in lphRecipientJobs, invoke FaxDevAbortOperation, as follows: BOOL fRetVal = FaxDevAbortOperation( hParentJob ); Where, hParentJob is the parent job handle from the above call to FaxDevSendEx. Verify that FaxDevAbortOperation sets the above fRetVal to TRUE. Verify that immediately after FaxDevAbortOperation returns, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_ABORTING status for each one of the 5 recipient jobs in lphRecipientJobs. Also verify that when each of the 5 recipient jobs is aborted successfully, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a job status of FSPI_JS_ABORTED for that recipient job. Test Case   FaxDevAbortOperation of an EFSP that supports FSPI_CAP_ABORT_PARENT correctly handles a valid parent job hFaxHandle already in FSPI_JS_ABORTING status. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_ABORT_PARENT capability has implemented FaxDevAbortOperation to correctly handle the abortion of a valid parent job that is already in FSPI_JS_ABORTING status. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, &hParentJob );  Where, dwNumRecipients=5 and accordingly lpcRecipientProfiles points to an array of 5 valid personal profile structures. Where, tmSchedule=0 indicating  And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. When the Extended Fax Service Provider reports a  sending  status for some of the recipient jobs in lphRecipientJobs, invoke FaxDevAbortOperation, as follows: BOOL fRetVa1l = FaxDevAbortOperation( hParentJob ); Where, hParentJob is the parent job handle from the above call to FaxDevSendEx. Verify that FaxDevAbortOperation sets the above fRetVal1 to TRUE. Verify that immediately after FaxDevAbortOperation returns, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_ABORTING status for each one of the 5 recipient jobs in lphRecipientJobs. While status of some of the jobs in lphRecipientJobs is still FSPI_JS_ABORTING, invoke FaxDevAbortOperation again, as follows: BOOL fRetVal2 = FaxDevAbortOperation( hParentJob ); Verify that FaxDevAbortOperation sets the above fRetVal2 to TRUE. Verify that when each of the 5 recipient jobs is aborted successfully, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a job status of FSPI_JS_ABORTED for that recipient job. Test Case   FaxDevAbortOperation of an EFSP that does not support FSPI_CAP_ABORT_PARENT correctly handles a valid parent job hFaxHandle. This test case verifies that an Extended Fax Service Provider DLL that registered without the FSPI_CAP_ABORT_PARENT capability has implemented FaxDevAbortOperation to fail when invoked with a parent job handle. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, &hParentJob );  Where, dwNumRecipients=5 and accordingly lpcRecipientProfiles points to an array of 5 valid personal profile structures. Where, tmSchedule=0 indicating  And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. When the Extended Fax Service Provider reports a  sending  status for some of the recipient jobs in the above lphRecipientJobs, invoke FaxDevAbortOperation, as follows: BOOL fRetVal = FaxDevAbortOperation( hParentJob ); Verify that FaxDevAbortOperation sets the above fRetVal to FALSE. Also verify that the call is not aborted. Auto-Retry Test Case   FaxDevSendEx of an EFSP that supports FSPI_CAP_AUTO_RETRY correctly retries a recipient job. This test case verifies that an Extended Fax Service Provider DLL that registered with the FSPI_CAP_AUTO_RETRY capability has implemented FaxDevSendEx to correctly retry a recipient job.  Scenario  Configure the Extended Fax Service Provider to retry each job 3 times. Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, lpcRecipientProfiles[0].lpwstrFaxNumber indicates a phone number which will not be answered when called (i.e. the call will fail with a  no answer  status). And where, all the parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the above call begins execution. Verify that at some point later, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_RETRY status and a FSPI_ES_NO_ANSWER extended status for job lphRecipientJobs[0]. Verify that the Extended Fax Service Provider retries the job 3 more times (according to its settings). Specifically verify  For the first two retries, some time after the call begins execution, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_RETRY status and a FSPI_ES_NO_ANSWER extended status for job lphRecipientJobs[0]. For the 3rd (and last) retry, some time after the call begins execution, the Extended Fax Service Provider invokes FaxServiceCallbackEx to report a FSPI_JS_FAILED status and a FSPI_ES_NO_ANSWER extended status for job lphRecipientJobs[0]. For an Extended Fax Service Provider that has a setting configuring the time interval between retries, the retries are conducted according to settings. Job Context Reestablishment Test Case   FaxDevInitializeEx of an EFSP that supports job context reestablishment correctly sets the lpdwMaxMessageIdSize out parameter This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevInitializeEx to set the lpdwMaxMessageIdSize out parameter to a valid value.  Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, lpdwMaxMessageIdSize is a valid pointer to a DWORD variable and *lpdwMaxMessageIdSize=0. And where, all the other parameters of FaxDevInitializeEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr to FSPI_S_OK. Also verify that after the call * lpdwMaxMessageIdSize!=0 and indicates the maximum message id size that the EFSP will require. Test Case   FaxDevInitializeEx of an EFSP that does not support job context reestablishment correctly sets the lpdwMaxMessageIdSize out parameter This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevInitializeEx to set the lpdwMaxMessageIdSize out parameter to zero.  Scenario  Invoke FaxDevInitializeEx, as follows: HRESULT hr = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, lpdwMaxMessageIdSize is a valid pointer to a DWORD variable and *lpdwMaxMessageIdSize=256. And where, all the other parameters of FaxDevInitializeEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr to FSPI_S_OK. Also verify that after the call * lpdwMaxMessageIdSize==0 indicating that the Extended Fax Service Provider does not support Job Context Reestablishment. Test Case   FaxDevSendEx of an EFSP that supports job context reestablishment correctly sets message id out parameters This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevSendEx to set message id out parameters to valid values.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, lpRecipientMessageIds is a valid pointer to an array of dwNumRecipients FSPI_MESSAGE_IDs and every lpRecipientMessageIds[i]=NULL. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that after the call every lpRecipientMessageIds[i]!=NULL and contains a valid recipient message id. If the EFSP requires permanent message ids at the parent job level then also  Invoke FaxDevSendEx, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, lpParentMessageId is a valid pointer to a FSPI_MESSAGE_ID and *lpParentMessageId=NULL. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr2 to FSPI_S_OK. Also verify that after the call *lpParentMessageId!=NULL and contains a valid parent message id. Test Case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment correctly sets out parameters This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevReestablishJobContext to set message id out parameters to valid values.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that after the call every lpRecipientMessageIds[i]!=NULL and contains a valid recipient message id. And that after the call *lpParentMessageId!=NULL and contains a valid parent message id Invoke FaxDevReestablishJobContext, as follows: HRESULT hr2 = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob2, dwNumRecipients, lpcRecipientMessageIds, lphRecipientJobs2 );  Where, lpRecipientMessageIds, lpcParentMessageId, hTapiLine, dwNumRecipients and dwDeviceId are from above call to FaxDevSendEx. Where, lphRecipientJobs2 is a valid pointer to an array of dwNumRecipients HANDLEs and every lphRecipientJobs2[i]=NULL. Where lphParentJob2 is a valid pointer to a HANDLE and * lphParentJob2=NULL. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets the above hr2 to FSPI_S_OK. Also verify that after the call every lphRecipientJobs2[i]!=NULL and every lphRecipientJobs2[i]==lphRecipientJobs[i]. Similarly verify that * lphParentJob2!=NULL and * lphParentJob2==* lphParentJob. Branding Test Case   FaxDevSendEx of an EFSP that supports branding correctlly renders the fax This test case verifies that an Extended Fax Service Provider DLL that supports branding has implemented FaxDevSendEx to correctlly render the fax.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, TRUE, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Verify that the rendered fax has the correct branding on the rendered cover page and on every page of the document body. Invoke FaxDevSendEx, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, FALSE, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Verify that the rendered fax does not contain branding (not on the cover page and not on the document body). Test Case   FaxDevSendEx of an EFSP that does not support branding correctlly renders the fax This test case verifies that an Extended Fax Service Provider DLL that does not support branding has implemented FaxDevSendEx to correctlly render the fax.  Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, TRUE, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Verify that the rendered fax has the correct branding on the rendered cover page only and that the document body is unchanged. Invoke FaxDevSendEx, as follows: HRESULT hr2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, FALSE, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Verify that the rendered fax does not contain branding (not on the cover page and not on the document body). API Sequence The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented the APIs according to their cross-dependencies as documented in NT5 Fax SDK and in  Comet Fax Service   Extended Fax Service Provider Interface . The tests also attempt to reveal any implicit inter-dependencies wrongfully imposed by the implementation. EFSP Initialization Sequence Test case   FaxDevEnumerateDevices may be invoked again any time after a successful initialization sequence [TBD]  FSPI_MSG_VIRTUAL_DEVICE_LIST_CHANGED is not supported in this release.  That is, FaxDevEnumerateDevices will be invoked only once during service start. Send \ Receive Sequence (FSP and EFSP) Test case   FaxDevEndJob of job in non-final state should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevEndJob to succeed when invoked on a job which is in a non-final state.  Scenario  For an EFSP  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface For an FSP  Invoke FaxDevStartJob and FaxDevSend, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback ); Where, all the parameters of FaxDevStartJob and FaxDevSend are valid as documented in the  NT5 Fax SDK For an EFSP  Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the send job begins execution and that the job is in a non-final state. For an FSP  Verify that FaxDevStartJob sets the above fRetVal1to TRUE and that FaxDevSend begins execution. Also verify that the send job is in a non-final state. While the send job is still executing, invoke FaxDevEndJob, as follows: BOOL fRetVal3 = FaxDevEndJob( FaxHandle );    Where, for an FSP FaxHandle is the handle received from FaxDevStartJob above,  and for an EFSP FaxHandle = lphRecipientJobs[0] from the above FaxDevSendEx. Verify that FaxDevEndJob sets the above fRetVal3 to TRUE. When the Comet Fax Service calls the FaxDevEndJob API for a job that is in a non-finite state, the Comet Fax Service is indicating that it is no longer interested in the job and that the Fax Service Provider or Extended Fax Service Provider should dealocate all resources related to this job. Specifically, the Fax Service Provider or Extended Fax Service Provider should no longer report anything relating to this job to the Comet Fax Service. Test case   FaxDevAbortOperation of job in final state should fail. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to fail when invoked on a job which is in a final state.  Scenario  For an EFSP  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface For an FSP  Invoke FaxDevStartJob and FaxDevSend, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback ); Where, all the parameters of FaxDevStartJob and FaxDevSend are valid as documented in the  NT5 Fax SDK For an EFSP  Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that the send job begins execution, completes successfully and that the job is in a final state (FSPI_JS_COMPLETED). For an FSP  Verify that FaxDevStartJob sets the above fRetVal1to TRUE and that FaxDevSend sets the above fRetVal2 to TRUE. Also verify that the send job has completed successfully and that the job is in a final state (FS_COMPLETED). Invoke FaxDevAbortOperation, as follows: BOOL fRetVal3 = FaxDevAbortOperation( FaxHandle );    Where, for an FSP FaxHandle is the handle received from FaxDevStartJob above,  and for an EFSP FaxHandle = lphRecipientJobs[0] from the above FaxDevSendEx. Verify that FaxDevAbortOperation sets the above fRetVal3 to FALSE. API Concurrency The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented the APIs in a manner that enables invoking them concurrently as documented in the NT5 Fax SDK and in the  Comet Fax Service   Extended Fax Service Provider Interface Common APIs Test case   concurrent calls to FaxDevAbortOperation with same job handle, all calls should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to function correctly when invoked concurrently with the same job handle.  Scenario  For an EFSP  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface For an FSP  Invoke FaxDevStartJob and FaxDevSend, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback ); Where, all the parameters of FaxDevStartJob and FaxDevSend are valid as documented in the  NT5 Fax SDK For an EFSP  Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. For an FSP  Verify that FaxDevStartJob sets the above fRetVal1to TRUE and that FaxDevSend begins execution. While the above send job is in progress, concurrently invoke 5 instances of FaxDevAbortOperation, as follows: BOOL fRetVal2 = FaxDevAbortOperation( FaxHandle );  //instance 1 BOOL fRetVal3 = FaxDevAbortOperation( FaxHandle );  //instance 2 BOOL fRetVal4 = FaxDevAbortOperation( FaxHandle );  //instance 3 BOOL fRetVal5 = FaxDevAbortOperation( FaxHandle );  //instance 4 BOOL fRetVal6 = FaxDevAbortOperation( FaxHandle );  //instance 5 Where, for an FSP FaxHandle is the handle received from FaxDevStartJob above,  and for an EFSP FaxHandle = lphRecipientJobs[0] from the above FaxDevSendEx. Verify that all of  fRetVal2 to fRetVal6 are set to TRUE. Also verify that the above send job is aborted. Test case   call to FaxDevAbortOperation before FaxDevReceive of same job handle starts execution, should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to function correctly when invoked before FaxDevReceive for the same job handle has been called.  Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); Where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets the above fRetVal1to TRUE. Invoke FaxDevAbortOperation, as follows: BOOL fRetVal2 = FaxDevAbortOperation( FaxHandle );  Where, FaxHandle is the handle received from FaxDevStartJob above. Verify that fRetVal2 is set to TRUE and that the above receive job is aborted. Test case   call to FaxDevAbortOperation while FaxDevReceive of same job handle is executing should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to function correctly when invoked while FaxDevReceive with the same job handle is executing.  Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); Where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets the above fRetVal1to TRUE. Invoke FaxDevReceive, as follows:  BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive ); Where, FaxHandle is the job handle from the above call to FaxDevStartJob. And where, all the other parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive begins execution. While the above receive job is in progress, concurrently invoke 5 instances of FaxDevAbortOperation, as follows: BOOL fRetVal2 = FaxDevAbortOperation( FaxHandle );  //instance 1 BOOL fRetVal3 = FaxDevAbortOperation( FaxHandle );  //instance 2 BOOL fRetVal4 = FaxDevAbortOperation( FaxHandle );  //instance 3 BOOL fRetVal5 = FaxDevAbortOperation( FaxHandle );  //instance 4 BOOL fRetVal6 = FaxDevAbortOperation( FaxHandle );  //instance 5 Where, FaxHandle is the handle received from FaxDevStartJob above. Verify that only one of  fRetVal2 to fRetVal6 are set to TRUE and all the others are set to FALSE. Also verify that the above receive job is aborted. Test case   call to FaxDevAbortOperation while FaxDevEndJob of same job handle is executing should fail. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevAbortOperation to function correctly when invoked while FaxDevEndJob with the same job handle is executing.  Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey ); Where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets the above fRetVal1to TRUE. Invoke FaxDevReceive, as follows:  BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive ); Where, FaxHandle is the job handle from the above call to FaxDevStartJob. And where, all the other parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive completes successfully. Invoke FaxDevEndJob, as follows: BOOL fRetVal3 = FaxDevEndJob( FaxHandle );  Where, FaxHandle is the handle received from FaxDevStartJob above. Verify that FaxDevEndJob begins execution. Verify that fRetVal3 is set to TRUE and that the above receive job is aborted. While FaxDevEndJob is executing, invoke FaxDevAbortOperation, as follows: BOOL fRetVal4 = FaxDevAbortOperation( FaxHandle );  Where, FaxHandle is the handle received from FaxDevStartJob above. Verify that above fRetVal4 is set to FALSE and that the above fRetVal3 is set to TRUE. That is, the receive job completes successfully (it is not aborted). Test case   concurrent calls to FaxDevStartJob on different devices, all calls should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevStartJob to function correctly when invoked concurrently on all devices.  Scenario  Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Test case   concurrent calls to FaxDevReceive with different job handles on different devices, all calls should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevReceive to function correctly when invoked concurrently on all devices.  Scenario  Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevReceive, as follows: BOOL fRetVal_01 = FaxDevReceive( FaxHandle_1, CallHandle_1, FaxReceive_1 );  //instance 1 BOOL fRetVal_02 = FaxDevReceive( FaxHandle_2, CallHandle_2, FaxReceive_2 );  //instance 2 BOOL fRetVal_0n = FaxDevReceive( FaxHandle_n, CallHandle_n, FaxReceive_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive sets all the above fRetVal_01 to fRetVal_0n to TRUE. And that all faxes are successfully received. Test case   concurrent calls to FaxDevEndJob with different job handles, all calls should succeed. This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxDevEndJob to function correctly when invoked concurrently on all devices.  Scenario  Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevReceive, as follows: BOOL fRetVal_01 = FaxDevReceive( FaxHandle_1, CallHandle_1, FaxReceive_1 );  //instance 1 BOOL fRetVal_02 = FaxDevReceive( FaxHandle_2, CallHandle_2, FaxReceive_2 );  //instance 2 BOOL fRetVal_0n = FaxDevReceive( FaxHandle_n, CallHandle_n, FaxReceive_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive sets all the above fRetVal_01 to fRetVal_0n to TRUE. And that all faxes are successfully received. Concurrently invoke n instances of FaxDevReceive, as follows: BOOL fRetVal_001 = FaxDevEndJob( FaxHandle_1 );   //instance 1 BOOL fRetVal_002 = FaxDevEndJob( FaxHandle_2 );   //instance 2 BOOL fRetVal_00n = FaxDevEndJob( FaxHandle_n );   //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevEndJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevEndJob sets all the above fRetVal_001 to fRetVal_00n to TRUE. And that all jobs are successfully ended. Test case   For a Virtual FSP or Virtual EFSP, concurrent calls to LineCallbackFunction should succeed. This test case verifies that a Virtual Fax Service Provider DLL or a Virtual Extended Fax Service Provider DLL has implemented FaxDevEndJob to function correctly when invoked concurrently on all devices.  Scenario  Concurrently invoke n instances of LineCallbackFunction, as follows: LineCallbackFunction( NULL, DeviceId_1, LINE_DEVSPECIFIC, 0, 1, 1, 0 );   //instance 1 LineCallbackFunction( NULL, DeviceId_2, LINE_DEVSPECIFIC, 0, 1, 1, 0 );   //instance 2 LineCallbackFunction( NULL, DeviceId_n, LINE_DEVSPECIFIC, 0, 1, 1, 0 );   //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that all n instances of LineCallbackFunction successfully execute. Also verify that all the devices of the Fax Service Provider or the Extended Fax Service Provider, are send and receive enabled.  Concurrently invoke n instances of LineCallbackFunction, as follows: LineCallbackFunction( NULL, DeviceId_1, LINE_DEVSPECIFIC, 0, 0, 0, 0 );   //instance 1 LineCallbackFunction( NULL, DeviceId_2, LINE_DEVSPECIFIC, 0, 0, 0, 0 );   //instance 2 LineCallbackFunction( NULL, DeviceId_n, LINE_DEVSPECIFIC, 0, 0, 0, 0 );   //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that all n instances of LineCallbackFunction successfully execute. Also verify that all the devices of the Fax Service Provider or the Extended Fax Service Provider, are send and receive disabled. Concurrently invoke n instances of LineCallbackFunction, as follows: LineCallbackFunction( NULL, DeviceId_1, LINE_DEVSPECIFIC, 0, 1, 1, 0 );   //instance 1 LineCallbackFunction( NULL, DeviceId_2, LINE_DEVSPECIFIC, 0, 1, 1, 0 );   //instance 2 LineCallbackFunction( NULL, DeviceId_n, LINE_DEVSPECIFIC, 0, 1, 1, 0 );   //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that all n instances of LineCallbackFunction successfully execute. Also verify that all the devices of the Fax Service Provider or the Extended Fax Service Provider, are send and receive enabled. FSP APIs Test case   concurrent calls to FaxDevSend with different job handles on different devices, all calls should succeed. This test case verifies that a Fax Service Provider DLL has implemented FaxDevSend to function correctly when invoked concurrently on all devices.  Scenario  Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2 = FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevSend, as follows: BOOL fRetVal_01 = FaxDevSend( FaxHandle_1, FaxSend_1, FaxSendCallback_1 );  //instance 1 BOOL fRetVal_02 = FaxDevSend( FaxHandle_2, FaxSend_2, FaxSendCallback_2 );  //instance 2 BOOL fRetVal_0n = FaxDevSend( FaxHandle_n, FaxSend_n, FaxSendCallback_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider. And where, all the parameters of FaxDevSendJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevSendJob sets all the above fRetVal_01 to fRetVal_0n to TRUE. Also verify, that all the faxes are successfully sent. Test case   concurrent calls to FaxDevReportStatus with different job handles, all calls should succeed. This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to function correctly when invoked concurrently on different job handles.  Scenario  Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2 = FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevSend, as follows: BOOL fRetVal_01 = FaxDevSend( FaxHandle_1, FaxSend_1, FaxSendCallback_1 );  //instance 1 BOOL fRetVal_02 = FaxDevSend( FaxHandle_2, FaxSend_2, FaxSendCallback_2 );  //instance 2 BOOL fRetVal_0n = FaxDevSend( FaxHandle_n, FaxSend_n, FaxSendCallback_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider. And where, all the parameters of FaxDevSendJob are valid as documented in the  NT5 Fax SDK Verify that all above calls to FaxDevSend begin execution. While all above calls to FaxDevSend are still executing, concurrently invoke n instances of FaxDevReportStatus, as follows: BOOL fRetVal_001 = FaxDevReportStatus( FaxHandle_1, FaxStatus_1, FaxStatusSize_1, FaxStatusSizeRequired_1 );   //instance 1 BOOL fRetVal_002 = FaxDevReportStatus( FaxHandle_2, FaxStatus_2, FaxStatusSize_2, FaxStatusSizeRequired_2 );   //instance 2  BOOL fRetVal_00n = FaxDevReportStatus( FaxHandle_n, FaxStatus_n, FaxStatusSize_n, FaxStatusSizeRequired_n );   //instance n Where, n is the number of devices exported by the Fax Service Provider. And where, all the parameters of FaxDevReportStatus are valid as documented in the  NT5 Fax SDK Verify that FaxDevReportStatus sets all the above fRetVal_001 to fRetVal_00n to TRUE. Also verify, that all the above calls return a valid FaxStatus. Verify that all the faxes are successfully sent. Test case   concurrent calls to FaxDevReportStatus with same job handle, all calls should succeed. This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to function correctly when invoked concurrently with the same job handle.  Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob(LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Invoke FaxDevSend, as follows: BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallbac );  Where, FaxHandle is the job handle from the above call to FaxDevStartJob. And where, all the other parameters of FaxDevSendJob are valid as documented in the  NT5 Fax SDK Verify that the above call to FaxDevSend begins execution. While the above call to FaxDevSend is still executing, concurrently invoke n instances of FaxDevReportStatus, as follows: BOOL fRetVal_01 = FaxDevReportStatus( FaxHandle, FaxStatus_1, FaxStatusSize_1, FaxStatusSizeRequired_1 );   //instance 1 BOOL fRetVal_02 = FaxDevReportStatus( FaxHandle, FaxStatus_2, FaxStatusSize_2, FaxStatusSizeRequired_2 );   //instance 2  BOOL fRetVal_0n = FaxDevReportStatus( FaxHandle, FaxStatus_n, FaxStatusSize_n, FaxStatusSizeRequired_n );   //instance n Where, n is the number of devices exported by the Fax Service Provider. And where, all the parameters of FaxDevReportStatus are valid as documented in the  NT5 Fax SDK Verify that FaxDevReportStatus sets all the above fRetVal_01 to fRetVal_0n to TRUE. Also verify, that all the above calls return a valid FaxStatus. Verify that all the faxes are successfully sent. EFSP APIs Test case   concurrent calls to FaxDevSendEx on different devices, all calls should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to function correctly when invoked concurrently on all exported devices.  Concurrently invoke n instances of FaxDevSendEx, as follows: HRESULT hr_1 = FaxDevSendEx( hTapiLine_1, dwDeviceId_1, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_1, lphRecipientJobs_1, lpParentMessageId_1, lphParentJob_1 );  //instance 1 HRESULT hr_2 = FaxDevSendEx( hTapiLine_2, dwDeviceId_2, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_2, lphRecipientJobs_2, lpParentMessageId_2, lphParentJob_2 );  //instance 2 HRESULT hr_n = FaxDevSendEx( hTapiLine_n, dwDeviceId_n, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_n, lphRecipientJobs_n, lpParentMessageId_n, lphParentJob_n );  //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets all above hr_1 to hr_n to FSPI_S_OK. Also verify that all faxes are successfully sent. Test case   on EFSP that supports FSPI_CAP_MULTISEND, all concurrent calls to FaxDevSendEx on same device should succeed. This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND has implemented FaxDevSendEx to function correctly when invoked concurrently on the same device.  Concurrently invoke 3 instances of FaxDevSendEx, as follows: HRESULT hr_1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_1, lphRecipientJobs_1, lpParentMessageId_1, lphParentJob_1 );  //instance 1 HRESULT hr_2 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_2, lphRecipientJobs_2, lpParentMessageId_2, lphParentJob_2 );  //instance 2 HRESULT hr_3 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_3, lphRecipientJobs_3, lpParentMessageId_3, lphParentJob_3 );  //instance 3  Where all instances are invoked with the same hTapiLine and dwDeviceId values. And where, all the parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets all above hr_1 to hr_n to FSPI_S_OK. Also verify that all faxes are successfully sent. Test case   concurrent calls to FaxDevReportStatusEx with different job handles, all calls should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReportStatusEx to function correctly when invoked concurrently with different job handles.  Concurrently invoke n instances of FaxDevSendEx, as follows: HRESULT hr_1 = FaxDevSendEx( hTapiLine_1, dwDeviceId_1, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_1, lphRecipientJobs_1, lpParentMessageId_1, lphParentJob_1 );  //instance 1 HRESULT hr_2 = FaxDevSendEx( hTapiLine_2, dwDeviceId_2, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_2, lphRecipientJobs_2, lpParentMessageId_2, lphParentJob_2 );  //instance 2 HRESULT hr_n = FaxDevSendEx( hTapiLine_n, dwDeviceId_n, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_n, lphRecipientJobs_n, lpParentMessageId_n, lphParentJob_n );  //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets all above hr_1 to hr_n to FSPI_S_OK. Concurrently invoke n instances of FaxDevReportStatusEx, as follows: HRESULT hr_01 = FaxDevReportStatusEx( lphRecipientJobs_1[0], lpStatus_1, dwStatusSize, lpdwRequiredStatusSize );   //instance 1 HRESULT hr_02 = FaxDevReportStatusEx( lphRecipientJobs_2[0], lpStatus_2, dwStatusSize, lpdwRequiredStatusSize );   //instance 2 HRESULT hr_0n = FaxDevReportStatusEx( lphRecipientJobs_1[0], lpStatus_n, dwStatusSize, lpdwRequiredStatusSize );   //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, lphRecipientJobs_1[0 ] to lphRecipientJobs_n[0] are the job handles returned from the corresponding FaxDevSendEx calls above. And where, all the other parameters of FaxDevReportStatusEx are valid as documented in the  NT5 Fax SDK Verify that FaxDevReportStatusEx sets the above hr_01 to hr_0n to FSPI_S_OK. Also verify that lpStatus_1 to lpStatus_n are all set to indicate valid statuses. Verify that all the faxes are successfully sent. Test case   concurrent calls to FaxDevReportStatusEx with same job handle, all calls should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReportStatusEx to function correctly when invoked concurrently with different job handles.  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets all above hr1 to FSPI_S_OK. Concurrently invoke n instances of FaxDevReportStatusEx, as follows: HRESULT hr_01 = FaxDevReportStatusEx( lphRecipientJobs[0], lpStatus_1, dwStatusSize, lpdwRequiredStatusSize );   //instance 1 HRESULT hr_02 = FaxDevReportStatusEx( lphRecipientJobs[0], lpStatus_2, dwStatusSize, lpdwRequiredStatusSize );   //instance 2 HRESULT hr_0n = FaxDevReportStatusEx( lphRecipientJobs[0], lpStatus_n, dwStatusSize, lpdwRequiredStatusSize );   //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, lphRecipientJobs[0 ] is the first recipient job handle returned from the above FaxDevSendEx call. And where, all the other parameters of FaxDevReportStatusEx are valid as documented in the  NT5 Fax SDK Verify that FaxDevReportStatusEx sets the above hr_01 to hr_0n to FSPI_S_OK. Also verify that lpStatus_1 to lpStatus_n are all set to indicate valid statuses. Verify that all the faxes are successfully sent. Test case   concurrent calls to FaxDevReestablishJobContext with different message ids, all calls should succeed. This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment, has implemented FaxDevReestablishJobContext to function correctly when invoked concurrently with different message ids.  Concurrently invoke n instances of FaxDevSendEx, as follows: HRESULT hr_1 = FaxDevSendEx( hTapiLine_1, dwDeviceId_1, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_1, lphRecipientJobs_1, lpParentMessageId_1, lphParentJob_1 );  //instance 1 HRESULT hr_2 = FaxDevSendEx( hTapiLine_2, dwDeviceId_2, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_2, lphRecipientJobs_2, lpParentMessageId_2, lphParentJob_2 );  //instance 2 HRESULT hr_n = FaxDevSendEx( hTapiLine_n, dwDeviceId_n, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_n, lphRecipientJobs_n, lpParentMessageId_n, lphParentJob_n );  //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets all above hr_1 to hr_n to FSPI_S_OK.  Also verify that after the call every lpRecipientMessageIds[i]!=NULL and contains a valid recipient message id. And that *lpParentMessageId!=NULL and contains a valid parent message id Concurrently invoke n instances of FaxDevReestablishJobContext, as follows: HRESULT hr_01 = FaxDevReestablishJobContext( hTapiLine_1, dwDeviceId_1, lpcParentMessageId_1, lphParentJob_01, dwNumRecipients, lpcRecipientMessageIds_1, lphRecipientJobs_01 ); //instance 1  HRESULT hr_02 = FaxDevReestablishJobContext( hTapiLine_2, dwDeviceId_2, lpcParentMessageId_2, lphParentJob_02, dwNumRecipients, lpcRecipientMessageIds_2, lphRecipientJobs_02 ); //instance 2  HRESULT hr_0n = FaxDevReestablishJobContext( hTapiLine_n, dwDeviceId_n, lpcParentMessageId_n, lphParentJob_0n, dwNumRecipients, lpcRecipientMessageIds_n, lphRecipientJobs_0n ); //instance n  Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReestablishJobContext sets hr_01 to hr_0n to FSPI_S_OK. Also verify that it sets lphParentJob_01 to lphParentJob_0n to valid parent job handles, and lphRecipientJobs_01 to lphRecipientJobs_0n to valid arrays of dwNumRecipients valid recipient job handles. Verfiy that all faxes are successfully sent. Test case   concurrent calls to FaxDevGetLogData, all calls should succeed. [TBD] FaxDevGetLogData is not supported in this release. Test case   shutdown while FaxDevStartJob is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevShutdown to function correctly when invoked while FaxDevStartJob is executing.  Note   after a call to FaxDevShutdown it should be safe to unload the EFSP DLL. Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that all above instances of FaxDevStartJob begin execution. While all instances of FaxDevStartJob are still executing invoke FaxDevShutdown, as follows: HRESULT hr1 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr1 to FSPI_S_OK. Also verify that all the above instances of FaxDevStartJob return before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevReceive is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevShutdown to function correctly when invoked while FaxDevReceive is executing.  Note   after a call to FaxDevShutdown it should be safe to unload the EFSP DLL. Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevReceive, as follows: BOOL fRetVal_01 = FaxDevReceive( FaxHandle_1, CallHandle_1, FaxReceive_1 );  //instance 1 BOOL fRetVal_02 = FaxDevReceive( FaxHandle_2, CallHandle_2, FaxReceive_2 );  //instance 2 BOOL fRetVal_0n = FaxDevReceive( FaxHandle_n, CallHandle_n, FaxReceive_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that all above instances of FaxDevReceive begin execution. While all instances of FaxDevReceive are still executing invoke FaxDevShutdown, as follows: HRESULT hr1 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr1 to FSPI_S_OK. Also verify that all the above instances of FaxDevReceive return before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevEndJob is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevShutdown to function correctly when invoked while FaxDevEndJob is executing.  Note   after a call to FaxDevShutdown it should be safe to unload the EFSP DLL. Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevReceive, as follows: BOOL fRetVal_01 = FaxDevReceive( FaxHandle_1, CallHandle_1, FaxReceive_1 );  //instance 1 BOOL fRetVal_02 = FaxDevReceive( FaxHandle_2, CallHandle_2, FaxReceive_2 );  //instance 2 BOOL fRetVal_0n = FaxDevReceive( FaxHandle_n, CallHandle_n, FaxReceive_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that FaxDevReceive sets all the above fRetVal_01 to fRetVal_0n to TRUE. Concurrently invoke n instances of FaxDevEndJob, as follows: BOOL fRetVal_01 = FaxDevEndJob( FaxHandle_1 );  //instance 1 BOOL fRetVal_02 = FaxDevEndJob( FaxHandle_2 );  //instance 2 BOOL fRetVal_0n = FaxDevEndJob( FaxHandle_n );  //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the parameters of FaxDevEndJob are valid as documented in the  NT5 Fax SDK Verify that all above instances of FaxDevEndJob begin execution. While all instances of FaxDevEndJob are still executing invoke FaxDevShutdown, as follows: HRESULT hr1 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr1 to FSPI_S_OK. Also verify that all the above instances of FaxDevEndJob return before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevReportStatusEx is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevShutdown to function correctly when invoked while FaxDevEndJob is executing.  Note   after a call to FaxDevShutdown it should be safe to unload the EFSP DLL. Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Concurrently invoke n instances of FaxDevStartJob, as follows: BOOL fRetVal_1 = FaxDevStartJob(LineHandle_1, DeviceId_1, FaxHandle_1, CompletionPortHandle_1, CompletionKey_1 ); //instance 1 BOOL fRetVal_2= FaxDevStartJob(LineHandle_2, DeviceId_2, FaxHandle_2, CompletionPortHandle_2, CompletionKey_2 ); //instance 2 BOOL fRetVal_n = FaxDevStartJob(LineHandle_n, DeviceId_n, FaxHandle_n, CompletionPortHandle_n, CompletionKey_n ); //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the parameters of FaxDevStartJob are valid as documented in the  NT5 Fax SDK Verify that FaxDevStartJob sets all the above fRetVal_1 to fRetVal_n to TRUE. Concurrently invoke n instances of FaxDevReceive, as follows: BOOL fRetVal_01 = FaxDevReceive( FaxHandle_1, CallHandle_1, FaxReceive_1 );  //instance 1 BOOL fRetVal_02 = FaxDevReceive( FaxHandle_2, CallHandle_2, FaxReceive_2 );  //instance 2 BOOL fRetVal_0n = FaxDevReceive( FaxHandle_n, CallHandle_n, FaxReceive_n );  //instance n Where, n is the number of devices exported by the Fax Service Provider or the Extended Fax Service Provider. And where, all the parameters of FaxDevReceive are valid as documented in the  NT5 Fax SDK Verify that all above instances of FaxDevReceive begin execution. While all instances of FaxDevReceive are still executing, concurrently invoke n instances of FaxDevReportStatusEx, as follows: HRESULT hr_01 = FaxDevReportStatusEx(FaxHandle_1, lpStatus_1, dwStatusSize, lpdwRequiredStatusSize );   //instance 1 HRESULT hr_02 = FaxDevReportStatusEx(FaxHandle_2, lpStatus_2, dwStatusSize, lpdwRequiredStatusSize );   //instance 2 HRESULT hr_0n = FaxDevReportStatusEx(FaxHandle_n, lpStatus_n, dwStatusSize, lpdwRequiredStatusSize );   //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the parameters of FaxDevReportStatusEx are valid as documented in the  NT5 Fax SDK Verify that all above instances of FaxDevReportStatusEx begin execution. While all instances of FaxDevReportStatusEx are still executing invoke FaxDevShutdown, as follows: HRESULT hr1 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr1 to FSPI_S_OK. Also verify that all the above instances of FaxDevEndJob return before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevSendEx is executing should succeed. This test case verifies that an Extended Fax Service Provider has implemented FaxDevShutdown to function correctly when invoked while FaxDevSendEx is executing.  Note   after a call to FaxDevShutdown it should be safe to unload the EFSP DLL. Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Concurrently invoke n instances of FaxDevSendEx, as follows: HRESULT hr_1 = FaxDevSendEx( hTapiLine_1, dwDeviceId_1, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_1, lphRecipientJobs_1, lpParentMessageId_1, lphParentJob_1 );  //instance 1 HRESULT hr_2 = FaxDevSendEx( hTapiLine_2, dwDeviceId_2, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_2, lphRecipientJobs_2, lpParentMessageId_2, lphParentJob_2 );  //instance 2 HRESULT hr_n = FaxDevSendEx( hTapiLine_n, dwDeviceId_n, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds_n, lphRecipientJobs_n, lpParentMessageId_n, lphParentJob_n );  //instance n Where, n is the number of devices exported by the Extended Fax Service Provider. And where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that all above instances of FaxDevSendEx begin execution. While all instances of FaxDevSendEx are still executing invoke FaxDevShutdown, as follows: HRESULT hr1 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr1 to FSPI_S_OK. Also verify that all the above instances of FaxDevSendEx return before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevReestablishJobContext is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment, has implemented FaxDevShutdown to function correctly when invoked while FaxDevReestablishJobContext is executing.  Note   after a call to FaxDevShutdown it should be safe to unload the EFSP DLL. Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, all the other parameters of FaxDevSendEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Also verify that after the call every lpRecipientMessageIds[i]!=NULL and contains a valid recipient message id. And that *lpParentMessageId!=NULL and contains a valid parent message id Concurrently invoke 5 instances of FaxDevReestablishJobContext, as follows: HRESULT hr01 = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob01, dwNumRecipients, lpcRecipientMessageIds, lphRecipientJobs01 );  //instance 1 HRESULT hr02 = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob02, dwNumRecipients, lpcRecipientMessageIds, lphRecipientJobs02 );  //instance 2  HRESULT hr03 = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob03, dwNumRecipients, lpcRecipientMessageIds, lphRecipientJobs03 );  //instance 3  HRESULT hr04 = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob04, dwNumRecipients, lpcRecipientMessageIds, lphRecipientJobs04 );  //instance 4  HRESULT hr05 = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob05, dwNumRecipients, lpcRecipientMessageIds, lphRecipientJobs05 );  //instance 5  Where, lpRecipientMessageIds, lpcParentMessageId, dwNumRecipients and dwDeviceId are from above call to FaxDevSendEx. And where, all the other parameters of FaxDevReestablishJobContext are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that all 5 instances of FaxDevReestablishJobContext begin execution. While all instances of FaxDevReestablishJobContext are still executing invoke FaxDevShutdown, as follows: HRESULT hr3 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr3 to FSPI_S_OK. Also verify that all the above instances of FaxDevReestablishJobContext return before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevGetLogData is executing should succeed. [TBD] FaxDevGetLogData is not supported in this release. Test case   shutdown while FaxDevInitializeEx is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevShutdown to function correctly when invoked while FaxDevInitializeEx is executing. Scenario  Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Invoke FaxDevInitializeEx, as follows: HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the other parameters of FaxDevInitializeEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface While FaxDevInitializeEx is still executing, invoke FaxDevShutdown, as follows: HRESULT hr2 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr2 to FSPI_S_OK. Also verify that all the above call to FaxDevInitializeEx returns before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Test case   shutdown while FaxDevEnumerateDevices is executing should succeed. This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevShutdown to function correctly when invoked while FaxDevEnumerateDevices is executing. Scenario  Your test application should load your EFSP DLL dynamically via a call to the LoadLibrary Win32 API, and retreive all exported functions via appropriate calls to the GetProcAddress Win32 API. Do not statically link the test application with your EFSP DLL. Invoke FaxDevInitializeEx, as follows: HRESULT hr1 = FaxDevInitializeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the other parameters of FaxDevInitializeEx are valid as documented in  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitializeEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevEnumerateDevices, as follows: HRESULT hr2 = FaxDevEnumerateDevices( dwDeviceIdBase, lpdwDeviceCount, NULL );  Where, lpdwDeviceCount is a valid pointer to a DWORD and * lpdwDeviceCount=0. Verify that FaxDevEnumerateDevices sets the above hr2 to FSPI_S_OK. Also verify that * lpdwDeviceCount>0 and  * lpdwDeviceCount<=EFSPI_MAX_DEVICE_COUNT and that it is set to indicate the correct number of devices that the EFSP exports. Invoke FaxDevEnumerateDevices, as follows: HRESULT hr3 = FaxDevEnumerateDevices(dwDeviceIdBase, lpdwDeviceCount, lpDevices );  Where, lpdwDeviceCount is the variable from the previous call.  And where, lpDevices is a valid pointer to an array of *lpdwDeviceCount FSPI_DEVICE_INFO structures where every lpDevices[i].szFriendlyName contains all zeroes and every lpDevices[i].dwId=0. While FaxDevEnumerateDevices is still executing, invoke FaxDevShutdown, as follows: HRESULT hr4 = FaxDevShutdown( ); Verify that FaxDevShutdown sets the above hr4 to FSPI_S_OK. Also verify that all the above call to FaxDevEnumerateDevices returns before the call to FaxDevShutdown does. Immediately after FaxDevShutdown returns, unload your EFSP DLL from the test application using the FreeLibrary Win32 API. Verify that the above call to FreeLibrary returns TRUE and that the DLL is safely unloaded. Low Memory Conditions The following tests strive to verify that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented the APIs to function correctly in low memory conditions. During low memory conditions any allocation request may fail, and thus any number of system calls may also fail. The Fax Service Provider or Extended Fax Service Provider must implement its APIs to detect these errors and handle them correctly. If the API cannot recover from the error it must fail gracefully returning and appropriate error value and setting the last error where required. Please note that if the API s implementation does not allocate any memory, and does not call any other functions, which allocate memory, then the API should not fail under low memory condition. Furthermore, even under low memory conditions some memory allocations may succeed and thus a call to the Fax Service Provider or Extended Fax Service Provider may complete successfully. The test cases below refer to the situations where at least one memory allocation has failed during the execution of an API. If this situation is not encountered when you perform the test case, please repeat the test case until it does.  FSP APIs function in Low Memory Conditions Test case   FSP FaxDevInitalize functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL has implemented FaxDevInitalize to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevInitalize, as follows: BOOL fRetVal = FaxDevInitalize( LineAppHandle, HeapHandle, LineCallbackFunction, FaxServiceCallback );  Where, all the parameters of FaxDevInitalize are valid as documented in the NT5 Fax SDK Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevInitalize sets the above fRetVal to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Test case   Virtual-FSP FaxDevVirtualDeviceCreation functions correctly in low memory conditions This test case verifies that a Virtual Fax Service Provider DLL has implemented FaxDevVirtualDeviceCreation to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevVirtualDeviceCreation, as follows: BOOL fRetVal = FaxDevVirtualDeviceCreation( DeviceCount, DeviceNamePrefix, DeviceIdPrefix, CompletionPort, CompletionKey );  Where, all the parameters of FaxDevVirtualDeviceCreation are valid as documented in the NT5 Fax SDK Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevVirtualDeviceCreation sets the above fRetVal to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Test case   FSP FaxDevSend functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL has implemented FaxDevSend to function correctly in low memory conditions. Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob( LineHandle, DeviceId, &FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Activate a memory-hogging tool. Invoke FaxDevSend, as follows: BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback );  Where, FaxHandle is the job handle from the above FaxDevStartJob call. Where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevSend sets the above fRetVal2 to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Test case   FSP FaxDevReportStatus functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL has implemented FaxDevReportStatus to function correctly in low memory conditions. Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob( LineHandle, DeviceId, &FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Invoke FaxDevSend, as follows: BOOL fRetVal2 = FaxDevSend( FaxHandle, FaxSend, FaxSendCallback );  Where, FaxHandle is the job handle from the above FaxDevStartJob call. Where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK Verify that FaxDevSend sets the above fRetVal2 to TRUE. Invoke FaxDevReportStatus, as follows: BOOL fRetVal3 = FaxDevReportStatus( FaxHandle, NULL, NULL, &FaxStatusSizeRequired1 );  Where, FaxHandle is the job handle from the above FaxDevSend call. Where, all the other parameters of FaxDevReportStatus are valid as documented in the NT5 Fax SDK Verify that FaxDevReportStatus sets the above fRetVal3 to TRUE. Allocate a FAX_DEV_STATUS according to FaxStatusSizeRequired1 from above call to FaxDevReportStatus and set its fields according to the NT5 Fax SDK. Activate a memory-hogging tool. Invoke FaxDevReportStatus, as follows: BOOL fRetVal4 = FaxDevReportStatus( FaxHandle, NULL, NULL, &FaxStatusSizeRequired2 );  Where, FaxHandle is the job handle from the above FaxDevSend call. Where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK Invoke the Win32 API GetLastError, as follows: DWORD dwEC1 = GetLastError(); Invoke FaxDevReportStatus, as follows: BOOL fRetVal5 = FaxDevReportStatus( FaxHandle, FaxStatus, FaxStatusSizeRequired1, &FaxStatusSizeRequired3 );  Where, FaxHandle is the job handle from the above FaxDevSend call. Where, FaxStatus is the FAX_DEV_STATUS structure you allocated in clause 7 and FaxStatusSizeRequired1 is its size. Where, all the other parameters of FaxDevSend are valid as documented in the NT5 Fax SDK Invoke the Win32 API GetLastError, as follows: DWORD dwEC2 = GetLastError(); Deactivate the memory-hogging tool. Examine your FaxDevReportStatus implementation (memory allocations) to determine whether the above calls (at clause 9 and 11) should set the above fRetVal4 and fRetVal5 to FALSE and dwEC1 and dwEC2 to ERROR_NOT_ENOUGH_MEMORY, or if the calls should succeed and set fRetVal4 and fRetVal5 to TRUE. EFSP APIs function in Low Memory Conditions Test case   EFSP FaxDevInitalizeEx functions correctly in low memory conditions This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevInitalizeEx to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevInitalizeEx, as follows: HRESULT hr = FaxDevInitalizeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the parameters of FaxDevInitalizeEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Deactivate the memory-hogging tool. Verify that FaxDevInitalize sets the above hr to FSPI_E_NOMEM. Test case   Virtual EFSP FaxDevEnumerateDevices functions correctly in low memory conditions This test case verifies that a Virtual Extended Fax Service Provider DLL has implemented FaxDevEnumerateDevices to function correctly in low memory conditions. Scenario  Invoke FaxDevInitalizeEx, as follows: HRESULT hr1 = FaxDevInitalizeEx( hFSP, LineAppHandle, LineCallbackFunction, FaxServiceCallbackEx, lpdwMaxMessageIdSize );  Where, all the parameters of FaxDevInitalizeEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevInitalize sets the above hr1 to FSPI_S_OK. Activate a memory-hogging tool. Invoke FaxDevEnumerateDevices, as follows: HRESULT hr2 = FaxDevEnumerateDevices(dwDeviceIdBase, lpdwDeviceCount, lpDevices );  Where, all the parameters of FaxDevEnumerateDevices are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Deactivate the memory-hogging tool. Verify that FaxDevEnumerateDevices sets the above hr2 to FSPI_E_NOMEM. Test case   EFSP FaxDevSendEx functions correctly in low memory conditions This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevSendEx to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevSendEx, as follows: HRESULT hr = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, tmSchedule=0 indicating  And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Deactivate the memory-hogging tool. Verify that FaxDevSendEx sets the above hr to FSPI_E_NOMEM. Test case   EFSP FaxDevReportStatusEx functions correctly in low memory conditions This test case verifies that an Extended Fax Service Provider DLL has implemented FaxDevReportStatusEx to function correctly in low memory conditions. Scenario  Invoke FaxDevSendEx, as follows: HRESULT hr1 = FaxDevSendEx( hTapiLine, dwDeviceId, lpcwstrBodyFileName, lpcCoverPageInfo, bAddBranding, tmSchedule, lpcSenderProfile, dwNumRecipients, lpcRecipientProfiles, lpRecipientMessageIds, lphRecipientJobs, lpParentMessageId, lphParentJob );  Where, tmSchedule=0 indicating  And where, all the other parameters of FaxDevSendEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevSendEx sets the above hr1 to FSPI_S_OK. Invoke FaxDevReportStatusEx, as follows: HRESULT hr2 = FaxDevReportStatusEx( hJob, NULL, NULL, &dwRequiredStatusSize1 );  Where, hJob=lphRecipientJobs[0] the first recipient job handle from the above FaxDevSendEx call. And where, all the other parameters of FaxDevReportStatusEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Verify that FaxDevReportStatusEx sets the above hr2 to FSPI_S_OK. Allocate a FSPI_JOB_STATUS according to dwRequiredStatusSize1 from above call to FaxDevReportStatusEx and set its fields according to the  Comet Fax Service   Extended Fax Service Provider Interface Activate a memory-hogging tool. Invoke FaxDevReportStatusEx, as follows: HRESULT hr3 = FaxDevReportStatusEx( hJob, NULL, NULL, &dwRequiredStatusSize2 ); Where, hJob=lphRecipientJobs[0] the first recipient job handle from the above FaxDevSendEx call. And where, all the other parameters of FaxDevReportStatusEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Invoke FaxDevReportStatusEx, as follows: HRESULT hr4 = FaxDevReportStatusEx( hJob, Status, dwRequiredStatusSize1, &dwRequiredStatusSize2 ); Where, hJob=lphRecipientJobs[0] the first recipient job handle from the above FaxDevSendEx call. Where, Status is the FSPI_JOB_STATUS structure you allocated in clause 5 and dwRequiredStatusSize1 is its size. And where, all the other parameters of FaxDevReportStatusEx are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Deactivate the memory-hogging tool. Examine your FaxDevReportStatusEx implementation (memory allocations) to determine whether the above calls (at clause 7 and 8) should set the above hr3 and hr4 to FSPI_E_NOMEM, or if the calls should succeed and set hr3 and hr4 to FSPI_S_OK. Test case   FaxDevReestablishJobContext of an EFSP that supports job context reestablishment, functions correctly in low memory conditions This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment has implemented FaxDevReestablishJobContext to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevReestablishJobContext, as follows: HRESULT hr = FaxDevReestablishJobContext( hTapiLine, dwDeviceId, lpcParentMessageId, lphParentJob, dwRecipientCount, lpcRecipientMessageIds, lpRecipientJobs );  Where, all the parameters of FaxDevReestablishJobContext are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Deactivate the memory-hogging tool. Verify that FaxDevReestablishJobContext sets the above hr2 to FSPI_E_NOMEM. Test case   EFSP FaxDevGetLogData functions correctly in low memory conditions [TBD] FaxDevGetLogData is not supported in this release. This test case verifies that an Extended Fax Service Provider has implemented FaxDevGetLogData to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevGetLogData, as follows: HRESULT hr = FaxDevGetLogData( hFaxHandle, lppLogData );  Where, all the parameters of FaxDevGetLogData are valid as documented in the  Comet Fax Service   Extended Fax Service Provider Interface Deactivate the memory-hogging tool. Verify that FaxDevGetLogData sets the above hr to FSPI_E_NOMEM. Common APIs function in Low Memory Conditions Test case   FSP FaxDevStartJob functions correctly in low memory conditions This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevStartJob to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob( LineHandle, DeviceId, FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevStartJob sets the above fRetVal to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Test case    FaxDevEndJob functions correctly in low memory conditions This test case verifies that a Fax Service Provider or an Extended Fax Service Provider DLL has implemented FaxDevEndJob to function correctly in low memory conditions. Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob( LineHandle, DeviceId, &FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Invoke FaxDevReceive, as follows: BOOL fRetVal2 = FaxDevReceive ( FaxHandle, CallHandle, FaxReceive );  Where, FaxHandle is the job handle from the above FaxDevStartJob call. Where, all the other parameters of FaxDevReceive are valid as documented in the NT5 Fax SDK Verify that FaxDevReceive sets the above fRetVal2 to TRUE. Activate a memory-hogging tool. Invoke FaxDevEndJob, as follows: BOOL fRetVal3 = FaxDevEndJob( FaxHandle );  Where, FaxHandle is the job handle from the above FaxDevReceive call. Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevEndJob sets the above fRetVal3 to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Note that if your FaxDevEndJob implementation does not allocate any memory (explicitly or implicitly) then instead of failing it should succeed and set the above fRetVal3 to TRUE. Test case   FSP FaxDevAbortOperation functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL has implemented FaxDevAbortOperation to function correctly in low memory conditions. Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob( LineHandle, DeviceId, &FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Invoke FaxDevReceive, as follows: BOOL fRetVal2 = FaxDevReceive( FaxHandle, CallHandle, FaxReceive );  Where, FaxHandle is the job handle from the above FaxDevStartJob call. Where, all the other parameters of FaxDevReceive are valid as documented in the NT5 Fax SDK Verify that FaxDevSend sets the above fRetVal2 to TRUE. Before FaxDevReceive returns  Activate a memory-hogging tool. While FaxDevReceive is still executing  Invoke FaxDevAbortOperation, as follows: BOOL fRetVal3 = FaxDevAbortOperation( FaxHandle );  Where, FaxHandle is the job handle from the above FaxDevReceive call. Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevAbortOperation sets the above fRetVal3 to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Note that if your FaxDevAbortOperation implementation does not allocate any memory (explicitly or implicitly) then instead of failing it should succeed and set the above fRetVal3 to TRUE. Test case   FaxDevReceive functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL has implemented FaxDevReceive to function correctly in low memory conditions. Scenario  Invoke FaxDevStartJob, as follows: BOOL fRetVal1 = FaxDevStartJob( LineHandle, DeviceId, &FaxHandle, CompletionPortHandle, CompletionKey );  Where, all the parameters of FaxDevStartJob are valid as documented in the NT5 Fax SDK. Verify that FaxDevStartJob sets the above fRetVal1 to TRUE. Activate a memory-hogging tool. Invoke FaxDevReceive, as follows: BOOL fRetVal2 = FaxDevReceive ( FaxHandle, CallHandle, FaxReceive );  Where, FaxHandle is the job handle from the above FaxDevStartJob call. Where, all the other parameters of FaxDevReceive are valid as documented in the NT5 Fax SDK Invoke the Win32 API GetLastError, as follows: DWORD dwEC = GetLastError(); Deactivate the memory-hogging tool. Verify that FaxDevReceive sets the above fRetVal2 to FALSE and the last error dwEC to ERROR_NOT_ENOUGH_MEMORY. Test case   FaxExtInitializeConfig functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxExtInitializeConfig to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxExtInitializeConfig, as follows: HRESULT hr1 = FaxExtInitializeConfig(  pGetExtData, pSetExtData, pRegister, pUnregister, pFreeBuffer );  Where, all parameters of FaxExtInitializeConfig are valid as documented in the  Fax Server Extension Configuration Mechanism  document. Deactivate the memory-hogging tool. Verify that FaxExtInitializeConfig sets the above hr1 to E_OUTOFMEMORY. Note - If the implementation of FaxExtInitializeConfig does not perform any allocations then FaxExtInitializeConfig should succeed, and set the above hr1 to NOERROR. Test case   FaxExtConfigChange functions correctly in low memory conditions This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL has implemented FaxExtConfigChange to function correctly in low memory conditions. Scenario  Activate a memory-hogging tool. Invoke FaxExtConfigChange, as follows: HRESULT hr1 = FaxExtConfigChange (  dwDeviceId,lpcwstrDataGUID, lpData, dwDataSize );  Where, all parameters of FaxExtConfigChange are valid as documented in the  Fax Server Extension Configuration Mechanism  document. Deactivate the memory-hogging tool. Verify that FaxExtConfigChange sets the above hr1 to E_OUTOFMEMORY. Note - If the implementation of FaxExtConfigChange does not perform any allocations then FaxExtConfigChange should succeed, and set the above hr1 to NOERROR. Driver Verifier The following tests strive to verify the integrity of drivers that the Fax Service Provider or the Extended Fax Service use and that the Provider handles any possible failures of these drivers correctly. Please note that activating the  Driver Verifier  will effect performance. Third Party Drivers Integrity For a Fax Service Provider or an Extended Fax Service that uses any third party drivers, the integrity of these drivers should be verified. Driver Verifier  tool should be configured as described below, and all the tests in this document should be re-run while the verifier is active. Configuration: Activate verifier.exe In the  Settings  tab select the  Verify selected drivers  radio button,  select the drivers you wish to enable verification for (all the 3rd party drivers your Provider uses), and click the  Verify  button. Also in the  Settings  tab check all the  Verification Type  check boxes, except  Low resources simulation . Also select  I\O verification  Level 2. Reboot the machine. Activate verifier.exe In the  Settings  tab verify that for all the drivers you have previousely selected the  Verification Status  is now set to  Verify Enabled Run all the tests in this document. Handling Third Party and System Drivers Failures For a Fax Service Provider or an Extended Fax Service using any drivers (third party or system), the correct handling of any possible driver failure should be verified. Driver Verifier  tool should be configured as described below, and all the tests in this document should be re-run while the verifier is active. Configuration: Activate verifier.exe In the  Settings  tab select the  Verify selected drivers  radio button,  select the drivers you wish to enable verification for (all the drivers your Provider uses), and click the  Verify  button. Reboot the machine. Activate verifier.exe In the  Settings  tab verify that for all the drivers you have previousely selected the  Verification Status  is now set to  Verify Enabled In the  Volatile Settings  tab check the  Low resources simulation  check box, and click  Apply Run all the tests in this document. As described above the  Driver Verifier  should be configured to enable verification for all the drivers your Provider uses, specific system driver candidates are: serial.sys (the modem driver) tdi.sys, tcpip.sys, ndis.sys and afd.sys (network related drivers). Integration Tests The following Integration Tests invoke the APIs from the Microsoft  Comet Fax Service context. The tests look at the Fax Service Provider or Extended Fax Service Provider as the Comet Fax Service uses it when the Comet Fax Service APIs and UI are activated.  Setup and Configuration The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully  Setup on the Comet Fax Service machine. Configured via the Comet Fax Service Administration Console. Setup Test case   FSP / EFSP setup on server machine fails if service is down This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL setup application fails if the Comet Fax Service is down, on the Comet Fax Service machine. Scenario  Stop the Comet Fax Service. You can stop the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Invoke the setup application for the Fax Service Provider DLL or the Extended Fax Service Provider DLL. Verify that the setup application has fails indicating that the Comet Fax Service is down. The Fax Service Provider or Extended Fax Service Provider setup application should not start or stop the Comet Fax Service. If the Comet Fax Service is down, the setup application should fail indicating that setup requires the Comet Fax Service be started.  The administrator can then start the Comet Fax Service and re-run setup, if he so chooses. Test case   FSP / EFSP is successfully setup on server machine while service is up This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully loaded by the Comet Fax Service after running the DLL s setup application, while the service was up, on the Comet Fax Service machine. Scenario  Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Invoke the setup application for the Fax Service Provider DLL or the Extended Fax Service Provider DLL. Verify that the setup application has completed successfully and has indicated the the changes will come into affect only after the Comet Fax Service is re-started. The Fax Service Provider or Extended Fax Service Provider setup application should not start or stop the Comet Fax Service. Since the current version of Comet Fax Service requires the service be restarted in order for the changes to take affect, the setup application should indicating this upon successful completion.  The administrator can than re-start the Comet Fax Service, if he so chooses. Stop the Comet Fax Service. You can stop the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. While the service is starting,  For an FSP   verify that the Fax Service Provider s FaxDevInitialize API is invoked and completes successfully. For a Virtual FSP   also verify that the Fax Service Provider s FaxDevVirtualDeviceCreation API is also invoked and completes successfully. For an EFSP   verify that the Extended Fax Service Provider s FaxDevInitializeEx API is invoked and completes successfully. For a Virtual EFSP   also verify that the Extended Fax Service Provider s FaxDevEnumerateDevices API is invoked and completes successfully. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Fax Service Provider or the Extended Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Test case   FSP / EFSP is successfully uninstalled from server machine while service is down This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL is successfully uninstalled after running the DLL s uninstall application, while the service was down, on the Comet Fax Service machine. Scenario  Stop the Comet Fax Service. You can stop the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Invoke the uninstall application for the Fax Service Provider DLL or the Extended Fax Service Provider DLL. Verify that the uninstall application has completed successfully. Verify that the Comet Fax Service is stopped. Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. While the service is starting, verify that the Comet Fax Service does not attempt to load the Provider DLL. You can check the Event Viewer for events regarding Fax Service Provider initialization failures. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the Fax Service Provider does not appear under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node. Verify that all Fax Service Provider files, directories and any registry entries have been cleaned up by the uninstall application. Test case   FSP / EFSP cannot be uninstalled from server machine while service is up This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL cannot be uninstalled while the service is up. Scenario  Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. And verify that your Fax Service Provider is successfully loaded. Invoke the uninstall application for the Fax Service Provider DLL or the Extended Fax Service Provider DLL. Verify that the uninstall application fails without performing any uninstall actions. Also verify that an appropriate error message, indicating that it is not possible to uninstall the Fax Service Provider while the Comet Fax Service is running, is generated. Verify that the Comet Fax Service is still started. Active the Comet Fax Administration Tool. Verify that the Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node. Configuration Test case   FSP / EFSP is successfully configured via the local Comet Fax Service Admin Console This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully configured via the local Comet Fax Service Admin Console on the Comet Fax Service machine. Scenario  Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Fax Service Provider or the Extended Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Invoke the Provider Device Properties  MMC Snapin Extension by double clicking on a Provider s device entry. Verify that all of the device settings can be successfully configured. Verify that the UI responds correctly and that the changes affect the behavior of the selected device. Invoke the Provider Provider Properties  MMC Snapin Extension by double clicking on the Provider entry. Verify that all of the global Provider settings can be successfully configured. Verify that the UI responds correctly and that the changes affect the behavior of Provider. Test case   FSP / EFSP is successfully configured via a remote Comet Fax Service Admin Console This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully configured via a remote Comet Fax Service Admin Console (from a Comet Fax Service client machine). Scenario  Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. On a Comet Fax Service client machine (of the above server)  Active the (remote) Comet Fax Administration Tool. Verify that the Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Fax Service Provider or the Extended Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Invoke the Provider Device Properties  MMC Snapin Extension by double clicking on a Provider s device entry. Verify that all of the device settings can be successfully configured. Verify that the UI responds correctly and that the changes affect the behavior of the selected device. Invoke the Provider Provider Properties  MMC Snapin Extension by double clicking on the Provider entry. Verify that all of the global Provider settings can be successfully configured. Verify that the UI responds correctly and that the changes affect the behavior of Provider. Initialization The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully loaded and initialized by the Comet Fax Service. Section   REF _Ref466698640 \w \h  7.2.1  lays out the tests for a Fax Service Provider, while section   REF _Ref466784272 \w \h  7.2.2  does so for an Extended Fax Service Provider. FSP Initialization Test case   FSP is successfully loaded and initialized when there are no modems installed on server machine This test case verifies that a Fax Service Provider DLL is successfully loaded and initialized by the Comet Fax Service when there are no modem devices installed on the server machine. Scenario  Verify that there are no modems installed on the Comet Fax Service machine. Setup and register the Fax Service Provider or Extended Fax Service Provider on the Comet Fax Service machine. Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. While the service is starting, verify that the Fax Service Provider s FaxDevInitialize API is invoked and completes successfully. For a Virtual Fax Service Provider verify that the Fax Service Provider s FaxDevVirtualDeviceCreation API is also invoked and completes successfully. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Test case   FSP is successfully loaded and initialized when there are modems installed on server machine This test case verifies that a Fax Service Provider DLL is successfully loaded and initialized by the Comet Fax Service when there are modem devices installed on the server machine. Scenario  Verify that there are modem devices installed on the Comet Fax Service machine. Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. While the service is starting, verify that the Fax Service Provider s FaxDevInitialize API is invoked and completes successfully. For a Virtual Fax Service Provider verify that the Fax Service Provider s FaxDevVirtualDeviceCreation API is also invoked and completes successfully. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the  Microsoft T30 Telephony Provider  appears under the  Microsoft SBS Fax Server \Device and Providers Device Providers  node. Verify that all the installed modem devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that they are all using the  Microsoft T30 Telephony Provider Stop the Comet Fax Service. Setup and register the Fax Service Provider on the Comet Fax Service machine. Start the Comet Fax Service. Verify that the Comet Fax Service has successfully started. Active the Comet Fax Administration Tool. Verify that the Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Verify that the  Microsoft T30 Telephony Provider  and all its modem devices appear, as before, under the  Microsoft SBS Fax Server Devices and Providers Device Providers  and  Microsoft SBS Fax Server Devices and Providers Devices  nodes. EFSP Initialization Test case   EFSP is successfully loaded and initialized when there are no modems installed on server machine This test case verifies that an Extended Fax Service Provider DLL is successfully loaded and initialized by the Comet Fax Service when there are no modem devices installed on the server machine. Scenario  Verify that there are no modems installed on the Comet Fax Service machine. Setup and register the Extended Fax Service Provider or Extended Fax Service Provider on the Comet Fax Service machine. Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. While the service is starting, verify that the Extended Fax Service Provider s FaxDevInitializeEx API is invoked and completes successfully. For a Virtual Extended Fax Service Provider verify that the Extended Fax Service Provider s FaxDevEnumerateDevices API is also invoked and completes successfully. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the Extended Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Extended Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Test case   EFSP is successfully loaded and initialized when there are modems installed on server machine This test case verifies that an Extended Fax Service Provider DLL is successfully loaded and initialized by the Comet Fax Service when there are modem devices installed on the server machine. Scenario  Verify that there are modem devices installed on the Comet Fax Service machine. Start the Comet Fax Service. You can start the service from the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. While the service is starting, verify that the Extended Fax Service Provider s FaxDevInitializeEx API is invoked and completes successfully. For a Virtual Extended Fax Service Provider verify that the Extended Fax Service Provider s FaxDevEnumerateDevices API is also invoked and completes successfully. Verify that the Comet Fax Service has successfully started. You can see the service s status at the  Computer Management  MMC, under the  Computer Management Services and Applications Services  node. Active the Comet Fax Administration Tool. Verify that the  Microsoft T30 Telephony Provider  appears under the  Microsoft SBS Fax Server \Device and Providers Device Providers  node. Verify that all the installed modem devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that they are all using the  Microsoft T30 Telephony Provider Stop the Comet Fax Service. Setup and register the Extended Fax Service Provider on the Comet Fax Service machine. Start the Comet Fax Service. Verify that the Comet Fax Service has successfully started. Active the Comet Fax Administration Tool. Verify that the Extended Fax Service Provider appears under the  Microsoft SBS Fax Server Devices and Providers Device Providers  node, and that the specified details are correct. Verify that all of the Extended Fax Service Provider devices appear under the  Microsoft SBS Fax Server Devices and Providers Devices  node, and that the specified details are correct. Verify that the  Microsoft T30 Telephony Provider  and all its modem devices appear, as before, under the  Microsoft SBS Fax Server Devices and Providers Device Providers  and  Microsoft SBS Fax Server Devices and Providers Devices  nodes. Sending The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully used by the Comet Fax Service to send faxes. Fax Pages Test case   Single Page Fax without a cover page is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a single page fax without a cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a single page fax (without a cover page) to a single recipient. Verify that the single page fax is successfully sent and reaches its destination. Verify that the original (sent) single page fax TIF image and the received TIF image are identical. Test case   Single Page Fax with a cover page is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a single page fax with a cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a single page fax with a cover page to a single recipient. Verify that the two-page fax (single page plus cover page) is successfully sent and reaches its destination. Verify that the information on the sent cover page is correct. Verify that the original (sent) two-page fax TIF image and the received TIF image are identical. Test case   A Cover page fax is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a cover page fax (just a cover page without a body). Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a cover page fax (without a body file) to a single recipient. Verify that the single page fax is successfully sent and reaches its destination. Verify that the information on the sent cover page is correct. Verify that the original (sent) single page fax TIF image and the received TIF image are identical. Test case   A multiple page fax without a cover page is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a multiple page fax (without a cover page) Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a 7 page fax (without a cover page) to a single recipient. Verify that the 7-page fax is successfully sent and reaches its destination. Verify that the original (sent) 7-page fax TIF image and the received TIF image are identical. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a 137-page fax (without a cover page) to a single recipient. Verify that the 137-page fax is successfully sent and reaches its destination. Verify that the original (sent) 137-page fax TIF image and the received TIF image are identical. Test case   A multiple page fax with a cover page is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a multiple page fax with a cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a 7 page fax with a cover page to a single recipient. Verify that the 8-page fax (7 pages plus cover page) is successfully sent and reaches its destination. Verify that the original (sent) 8-page fax TIF image and the received TIF image are identical. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a 137-page fax with a cover page to a single recipient. Verify that the 138-page fax (137 pages plus cover page) is successfully sent and reaches its destination. Verify that the original (sent) 138-page fax TIF image and the received TIF image are identical. Fax Session Test case   Sending a fax to a busy line  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to attempt to send a fax to a busy line. The attempt should fail indicating that the line was busy. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to send a fax to a single recipient. Where, the recipient phone number is a line that is always busy. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the line was busy. Verify that the call is retried according to retries settings. Verify that all retries also fail indicating busy. Verify that the call then reaches a  Maximum Retries Exceeded  status (and is not retried again). Test case   Sending a fax to a no-answer line  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to attempt to send a fax to a no-answer line. The attempt should fail indicating that there was no answer. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to send a fax to a single recipient. Where, the recipient phone number is a line that will never answer the call. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that there was no answer. Verify that the call is retried according to retries settings. Verify that all retries also fail indicating no answer. Verify that the call then reaches a  Maximum Retries Exceeded  status (and is not retried again). Test case   Sending a fax to a line that will disconnect in the middle of the fax session  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to send a fax to a line, which will disconnect in the middle of the fax session. The attempt should fail indicating that the line was disconnected. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to send a fax to a single recipient. Where, the recipient phone number is a line that will always disconnect in the middle of the fax session. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the call has been disconnected. Verify that the call is retried according to retries settings. Verify that all retries also fail indicating disconnection. Verify that the call then reaches a  Maximum Retries Exceeded  status (and is not retried again). Test case   Sending a fax to a non-fax line that will answer and disconnect This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to attempt to send a fax to a non-fax line, which will answer and then disconnect. The attempt should fail indicating that the line was disconnected. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to send a fax to a single recipient. Where, the recipient phone number is a non-fax line that will always answer the call, wait a few seconds and then disconnect (as when a human answers a line and hears it s a fax). Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the call has been disconnected. Verify that the call is retried according to retries settings. Verify that all retries also fail indicating disconnection. Verify that the call then reaches a  Maximum Retries Exceeded  status (and is not retried again). Test case   Sending a fax when there is no dial tone This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to attempt to send a fax on a phone line that has no dial tone. The attempt should fail indicating that the (sending device s) line has no dial tone. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to send a fax to a single recipient. Where, the sending device s line is unplugged (thus having no dial tone). Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the line has no dial tone. Verify that the call is retried according to retries settings. Verify that all retries also fail indicating disconnection. Verify that the call then reaches a  Maximum Retries Exceeded  status (and is not retried again). Concurrency Test case   Send faxes concurrently on all FSP s or EFSP s devices  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that exports multiple devices, can be used by the Comet Fax Service to successfully send a multiple page fax with a cover page on all the exported devices simultaneously. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure all of the Fax Service Provider or Extended Fax Service Provider devices as send enabled. Simultaneously send a 7 page fax with a cover page using each the Fax Service Provider s or Extended Fax Service Provider s devices. Send the faxes to a single recipient, where each fax is sent to a different phone number (to avoid getting a busy signal). For each of the faxes sent, verify that the 8-page fax (7 pages plus cover page) is successfully sent and reaches its destination. For each of the faxes sent, verify that the original (sent) 8-page fax TIF image and the received TIF image are identical. Test case   Send faxes concurrently using a single EFSP device that supports FSPI_CAP_MULTISEND  This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully send many concurrent multi-page faxes on the same device. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure only one of the Extended Fax Service Provider devices as send enabled (disable send on all other devices). Simultaneously send 5 faxes (each composed of 7 pages and a cover page) using the Extended Fax Service Provider s single send enabled device. Send the faxes to a single recipient, where each fax is sent to a different phone number (to avoid getting a busy signal). Verify that the Extended Fax Service Provider device handles all the faxes simultaneously.  That is, all the simultaneous calls to FaxDevSendEx complete successfully.  Note that the Extended Fax Service Provider is not obligated to actually perform the fax session concurrently. For each of the faxes sent, verify that the 8-page fax (7 pages plus cover page) is successfully sent and reaches its destination. For each of the faxes sent, verify that the original (sent) 8-page fax TIF image and the received TIF image are identical. Test case   Send a fax on an already receiving device of an EFSP that supports FSPI_CAP_MULTISEND This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully send a multiple page fax on a device, while the device is receiving. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as send and receive enabled. Using a different device, send a 5-page fax to Device1above. While Device1 is receiving, send a fax (composed of 7 pages and a cover page) using the Extended Fax Service Provider s Device1 device. Verify that the Extended Fax Service Provider Device1 device sends the fax while it is receiving.  That is, the device handles both the sending and the receiving simultaneously. Verify that the 5-page fax sent to Device1 is successfully received. Verify that the 8-page fax (7 pages plus cover page) is successfully sent and reaches its destination. For each of the faxes, verify that the original (sent) TIF image and the received TIF image are identical. Receiving The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully used by the Comet Fax Service to receive faxes. Fax Pages Test case   Single Page Fax is successfully received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully receive a single page fax. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a single page fax. Verify that the single page fax is successfully received. Verify that the original (sent) single page fax TIF image and the received TIF image are identical. Test case   A multiple page fax is successfully received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully receive a multiple page fax. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a 7 page fax. Verify that the 7-page fax is successfully received. Verify that the original (sent) 7-page fax TIF image and the received TIF image are identical. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a 137-page fax. Verify that the 137-page fax is successfully received. Verify that the original (sent) 137-page fax TIF image and the received TIF image are identical. Fax Session Test case   Receiving a fax from a line that will disconnect before the first page is received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to receive a fax from a line, which will disconnect before the first page of the fax is received. The attempt should fail indicating that the line was disconnected. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a fax from a line that will always disconnect the call before the first page of the fax is received. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the call has been disconnected. Test case   Receiving a fax from a line that will disconnect after the first page is received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to receive a fax from a line, which will disconnect after the first page of the fax is received. The attempt should fail indicating that the line was disconnected, but the information of the received page (or pages) should be preserved. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a fax from a line that will always disconnect the call after the first page of the fax is received. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the call has been disconnected. Verify that the received TIF file, as indicated by the receive job information in the Comet Fax Service inbound queue, exists and is in valid format. Test case   Receiving a non-fax call This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to attempt to receive a non-fax call, where the caller will then disconnect. The attempt should fail indicating that the call was not a fax call. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to receive a non-fax call. Where, the caller will wait a few seconds and then disconnect (as when a human calls a line and hears it s a fax). Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the call was not a fax call. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to attempt to receive a data call.  Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has failed with a status indicating that the call was not a fax call. Concurrency Test case   Receive faxes concurrently on all FSP s or EFSP s devices  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that exports multiple devices, can be used by the Comet Fax Service to successfully receive a multiple page faxes on all the exported devices simultaneously. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure all the Fax Service Provider or Extended Fax Service Provider devices as receive enabled. Simultaneously send a 7 page fax to each of the Fax Service Provider s or Extended Fax Service Provider s devices.  For each of the faxes sent, verify that the 7-page fax is successfully received. For each of the faxes sent, verify that the original (sent) 7-page fax TIF image and the received TIF image are identical. Test case   Receive faxes concurrently using a single EFSP device that supports FSPI_CAP_MULTISEND  This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully receive concurrent multi-page faxes on the same device simultaneously. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices as receive enabled. Simultaneously send 5 faxes (each composed of 7 pages and a cover page) to the Extended Fax Service Provider s single receive enabled device.  Verify that the Extended Fax Service Provider device successfully receives all the faxes simultaneously.  For each of the faxes sent, verify that the 7-page fax is successfully received. For each of the faxes sent, verify that the original (sent) 7-page fax TIF image and the received TIF image are identical. Test case   Receive a fax on an already sending device of an EFSP that supports FSPI_CAP_MULTISEND This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully receive a multiple page fax on a device, while the device is sending. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as send and receive enabled. Using Device1above, send a 5-page fax to a single recipient. While Device1 is sending, receive a fax (composed of 7 pages and a cover page) using the Extended Fax Service Provider s Device1 device. Verify that the Extended Fax Service Provider Device1 device receives the fax while it is sending.  That is, the device handles both the sending and the receiving simultaneously. Verify that the 7-page fax sent to Device1 is successfully received. Verify that the 5-page fax sent from Device1 is successfully sent and reaches its destination. For each of the faxes, verify that the original (sent) TIF image and the received TIF image are identical. Aborting The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully used by the Comet Fax Service to abort both outbound and inbound faxes. Fax Pages Test case   Aborting an inbound fax before the first page is received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an inbound fax before the first page of the fax is received.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a multi-page fax. Before the first page of the fax is received, abort the receive job. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Verify that the receive TIF file used by the receive job is deleted. Test case   Aborting an inbound fax after the first page is received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an inbound fax after the first page of the fax is received.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a multi-page fax. After the first page of the fax is received and before the call completes, abort the receive job. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Verify that the receive TIF file used by the receive job is deleted. Test case   Aborting an inbound fax after the 45th page is received This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an inbound fax after the 45th page of the fax is received.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to receive a 50-page fax. Immediately after the 45th page of the fax is received, abort the receive job. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Verify that the receive TIF file used by the receive job is deleted. Test case   Aborting an inbound fax after N milliseconds This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an inbound fax after N milliseconds from start of call.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure only one of the Fax Service Provider or Extended Fax Service Provider devices as receive enabled. Configure another device as send enabled. Use the  Abort Tool  (as described in the section 9  Test Tools ) to send a fax to your Fax Service Provider or Extended Fax Service Provider receiving device, and abort the job after N milliseconds. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Verify that the receive TIF file used by the receive job is deleted. Use the  Abort Tool  to test aborting a 10-page inbound job with N=0 to 5*60*1000 ms. Test case   Aborting an outbound fax before the first page is sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an outbound fax before the first page of the fax is sent.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a multi-page fax. Before the first page of the fax is sent, abort the send job. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Aborting an outbound fax after the first page is sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an outbound fax after the first page of the fax is sent.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a multi-page fax. After the first page of the fax is sent and before the call completes, abort the send job. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Aborting an outbound fax after the 45th page is sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an outbound fax after the 45th page of the fax is sent.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use one of the Fax Service Provider s or Extended Fax Service Provider s devices to send a 50-page fax. Immediately after the 45th page of the fax is sent, abort the send job. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Aborting an outbound fax after N milliseconds This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL will behave correctly when used by the Comet Fax Service to abort an outbound fax after N milliseconds from start of call.  Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure only one of the Fax Service Provider or Extended Fax Service Provider devices as send enabled. Configure another device as receive enabled. Use the  Abort Tool  (as described in the section 9  Test Tools ) to send a fax using your Fax Service Provider or Extended Fax Service Provider send enabled device, and abort the send job after N milliseconds. Verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Use the  Abort Tool  to test aborting a 10-page outbound job with N=0 to 5*60*1000 ms. Concurrency Test case   Abort multiple inbound jobs simultaneously on all FSP s or EFSP s devices  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that exports multiple devices, can be used by the Comet Fax Service to successfully abort incoming multiple page faxes on all the exported devices simultaneously. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure all the Fax Service Provider or Extended Fax Service Provider devices as receive enabled. Simultaneously receive a 7 page fax on each of the Fax Service Provider s or Extended Fax Service Provider s devices.  While the devices are receiving, simultaneously abort all the inbound (receive) jobs of the Fax Service Provider s or Extended Fax Service Provider s devices.  For each of the incoming faxes, verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Abort multiple inbound jobs simultaneously on a single EFSP device that supports FSPI_CAP_MULTISEND  This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully abort concurrent incoming multi-page faxes on the same device simultaneously. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices as receive enabled. Simultaneously send 5 faxes (each composed of 7 pages and a cover page) to the Extended Fax Service Provider s single receive enabled device.  Verify that the Extended Fax Service Provider device begins receiving all the faxes simultaneously.  While the device is receiving, simultaneously abort all the inbound (receive) jobs on the device.  For each of the incoming faxes, verify that the Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Abort an inbound job on a sending and receiving device of  an EFSP that supports FSPI_CAP_MULTISEND This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully abort an incoming multiple page fax on a device, while the device is sending and receving. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as send and receive enabled. Using Device1above, send a 5-page fax to a single recipient. While Device1 is sending, receive a fax (composed of 7 pages and a cover page) using the Extended Fax Service Provider s Device1 device. Verify that the Extended Fax Service Provider Device1 device begins receiving the fax while it is sending. That is, the device is both sending and receiving simultaneously. While the device is both sending and receiving, abort the inbound (receive) job on the device.  Verify that the Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Abort multiple outbound jobs simultaneously on all FSP s or EFSP s devices  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that exports multiple devices, can be used by the Comet Fax Service to successfully abort outgoing multiple page faxes on all the exported devices simultaneously. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure all the Fax Service Provider or Extended Fax Service Provider devices as send enabled. Simultaneously send a 7 page fax on each of the Fax Service Provider s or Extended Fax Service Provider s devices.  While the devices are sending, simultaneously abort all the outbound (send) jobs of the Fax Service Provider s or Extended Fax Service Provider s devices.  For each of the outgoing faxes, verify that the Fax Service Provider or Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Abort multiple outbound jobs simultaneously on a single EFSP device that supports FSPI_CAP_MULTISEND  This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully abort concurrent outgoing multi-page faxes on the same device simultaneously. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices as send enabled. Simultaneously send 5 faxes (each composed of 7 pages and a cover page) using the Extended Fax Service Provider s single send enabled device.  Verify that the Extended Fax Service Provider device begins sending all the faxes simultaneously.  While the device is sending, simultaneously abort all the outbound (send) jobs on the device.  For each of the outgoing faxes, verify that the Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Test case   Abort an inbound job on a sending and receiving device of  an EFSP that supports FSPI_CAP_MULTISEND This test case verifies that an Extended Fax Service Provider DLL that supports FSPI_CAP_MULTISEND can be used by the Comet Fax Service to successfully abort an outgoing multiple page fax on a device, while the device is sending and receving. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as send and receive enabled. Using Device1above, send a 5-page fax to a single recipient. While Device1 is sending, receive a fax (composed of 7 pages and a cover page) using the Extended Fax Service Provider s Device1 device. Verify that the Extended Fax Service Provider Device1 device begins receiving the fax while it is sending. That is, the device is both sending and receiving simultaneously. While the device is both sending and receiving, abort the outound (send) job on the device.  Verify that the Extended Fax Service Provider reports that the call has been aborted, and discontinues the call. Cover Pages The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be successfully used by the Comet Fax Service to send faxes that contain cover pages. Default Server Cover Pages Test case   Server Cover Page CONFDENT.COV is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using the CONFDENT.COV server cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the CONFDENT.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the CONFDENT.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the CONFDENT.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the CONFDENT.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Test case   Server Cover Page FYI.COV is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using the FYI.COV server cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the FYI.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the FYI.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the FYI.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the FYI.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Test case   Server Cover Page GENERIC.COV is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using the GENERIC.COV server cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the GENERIC.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the GENERIC.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the GENERIC.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the GENERIC.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Test case   Server Cover Page URGENT.COV is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using the URGENT.COV server cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the URGENT.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the URGENT.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the URGENT.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the URGENT.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Personal Cover Pages Test case   Personal Cover Page containing all fields is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using a personal cover page that contains all possible information fields (ALLFIELDS.COV). See section 9  Test Tools  for a description of the ALLFIELDS.COV cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Client Console to add the ALLFIELDS.COV personal cover page that contains all possible information fields - Activate the Comet Fax Service Client Console. Select the  Microsoft SBS Fax Client \Personal cover pages  node. Right click and select  \Existing cover page In the  Browse for Cover Pages  dialog that opens, type the full path to the ALLFIELDS.COV file, and click  Verify that the ALLFIELDS.COV cover page now appears in the right pane. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the ALLFIELDS.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the ALLFIELDS.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the ALLFIELDS.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the ALLFIELDS.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant user information fields, subject and note). Test case   Personal Cover Page containing no fields is successfully sent This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using a personal cover page that contains no information fields (NOFIELDS.COV). See section 9  Test Tools  for a description of the NOFIELDS.COV cover page. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Client Console to add the NOFIELDS.COV personal cover page that contains all possible information fields - Activate the Comet Fax Service Client Console. Select the  Microsoft SBS Fax Client \Personal cover pages  node. Right click and select  \Existing cover page In the  Browse for Cover Pages  dialog that opens, type the full path to the NOFIELDS.COV file, and click  Verify that the NOFIELDS.COV cover page now appears in the right pane. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NOFIELDS.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with no information fields). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NOFIELDS.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with no information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NOFIELDS.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with no information fields). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NOFIELDS.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with no information fields). Test case   Personal Cover Page containing only a subject is successfully sent  This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using a personal cover page that contains only a subject information field (SubjectOnly.COV). Note that the Fax Send Wizard GUI may prevent entering a note if the selected cover page does not contain a note information field. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Client Console to add the SubjectOnly.COV personal cover page that contains all possible information fields - Activate the Comet Fax Service Client Console. Select the  Microsoft SBS Fax Client \Personal cover pages  node. Right click and select  \Existing cover page In the  Browse for Cover Pages  dialog that opens, type the full path to the SubjectOnly.COV file, and click  Verify that the SubjectOnly.COV cover page now appears in the right pane. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the SubjectOnly.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the subject information field). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the SubjectOnly.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the subject information field). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the SubjectOnly.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the subject information field). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the SubjectOnly.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the subject information field). Test case   Personal Cover Page containing only a note is successfully sent   [This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to successfully send a fax using a personal cover page that contains only a note information field (NoteOnly.COV). Note that the Fax Send Wizard GUI may prevent entering a subject if the selected cover page does not contain a subject information field. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Client Console to add the NoteOnly.COV personal cover page that contains all possible information fields - Activate the Comet Fax Service Client Console. Select the  Microsoft SBS Fax Client \Personal cover pages  node. Right click and select  \Existing cover page In the  Browse for Cover Pages  dialog that opens, type the full path to the NoteOnly.COV file, and click  Verify that the NoteOnly.COV cover page now appears in the right pane. Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NoteOnly.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the note information field). Use the Comet Fax Administration Console to configure the Comet Fax User Information so that all user information fields are all non-empty. Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NoteOnly.COV server cover page and enter both a subject line and a note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the note information field). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NoteOnly.COV server cover page and enter a subject line but no note. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the note information field). Use the Fax Send Wizard utility (fxssend.exe) to send a cover page fax via one of the Fax Service Provider s or Extended Fax Service Provider s devices.  In the wizard choose the NoteOnly.COV server cover page and enter a note but no subject line. Send the fax. Verify that the cover page fax is successfully sent. Verify that the original (sent) single page fax TIF image and the received TIF image are identical, and that the cover page was correctly rendered (with the relevant text in the note information field). Shutdown The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can cleanly shutdown when the Comet Fax Service so requests. An Extended Fax Service Provider must perform all necessary cleanup upon a call to its FaxDevShtdown API. A Fax Service Provider must perform all its cleanup in its DllMain function when invoked with dwReason = DLL_PROCESS_DETACH. Section   REF _Ref467649495 \w \h  7.7.1  decribes the test cases common to both Fax Service Providers and Extended Fax Service Providers, section   REF _Ref467649500 \w \h  7.7.1.6  describes the test cases relevant for Extended Fax Service Providers and section   REF _Ref467650166 \w \h  7.7.3  describes the test cases relevant for Fax Service Providers. Common Test case   FSP\EFSP successfully shutsdown while device is sending This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that is used by the Comet Fax Service to send a fax, can successfully shutdown while its device is sending. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as send enabled. Using Device1 above, send a 5-page fax to a single recipient. Verify that Device1 starts sending the fax. While Device1 is still sending, stop the Comet Fax Service. For EFSP only   verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. For FSP only   verify that Device1 terminates the send job. Re-start the Comet Fax Service. Using Device1 again, send a 5-page fax to a single recipient. Verify that the fax is sent successfully. Test case   FSP\EFSP successfully shutsdown while device is receiving This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that is used by the Comet Fax Service to receive a fax, can successfully shutdown while its device is receiving. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as receive enabled. Using Device1 above, receive a 5-page fax. Verify that Device1 starts receiving the fax. While Device1 is still receiving, stop the Comet Fax Service. For EFSP only   verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped and that Device1 terminates the receive job. Re-start the Comet Fax Service. Using Device1 again, receive a 5-page fax. Verify that the fax is received successfully. Test case   FSP\EFSP successfully shutsdown while aborting an outbound job This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that is used by the Comet Fax Service to send a fax, can successfully shutdown while its device is aborting the send job. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as send enabled. Using Device1 above, send a 5-page fax to a single recipient. Verify that Device1 starts sending the fax. Abort the above send job. Verify that Device1 starts aborting the fax. While Device1 is still aborting, stop the Comet Fax Service. For EFSP only   verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. For FSP only    verify that Device1 terminates the send job. Re-start the Comet Fax Service. Using Device1 again, send a 5-page fax to a single recipient. Verify that the fax is sent successfully. Test case   FSP\EFSP successfully shutsdown while aborting an inbound job This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that is used by the Comet Fax Service to receive a fax, can successfully shutdown while its device is aborting the receive job. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as receive enabled. Using Device1 above, receive a 5-page fax. Verify that Device1 starts receiving the fax. Abort the above receive job. Verify that Device1 starts aborting the fax. While Device1 is still aborting, stop the Comet Fax Service. For EFSP only   verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped and that Device1 terminates the receive job. Re-start the Comet Fax Service. Using Device1 again, receive a 5-page fax. Verify that the fax is received successfully. Test case   FSP\EFSP successfully shutsdown while starting a job (FaxDevStartJob) This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that is used by the Comet Fax Service to receive a fax, can successfully shutdown while FaxDevStartJob code is executing. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as receive enabled. Receive a 5-page fax on Device1 above. Verify that the FaxDevStartJob API of the Fax Service Provider or Extended Fax Service Provider is invoked. While FaxDevStartJob is still executing, stop the Comet Fax Service. For EFSP only   verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped and that Device1 terminates the receive job. Re-start the Comet Fax Service. Using Device1 again, receive a 5-page fax. Verify that the fax is received successfully. Test case   FSP\EFSP successfully shutsdown while ending a job (FaxDevEndJob) This test case verifies that a Fax Service Provider DLL or an Extended Fax Service Provider DLL that is used by the Comet Fax Service to send a fax, can successfully shutdown while FaxDevEndJob code is executing. Scenario  Start the Comet Fax Service with the Fax Service Provider or Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as receive enabled. Send a 5-page fax to Device1 above. Verify that Device1 above successfully sends the fax. Verify that the FaxDevEndJob API of the Fax Service Provider or Extended Fax Service Provider is invoked, once the above send job completes. While FaxDevEndJob is still executing, stop the Comet Fax Service. For EFSP only   verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Using Device1 again, send a 5-page fax. Verify that the fax is sent successfully. Test case   EFSP successfully shutsdown while reporting status (FaxDevReportStatusEx) This test case verifies that an Extended Fax Service Provider DLL that is used by the Comet Fax Service to receive a fax, can successfully shutdown while FaxDevReportStatusEx code is executing. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as receive enabled. Receive a 5-page fax on Device1 above. Verify that Device1 above successfully receives the fax. Verify that the FaxDevReportStatusEx API of the Extended Fax Service Provider is invoked. While FaxDevReportStatusEx is still executing, stop the Comet Fax Service. Verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Using Device1 again, receive a 5-page fax. Verify that the fax is received successfully. Test case   EFSP that supports job context reestablishment successfully shutsdown while reestablishing job context (FaxDevReestablishJobContext) This test case verifies that an Extended Fax Service Provider DLL that supports job context reestablishment and is used by the Comet Fax Service can successfully shutdown while its FaxDevReestablishJobContext code is executing. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Extended Fax Service Provider devices (Device1) as receive enabled. Send a 5-page fax on Device1 above. Verify that Device1 above starts sending the fax. While the device is sending, stop the Comet Fax Service. Verify that FaxDevShutdown is invoked and completes successfully. Also verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Verify that the FaxDevReestablishJobContext API of the Extended Fax Service Provider is invoked. While FaxDevReestablishJobContext is still executing, stop the Comet Fax Service again. Verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Verify that the FaxDevReestablishJobContext API of the Extended Fax Service Provider is invoked and completes successfully. Verify that the above (5-page) send job is correctlly reestablished and completes successfully. Using Device1 again, send another 4-page fax. Verify that the fax is sent successfully. Test case   EFSP successfully shutsdown while enumerating devices (FaxDevEnumerateDevices) This test case verifies that an Extended Fax Service Provider DLL can successfully shutdown while FaxDevEnumerateDevices code is executing. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. While the Comet Fax Service is starting and FaxDevEnumerateDevices is executing, stop the Comet Fax Service. Verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Send a fax using one of the Extended Fax Srevice Provider devices. Verify that the fax is sent successfully. Test case   EFSP successfully shutsdown while initializing (FaxDevInitializeEx) This test case verifies that an Extended Fax Service Provider DLL can successfully shutdown while FaxDevInitializeEx code is executing. Scenario  Start the Comet Fax Service with the Extended Fax Service Provider installed and configured. While the Comet Fax Service is starting and FaxDevInitializeEx is executing, stop the Comet Fax Service. Verify that FaxDevShutdown is invoked and completes successfully. Verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Send a fax using one of the Extended Fax Srevice Provider devices. Verify that the fax is sent successfully. Test case   EFSP successfully shutsdown while getting log data (FaxDevGetLogData) [TBD] FaxDevGetLogData is not supported in this release. Test case   FSP successfully shutsdown while reporting status (FaxDevReportStatus) This test case verifies that a Fax Service Provider DLL that is used by the Comet Fax Service to receive a fax, can successfully shutdown while FaxDevReportStatus code is executing. Scenario  Start the Comet Fax Service with the Fax Service Provider installed and configured. Use the Comet Fax Administration Console to configure one of the Fax Service Provider devices (Device1) as receive enabled. Receive a 5-page fax on Device1 above. Verify that Device1 above successfully receives the fax. Verify that the FaxDevReportStatus API of the Fax Service Provider is invoked. While FaxDevReportStatus is still executing, stop the Comet Fax Service. Verify that the Comet Fax Service is stopped. Re-start the Comet Fax Service. Using Device1 again, receive a 5-page fax. Verify that the fax is received successfully. Stress The following tests strive to verify that a Fax Service Provider DLL or an Extended Fax Service Provider DLL can be used by the Comet Fax Service to send, receive and abort faxes under stress conditions. Test case   Many sends receives and aborts on all FSP\EFSP devices simultaneously Use the SendBroadcastFax and Abort tools (described in the Tools section) to perform many send, receive and abort operations simultaneously. Note that you can write a short script that invokes the SendBroadcastFax tool, then sleeps for 2 seconds and then recalls itself. Such a script will allow you to continuously generate send operations. Verify that all sent faxes are successfully sent. Verify that all received faxes are successfully received. Verify that all aborted jobs (whether incoming or outgoing) are successfully terminated. Specific Tests This section describes test areas that pertain to specific Fax Service Provider or Extended Fax Service Provider implementations. The listed test areas may not be relevant to all implementations, and naturally not every possible implementation or test area is covered.  The Fax Service Provider and Extended Fax Service Provider developers should recognize which of the test areas are relevant to their implementation. The developers should also invest time defining other specific test areas (not included here) that their implementation may require testing for, and perform any further testing. The following sub-sections describe considerations in testing several specific Fax Service Provider and Extended Fax Service Provider implementations. Actual test cases are not detailed, as they are implementation dependent. The Fax Service Provider and Extended Fax Service Provider developers should define the specific test cases that their implementation requires. Implementation of the T30 Protocol This sub-section is relevant for any Fax Service Provider or Extended Fax Service Provider that implements the T30 Protocol. Any such Provider should test that its implementation of the T30 Protocol is correct and complete, precisely matching T30 specifications as documented by all T30 ITU-T documents. Some examples of test areas are: Support for sending and receiving faxes via class 1, 2 and 2.0 modems.  Correct implementation of all reported capabilities (in the DIS frame that the Provider sends), such as different transmission rates and schemes, 1D and 2D encoding, different paper length and width, resolution, minimum wait time, etc. Rejection of any attempt by the other side to communicate in a manner that does not match the Provider s reported capabilities. Correct implementation of T30 ECM, if supported, or correctly rejecting any attempt for ECM by the other side, if not supported. Correct handling of carrier dropouts. Note that carrier dropouts are quite common in satellite communications. Correct responses to any T30 violations that the other side may generate. ISDN support. There exist some very helpful tools for testing T30 Protocol implementations, such as: FaxTrace  by Telegra  FaxTrace  uses scripts, to stress the device or network under test with well-defined normal, difficult to handle, and abnormal calls. Website   HYPERLINK http://www.telegra.com  http://www.telegra.com FaxLab  by Genoa Technology (now known as Quality Logic) FaxLab  plays back the behavior of real-world devices.  Website   HYPERLINK http://www.qualitylogic.com  http://www.qualitylogic.com Implementation using a Network This sub-section is relevant for any Fax Service Provider or Extended Fax Service Provider implementation that uses a network. Any such Provider should test that its implementation takes into account any explicit and implicit network dependencies. Some examples of test areas are: Correct behavior over different network platforms and configurations. Behavior under heavy network load. Correct handling of network timeouts. Maintaining network security. Temporary loss of network. Implementation delegating work to another Server This sub-section is relevant for any Fax Service Provider or Extended Fax Service Provider implementation that delegates work to another server. Any such Provider should test that its implementation takes into account any explicit and implicit dependencies on the other server state and configuration. Some examples of test areas are: Correct behavior when the remote server (that work is delegated to) is down. Correct behavior when the remote service goes down in the middle of a session. Correct behavior when the remote server is up but the attempt to connect fails. This may happen due to a bad password, network timeouts, server resources, etc. Support for receiving faxes from the remote server. Security issues on the remote server.  Most importantly fax content confidentiality. User account issues on the remote server. Such as password control, quota, activity reports, cost reports, billing, etc. Remote server support of concurrent sessions. How many concurrent sessions can exist between the Provider and the remote server? How many concurrent sessions will hurt performance? Test Tools In an effort to aid 3rd parties test their Fax Service Provider or Extended Fax Service Provider, MS has made available the tools and files described in this section.  Each of the following sub-sections contains a general description of the specified tool, the location at which it can be found and the recommended context for its use. Please note that MS is not obligated to provide any additional support for these tools and files. FSP Tester The FSP Tester (FspTester.exe) is a stand-alone tool that is independent of the Comet Fax Server product, the tool can be used for testing 3rd party FSPs prior to shipping of the final Fax Server product. The tool invokes the FSPI functions simulating typical scenarios (for example sending a fax, receiving a fax, aborting active jobs, starting new jobs, getting reports on active / non active job status, ending jobs etc) and less-typical scenarios (such as API calls with invalid parameters). This tool can be used for testing the FSPI interface only (and not the EFSPI interface) on Tapi FSPs only, the tool cannot be used for testing FSPs, which support virtual devices. Location:  The tool and all accompanying files are located under the Tools\FspTester directory. This tool is recommended for performing the Component tests detailed in section   REF _Ref473100909 \r \h  , on TAPI FSPs. EFSP Tester The EFSP Tester (EfspTester.exe) is a stand-alone tool that is independent of the Comet Fax Server product, the tool can be used for testing 3rd party EFSPs prior to shipping of the final Fax Server product. The tool invokes the EFSPI functions simulating typical scenarios (for example sending a fax, receiving a fax, aborting active jobs, starting new jobs, getting reports on active / non active job status, ending jobs etc) and less-typical scenarios (such as API calls with invalid parameters). This tool can be used for testing the EFSPI interface only (and not the FSPI interface) on Virtual EFSPs only, the tool cannot be used for testing TAPI EFSPs, which support non-virtual devices. Location:  The tool and all accompanying files are located under the Tools\EfspTester directory. This tool is recommended for performing the Component tests detailed in section   REF _Ref473100909 \r \h  , on Virtual EFSPs. Hogger The Hogger is a command line application that performs a resource-hogging algorithm to emulate a low resource situation. Lack of resources is the most common reason for function failure. Thus the Hogger can be used to check that the code under test correctly handles failures of any functions that it invokes and that it performs correct cleanup when these functions fail.  Hogger algorithm  The hogger can hog a specific resource from a predefined list. The most important is memory, then GDI, disk and registry space. The hogger hogs the resource until that resource is not available to the hogger process anymore, then the hogger sleeps for a predefined period, frees a predefined amount of resources, sleeps for another predefined period, and then starts the hogging process again. This way other processes (including the process under test) will suffer from periodic lack of resources, and therefore API calls will fail at different places in the code under test. Location:  The tool and all accompanying files are located under the Tools\Hogger directory. This tool is recommended for performing the Low Memmory Conditions tests detailed in section   REF _Ref471525193 \r \h  Driver Verifier Driver Verifier  (verifier.exe) is a tool for testing driver integrity, by applying directed pressure on selected drivers. The tool can be used to: Allocate all of a driver s pool allocations from special pool. Provide extreme memory pressure on a specific driver without affecting other drivers and regardless of system memory size. Perform automatic parameter validation on all spinlock, IRQL and pool allocation calls made by the driver. Inject failures into pool allocation requests. Examine all pools being freed to ensure no pending timers are inside the pool allocation. Detect pool leakage. Checking driver unload to catch drivers that unload forgetting to free resources. Location:  The tool can be found in the NT5 system directory (%windir%\system32). As described in section   REF _Ref473100440 \r \h  SendBroadcastFax The SendBroadcastFax (SendBroadcastFax.exe) is a command line utility for sending a broadcast fax via the comet-fax service. ocation:  The tool and all accompanying files are located under the Tools\SendBroadcastFax directory. This tool is recommended for performing the Integration Tests detailed in section   REF _Ref469808749 \r \h  Abort Tool The Abort tool (AbortTest.exe) is a command line utility for testing the abortion of send and receive operations of the comet-fax service. The tool queues a send job (according to the command line parameters) and then waits start_time ms before aborting either the send or the receive job. After sleeping for a minute, the tool queues another send job and waits satrt_time+delta ms before performing another abort. The tool continues to queue and abort at delta ms increments, untill it queues a send job and waits stop_time ms before aborting. After every sanity number of jobs are queued and aborted, the tool performs a sanity check (sending a fax without aborting it). The tool receives the following parameters: server_name  A Comet Fax server name. fax_number  A fax number to send faxes to. document  The name of the document to send. cover_page  The name of the fax cover page to send. abort_receive_job  A flag indicating whether to abort the receive job. start_time The minimum time to wait before starting the abortion operation. stop_time  The maximum time to wait before starting the abortion operation. delta  The delta time increments from start_time to stop_time. sanity The number of aborts after which to perform a sanity check. After every sanity aborts a complete fax send operation will be performed, as a sanity check. Location:  The tool and all accompanying files are located under the Tools\AbortTest directory. This tool is recommended for performing the Integration Tests that deal with aborting jobs as detailed in sections   REF _Ref471535649 \r \h   REF _Ref473082963 \r \h  7.7.1.3  REF _Ref473082973 \r \h  7.7.1.4  and   REF _Ref471535691 \r \h  Cover Pages Arsenal The Cover Page Arsenal is a collection of all sorts of cover pages, variying in paper size, text, fields, orientation etc. The Cover Page Arsenal contains several classes of cover pages:  Empty CP. CP with subject field only. CP with note field only. CP with a subject and a note filed. CP with all possible fields. CP with drawing objects only. CP with many different objects (fields, text, drawings, etc). CP with font that is not available on server. Landscape CPs in all paper sizes. Portrait CPs in all paper sizes. The cover page filenames in the Cover Page Arsenal are in the form Cp_xx*.cov, where xx corresponds to the test classes above. Additional cover pages in arsenal: ALLFIELDS.COV NOFIELDS.COV SubjectOnly.COV NoteOnly.COV SubNote.COV Interesting Cover Pages not in arsenal: CP with 0 margins CP with very large margins CP with 0 top and bottom margins but large left and right margins. CP with large top and bottom margins but 0 left and right margins. CP with very small field size (i.e. every field has room for just 1 char) CP with very large field size (i.e. every field has room for 100 chars, note & subject even more). Existing  server side  SBS CPs. Server side CPs which are provided with CometFax. Personal CPs created on non-NT5 clients. Invalid CPs (e.g. rename a file.doc as file.cov and attempt to use it as a CP). Location:  The Cover Page Arsenal is located under the Tools\CPArsenal directory. This tool is recommended for performing the Integration Tests that deal with cover pages as detailed in section   REF _Ref471617031 \r \h  Extended FSP API Page   PAGE   DATE  01/23/00 EFSP Test Specifications Page   PAGE  Last Modified On:   SAVEDATE  \* MERGEFORMAT  01/21/00 4:02 PM Extended FSP API Page   PAGE   DATE  5/6/99 PAGE \# "'Page: '#' Page: 12  Is this what we are calling it? PAGE \# "'Page: '#' Page: 107  TO DO   if we aren t ready with this yet, then  a drop of this tool ASAP PAGE \# "'Page: '#' Page: 107  TO DO   if we aren t ready with this yet, then  a drop of this tool ASAP ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ {wrmh`\Y vspdXUP ytfZWTNF ~yskfXURF ~vh\YTNF wifa[SEB wtoiaSGD tqlf^VN qeb]WOA zrda\VNF }umeWTOI ~vnfcUROJD |nb_ZTLD ~{vph`XJG spke]OLG zrda\VNF wtoiaSP {seb]WOG qn`TQLF spke]UGD yqiaSPJB }ume]UM wol^RMHB }ume]UME tqlf`XPH ykf`XPH xph`RM? xje_WOG }ugb\TLD |tfc^XPB? {skc[SE {ume]OLGA |tldVSNH {mje_WIFA zrjbZL@ |wqiaYQI ~vhe_WOG? xpb_YQIA xpb_YQIA roiaYQIA |wqiaYQIA |wqiaYQC }ume]UME {seb]WOG }wog_QNKF ~vnf^VNF yqiaYQI }znkhbZRJ }znkc[OC wifa[SK uifa[SKC {mjg[OLGA {skc[SKC {skc[SKC xseb]WOG wogYVQKC yvqkc[SKC wifa[SKC ~vnf^PMHB xjgb\TLD {mje_WOG {sk]ZUOG xjgb\TLD |nkf`XPH {skc`RFC {ume]UME qnic[SKC xph`XPH {seb]WOG {skc[SKC wog_WOG? {skc[MJE tqlgaYQI xupjbZRJB {seb]WOG {skc[SKC }wog_WOG wogYVQKC ~yskc[SKC ~xph`XPH@ xphebZR wtlifZWTOLI zrjbZR hvd5f hvd5f xphc`[XS dh)L5 dhvd5fgH dhvd5fgH hvd5f hvd5f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\faxservertestplan.doc ===
Microsoft Word Document MSWordDoc Word.Document.8INTRODUCTION Title _PID_GUID _PID_HLINKSINTRODUCTION Peter Sugarman Normal.dot micky snir Microsoft Word 8.0@\\HAIPRN\HP LaserJet 8000 Series PCL 6 Ne00: winspool \\HAIPRN\HP LaserJet 8000 Series PCL 6 \\HAIPRN\HP LaserJet 8000 Serie Letter \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:757 \]:763 \]:776 ""\]\]:763 \]:763 \]:776 ""\]:763 \]:776 ""\]:757 \]:763 \]\]:757 \]:763 \]\]:757 \]:763 \]\]:757 \]:763 \]\]:776 "Untitled"\]:763 \]:758 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:757 \]:763 \]:763 \]\]:757 \]:763 \]:763 \]\]:763 \]:758 \\HAIPRN\HP LaserJet 8000 Serie Letter \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:757 \]:763 \]:776 ""\]\]:763 \]:763 \]:776 ""\]:763 \]:776 ""\]:757 \]:763 \]\]:757 \]:763 \]\]:757 \]:763 \]\]:757 \]:763 \]\]:776 "Untitled"\]:763 \]:758 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:763 \]:757 \]:763 \]:763 \]\]:757 \]:763 \]:763 \]\]:763 \]:758Fax Server Test Plan Table of Contents   TOC \o "1-2"  I. INTRODUCTION  GOTOBUTTON _Toc311451806    PAGEREF _Toc311451806  A. Document Purpose  GOTOBUTTON _Toc311451807    PAGEREF _Toc311451807  B. Document Summary  GOTOBUTTON _Toc311451808    PAGEREF _Toc311451808  C. Document History/Revision  GOTOBUTTON _Toc311451809    PAGEREF _Toc311451809  II. BACKGROUND  GOTOBUTTON _Toc311451810    PAGEREF _Toc311451810  A. Product Vision and Goals  GOTOBUTTON _Toc311451811    PAGEREF _Toc311451811  B. Contacts  GOTOBUTTON _Toc311451812    PAGEREF _Toc311451812  C. Location of Pertinent Information  GOTOBUTTON _Toc311451813    PAGEREF _Toc311451813  III. QUALITY OBJECTIVE  GOTOBUTTON _Toc311451814    PAGEREF _Toc311451814  IV. RESPONSIBLE FOR DELIVERABLES  GOTOBUTTON _Toc311451815    PAGEREF _Toc311451815  A. Functional Group Responsibilities  GOTOBUTTON _Toc311451816    PAGEREF _Toc311451816  V. TESTING METHODOLOGY  GOTOBUTTON _Toc311451817    PAGEREF _Toc311451817  A. Overall Strategy  GOTOBUTTON _Toc311451818    PAGEREF _Toc311451818  B. Scope  GOTOBUTTON _Toc311451819    PAGEREF _Toc311451819  VI. TESTING APPROACH  GOTOBUTTON _Toc311451820    PAGEREF _Toc311451820  A. Milestone Process Project Level  GOTOBUTTON _Toc311451821    PAGEREF _Toc311451821  B. Test Documentation  GOTOBUTTON _Toc311451822    PAGEREF _Toc311451822  C. Test Release Procedures  GOTOBUTTON _Toc311451823    PAGEREF _Toc311451823  D. Post-Code Complete (Stabilization)Testing  GOTOBUTTON _Toc311451824    PAGEREF _Toc311451824  E. Automation Strategy  GOTOBUTTON _Toc311451825    PAGEREF _Toc311451825  F. Integration Testing Strategy  GOTOBUTTON _Toc311451826    PAGEREF _Toc311451826  G. API Testing Strategy  GOTOBUTTON _Toc311451827    PAGEREF _Toc311451827  H. Content Testing  GOTOBUTTON _Toc311451828    PAGEREF _Toc311451828  I. Performance (Benchmark) Testing  GOTOBUTTON _Toc311451829    PAGEREF _Toc311451829  J. Out-Of-Memory and Low Memory Testing  GOTOBUTTON _Toc311451830    PAGEREF _Toc311451830  K. Setup Testing Strategy  GOTOBUTTON _Toc311451831    PAGEREF _Toc311451831  L. Configuration Testing  GOTOBUTTON _Toc311451832    PAGEREF _Toc311451832  M. Compatibility Testing - Hardware  GOTOBUTTON _Toc311451833    PAGEREF _Toc311451833  P. Ad Hoc Testing Strategies  GOTOBUTTON _Toc311451836    PAGEREF _Toc311451836  Q. Localization Test Strategy  GOTOBUTTON _Toc311451837    PAGEREF _Toc311451837  R. DBCS Test Strategy  GOTOBUTTON _Toc311451838    PAGEREF _Toc311451838  S. Post Ship Strategy  GOTOBUTTON _Toc311451839    PAGEREF _Toc311451839  T. Beta Strategy  GOTOBUTTON _Toc311451840    PAGEREF _Toc311451840  V. Crippled Version Strategy  GOTOBUTTON _Toc311451842    PAGEREF _Toc311451842  VII. THIRD PARTY DEPENDENCIES  GOTOBUTTON _Toc311451843    PAGEREF _Toc311451843  A. List of Dependencies  GOTOBUTTON _Toc311451844    PAGEREF _Toc311451844  B. Negotiating With A Third Party  GOTOBUTTON _Toc311451845    PAGEREF _Toc311451845  VIII. SCHEDULE  GOTOBUTTON _Toc311451846    PAGEREF _Toc311451846  IX. PERSONNEL/TEST AREAS  GOTOBUTTON _Toc311451847    PAGEREF _Toc311451847  A. Team Structure  GOTOBUTTON _Toc311451848    PAGEREF _Toc311451848  B. Area Breakdown  GOTOBUTTON _Toc311451849    PAGEREF _Toc311451849  C. Interns/Contractors  GOTOBUTTON _Toc311451850    PAGEREF _Toc311451850  X. RESOURCE REQUIREMENTS  GOTOBUTTON _Toc311451851    PAGEREF _Toc311451851  A. Training Requirements  GOTOBUTTON _Toc311451852    PAGEREF _Toc311451852  B. Hardware Requirements  GOTOBUTTON _Toc311451853    PAGEREF _Toc311451853  C. Software Requirements  GOTOBUTTON _Toc311451854    PAGEREF _Toc311451854  D. Office Space Requirements  GOTOBUTTON _Toc311451855    PAGEREF _Toc311451855  XI. BUG PROCESS  GOTOBUTTON _Toc311451856    PAGEREF _Toc311451856  A. Database Administration  GOTOBUTTON _Toc311451857    PAGEREF _Toc311451857  B. Bug Life Cycle  GOTOBUTTON _Toc311451858    PAGEREF _Toc311451858  C. Remote Sites  GOTOBUTTON _Toc311451859    PAGEREF _Toc311451859  XII. METRICS  GOTOBUTTON _Toc311451860    PAGEREF _Toc311451860  A. Essential Standard Metrics  GOTOBUTTON _Toc311451861    PAGEREF _Toc311451861  B. Optional Metrics  GOTOBUTTON _Toc311451862    PAGEREF _Toc311451862  C. Reports  GOTOBUTTON _Toc311451863    PAGEREF _Toc311451863  XIII. RISKS  GOTOBUTTON _Toc311451864    PAGEREF _Toc311451864  A. Risk Areas  GOTOBUTTON _Toc311451865    PAGEREF _Toc311451865  Error! Bookmark not defined. XIV. SHIPPING THE PRODUCT  GOTOBUTTON _Toc311451866    PAGEREF _Toc311451866  A. Ship Criteria  GOTOBUTTON _Toc311451867    PAGEREF _Toc311451867  B. Building Golden Masters And Golden Verification  GOTOBUTTON _Toc311451868    PAGEREF _Toc311451868  C. Versions  GOTOBUTTON _Toc311451869    PAGEREF _Toc311451869  D. Sign Off Requirements  GOTOBUTTON _Toc311451870    PAGEREF _Toc311451870  XV. ARCHIVING  GOTOBUTTON _Toc311451871    PAGEREF _Toc311451871  XVI. GLOSSARY  GOTOBUTTON _Toc311451872    PAGEREF _Toc311451872  INTRODUCTION Document location This document is located on   HYPERLINK \\\\haifaslm\\SLMCOMET\\src\\fax\\faxtest\\docs\\FaxServerTestPlan.doc  \\haifaslm\SLMCOMET\src\fax\faxtest\docs\FaxServerTestPlan.doc Document Purpose A test plan describes the high level strategies and methodologies used to plan, organize and manage testing of a software project at Microsoft. This document contains sufficient detail to be informative for members of the core test team. In addition, the structure is such that any reader can grasp fundamental ideas and processes by skimming the first few pages. Since many sections cannot be written without some discussion and agreement with other functional leads on the project, a test plan often constitutes  the project plan  in the absence of any other. However, the test plan does not describe implementation details of test cases nor technical details of how product features should work. Document Summary The Comet fax server test plan is based on the NT5 fax test plan, but it enhances it a lot with new Comet features and better coverage. Test strategies: Validation. Each operation should be validated by a test. For example all sent faxes are received correctly, and routed accordingly. Massive system and stress tests. Self-host. Traditional   users will send faxes from their workstations, and faxes will be received via our fax server. As printer   people will send faxes to the hard-copy printer via our fax server. Integration with Comet (CRM, admin, logging etc.). API (module) testing. Hardware coverage (server side modems & fax-boards, other side fax devices). Ad hoc testing. NT5 fax test plan (as opposed to Comet fax test plan):   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\testplan.doc  \\nttest\ntct\slm\src\ntfax\specs\testplan.doc Most of the NT5 fax test specs need revisions and enhancements. Common test areas to NT5 fax and Comet fax server: Fax Send Wizard. (Item 4.12 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\faxsend.doc" \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc Fax client API. (Item 4.12 in NT5 test plan: TBD) Fax client COM interface. MAPI fax extension. (Item 4.14 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\mapi.doc" \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Image viewer. MSFAX TIFF tags. (Item 4.16 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\tifftag.doc" \\nttest\ntct\slm\src\ntfax\specs\tifftag.doc Control Panel. (Item 4.10 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\control.doc" \\nttest\ntct\slm\src\ntfax\specs\control.doc Routing. (Item 4.9 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\routing.doc" \\nttest\ntct\slm\src\ntfax\specs\routing.doc Printers preferences. (Item 4.11 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\routing.doc" \\nttest\ntct\slm\src\ntfax\specs\printer.doc Status monitor. (Item 4.13 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\faxstat.doc" \\nttest\ntct\slm\src\ntfax\specs\faxstat.doc Performance counters. (Item 4.15 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\faxperf.doc" \\nttest\ntct\slm\src\ntfax\specs\faxperf.doc Cover page editor. (Item 4.17 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\cpe.doc" \\nttest\ntct\slm\src\ntfax\specs\cpe.doc Test areas that need enhancements from the NT5 fax test plan: Support for fax boards (FSP interface). NT5 fax is a standalone application that supports up to 2 fax devices, so fax board vendors have no opportunity there. The Comet fax server is a server application that should support dozens of fax devices and is a very good opportunity for fax board vendors. There s an important role for program management here, in getting the important fax board vendors to write FSP s for the Comet fax server. We, in turn, need to test these FSPs in order to verify that their quality is good.  TBD: Will we write an acceptance test for 3rd party FSPs? SDK. All clients, server   public interfaces. Security. We also support remote clients, and of different OS s. (Item 4.6 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\security.doc" \\nttest\ntct\slm\src\ntfax\specs\security.doc Inbound routing extensions. In a large organization, managing incoming faxes with smart inbound routing can save a lot of work. (Item 4.9 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\routing.doc" \\nttest\ntct\slm\src\ntfax\specs\routing.doc TBD: will we write an inbound router to test the fax server? Will we have API test for inbound routers? Setup. Comet has it s own setup, including clients, and must consider the existence of previous MSFAX installations. (Item 4.1 in NT5 test plan:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\setup.doc Modem compatibility. (Item 4.2 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\modem.doc" \\nttest\ntct\slm\src\ntfax\specs\modem.doc  and  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\faxwhql.doc" \\nttest\ntct\slm\src\ntfax\specs\faxwhql.doc  and  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\faxvrfy.doc" \\nttest\ntct\slm\src\ntfax\specs\faxvrfy.doc This is an important issue, since not all MS-certified fax-modems are tested with MSFax, and those that do get tested are tested very superficially. MMC. Comet has a different admin model. (Item 4.6 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\mmc.doc" \\nttest\ntct\slm\src\ntfax\specs\mmc.doc Queue. Again, client issues. (Item 4.2 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\queue.doc" \\nttest\ntct\slm\src\ntfax\specs\queue.doc Logging. Comet logging model. (Item 4.9 in NT5 test plan:  HYPERLINK "\\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\routing.doc" \\nttest\ntct\slm\src\ntfax\specs\routing.doc Media detection. If Media detection is moved to the CRM, this item will be removed. Performance. Modem CoClass installer. Ad-hoc. s a list of new test areas for the Comet fax server: Co-existence with existing fax software, especially on the clients. Scale. Reliability. Fax client queue management. Fax client logging. Least cost routing. Is there an LCR feature? Clients. The Comet fax clients may be Win95, Win98, NT4 and NT5. TBD: which flavors do we test? Which SP? Array. The Comet servers may be in an array configuration. Command line (print.exe). Help files. Integration with CRM. IP fax (T.37 & T.38). Open Port s proprietary Internet FSP. Document History/Revision Micky Snir (MickyS)   7/4/98   1st version. Draft*1 Topic should be addressed in each project test plan Product Vision and Goals Goals: provide a very stable/reliable fax server, reduce PSS calls (compared with SBS) and integrate into Comet. Vision (short term) - Provide a simple Fax Server solution for small/medium organization and branch offices. Vision (long term) - Provide a comprehensive Fax Server solution that can meet most of the requirements that LORGs have. Contacts *1 Topic should be addressed in each project test plan Functional Group Development Boaz Feldbaum (BoazF) Localization Marketing Product Support Program Management Or Ben-Natan (OrBen) Testing Micky Snir (MickyS) User Education Location of Pertinent Information *1 Topic should be addressed in each project test plan Raid server  HYPERLINK \\\\haifaslm\\slmcomet  \\haifaslm\slmcomet , fax project. Product servers Product specification server Test case server *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here.  HYPERLINK \\\\haifaslm\\slmcomet  \\haifaslm\slmcomet , fax project, faxtest subdirectory. Tools server *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. QUALITY OBJECTIVE Quality for Comet fax server will be composed of the following attributes listed in order of priority. Schedule - The product ships on time. The current target date is NT5 RTM +60 days. Reliability.  Users should never run into a GPF, especially in the fax server. They still may crash due to circumstances outside our control, such as bugs in client applications that use our API. This will be measured by counting the percentage of PSS calls that involve a GPF.  Users should never lose data. All sent faxes will reach their destination and in any case the user will be notified (of success and of failure). All received faxes will reach their destination according to inbound routing. Integration. The fax server must be well integrated into Comet. The main areas are admin and CRM. Usability. The fax server and its client components must be easy to use. The server part is in the integration bullet above. The client side is the seamless operation of the fax printer, and the robustness of the client side fax API and utilities. Hardware compatibility.  Fax server s compatibility with fax-modems from the NT5 HCT.  Sending & receiving faxes to & from the most common fax devices (in the remote location).  Fax server s compatibility with fax-boards. Performance. Client side   sending a fax is like printing to a fax printer. Therefor, sending a fax to the fax server s queue should take as long as it takes to send the document to a printer s queue. Server side   fax should be sent as fast as possible. This means using the most appropriate FSP, with the least unneeded retries. RESPONSIBLE FOR DELIVERABLES *1 Topic should be addressed in each project test plan Functional Group Responsibilities Write vision statement for product Create daily builds Write setup Test templates Test code from external groups Master project schedule Help Testing  Build golden masters Manage the beta Wish List Disk Building Disk QA Create Benchmarks Run benchmark tests Localization? Create test release documents (TRD) Creating Contracts Archiving TESTING METHODOLOGY  Overall Strategy Comet fax uses the code base of NT5 fax. NT5 fax is after beta 2 so it is already code complete and tested by the NT5 fax test team.  At 1st we apply the NT5 test plan. We will and add new tests for Comet-fax features and enhance the NT5 test-plan were needed. There will be no Comet-fax build at least until the Comet preliminary release, so until the Comet preliminary release we will enhance the NT5 fax test plan. As soon as we will have Comet-fax builds, test and dev will work together on new features, so that each new feature is tested as soon as it is code complete. Each and every Dev checkin will be code-reviewed by a member of the test team. We will try to automate each test, and the test cycle as well. Tests will include as much verification as possible, e.g. each sent fax will be compared to the corresponding received fax, not only API return values are checked but when possible the API s action is verified too, etc. We will strive for a common code base for all platforms (NT4 ( & x86, NT5 ( & x86, Win95, Win98). We will strive to have a full test cycle per build, and therefor automation is important. In any case, the emphasis will be on the most recent checkins, the buggiest components and the most risky components. The last build of each milestone will have a full test cycle. We will start with a weekly build, and move to more frequent builds as needed. System and stress tests to verify the reliability and stability of the fax server are the most important. Self-host will be used as a system test as well. Scope The Comet fax test team will test all aspects of the Comet fax server and clients except: The FSP interface. TBD   we may write:  FSP test suite as an acceptance test for FSPs. Testing virtual FSPs is easier, since there s no TAPI code involved.  An FSP stub to test the fax server. The reason besides lack of HR and that OpenPort will write 3 FSPs for us, and each fax-board vendors will write one too. So testing those FSPs indirectly tests the FSP interface. OpenPort FSPs. We will conduct acceptance tests, but they will not be a part of our test cycle. OpenPort is responsible for testing their FSPs. We will review their test-plan, and perform only sanity checks. Win95 and Win98 clients. Contractors develop those.  TBD - I do not know yet the extent of testing that they do, and therefor what we should do. International support and Localization. For each component (server, clients) we will have a machine with a foreign language (German or French) and maybe a Japanese one. We will not test content, only functionality.  outbound & inbound routing. TBD: upgrade of SBS to Comet. Testing Approach Milestone Process Project Level Before every milestone we will brainstorm for new test cases. I consider this very important since usually after we have a test plan ready, we dive into implementing it and we tend to forget that we must always look for new test cases. Development phase The goal for Testing during this period is to thoroughly test the new features implemented in the milestone and their interaction with previous areas of the product. Many features already exist and are testable, since the Comet fax server is based on the NT5 fax, which is code complete and after beta 2. Bugs that must be fixed at this phase will be marked as  test blockers . It is recommended the all priority 1 bugs will also be fixed during this phase. Each and every bug must have a repro that is a part of the test cycle, preferably an automated repro. We will have a bug meeting every 1 or 2 weeks in order to evaluate the dev and test efforts. Participants   dev and test leads. Optional participants   AviN (Comet dev lead), NirM (Comet test lead) and fax team members. Stabilization phase During this stage we will run full test cycles on the product. We will have bug meetings once a week or as needed in order to prioritize bugs, set test focus and evaluate the quality of the product. We must review all our test cases again. We must refresh our thoughts and clear any fixations we have about testing. We have gained a better knowledge of the product, and we must take advantage of it and make sure that no important scenario has escaped us. At least 1 machine of each (server, clients) will not get upgraded each build, in order to test stress over time. This machine will be upgraded every 3 weeks, or sooner if builds are not stable enough. Test Documentation Test specifications  a test spec for each of the following areas: SDK. All client OSs, including COM interface. Fax Send Wizard. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc Fax client queue management.  Fax client logging. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\routing.doc Fax server queue management. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\queue.doc Fax server logging. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\queue.doc Exchange connector. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Cover page editor. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\cpe.doc Image viewer. FSP interface   TBD:will we test it? Will testing OpenPort and board FSPs suffice? Routing. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\routing.doc Printers preferences. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\printer.doc Status monitor. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\faxstat.doc Performance counters. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\faxperf.doc Setup. Comet has it s own setup, including clients, and must consider the existence of previous MSFAX installations. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\setup.doc Help files. Admin COM object. Scale. Security. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\security.doc Least cost routing. NT5 client. NT4 client. TBD   which SP? Win98 client. Win95 client TBD   which flavor? Arrays. Integrated with CRM. Control Panel. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\control.doc MSFAX TIFF tags. Based on:   HYPERLINK \\\\nttest\\ntct\\slm\\src\\ntfax\\specs\\setup.doc  \\nttest\ntct\slm\src\ntfax\specs\tifftag.doc OpenPort s IP fax FSP. OpenPort s proprietary Internet FSP. T30 protocol (UNIMODEM FSP). Media detection. Migration to NT5 DS (registry / DS abstraction layer). Command line Print.exe. Performance. Guerilla testing. Miscellaneous. Stopping the fax service in the middle of actions (while sending a fax, while fax MMC is open and then close it, etc.). Properties persistence. Verify that if a property is changed, the change is persistent. Stop the service, or reboot, and verify that the property persists. Several properties can be changed via different controls. Verify that these ways are equivalent. Test specification reviews The object if the spec review is to prioritize  *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. the test cases and preferably to find new ones. During each milestone, a test specification review will be conducted in coordination with development of each testable unit.  Spec reviews should occur early enough during development to allow revisions to the spec. Each test spec will be reviewed for completeness by the tester author, the developer, a program manager (optional), and at least one additional tester.  Test cases, on the other hand, may be reviewed on an as needed basis (suggested for very complex features and/or for inexperienced testers).  Each tester will be responsible for getting their specs/cases completed and reviewed in a timely manner. At the beginning of each milestone the test lead should determine what testable units are going to be spec'ed and cased in the up coming milestone.  A preliminary schedule of spec reviews for each person on the team should be ready at the beginning of the milestone.  The first spec review for each tester should be scheduled.  A test spec for a testable unit should be brought to high stability during the development phase of that testable unit. Test cases Have one "Verify" statement (or its equivalent) per case. Give a list of equivalence classes for each "Verify" statement. Write each case to be run standalone.  It shouldn't depend on previous cases. Use shared cases where appropriate Be specific enough to be understood, but vague enough to accommodate minor program changes. Look for areas of functionality that can be put into common documents Think "reusable code." t use  correctly as it should , or   as speced  in a case - define what correct is. Don't have cases rely on other cases being run. Don't use test files unless clearly helpful.  Try to have the creation of the test file be part of the case. Don't give steps to repro, unless non-obvious. Don't list permutations of items that are independent of each other. Each single issue in the test spec should translate to a single case. All cases should conform to the following model: Abstract: Verify this issue: () EquivalenceClassA description () EquivalenceClassB description () EquivalenceClassC description Specific Example: Verify that documents can be removed from the queue: () before dialing. () while dialing. () while sending. () while other jobs are put on the Queue. *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. Test Release Procedures *1 Topic should be addressed in each project test plan Build acceptance criteria Summary: Starting test cycle. Closing bugs. Finishing test cycle. Keep developing new tests and automation Test team will prepare a simple automated test for the Dev team to run before they checkin their code. Each component will have its own pre-checkin tests. Complex or buggy components  pre-checkin tests will evolve as needed. The test cycle will start with a BVT. A build will be released for testing only if it passes the BVT. A BVT should not last more than an hour. The BVT will be updated as the product evolves in order to include as many features as possible. Frequent regression bugs will be a part of the BVT. We will strive to run a full test cycle on each build. This requires full automation, since the time between builds may shorten as we get near the release. Most test cycles will be on the debug version of the product. Once every few builds (3-5) we will run a test cycle on the release version. After the last milestone (before the release) we will test only release versions. Stress will run on the debug version. We will switch to the release version if no bugs are found in the debug version, or after the last milestone (before the release). During each test cycle we will test a single build. We may not have overlapping test cycles. The only exception is stress testing. A full test cycle should eventually take at most a week. Stress acceptance is at least 3 weeks of continuous stress. Release schedule We will have a new build once a week. The first builds may be farther apart, according to dev progress, but we should strive for 1 build per week. Before milestones, we may have 2 builds a week, and even a daily build. We should try as hard as we can to avoid patches of builds. A test cycle will always be on a whole new build. Post-Code Complete (Stabilization)Testing *1 Topic should be addressed in each project test plan Stabilization phase summary At least 1 full test cycle after the RC, on both debug and retail versions. At least 1 test cycle will run concurrently with the rest of the Comet components using the same machines (clients and servers). Once every few builds we must setup fresh machines and test with them (server & clients). This is done to ensure that we use the latest fax build, and that fax does not rely on components that do not exist on a freshly installed machine. Upgrade the RC over the last beta. Areas that had checkins will go under intense testing. Risky checkins must be reviewed buy at least 2 people. Areas that had no checkins will get less attention. Test cycles focus will shift from debug versions to retail versions. Last cycles before the release will be on retail builds only. Bug bash. Self host. Benchmark & performance test every 3-4 builds. Full test cycle done by a non trained person (or switch parts). Someone that will catch bugs that we are used to seeing and therefor ignore. Brainstorm for new scenarios. Guerilla testing   hard reboots, disconnect network etc. Final 2 weeks - Ad Hoc (Goal - maximize coverage - breadth prioritized over depth). Risky areas get new attention. Based on buggy areas and complicated code. Almost daily bug meetings. Stomp Test (We don't Stomp existing MS Apps) Stomp Test (We aren't Stomped by other MS Apps) Fax print from any possible application, including 16bit. Give to PSS to play. Verify that important (P1, P2) bugs that were not automated are tested for regression. Automation Strategy The goals of automation are: Reduce the time of the test cycle. Reduce the time test-developers invest in test cycles, and thus give them more time to think up new test cases and to implement them. Increase the reliability of the test cycle   long lasting manual tests may lead testers to dangerous numbness. Increase testers  motivation   it may be very discouraging for software design engineers to perform manual testing. Automation will be measured by a combination of several factors: Reducing the time it takes to run a full test cycle. Broadening the coverage of the test cycle. Finding regression bugs with automation. Finding new bugs with automation. The goal is full test cycle automation   a one click test cycle. However, achieving this goal is not always cost effective, since the development time may take too long, and we may have more important goals for achieving meanwhile. Therefor the practical goal is to optimize automation for maximum coverage. The most important automation is in API testing, system testing and stress testing. Automating GUI testing is very important, but we will automate only areas that are less likely to change. We will not invest in automation of areas that are likely to change. We will perform ad hoc GUI tests even to automated areas since GUI automation is likely to miss bugs that a human eye / mind can catch. After code complete we will reevaluate the need for automating manual GUI tests. Automation will require the development of several tools, such as a TIFF comparison tool, that will compare the sent and received faxes. Admin automation will be based on a tool developed by the Proxy team. However, due to the limited number of property pages, we will start with manual testing, and will move to automated testing as the admin modem will stabilize and the automation tool will prove itself useful by the proxy team. We do not plan to develop any new automation tools. We will use existing distributed and remote test managers (DCOM DTM, DTM, RTERM etc.). We will not conduct code coverage tests, branch coverage tests, or function coverage tests. Integration Testing Strategy *1 Topic should be addressed in each project test plan Integration is one of the key goals of Comet, and therefor fax as a part of Comet must be well integrated into Comet and other components. Server side: Integration with CRM. I consider this a risk area, since the NT5 fax manages its own fax devices, and now all of this will be done in the CRM. We have many issues here, for example modem CoClass installer notified the fax server of added / removed modems, and now CRM is responsible for it. CRM is also a dependency factor   fax will work only with a functioning CRM. Integration with other Comet components. Besides running Comet system tests, and running each component s tests using the same server(s), we will test special Comet-integration scenarios, such as fax server sending an IP fax via a proxy with a modem connection. Is the admin modem similar to other Comet components? Same look and feel? Client side: MAPI extention. Sending faxes from exchange clients. Coexisting with Symantec fax on Win9X. Fax as a printer. Misc: Are the help files self-containing, or do they include pointer to other Comet components? Does the client side help contain server side help? Vice versa? Is it always clear if the help refers to client or server side? API Testing Strategy *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. There are 4 groups of public interfaces, listed in priority order: Client API (WinFax.dll). Client COM interface (FaxCom.dll). Fax service provider API (FSP). Fax service routing API. Most of the API testing will be on the client side. We should remember that we support Win9X and NTX clients. The FSP will receive less attention, since OpenPort will provide us 3 FSPs, and thus will indirectly test out FSP interface. Also, fax board vendors that will write FSPs for their fax boards before the release will test our FSP interface as well.  We may develop an API test for the FSP interface, although it currently looks that we will not have the time. The routing API: if we ll have time we will write a test routing extension that will emulate a routing extension.  API testing methodology: Each API will be tested, in ANSI and UNICODE versions. Verify that each relevant property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback. Return values are always verified. Try to extract every possible error code. Verify results if possible. Return values are usually not enough! Example: abort a fax job. Verify on the server that the job actually gets aborted. Example: set retries to 3. Verify that after 3 retries the fax stops retrying. Cause 2 retries and succeed on the 3rd. Illegal parameters. Only one illegal parameter at a time. Combinations of illegal parameters will be tested only if they make sense   there are too many possibilities. Legal parameters   equivalence classes. States   call an API at several states. This calls for defining scenarios of API calls. Aborting and closing while actions are performed. Experience shows that this finds many bugs. Multi threading. Multi process. Many processes may use the client APIs. Low memory. Hog memory, and then call an API. Call asynchronous APIs and then hog memory. Low disk space. Low CPU resources (hog the CPU). We will not test: Branch coverage Function coverage. Private interfaces. Content Testing Help files will be manually tested. Wizards will have automation, as well as manual ad hoc tests. Issues: Are the help files self-containing, or do they include pointer to other Comet components? Does the client side help contain server side help? Vice versa? Is it always clear if the help refers to client or server side? Performance (Benchmark) Testing Client side:  Printing to a fax printer should take about as long as it takes to print to a network printer, or as much as it takes other vendor s fax software to send. We should find the bottleneck. Server side:  Unimodem and fax board FSPs should send and receive at certain baud rates. Will be measured against other fax software. Other FSPs (IP, OpenPort): TBD. Scale: the above actions should be benchmarked for hundreds of users, and tens of fax devices per server. We will try to automate the benchmarks, but if not we will use a stopwatch. Out-Of-Memory and Low Memory Testing This section is very important   our customers reach out of memory conditions much more than we do! All tests should be able to handle out of memory conditions as well as to test them (i.e. GUI tests should expect the  System is running low on memory  pop up. Manual tests will run with / without a memory hogging tool. Automated tests are tricky, since the test itself may fail to perform due to no memory. API tests will include low memory tests. Low memory tests should run many times, since we cannot guarantee that a specific allocation will fail within the tested component. Low GDI and low USER memory as well as GLOBAL memory. Before each milestone, we will perform at least 1 test cycle that will focus on low memory conditions. It is too late in the project to write a layer that will emulate out of memory conditions. Page heap. Bounds-Checker. Code review. Stress.exe. Low memory machines   32M for NT, 16M for Win9X.*1 Topic should be addressed in each project test plan Self-host The fax server is a classic component for self-hosting. The entire Haifa site will use the fax server to send and receive faxes. We will try to convince Microsoft to use the fax server. ITG? Same for the Herzlia MS center. Non classic usage: replace network-printers with fax-servers   people will print to the fax server instead to the network printer. The phone number will choose the actual network printer. This is great for stress and quality tests! Each fax is manually inspected! Pitfalls:   Not all printer settings can be set as in the network printer.  Slow, but we can broaden the baud bottleneck if we use more fax-modems, so that many concurrent jobs can be performed. Setup Testing Strategy *1 Topic should be addressed in each project test plan Upgrading from previous Beta (server & clients). Upgrade from SBS (server & clients).  This is a very risky issue since SBS fax components do not work well with Comet components. We must be very careful regarding what the users might get when upgrading. For example, do we allow an upgrade of a client to a Comet client, if the server was not upgraded to a Comet server yet? Upgrading a machine with existing MS-fax software. Upgrading a machine with existing non MS-fax software. Do we install system files? Out of disk-space. Will setup check for enough memory? Will setup check for the correct OS? Correct SP? Configuration Testing *1 Topic should be addressed in each project test plan Issues to consider: Hardware platform (X86 Intel & Alpha DEC) OS (Win95, Win98, NT4, NT5) NT5 DS / registry. Network (10 / 100 MHZ) The following will not be tested, but we will try to have a sample of these in our labs: Mouse driver (8.0, 9.0, 10.0, LogiTech, ....) Keyboard drivers (MS Natural Kbd, std, programmable, Dvorak, language layouts, ...) Video (CGA, EGA, SVGA, ...) Sound (speaker driver, Windows Sound System, SoundBlaster) Compatibility Testing - Hardware Fax modems - the fax server should support all fax capable modems from the NT5 HCT. However, we can not buy all of them, and some of them may not be available in Israel. We will try to test the modem that take the highest market percentage. Those that are not suited for Israel will be tested in Redmond. Fax boards   fax board vendors must write a TSP and an FSP (or only an FSP in the case of a virtual FSP) in order to work with MS-fax. There s no list that we should support, but we should test every fax board that the vendors will lend us. Multiport serials   in order to use more than 2 modems, multiport serial adapters are needed. We will support HW that we borrow from the following HW vendors: Digi, Equinox, Stallion, Moxa, TurboCom etc. The fax server should send-to and receive-from faxes / fax-modems that are not on any HCT. For this reason we will buy a special card+software that will emulate the most common 79 fax-modems in the market, and we will sent them faxes and receive faxes from them. Ad Hoc Testing Strategies Ad hoc testing is very important. It is a reminder that we may never stop looking for new scenarios. This will usually be done after brainstorming for new test cases (before each milstone). Have testers list random ideas about ways to use an area, or things to try during ad hoc testing that you might not want to case. Then, when it s time to run cases, each tester has a list of ideas with which to experiment. All the bugs that are found will enter the test cycle, and preferably get automated. Bug bash. Bug bash guidelines doc. Rewards? Replace intra-Comet groups for bug bashing. Once in a while a test cycle will get ad hoc priority. This may be due to a risky checkin, a risky area, or a crucial component. Localization Test Strategy *3 Topic is optional for any project test plan DBCS Test Strategy *3 Topic is optional for any project test plan Post Ship Strategy *1 Topic should be addressed in each project test plan Beta Strategy *1 Topic should be addressed in each project test plan *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. Crippled Version Strategy *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. Third Party Dependencies List of Dependencies NT5 fax. Our sources are based on the NT5 fax. Should the NT5 fax be unstable, we are unstable with it. CRM (depends on TAPI3). All the devices management will move into the CRM. Ship date depends on NT5 ship date. MMC. Fax admin is via MMC. OpenPort IP FSP and proprietary FSP. We have a contract with them, and we do / approve acceptance testing. we also should not block them by not having the FSP interface well documented and stable. Setup? TBD. Negotiating With A Third Party *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. SCHEDULE Milestone 1 Milestone X Code Complete Test Pass 1 Test Pass X Config Pass PERSONNEL/TEST AREAS Team Structure Test lead   Micky Snir (MickyS). FT tester   Sigalit Bar (SigalitB). Contractor   TBH. Contractor   TBH. My estimation is that 1 FT and 2 contractors are the minimal requirements. The reasons for that are that the NT5 fax test team has 1 FT and 2 contractors, but we have more coverage to do: Support Win95, Win98, NT4 and NT5 clients (NT5 fax supports only NT5 fax). Be a real fax server (NT5 fax is a standalone). Integration with CRM. Array support. The Fax server may be an array. Use the DS / registry abstraction layer. Support fax boards. Irrelevant for NT5 as a standalone application. Support OpenPort FSPs. Admin model is changing to the Comet admin model. Setup is changing to the Comet setup. Doubts about the quality of the NT5 fax. The reason why 1 FT and 2 contractors may be enough: The NT5 test team has already done some testing and the NT5 fax is already tested to some extent and NT5 Beta 2 has already shipped. Area Breakdown Team Member Team Member x Contractor X Intern Y Area x Area  y Interns/Contractors RESOURCE REQUIREMENTS Training Requirements TBD. *3 Topic is optional for any project test plan Hardware Requirements TBD. *3 Topic is optional for any project test plan Software Requirements TBD. *3 Topic is optional for any project test plan Office Space Requirements TBD. *3 Topic is optional for any project test plan BUG PROCESS Database Administration TBD. *1 Topic should be addressed in each project test plan Bug Life Cycle TBD. *1 Topic should be addressed in each project test plan Remote Sites TBD. *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. METRICS Essential Standard Metrics *1 Topic should be addressed in each project test plan Optional Metrics *2 Topic should optionally be addressed in a project test plan.  Justification for why this topic is omitted should be noted here. Reports *1 Topic should be addressed in each project test plan RISKS Modem support. *1 Topic should be addressed in each project test plan SHIPPING THE PRODUCT Ship Criteria *1 Topic should be addressed in each project test plan Building Golden Masters And Golden Verification *1 Topic should be addressed in each project test plan Versions *1 Topic should be addressed in each project test plan Sign Off Requirements *1 Topic should be addressed in each project test plan ARCHIVING *1 Topic should be addressed in each project test plan Glossary *2 Glossary items should optionally be addressed in a project test plan. Definitions to technical terms contained in this document are provided below.  They are intended as sample definitions.  For the author of a test plan, the key is to obtain agreement to specific definitions within your product group early in the planning phase. Acceptance - Acceptance tests are designed to set a minimum threshold over which a newly coded feature must pass.  The intention is to find blocking bugs that could impede the test effort of one tester or for the entire test team.  A build of the product that can pass acceptance is ready for more stringent tests.  If a build fails acceptance, fewer testing resources were wasted discovering the blocking problem(s). Archives -  The organization within Microsoft that retains records, artifacts, and memorabilia considered to have long-term value to the business or institution Benchmarks - Timed measures of various actions within a product.  They consist of establishing a timed baseline and comparing the duration of these same actions after a set of features is code complete or potomized. Beta Release - A release of the product intended for beta testing with no known active severity 1 or 2 bugs.  Special last minute QA tests, like those performed on  Golden Master  disks, should be conducted on a Beta release before sending to Beta sites. Build Verification Test (BVT) - A quick, automated test run by Development on every daily build.  The purpose of this script is to catch major breaks in the product executable. Code Complete- An exit criteria for the last testable unit in the Development Phase of each milestone.  For the final milestone, all features and sub-features have been coded.  No known coding should remain except performance swap tuning. Multimedia products may need a different definition.  Crippled Version - A stripped down version of your product.  Much of the functionality of the product is available for the customer to use, but some critical features might be disabled.  A crippled version of Publisher might not allow you to print your work.  A crippled version of Chip s Challenge may only have the first 10 levels.  A crippled version of a multimedia title may include only 5% of the content. Daily Build - Each day during product development, each developer routinely checks in their work by a predetermined time.  That entire set of work is compiled into a daily build. Demo Version- Generally contains no code from your product. May be a MacroMind Director movie, or some other program that shows pictures of, or somehow describes the features of your product. Disk Building - The process by which the entire set of files created for a project are copied to sets of disks.  There are a variety of quality assurance checks that must be addressed in this process.  Often this process is automated. Disk Quality Assurance (QA) - Numerous quality checks that must be applied to the golden master disks in order to ensure that the contents are what you expect and work as expected. Golden Masters - The final sets of disks that are sent to Product Release Services for manufacturing. Localization Test Kit (LTK) -   A kit provided to localizers (esp. vendors), telling testers exactly what needs to be tested in a localized build and how this should be accomplished.  Among its contents may be manual tests, automated test scripts, test files, and test tools. Master Project Schedule - The big picture schedule the includes major milestones and review points of a project from start of finish.  This schedule must be reconciled with activities across each functional group. Milestone Certification - During this stage, Testing runs all cases against the testable units delivered in the milestone. At the same time, Development continues to fix bugs to reach the goal of zero active bugs. Certification of the milestone depends on a final build that includes all bug fixes and no reactivated bugs. PILOT version (Partially-Internationally LOcalized Testing version) - A pseudo-localized version of the product used by testing to find as many localization bugs as possible before the product is actually localized.  Using this version testers create scenarios like "expand all the strings by 50%," then observe the behavior of the product under these scenarios.  This PILOT version can touch areas of the product that the average tester cannot, e.g., strings in dialogs, headers, defaults, etc. Release Candidate (RCx) - A build released to Testing with no known show stopper bugs.  The goal is to release the build to Manufacturing. Release To Manufacturing (RTM) - The date on which the completed set of product disks are sent to manufacturing.  All disk QA work is complete and functional group leads sign off on a product release document. Resource Editor -  In the context of localization, an editor that localizers should use to take a given resource (e.g., a dialog) and translate it, then make necessary changes (e.g., sizing changes).  In the best scenario, the editor also prevents casual errors (e.g., sizing a dialog larger than a VGA screen). Test Release Procedures - Process by which Testing takes a daily build from Development and the requirements or checks that need to be done before a build is accepted. Testable Unit - Comprised of one or more  Work Items  and refers to any piece of the software package that is testable. Vision Statement - A vision document defines the broad scope and goals for the product. It should include analysis of market and competition; target audience; external product positioning; internal product vision and design goals for domestic and international versions; analysis of users, activities, and prioritization of activities; timing and version requirements. The vision should be obtained from Marketing and Program Management. By having the vision in the test plan you  insure that all testers are aware of the project objectives. Wish List - There are two types of wish lists.  One, obtained from Product Support, highlights features that are requested by customers for inclusion in a new release of the product.  The other is obtained from Program Management and Marketing during product design.  This list generally includes desirable but lower priority features.  If there is room in the development schedule, wish listed items may be added to the official development feature list. Work Item- A scheduled task representing the lowest level granularity of work by development. Zero Bug Release (ZBR) - A product build where there are no active bugs in the list older than (e.g., 36) hours and no blocking bugs in the list less than (e.g., 36) hours old. Microsoft Confidential FaxServerTestPlan Page   PAGE   NUMPAGES  \* MERGEFORMAT   DATE  \l  11/8/98 {vqlgb] ~ytoje`[X |yskc[SK |tlda^XPH |ytqc`]ZUPL zwtfc`R upkfa\W |wrmhc_Z {vqlhc^Y {vrmhc^Y |wrmhc^Y |wrmhc_\ kheb_ {skc[SK wog]SI? |tld\YVN }znke]U }ume]U {xrjbZWTNF {xuogda zrjbZRJ qnkheb_\Y }ume]ZW spmjgda^[X ~xph`XP |wsnie`[ id_ZU }znzkhZzkh nkheWT rda^[S
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\faxtesttools.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FaxTestTools Title _PID_GUIDFaxTestTools micky snir Normal.dot micky snir Microsoft Word 8.0FaxTestTools Fax service monitor. This tool will monitor event on the fax server and will use logic and heuristics to verify the operation of the fax service. Memory hogging. This is a toll that hogs all memory, frees X bytes, hogs all memory, and so on. It can be used as a standalone application to emulate low machine memory. It can be used as an in-process memory hogging for the fax service itself (using a compilation switch). Fax callback services around the world will be used to send us back faxes so that we will test compatibility with different fax-modems all over the world. Use fax service providers to send ourselves faxes. This way we test our T30 FSP both for sending and receiving to and from different fax-modems around the world. Political issue: can just fax to numbers that we find on the Internet? We can disguise these as faxes demanding information, and thus also get a fax back! FaxTrace from Telegra will test our T30 FSP. It comes with test suites, and it also enables custom test-case development for the T.30. FaxLab from Genoa emulates 79 of the popular fax-modems, and thus enables use to send & receive from them. Print from every available application, including 16 bit apps. This include a variety of
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\faxtestthoughts.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Test Cases for the NT5 Title _PID_GUIDTest Cases for the NT5 Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0A'fL#1&Comet Fax Service Testing Preface: This is a draft document.  This document contains ideas and thoughts regarding testing of the NT5 and Comet Fax Service products, some of which we may decide not to implement. The following test case list is not prioritized and is in no way complete. Test guide lines: Look for any implicit assumptions that developers might have made when implementing both the client and the server on same machine. Check everything in both local and remote server configurations. Bare in mind that Comet is an array. An array has many Fax servers and we have no idea which one we will connect to when connecting to Fax of the array. APIs: API test guide lines Test every parameter with valid and invalid values. For every data type test maximum and minimum valid values. Check that correct error values are returned For every parameter that is a pointer, check NULL For every parameter that is a pointer to a structure also check valid and invalid values for structure fields. For every parameter that is a string, check both pointer is NULL and empty string (pointer pointing to NULL). Implement FSP Extension APIs and Routing Extension APIs that cause exceptions, so that we can make sure the server calls Extension functions inside a try   except. FaxAbort API.  [TBD] FaxAccessCheck API.  [TBD] FaxClose API.  [TBD] FaxCompleteJobParams API.  [TBD] FaxConnectFaxServer API.  [TBD] FaxEnableRoutingMethod API.  [TBD] FaxEnumGlobalRoutingInfo API.  [TBD] FaxEnumJobs API.  [TBD] FaxEnumPorts API.  [TBD] FaxEnumRoutingMethods API.  [TBD] FaxFreeBuffer API.  [TBD] FaxGetConfiguration API.  [TBD] FaxGetDeviceStatus API.  [TBD] FaxGetJob API.  [TBD] FaxGetLoggingCategories API.  [TBD] FaxGetPageData API.  [TBD] FaxGetPort API.  [TBD] FaxGetRoutingInfo API.  [TBD] FaxInitializeEventQueue API.   (when already initialized) [TBD] FaxOpenPort API.  [TBD] FaxPrintCoverPage API.  [TBD] FaxRegisterRoutingExtension API.  [TBD] FaxRegisterServiceProvider API. [TBD] FaxSendDocument API. Responses to level one parameters. Call API using an non-initialized service HANDLE. That is call FaxSendDocument without first calling FaxConnectFaxService. Call API using INVALID_HANDLE_VALUE service HANDLE. Call API using a random number as an illegal service HANDLE. Call API using a valid port HANDLE as the service HANDLE. Call API using a valid non-fax HANDLE as the service HANDLE. Call API using a service HANDLE that has just been closed as the service HANDLE. Have a process get a valid service HANDLE (using FaxConnectFaxService), have it start two threads (each having a copy of the HANDLE), while the first thread is in  mid-execution  of the FaxSendDocument API (with the HANDLE) have the other thread gain the CPU and close the HANDLE. Check that the Fax service can recover. Call API with NULL parameters. That is, call the API when one of the parameters is NULL and all others are valid, for each of the parameters. Call API with existent \ non-existent document file (with full path \ without path \ network path). Call API with existent document file that can not be opened (insufficient permissions) File name longer than MAX_PATH. The first MAX_PATH characters should compose an existent file name. We do not want to allow using part of the file s name string (chars 0..MAX_PATH) but receive an ERROR indicating an illegal file name. Call API with filename  * +;:`file@%&*  (a filename with invalid characters). Call API with empty string (valid LPTSTR pointing to NULL). Call API with valid filename that has spaces. Call API with valid filename and a path that has spaces. Call API with valid filename and valid relative path ( ..\..\myfile.tif Call API with valid filename and non-existent valid relative path ( ..\..\..\..\myfile.tif  when current directory is D:\MyFiles). Check that every string (representing a path & filename) that CreateFile considers to be legal, FaxSendDocument also treats as legal.  Valid file formats for this API are valid *.tif  => Call API with valid and invalid *.tif files. Rename a valid tif format file to <filename>.doc, make sure that FaxSendDocument succeeds. Call API with *.txt, expecting SUCCESS (the Fax service converts it to tif - \fax\tiff\src\tiflib.c in function ConvertTiffFileToValidFaxFormat). Call API with *.doc (when Word installed on machine), activate Word and sends. Call API with *.doc (when Word not installed on machine), expecting ERROR. Call API with *.xls (when Excel installed on machine), activate Excel and sends. Call API with *.xls (when Excel not installed on machine), expecting ERROR. Responses to level two parameters (FAX_JOB_PARAM and FAX_COVERPAGE_INFO). Call API with NULLed FAX_JOB_PARAM structure. Call API with FAX_JOB_PARAM structure with empty strings in string fields. Call API with NULLed FAX_COVERPAGE_INFO structure. Call API with minimum information required for FAX_JOB_PARAM structure. Call API with maximum information required for FAX_JOB_PARAM structure. Call API with minimum information required for FAX_COVERPAGE_INFO structure. Call API with maximum information required for FAX_COVERPAGE_INFO structure. Call API with illegitimate FAX_JOB_PARAM structure (e.g. FAX_JOB_PARAM->SizeOfStruct=0, FAX_JOB_PARAM->Reserved[0..2]!=0). Call API with illegitimate FAX_COVERPAGE_INFO structure (e.g. FAX_COVERPAGE_INFO ->SizeOfStruct=0). FAX_JOB_PARAM structure contains LPTSTR fields, DWORD fields, SYSTEMTIME field and an HCALL field. For each data type give a very large value (long string), smallest value, and illegal value. FAX_COVERPAGE_INFO structure contains LPTSTR fields, DWORD fields, SYSTEMTIME field and a BOOL field. For each data type give a very large value (long string), smallest value, and illegal value. Call API with SYSTEMTIME of FAX_JOB_PARAM and FAX_COVERPAGE_INFO with 1-Jan-2000 00:00:00 and  31-Dec-1999 23:59:59. Call API with FAX_COVERPAGE_INFO->Subject and FAX_COVERPAGE_INFO->Note each longer than a page. Call API with incorrect FAX_COVERPAGE_INFO->PageCount and FAX_COVERPAGE_INFO->TimeSent. Make sure that these fields are overwritten correctly by the server. FAX_JOB_PARAM and FAX_COVERPAGE_INFO have a number of identical fields. These fields (if their values differ) should be overwritten in FAX_COVERPAGE_INFO by the values of FAX_JOB_PARAM. => Call API with different values of these fields in FAX_COVERPAGE_INFO and FAX_JOB_PARAM. Because of the above clause and the fact that some of the fields described above are LPTSTR, we need to make sure that the memory we allocated for them before we called the API is freed by the server. Call API with FAX_JOB_PARAM->ScheduleAction equaling JSA_NOW and  FAX_JOB_PARAM->ScheduleTime equaling a legitimate time in the future, make sure fax is sent NOW. Call API with FAX_JOB_PARAM->ScheduleAction equaling JSA_DISCOUNT_PERIOD and  FAX_JOB_PARAM->ScheduleTime equaling a legitimate time in the future that is not during the discount rates, make sure fax is sent during discount rates. Logic of API semantically connects between FAX_COVERPAGE_INFO->ServerCoverPage (BOOL) and FAX_COVERPAGE_INFO->CoverPageName (LPTSTR). A {TRUE, <file name>} indicates to search for filename on local machine (client) and {FALSE, <filename>} indicates to search for filename on server machine => Call API with FAX_COVERPAGE_INFO->CoverPageName equaling an UNC path existent file name and  FAX_COVERPAGE_INFO->ServerCoverPage equaling TRUE (use server file). Call API with FAX_COVERPAGE_INFO->CoverPageName equaling an UNC path existent file name and  FAX_COVERPAGE_INFO->ServerCoverPage equaling FALSE (use local file). When remote client server configuration will be possible  Have machine#1 with Fax client & server installed and machine#2 with only a server installed. Both machines have the server cover page directory with files by the same names. Change one of the files (its content) so we could tell which one of the cover page files was used. From machine#1 connect to machine#2 Fax server and call API with {TRUE, <filename>}, machine#2 server cover page file should be used.  From machine#1 connect to machine#2 Fax server and call API with {FALSE, <filename>}, machine#1 cover page file should be used (if no path is given then current directory of machine#1 will be searched, so make sure the C.P. file is there). From machine#1 connect to machine#1 Fax server and call API with {TRUE, <filename>}, machine#1 server cover page file should be used.  From machine#1 connect to machine#1 Fax server and call API with {FALSE, <filename>}, machine#1 local cover page file should be used (if no path is given then current directory of machine#1 will be searched, so make sure the C.P. file is there). Call API with FAX_COVERPAGE_INFO->CoverPageName equaling a network path existent file name and  FAX_COVERPAGE_INFO->ServerCoverPage equaling FALSE (use file from network). Call API with FAX_COVERPAGE_INFO->CoverPageName equaling a network path existent file name and  FAX_COVERPAGE_INFO->ServerCoverPage equaling TRUE (use file from network). Create sub directories in the server cover page directory with cover page files in them. Call API with FAX_COVERPAGE_INFO->ServerCoverPage equaling TRUE (use server file) and a filename in one of the sub directories (filename with partial path).  E.g.  Server C.P. directory is \WINNT\Profiles\All Users\Application Data\Microsoft\MSFax\coverpg\, create sub directory  HighGraphicsCPs  with cover page file  HighCP1.cov Call API with {TRUE,  HighGraphicsCPs\HighCP1.cov }, expecting fax to use above file. Call API with existent \ non-existent cover page file shortcut (*.lnk) with full path \ without path \ network path. Check both server and local cover page (FAX_COVERPAGE_INFO->ServerCoverPage = {TRUE | FALSE}). FaxSendDocumentForBroadcastAPI.  Responses to level one parameters. Call API using an non-initialized service HANDLE. Call API using INVALID_HANDLE_VALUE service HANDLE. Call API using a random number as the service HANDLE. Call API with NULL parameters. That is, call the API when one of the parameters is NULL and all others are valid, for each of the parameters. Call API with existent \ non-existent document file (with full path \ without path \ network path). Call API with existent document file that can not be opened (insufficient permissions) File name longer than MAX_PATH. The first MAX_PATH characters should compose an existent file name. We do not want to allow using part of the file s name string (chars 0..MAX_PATH) but receive an ERROR indicating an illegal file name. Call API with filename  * +;:`file@* Call API with valid filename that has spaces. Call API with valid filename and a path that has spaces. Call API with valid filename and valid relative path ( ..\..\myfile.tif Call API with valid filename and non-existent valid relative path ( ..\..\..\..\myfile.tif  when current directory is D:\MyFiles). Check that every string (representing a path & filename) that CreateFile considers to be legal, FaxSendDocument also treats as legal.  Valid file formats for this API are valid *.tif  => Call API with valid and invalid *.tif files. Rename a valid tif format file to <filename>.doc, make sure that FaxSendDocument succeeds. Call API with *.txt, expecting SUCCESS (the Fax service converts it to tif - \fax\tiff\src\tiflib.c in function ConvertTiffFileToValidFaxFormat). Call API with *.doc (when Word installed on machine), activate Word and sends. Call API with *.doc (when Word not installed on machine), expecting ERROR. Call API with *.xls (when Excel installed on machine), activate Excel and sends. Call API with *.xls (when Excel not installed on machine), expecting ERROR. Responses to level two parameters (FAX_RECIPIENT_CALLBACK and Context). Implement a FAX_RECIPIENT_CALLBACK that simply returns TRUE. Call API with a pointer to this callback and with Context parameter equaling NULL (all other parameters should be correct). Implement a FAX_RECIPIENT_CALLBACK that simply returns FALSE. Call API with a pointer to this callback and with Context parameter equaling NULL (all other parameters should be correct). A single job id is returned from the API for the entire broadcast. What happens if there are 123 recipients and send 1..121 succeed but send 122 fails? Does entire broadcast stay queued? All recipients retried? Do we attempt to send 123 and then retry 122 until we succeed? Documentation (check this information exists and is correct) Documentation on above issues. Which file types are valid for use with this API, what error values are returned for invalid types. Consistency with FaxSendDocument API FaxJobId (LPDWORD) OUT parameter of API is similar to FaxSendDocument FaxJobId (LPDWORD) OUT parameter, however, while in FaxSendDocument this parameter is allowed to be NULL (indicating that the FaxJobId should not be returned to API caller), FaxSendDocumentForBroadcast returns ERROR_INVALID_PARAMETER if FaxJobId is NULL. => FaxSendDocumentForBroadcast should return successfully when FaxJobId is NULL. FaxSendDocumentForBroadcast returns an ERROR_FILE_NOT_FOUND when the fax server cannot locate the file indicated by the FileName parameter, while FaxSendDocument will return ERROR_INVALID_PARAMETER in such a case. Make sure they both return the same (should be ERROR_FILE_NOT_FOUND) => The test case is to call both FaxSendDocument and FaxSendDocumentForBroadcast with a non-existent file name and make sure that they both return the same error (not necessarily ERROR_FILE_NOT_FOUND). Separating this test case from the error value validation of both APIs will allow us to test that new versions maintain consistency of error values (even if error values were changed or added). Similarly this can be done for every test case described for FaxSendDocument. That is, create the same situation and parameters (again), then call the FaxSendDocumentForBroadcast, and finally compare the values returned from the two API calls (they should be the same). Dependency upon implementation of Routing Extension s FAX_RECIPIENT_CALLBACK API Interaction via FAX_RECIPIENT_CALLBACK dictates that FaxSendDocumentForBroadcast allocate the FAX_JOB_PARAM and FAX_COVERPAGE_INFO structures we must make sure that FaxSendDocumentForBroadcast eventually frees all allocated memory. Since FaxSendDocumentForBroadcast calls FAX_RECIPIENT_CALLBACK to fill in these structures several time consecutively (for each recipient in the broadcast) it must either - i.  allocate the structures, call the callback, free the memory and so on ii. reuse the same memory but clear all fields of the structures before recalling the callback. This is due to the fact that the server cannot relay on the implementation of FAX_RECIPIENT_CALLBACK (to clear the structures before it uses them). FaxSetConfiguration API.  [TBD] FaxSetGlobalRoutingInfo API.  [TBD] FaxSetJob API.  [TBD] FaxSetLoggingCategories API.  [TBD] FaxSetPort API.  [TBD] FaxSetRoutingInfo API.  [TBD] FaxStartPrintJob API.  [TBD] Consistency throughout APIs.  This class of test cases exists in its own right and should be separate from test cases checking specific error values returned. Doing this will allow us to check consistency in upcoming versions of the product even if error values are changed or added. Return values Return values of all APIs are of the same type (BOOL). Boolean policy throughout APIs is TRUE on success and FALSE on failure. Error values Return values of all APIs are of the same type (BOOL). FAX_RECIPIENT_CALLBACK Routing Extension API. [TBD] FAX_ROUTING_INSTALLATION_CALLBACK Routing Extension API. [TBD] Send related: Fax service Send functionality (via all possible tools   SendWizard, FaxQueue, Outlook, Printer, etc) Sending of different files Speak with Kodak or Wang and ask for their file test suite. Valid tif formats. Any format (Word, Excel, Ppt, Outlook, Exchange, plain text, image files, etc) Foul-up a tif file (make its format illegitimate) and send it. Number of pages Percentage of image on page (empty lines, empty pages, etc) Paper size (does Fax Service resize?) Devices state while sending No device is send enabled. All send enabled devices are busy receiving. All send enabled devices are busy sending. Send enabled device is busy receiving but another send-enabled device exists. Send enabled device is busy sending but another send-enabled device exists. While sending, device   is disabled. While sending, device  receive  is enabled \ disabled. While sending, change CSID and TSID of device. Uninstall a modem while it is sending. Queue state (pause, order of jobs) while sending Send a fax while queue is paused. Is there any way to have the service up but its queue thread still down and then send a fax? Pause queue, send many faxes, resume queue, while there are still jobs in queue pause queue again, add more sends while queue is paused, resume queue. Send three faxes and make sure they are queued in correct order. Send enough faxes so that queue overflows (pause queue and then send 999 9 faxes). Send a single fax, pause the queue while it is sending, maintain queue in paused state until receiver side will time out, resume queue. Service state while sending Send when service is down \ up (obtain a HANDLE to service while it is up, stop service and then use HANDLE to send a fax). Send when service is going up \ down. RPC service state while sending Send when RPC service is down \ up (obtain a HANDLE to service while it is up, stop service and then use HANDLE to send a fax). State of files being sent Send an existent file (by dragging it over to the printer icon), while Fax is sending, delete the file. Delete the \WINNT\Profiles\All Users\Application Data\Microsoft\Windows NT\MSFax\queue directory (while sending, before sending). Change properties of above directory to  read only  (while sending, before sending). Rename (delete) the \WINNT\Profiles\All Users\Application Data\Microsoft\Windows NT\MSFax\coverpg directory (while or before) sending a fax using a server cover page. Delete the cover page file from above directory while sending a fax with that cover page. Archive outgoing faxes directory  of sending device is set to a non-existent directory before send. While sending, device  archive outgoing faxes directory  is changed (deleted). User defined receive directory of receiving device is   only. User defined  archive outgoing faxes directory  only. Retries Settings Send a fax that will fail, with retries set to 0, to max. Send a fax that will succeed, with retries set to 0, to max. Send a fax that will fail, with  time between retries  set to 0, to max. Send a fax that will succeed, with  time between retries  set to 0, to max. Days an unsent fax is kept (in archive or on queue?) Send a fax that will fail, with  days kept  set to 0, to max. Send a fax that will succeed, with  days kept  set to 0, to max. Send a fax that will fail, with  days kept  set to 1,   retries  set to max and  time between retries  also set to max (days kept run out before retries are exceeded). Using the Fax Send Wizard to send a fax Fax Scheduling (discount rates, now, specific time) Set discount rates to some time in the future, queue a fax to be sent when discount rates apply, change discount rates (check when is fax sent). Set discount rates to a range of 5 minutes, set number of retries to max, set time between retries to 15 minutes, queue a fax (that will fail) to be sent when discount rates apply. Thus creating a situation where the first retry is scheduled to occur when discount rates no longer apply. Fax should at least be retried the following day when discount rates apply. Set discount rates to a range of 2 minutes, queue a fax (of a hundred text filled pages) to be sent when discount rates apply. Thus creating a situation where the actual sending of the fax lasts longer than the discount rate time range. Queue a fax to be sent   (while there are no other jobs on queue, while there are other   jobs on queue, while there are   and  Specific time  jobs on queue). Queue a fax to be set  , while there are no send-enabled device. Wait a few minutes and then send-enable a device (fax should be immediately sent). Queue a fax (that will succeed) to be sent on specific time (see it is sent then). Queue a fax (that will fail) to be sent on specific time. Make sure it is retried according to  retries  settings (and not retried the same time tomorrow) Change system Date & Time settings while  specific time  send jobs are queued   change but don t click  Apply  of dialog box, change and click  Apply , change and click  Change system Date & Time settings while in  Scheduling  screen of Send Wizard   change but don t click  Apply  of dialog box, change and click  Apply , change and click  Fax Recipients  Send to single recipient (click   before going to next wizard screen \ don t click   before going to next wizard screen) Try to send to a single recipient without filling in all essential information fields. Send to multiple recipients (  all recipients to recipient list box \ do not click   for the last recipient Try to send to a multiple recipients without filling in all essential information fields of at least one (click   for last recipient \ do not click   for last recipient). Send to as many multiple recipients as possible. Sending to an internal recipient phone number (dial exactly as entered). Sending to an outside line (automatically use 9 prefix). Sending to same local area code. Sending to an international number. Invalid phone number (too short, empty, too long, alpha characters, etc) General  Check that wizard information is correctly maintained when moving among its screens (  and   buttons). Printing to the Fax printer from other applications Print an Outlook mail message which has attached files (with  print attachments  enabled). Print to file. Print several copies. Print settings (collate pages, etc). Sending a fax from Outlook  To a contact with a Fax number. To [FAX:<recipient>@<number>]. To several fax recipients and mail recipients. To fax recipient with CC to mail recipient. CC to fax recipients. Sending fax from Exchange Use Exchange to fax and print to Fax printer. Sending a fax by dragging files to the Fax printer icon Single file. Several files (make sure they are separate faxes). Several file, of which at least one (in the middle) is non-faxable. Printing to Fax printer from command line While Fax printer is default using  print <document name> While another printer is the default printer using  print /d <device name> <document name> Set device name of Fax printer (permanent or not). Net print from command line (from machine#1 net print to machine#2 that has a shared Fax printer installed). Receiving End Is an operational Fax device that will receive successfully. Is an operational Fax device that will run out of paper (or ink). Is an operational Fax device that will suddenly go off line (be powered off). Is an operational Fax device whose phone line will suddenly disconnect. Is an operational Fax device that will suddenly be paused. Is a voice line (human answers the phone). Is a data only line. Line is busy \ no answer. Is a computer (with fax software) that will suddenly reboot \ hang. Is a computer with an erroneous implementation of t30 protocol. Is a computer that will suddenly uninstall the receiving modem. Is a Fax service that will suddenly change device settings (receive \ CSID \ TSID). Is a Fax service that suddenly pauses its queue. Is a Fax service that suddenly Pauses \ Aborts \ Resumes the receiving job. Use of multiple   enabled devices on the server: Use all   devices to send several faxes at once. Enable   on all devices on server and queue as many jobs (as devices). All jobs should be sent at once. Disable   of all devices. Queue as many   jobs as devices. Then start enabling   on devices. After each enable another job should start sending. Correct use of   device priority. Pause server. Enable   on all devices on server and queue as many jobs (as devices). Pause every job on queue. Resume server. Resume a job. Check that priority 1 device starts to send that job. While priority 1 device is still busy, resume another job and check priority 2 device is used, and so on. Use VERY long files for sending, to make sure that a device doesn t finish a send until test is over. Similar to test 180, but use FaxAbort() or shorter faxes, to create situation where a high priority device is free to handle a job, and make sure it handles it. E.g.   devices priority 1 to priority 4 and leave lower priority devices  , make sure that priority 2 device is  freed  first. Resume next job (while priority 2 and priority 5 are both free), make sure that priority 2 device handles job.  Receive related: Fax service Receive functionality (via all possible tools) Different images  Paper sizes   check paper size and image proportions are maintained Take an A4 paper, mark its edges in black and write A4 in middle. Send this paper from an actual fax machine to the Fax Service. Similarly with Letter. Similarly with Legal. Similarly with 15  long. Similarly with wide (landscape) paper. Similarly with small paper size. Devices  No device is receive-enabled. Receive enabled device is busy receiving but another receive enabled device exists. Receive enabled device is busy sending but another receive enabled device exists. While receiving, device  receive  is enabled \ disabled. While receiving, device   is disabled. While receiving, device  incoming faxes directory  is changed. While receiving, change CSID and TSID of device. While an incoming call is ringing change the device  rings before answer  setting. Uninstall a modem while it is receiving. Files. While receiving a fax, delete the file that Fax creates. Delete the \WINNT\Profiles\All Users\Application Data\Microsoft\Windows NT\MSFax\faxrecieve directory (while receiving, before receiving). Queue state. Pause queue and then receive a fax (fax should be received even when queue is paused) Received Fax Verification Cover page The CP sent is the one received with all fields correctly set. The image is correctly received. The exact number of pages sent is received. Page size matches sent page size. Banner (if sent) is correct. Inbound Routing of a received fax. Routing priorities. Cause all but last priority routing to fail (play with order of methods on different devices). Route to local printer, route to network printer Run out of paper while receiving a fax to be routed to a printer Printer is offline while receiving a fax to be routed to a printer Printer is online but goes offline in midst of receiving No such printer Printer is removed from local computer while something is being routed to it Implementation of Inbound Routing Extensions. A routing extension with no methods, looking to see if user is somehow notified. Implementation of FAX_ROUTING_INSTALLATION_CALLBACK Does not perform minimal initialization required (CALLBACK structure). Receiving multiple jobs at same time on several devices. Maintaining state: Device configuration, Logging configuration, Queue state (paused or not), jobs on queue, Fax service Registry, Fax service application directories. Through service stop and start Through system crash (computer is powered off) Through modem crash (power off, disconnect) Through kill process (any of related process, such as TAPI, Fax, Queue) Job related: Abort the only job on queue while it is sending  Abort the only job on queue while it is idle (between retries) Abort the active job while all other jobs on queue are inactive Abort an active job while there are other active jobs on queue Abort a job while queue is paused Abort a receiving job (should not abort?) Job Id is represented as four digits on Fax Queue GUI, check what Id is shown for jobs number 9999, 10000 and 10001. Moreover, do this while job #1 is still on queue (paused).  Security related: Queue a few jobs of user#1 and a few jobs of user#2. Have user#1 abort jobs of user#2 When his permissions are  Submit  and  Query  only. When his permissions are  Manage Platform related: X86 computers. Alpha computers. Use all kinds of modems for sending and receiving (computer to computer faxing). Receive from common Fax devices (fax device to computer faxing).  Send to common Fax devices (computer to fax device faxing). Use common kinds of multiple ports for send \ receive. Use different Microsoft Office versions to send or print faxes. Service packs. Languages. Several Servers: Make sure it is possible to connect to several different (local and non-local) servers at same time. Make sure that while connected to several servers, I/O completion ports can be opened and initialized for every such server, and that events are posted correctly. Logging: NT5.0 Fax events logged in EventLogger. [TBD] Comet logging. [TBD] Array related (Comet feature): CRM policy is across array. A specific server in the array. Connection to a server. A specific server in the array. (not implemented) Any server in the array. (not implemented) All servers in the array (under one handle).   Client Local Fax Printer that will function opposite all Fax Servers on array, will balance loads and see all fax devices in array. Incoming. See all incoming jobs that I am supposed to see on queue. All incoming on array. Outgoing Devices. Utilization of all Fax enabled devices (under policy restriction) across array. There cannot be a situation where I want to send a fax, I connect to the array, I get a Fax Server handle of a server that all devices configured on it are   disabled. Have several servers in an array, have all devices configured as Fax enabled and   enabled. Pause the Client Local Fax queue. Queue as many (very long) jobs as there are devices in array. Resume Client Fax Local printer. Make sure all jobs handled at once.  enabled devices according to cross array priority. See all outgoing jobs that I am supposed to see on queue. All outgoing on array or all outgoing on servers that I queued jobs to. CRM related (Comet feature): Fax Server receives only fax calls from CRM. [TBD] Fax Server answers all incoming calls that CRM handoff to it. [TBD] CRM outbound allocation policy is maintained. [TBD] Broadcast (Comet feature): Cover page field rendering [TBD] Job state (correct progress indication) [TBD] Pause / resume / cancel  Entire broadcast job A specific recipient Notifications   which recipients received / failed  [TBD] Re-send To selected recipients To single  failed  recipient. To single  waiting  recipient. To single   recipient. To single  sending  recipient. To several (not all recipients in broadcast)  failed  recipients. To several (not all recipients in broadcast)  failed  and non-failed recipients. Select all recipients of broadcast after all have failed. Select all recipients of broadcast after some have failed. Select all recipients of broadcast when none have failed. To Busy To All Timing    re-send option should be made available as soon as one recipient fails. Re-send before any recipient has failed. => 10 recipients, 5 devices. While first 5 recipients are in the midst of their  first try . Re-send not possible since there is nothing to re-send yet. Re-send before all recipients first try  have started.  A re-send should not starve recipients whose  first attempt  has not yet started. => 10 recipients, 5 devices. Out of first 5 recipients 1 failed and four are still  sending . Thus one device is now free, 1 recipient is  failed , 4 are  sending  and 5 are  waiting . Re-send should be possible but carried out only after the 5  waiting  job have started their  first attempt Re-send after all recipients first try  have started. Failed  jobs should be resent as soon as possible. => 10 recipients, 5 devices. 4 recipients completed successfully, 1 failed, 5 others are now  sending . One of the  sending  jobs fails and the device is now  . User clicks  Re-send . Since all recipients first attempt  jobs have started (4 are yet unconcluded) the device should be immediately used to re-send  failed  job. We must not wait for the 4 jobs to finish. Automatic Retries Failed recipients only. Retry failed only after all recipients are handled. When a  retry  and a  first attempt  of the same broadcast are competing for a device, the  first attempt  should receive device. =>   Set retry time to zero. Broadcast to 10 recipients when there are 5 devices on server. Make sure that the first job fails. When that job  frees  the device recipient #6 should take device (it should not be used for the first job retry). Retry as soon as possible, and not after all  first attempts  end. => Broadcast (something VERY long) to 5 recipients when there are 5 devices on server. Fail one job. Make sure that other devices are still sending when it is time for that failed job to retry. It should be retried, since all other jobs are being handled. Device use Use all free devices at once Use devices according to device priority Removing recipients from a queued broadcast job Remove one / several / all recipients Remove a recipient while it is sending / paused Area Code Based Outbound Call Routing (Comet feature): [TBD] Thoughts: A client should connect to the Fax service and successfully receive a HANDLE to it. Before this client uses its HANDLE, the service is stopped. While the service is down the client attempts to use the HANDLE in any way possible. Fax Printer.  Make sure that Fax service can do everything a printer does => be a default printer, be the only printer, be shared, print from command line, print to file, set ports (?), set page preferences, etc. Make sure Fax server exports the Printer APIs and maintains whatever other Printer standards there are in its interaction with the OS, applications using printers and other components. Remove the Fax Printer port (from Hardware manager or command line). Make sure that Fax service either prevents this or at least notifies user (when?). After the Fax Printer port is removed, make sure there is some way to reinstall it using either printer tools or Fax tools. The user should not be forced to reinstall the Fax service all over. Stopping Fax service.  Stop service at  every  possible situation, see that nothing hangs and that when a   to the service is initiated an appropriate response is generated (either  service is down  or better service restarts. Connect to server (or   it for some service) while service is going down (up). Fax service documentation.  Online help. Product documentation (how to setup, configure, use etc.). API documentation (which last error is returned, consistency). General documentation and implementation documentation of test cycle and test cases. Fax service queue (try to make it overflow, show incorrect state, hang etc).  Fax service registry (try to register incorrectly, empty, register through service, register directly to registry, etc). Send a document.  Any thinkable kind. Any thinkable length. Through any tool (Word, Exchange, Outlook, SendWiz etc) both as  print  to MSFAX printer and as a Fax (if there is any way to specifically fax, like in Outlook). To any recipient (name length, invalid phone number, outside line, international line, no one etc). To many recipients (same recipient many times, as many as possible, none etc) To a line owned by server (internal Fax). Abort\Resume\Restart send. Scheduling.  Specific time => change system time&date while job already queued.  Discount rates => discount rates period of length zero (length zero is taken as all day by MSFax); after job is queued change d.r. to include current time; after job is queued change d.r. to earlier than current time; etc. Send many documents.  Try to explode queue. Send to same recipient. Send to same (many) recipients. Send Broadcast.  To single recipient. To as many recipients as possible. All recipients on same line. Recipients on different lines. Abort\Resume\Restart broadcast. One of many recipients is invalid (name, line, whatever), make sure user is notified and other recipients receive. Modems.  Number of modems installed (none, two, more than two). Fax is now limited to 2 devices. When more than 2 modems installed (prior to setup), which 2 are chosen? Can user select? How? Can a modem be installed on NT but specifically NOT on Fax? It should. Adding and removing modems (while Fax\Modem are online\offline\transmitting). Compatibility (use any thinkable modem for send and receive). Priorities (correctly updated upon install and remove). Priorities (if send via priority 1 device fails do we attempt to send via device 2?) Installation.  Clean NT 5.0 installation (with prior modems, without). Upgrade from NT 4.0 (important!), windows 95 (with At Work Fax and without), windows 98. Check with modems installed prior to upgrade and after upgrade. Check Office 97 installed prior to upgrade and after, Exchange and anything else that can fax. During Fax installation can we recognize  useful  information from other (already installed) applications? Such as cover pages, address books, dialing information etc. Check that if any OS components, that Fax is dependent upon, are removed or not installed Fax will not be installed and proper notification is issued. Uninstall Fax (all components are removed cleanly). Reinstall (NT or just Fax). Recognize whatever personalized setting that it is possible to recognize and reinstate them (e.g. find user defined cover pages on machine). Can we reinstall a specific component of Fax (say, just the send wizard or just the printer port)? Can we uninstall a specific Fax component (such as the Fax job queue or monitor)? Will the Fax service still function? Will it prevent removal of essential components (that is, allow removal of send wizard but prevent removal of queue)? If a Fax component is removed (not via uninstall Fax) will service function? Will service notify user? e.g. the Fax printer port is removed via the  Device Manager       (ControlPannel->System->Hardware tab->DeviceManager->Devices->Ports) Are cover page files read only by default? Should they be? What about server cover pages, who has permissions to edit them (on workstation installation, on client-server installation)? What is the current default installation when installing NT 5.0 (server, workstation, or what)? During installation (clean\upgrade) what part does faxsvc.exe play. Is it started? What for? When? What other processes interact with it during installation? Cover Page Editor.  Since we enable to open and edit windows 95 cover pages, shouldn t we also enable saving them in windows 95 (not NT 5.0 Fax) format? Hardware Profiles. Make sure that when using hardware profiles  (ControlPannel->System->Hardware tab->HardwareProfiles), where one profile has modems installed and another does not, the first profile has Fax enabled and the second does not. While a Fax call is in progress end it using  End Fax Call  button on Fax Monitor dialog box (while dialing, connecting, sending, and completing). Check what happens when configuration attributes (such as those in ControlPannel->Fax and in FaxServiceManagement->Devices or ControlPannel->Modems) are changed while a modem is sending\receiving.  Documents sent.  Verify received document is as sent. Cover page (with without, short, long, empty etc). All sorts of  good\bad format  documents   may be found at \\sigalitb0\roote\FaxTestEnlist\wangtest\auttest\filesafe\ \\sigalitb0\roote\FaxTestEnlist\faxapi\PrintApi\  \\sigalitb0\roote\FaxTestEnlist\faxapi\JobsApi\  \\sigalitb0\roote\FaxTestEnlist\old\testfile\ \\sigalitb0\roote\Nt\private\FaxTest\testfile\  \\sigalitb0\roote\Nt\private\fax\tiff\test\ccitt\ User permissions. Check that every action that is limited to users with certain permissions is correctly limited. Check that only allowed users could change permissions. User settings and configurations. The service should retain different user settings and configurations for many users. Administrator may effect all users. Check that Administrator effects all users while users effect themselves only. Check 3 users with different settings, then admin changes all, then users change again. Multiple MSFax services (printers) installed on same machine. Applies actions to the specific instance only (send, config, stop etc). Usage of modems. Which MSFax instance uses which modems, make sure they don t interrupt each other.  Settings and configurations are retained per instance.  RAS interaction. When fax receives data call it hands it off to RAS.  CRM interaction.  Fax retries and days kept.  Do we keep on retrying to send for up to  retries  or up to  days kept Is fax kept on queue even though it will not be retried again?  What is the relationship between retries and days kept? Fax is kept on queue for  kept days  starting at the last retry or first try? Or for which ever takes longer? What about  retries  zero, is fax kept? What happens if someone changes date&time (to next year) and immediately changes it back, are faxes discarded, can they be reproduced?  Send time. Check what happens when  Fax Printer Preferences  settings of scheduled time conflict with settings entered at SendWiz for a specific job? To open the  Fax Printer Preferences : in the Printers window select the Fax printer, right click to select  Printer preferences . The  Fax Printing Preferences  window appears. Inbound Routing. Check that each of the default (MS supplied) routing methods function correctly. Outbound Routing. Correct choosing of sending device (priorities of devices, send\receive devices etc.). Check if priority 1 device is send+receive and is now receiving that device with priority 2 is used to send and not waiting for device 1. Registry. Mainly what happens if faxsvc.exe tries to read from a field that was just removed from registry or while it is being removed. Multiple select should be enabled for all Fax related dialogs. E.g.  In job queue, several jobs may be selected and collectively canceled. In fax monitor (assuming it will eventually show the state of all service active devices), several devices may be selected and all their calls terminated. In the Fax MMC, several devices may be selected and send enabled for them all.  In the Fax MMC, several logging categories may be selected and the logging level for them all set to Medium.  Read\Write properties on related files (such as CPs, directories of Fax application, user s receive dir and sent archive dir, etc). Implementation (White box). Memory allocation and de-allocation. Resource allocation and de-allocation (HANDLEs, files, critical sections, etc) Logic flow. All possibilities are covered. Error handling.  All function calls are checked for return value.  All possible errors are covered. Every exception that may be raised will be caught (on the correct level). Data flow.  Integrity of data structures is maintained.  What is logically constant is maintained as such.  Data flow is kept at minimum. Data is copied (rather than referenced) only with good reason. No dangling references. Documentation in module, file, function and algorithm level is helpful and concise. Integration with TAPI devices and software. DialLogic Configuration after installation. Aborts. Abort job  1. (I have to try and  catch  it as one of the devices is ringing) Abort at different T30 stages.  send job   wait 1msec then abort, another send job   wait 2msec then abort,  receive job   similarly. Routing job   similarly. Abort non-existent job. Abort while service down, going down, going up. Abort while queue paused. Abort a paused job, aborting job, job that is being queued. Service running under user account. Password change. The user account permissions. IVR also use a user account so check what they re doing. Comet Fax Service Testing Page   PAGE   NUMPAGES  Microsoft Confidential Sigalit Bar,   TIME \@ "d-MMM-yy"  4-Jan-99 |vpjd^XR ztnhb\VP |vpjd |vpjd^XR |vpjd^XR |vpjd^XR |vpjd^XR |vpjd^XR ~xrlf` |vpjd^XR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\fspinitialcases.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.01@I[jMd @!)xJy ,fD,:FFSP Initial Test Cases Revision 0.2 Preface This is a draft document. About This Document For all test cases, unless stated otherwise, one functioning device is installed on the machine and the Fax Service is installed with the MS T.30 FSP and the MS Routing Extension. Unless stated otherwise, all send operations are scheduled to begin execution immediately (scheduled for  The CometFax root registry key is HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\CometFax and is referred to as   \CometFax  in this document.  Revision Information Revision Author Description 5-Jan-99 Sigalit Bar Initial version 4-Oct-99 Sigalit Bar Minor formatting changes. Replaced references to Fax registry key with CometFax. Replaced any references to an EFSP reporting statuses via a completion port, with the appropriate description of posting a status via FaxServiceCallbackEx(). Replaced any references to FaxSendDocumentForBroadcast() with FaxSendDocumentEx(). Removed any references to FaxDevGetDeliveryInfo(), because this API was discarded. Test Cases Illegal FSP/EFSP behavior  AV Test Cases: Call FaxSendDocumentEx to send a fax (using the VFSP in question).  Test Cases: A VFSP causing an AV (after a random amount of time) at the FaxDevStartJob API. Verify that: FaxSendDocumentEx returned FALSE. FaxSendDocumentEx returned last error TBD (E_FATAL_ERROR?). Job was not added to service queue. A notification indicating that an outbound call has failed, because VFSP could not initialize job, was added to log. A VFSP causing an AV (before initializing, before sending, before completed) at the FaxDevSend API. An EFSP causing an AV (before initializing, before sending, before completed) at the FaxDevSendEx API. A VFSP causing an AV (before answered, before receiving, before completed) at the FaxDevReceive API. A VFSP causing an AV (after a random amount of time) at the FaxDevEndJob API. For each test case verify that: FaxSendDocumentEx returned TRUE. Job was added to service queue. A notification indicating that an outbound/inbound call has failed, because VFSP could not send/receive/end job, was added to log. Call is retried according to service retries setting. Register the VFSP/EFSP in question using FaxRegisterServiceProvider/FaxRegisterServiceProviderEx and restart the Fax Service. Test Cases: A VFSP causing an AV (after a random amount of time) at the FaxDevInitialize API. An EFSP causing an AV (after a random amount of time) at the FaxDevInitializeEx API. Verify that: FaxRegisterServiceProvider/FaxRegisterServiceProvider returned TRUE. The FriendlyName (3rd) parameter given to FaxRegisterServiceProvider/FaxRegisterServiceProvider was used to add a registry key under the  ...\CometFax\Device Providers  registry key. Under the above key, three string entries (FriendlyName, ImageName and ProviderName) were added with data corresponding to the (3rd, 4th and 2nd) parameters given to FaxRegisterServiceProvider/FaxRegisterServiceProvider. After service restart FaxDevInitialize/FaxDevInitializeEx is invoked. A proper notification stating that VFSP/EFSP has AV ed is logged. At very least the DLL is re-loaded and only then retried. Register the EFSP in question using FaxRegisterServiceProviderEx, restart the Fax Service and then stop the service (using  net stop Test Cases: An EFSP causing an AV (after a random amount of time) at the FaxDevShutdown API. Verify that: Fax Service stops. A notification stating that the EFSP failed to shutdown cleanly is logged. Illegal packet Test Cases: Call FaxSendDocumentEx to send a fax using the VFSP/EFSP in question. Test Cases: A VFSP where FaxDevSend posts a packet with an illegal dwStatusId to the completion port (first status packet is illegal, after legal initializing status packet, after legal sending status packet, after legal completed packet). An EFSP where FaxDevSendEx posts an illegal dwStatusId in a call to FaxServiceCallbackEx (first status packet is illegal, after legal initializing status packet, after legal sending status packet, after legal completed packet). Verify that: The Fax Service considers this a fatal error and aborts the job. A notification stating that an outbound call failed due to unspecified VFSP/EFSP fatal error is logged. Cause an inbound call on a device of the VFSP/EFSP in question. Test Cases: A VFSP where FaxDevReceive posts a packet with an illegal dwStatusId to the completion port (first status packet is illegal, after legal answered status packet, after legal receiving status packet, after legal completed packet). Verify that: The Fax Service considers this a fatal error and aborts the job. A notification stating that an inbound call failed due to unspecified VFSP/EFSP fatal error is logged. Use the VFSP s completion port and key for ring events (the ones given by the service to FaxDevVirtualDeviceCreate). Test Cases: Instead of generating a legal   event, post an illegal packet to the above port. Verify that: The Fax Service does not treat the packet as if it was a legal  A notification stating that an inbound call failed due to unspecified VFSP fatal error is logged. Illegal message Test Cases: Use the FaxServiceCallbackEx function (provided by the service to the EFSP) to inform the service of status changes in the EFSP. Test Cases: The EFSP will invoke FaxServiceCallbackEx with an illegal message type. The EFSP will invoke FaxServiceCallbackEx with a legal message type but illegal message parameters. Verify that: The Fax Service does not treat the message as if it was legal. A notification stating that an unspecified EFSP device error occurred is logged. Legal FSP/EFSP behavior  API failure and success Test Cases: Call FaxSendDocumentEx to send a fax (using the VFSP/EFSP in question).  Test Cases: A VFSP where FaxDevSend, FaxDevReceive and FaxDevAbortOperation (sometimes) fail (with a legal error value). An EFSP where FaxDevSendEx, FaxDevReceive and FaxDevAbortOperation (sometimes) fail (with a legal error value). Verify that: FaxSendDocumentEx returns TRUE. Job is added to service queue. When API fails, a notification indicating that the operation (outbound call, inbound call or abort call) has failed, because VFSP function failed, is logged. When API succeeds a success notification is logged. When FaxDevSend/FaxDevSendEx fails, call is retried according to service retries setting. API sleep Test Cases: Register the VFSP/EFSP in question and restart the Fax Service. Test Cases: A VFSP/EFSP where FaxDevInitialize/FaxDevInitializeEx sleeps for a very long time. A VFSP/EFSP where FaxDevVirtualDeviceCreation/FaxDevEnumerateDevices sleeps for a very long time. Verify that: The VFSP/EFSP is successfully registered. During service restart FaxDevInitialize/FaxDevInitializeEx is called. After a sensible amount of time (~ a couple of minutes) service will give up on the VFSP/EFSP and will start without it. Register the EFSP in question and restart the Fax Service. After service comes up, stop the service again. Test Cases: An EFSP where FaxDevShutdown sleeps for a very long time. Verify that: The VFSP/EFSP is successfully registered. After service restart the EFSP successfully initializes. During service stop FaxDevShutdown is called. After a sensible amount of time (~ a couple of minutes) service will give up on the EFSP s FaxDevShutdown and will stop even though it did not complete. A notification stating that the EFSP failed to shutdown correctly is logged. Call FaxSendDocumentEx to send a fax (using the VFSP/EFSP in question).  Test Cases: A VFSP/EFSP where FaxDevSend/FaxDevSendEx sleeps for a very long time. Verify that: FaxSendDocumentEx returns TRUE. Job is added to service queue. FaxDevSend/FaxDevSendEx is called for the appropriate device. After a sensible amount of time (~10-20 minutes) service will give up on the VFSP s/EFSP s FaxDevSend/FaxDevSendEx and will consider it a failure, even though it did not complete. A notification stating that the send operation failed on timeout is logged. Call FaxSendDocumentEx to send a fax (using the VFSP/EFSP in question), while device is sending call FaxAbort for that job. Test Cases: A VFSP/EFSP where FaxDevAbortOperation sleeps for a very long time. Verify that: FaxSendDocumentEx returns TRUE. Job is added to service queue. FaxDevSend/FaxDevSendEx is called for the appropriate device. Job status changes to  sending . After FaxAbort is called, the service invokes FaxDevAbortOperation for the appropriate job. After a sensible amount of time (~10-20 minutes) service will give up on the VFSP s/EFSP s FaxDevAbortOperation and will consider it a failure, even though it did not complete. A notification stating that the abort operation failed on timeout is logged. The service removes the send job from the queue (job will not be retried). Receive a fax (using the VFSP/EFSP in question).  Test Cases: A VFSP/EFSP where FaxDevReceive sleeps for a very long time. Verify that: Receive job is added to service queue. FaxDevReceive is called for the appropriate device. After a sensible amount of time (~10-20 minutes) service will give up on the VFSP s/EFSP s FaxDevReceive and will consider it a failure, even though it did not complete. A notification stating that the receive operation failed on timeout is logged. Multi Send Capabilities  Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_MULTISEND capability.  Test Cases: Call FaxSendDocumentEx to send a single fax. Verify that: FaxSendDocumentEx returns TRUE. Job is added to service queue and begins execution. Fax is successfully sent. Test Cases: Call FaxSendDocumentEx to send a (long enough) fax, while that job is in state pending/initializing/sending call FaxSendDocumentEx again to send another fax. Verify that: FaxSendDocumentEx returns TRUE both times. 1st Job is added to service queue and begins execution. 2nd Job is added to service queue and begins execution immediately (service does not wait for the 1st job to complete). =>FaxDevSendEx (for 2nd job) is called before FaxDevEndJob (for 1st job) is called. Pause the Fax Service queue. Call FaxSendDocumentEx to send many (300) faxes. Resume queue. Verify that: FaxSendDocumentEx returns TRUE every time. All jobs are added to service queue but do not begin execution until queue is resumed. When queue is resumed all jobs begin executing at once. =>FaxDevSendEx is called for each job, before FaxDevEndJob is ever called. Call FaxSendDocumentEx to send a fax (1st job), while that job is in state pending/initializing/sending call FaxAbort (for that 1st job). Before FaxDevAbortOperation (for 1st job) returns, call FaxSendDocumentEx again to send another fax (2nd job). Verify that: FaxSendDocumentEx returns TRUE both times. 1st Job is added to service queue and begins execution. After FaxAbort (for 1st job) is called, service invokes FaxDevAbortOperation (for 1st job). 2nd Job is added to service queue and begins execution immediately (service does not wait for the 1st job to complete). =>FaxDevSendEx (for 2nd job) is called before FaxDevEndJob (for 1st job) is called. The idea here is to verify that FaxDevAbortOperation (on a multi-send device) isn t blocking. Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_MULTISEND and with the FSPI_CAP_BROADCAST capabilities.  Test Cases: Call FaxSendDocumentEx to send a fax to many (15) different recipients. Verify that: FaxSendDocumentEx returns TRUE. All (15) child jobs and a parent job are added to service queue. All child jobs begin execution at once. All child jobs and parent job complete successfully. Call FaxSendDocumentEx to send a fax to many (15) different recipients, twice. Verify that: FaxSendDocumentEx returns TRUE both times. All (15) child jobs and a parent job (of 1st broadcast) are added to service queue. All (15) child jobs and a parent job (of 2nd broadcast) are added to service queue. All child jobs (of 1st and 2nd broadcasts) begin execution at once. All child jobs and parent jobs (of both broadcasts) complete successfully. Call FaxSendDocumentEx to send a fax (1st job), while that job is in state pending/initializing/sending call FaxSendDocumentEx to send a fax to many (15) different recipients. Verify that: FaxSendDocumentEx returns TRUE both times. 1st Job is added to service queue and begins execution. All the (15) broadcast child jobs and the parent job, are added to service queue and begin execution immediately (service does not wait for the 1st job to complete). =>FaxDevSendEx (for broadcast job) is called before FaxDevEndJob (for 1st job) is called. Call FaxSendDocumentEx to send a fax to many (15) different recipients, while the child jobs are in states pending/initializing/sending call FaxSendDocumentEx to send another fax (2nd job). Verify that: FaxSendDocumentEx returns TRUE both times. All the (15) broadcast child jobs and the parent job, are added to service queue and begin execution at once. 2nd job is added to service queue and begins execution immediately. =>FaxDevSendEx (for 2nd job) is called before FaxDevEndJob (for broadcast job) is called. Pause the Fax Service queue. Call FaxSendDocumentEx to send many (20) separate faxes. Call FaxSendDocumentEx to send a fax to many (30) different recipients. Call FaxSendDocumentEx to send 20 more separate faxes. Call FaxSendDocumentEx to send another broadcast fax to more (30) different recipients. Resume queue. Verify that: FaxSendDocumentEx returns TRUE every time. All jobs (40 single recipients, 30 recipient broadcast and another 30 recipient broadcast) are added to service queue but do not begin execution until queue is resumed. When queue is resumed all jobs begin executing at once. =>FaxDevSendEx is called for each job (40 regular and 2 broadcast), before FaxDevEndJob is ever called. Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_MULTISEND and without the FSPI_CAP_BROADCAST capabilities.  Pause the Fax Service queue. Call FaxSendDocumentEx to send many (20) separate faxes. Call FaxSendDocumentEx to send a broadcast fax to many (30) different recipients. Call FaxSendDocumentEx to send more (20) separate faxes. Call FaxSendDocumentEx to send another broadcast fax to more (30) different recipients. Resume queue. Verify that: FaxSendDocumentEx returns TRUE every time. All jobs (40 single recipients, 30 recipient broadcast and another 30 recipient broadcast) are added to service queue but do not begin execution until queue is resumed. When queue is resumed all jobs begin executing at once. =>FaxDevSendEx is called for each job (40 regular and 60 broken-up from the 2 broadcasts), before FaxDevEndJob is ever called. Make sure that any faxes would be sent via a single EFSP that registered without the FSPI_CAP_MULTISEND capability.  Test Cases: Call FaxSendDocumentEx to send a fax, while that job is in state pending/initializing/sending call FaxSendDocumentEx again to send another fax. Pause the Fax Service queue. Call FaxSendDocumentEx to send many (300) faxes. Resume queue. Call FaxSendDocumentEx to send a fax (1st job), while that job is in state pending/initializing/sending call FaxAbort (for that 1st job). Before FaxDevAbortOperation (for 1st job) returns, call FaxSendDocumentEx again to send another fax (2nd job). For every test case verify that: FaxSendDocumentEx returns TRUE every time. Job execution is one at a time. => FaxDevSendEx (for job j+1) is always called after FaxDevEndJob (for job j) has been called.  Make sure that any faxes would be sent via a single EFSP that registered without the FSPI_CAP_MULTISEND and with the FSPI_CAP_BROADCAST capabilities.  Test Cases: Call FaxSendDocumentEx to send a fax to many (15) different recipients. Call FaxSendDocumentEx to send a fax to a single recipient (1st job), while that job is in state pending/initializing/sending call FaxSendDocumentEx to send a fax to many (15) different recipients. Call FaxSendDocumentEx to send a fax to many (15) different recipients, while the child jobs are in states pending/initializing/sending call FaxSendDocumentEx to send another fax (2nd job). Pause the Fax Service queue. Call FaxSendDocumentEx to send many (20) separate faxes. Call FaxSendDocumentEx to send a broadcast fax to many (30) different recipients. Call FaxSendDocumentEx to send more (20) separate faxes. Call FaxSendDocumentEx to send another broadcast fax to more (30) different recipients. Resume queue. For every test case verify that: FaxSendDocumentEx returns TRUE every time. Job execution is one at a time. => FaxDevSendEx (for job j+1) is always called after FaxDevEndJob (for job j) has been called. Note- since EFSP has broadcast capability FaxDevSendEx is called once per broadcast.  Make sure that any faxes would be sent via a single EFSP that registered without the FSPI_CAP_MULTISEND and without the FSPI_CAP_BROADCAST capabilities.  Pause the Fax Service queue. Call FaxSendDocumentEx to send many (20) separate faxes. Call FaxSendDocumentEx to send a broadcast fax to many (30) different recipients. Call FaxSendDocumentEx to send more (20) separate faxes. Call FaxSendDocumentEx to send another broadcast fax to more (30) different recipients. Resume queue. Verify that: FaxSendDocumentEx returns TRUE every time. Job execution is one at a time. => FaxDevSendEx (for job j+1) is always called after FaxDevEndJob (for job j) has been called. Note- since EFSP has no broadcast capability FaxDevSendEx is called for each recipient in a broadcast. In this case a total of 100 times (20+30+20+30).  Where both an EFSP that registered with the FSPI_CAP_MULTISEND capability and with the FSPI_CAP_BROADCAST capability and a legacy FSP are registered. Make sure that 1st broadcast is  handled  by EFSP and 2nd broadcast is  handled  by legacy FSP Pause Fax Service queue. Call FaxSendDocumentEx to send a broadcast fax to many (30) different recipients, twice. Resume queue. Make sure that all faxes are successfully sent. Verify that: FaxSendDocumentEx returns TRUE both times. 1st call to FaxSendDocumentEx adds one parent job and all (30) child jobs to queue. 2nd call to FaxSendDocumentEx adds one parent job and all (30) child jobs to queue. The EFSP s FaxDevSendEx is called only once. On the legacy FSP job execution is one at a time. FaxDevSend (for job j+1) will be invoked after FaxDevEnd (for job j) has been invoked. On the EFSP all jobs begin execution at once. Stress Test Cases: Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_MULTISEND and with the FSPI_CAP_BROADCAST capabilities.  Run many (100) iterations of the following. Randomly pick a number n (n<31). Use n to either call FaxSendDocumentEx n times with a single recipient or call FaxSendDocumentEx a single time with all n (different) recipients. Use fax images that will take a long time to transmit. Verify that: FaxSendDocumentEx returns TRUE every time. All jobs (regular, child and parent) are added to service queue and begin execution immediately. As soon as a job is added to queue it begins execution, even if other jobs have not yet completed. Broadcast Capabilities  Make sure that any faxes would be sent via a single legacy FSP that registered via the FaxRegisterServiceProvider Client API.  Test Cases: Call FaxSendDocumentEx to send many (300) separate faxes to different recipients. Make sure that all faxes are successfully sent. Verify that: FaxSendDocumentEx returns TRUE every time. 300 separate (regular) jobs are added to service queue. FaxDevStart is called for every job (a total of 300 times). FaxDevSend is called for every job (a total of 300 times). FaxDevEnd is called for every job (a total of 300 times) after that job completes. Job execution is one at a time. FaxDevSend (for job j+1) will be invoked after FaxDevEnd (for job j) has been invoked. Call FaxSendDocumentEx to send a fax to a single recipient. Make sure that fax is successfully sent. Verify that: FaxSendDocumentEx returns TRUE. A single broadcast job with a single recipient is added to service queue. FaxDevStart, FaxDevSend and then FaxDevEnd are called for this job. For all intents and purposes this job is treated as if it was created by a call to the legacy FaxSendDocument API. Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_BROADCAST capability.  Test Cases: Call FaxSendDocumentEx to send a broadcast fax to a few (3) different recipients. Make sure that all faxes are successfully sent. Call FaxSendDocumentEx to send a broadcast fax to many (3000) different recipients. Make sure that all faxes are successfully sent. Call FaxSendDocumentEx to send a broadcast fax to many (3000) recipients. Where all recipients are identical (same details and phone numbers). Make sure that all faxes are successfully sent. Verify that: FaxSendDocumentEx returns TRUE. One parent job and all (3 or 3000) child jobs are added to service queue. FaxDevSendEx is called only once. When a child job completes, FaxDevEndJob is invoked with the corresponding child job handle. FaxDevEndJob with the parent job handle is called (only) after FaxDevEndJob was called for all (3 or 3000) child jobs. Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_BROADCAST capability and different combinations of FSPI_CAP_ABORT_PARENT and FSPI_CAP_ABORT_RECIPIENT capabilities.  Test Cases: Abortion of child/parent job. Make sure that any faxes would be sent via a single EFSP that registered with the FSPI_CAP_BROADCAST capability.  Test Cases: Pause and resume of child/parent job. Where both an EFSP that registered with the FSPI_CAP_BROADCAST capability and a legacy FSP are registered. Make sure that 1st broadcast is  handled  by EFSP and 2nd broadcast is  handled  by legacy FSP.  Test Cases: Pause Fax Service queue. Call FaxSendDocumentEx to send a broadcast fax to many (30) different recipients, twice. Resume queue. Make sure that all faxes are successfully sent. Verify that: FaxSendDocumentEx returns TRUE both times. 1st call to FaxSendDocumentEx adds one parent job and all (30) child jobs to queue. 2nd call to FaxSendDocumentEx adds one parent job and all (30) child jobs to queue. The EFSP s FaxDevSendEx is called only once. On the legacy FSP job execution is one at a time. FaxDevSend (for job j+1) will be invoked after FaxDevEnd (for job j) has been invoked. On the EFSP job execution is one at a time (not multi-send). Only one child job is executing at any given time. Job Context Reestablishment  Make sure that any faxes would be sent via a single EFSP that exports the optional FaxDevReestablishJobContext API and whose FaxDevSendEx returns message ids. Test Cases: Call FaxSendDocumentEx to send a fax. While job is pending/initializing/sending, stop the fax service. Restart the fax service immediately.  Call FaxSendDocumentEx to send a fax. While job is pending/initializing/sending, kill the fax service process. Restart the fax service immediately.  Call FaxSendDocumentEx to send a fax. While job is pending/initializing/sending, reboot the machine immediately.  For each test case verify that: After service restarts, FaxDevReestablishJobContext is called with the initial message ids and returns new job handles associated with the jobs that were queued before the service was stopped. A job is added to fax queue and its state matches the state before service went down. Make sure that any faxes would be sent via a single EFSP that exports the optional FaxDevReestablishJobContext API and whose FaxDevSendEx returns message ids. Test Cases: Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_FAILED. Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_INVALID_JOB_HANDLE. Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_INVALID_MESSAGE_ID. For each test case verify that: After service restarts, FaxDevReestablishJobContext is called with the initial message ids. Since the attempt to reestablish job context has failed the service will restart the job from scratch. => FaxDevSendEx is called. Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_NETWORK when called for the 1st time. When called again it will return successfully. Verify that: After service restarts, FaxDevReestablishJobContext is called with the initial message ids. Since the attempt to reestablish job context has failed with FSPI_E_NETWORK the service will attempt to reestablish job context again. => Fax Service  waits  a while and then calls FaxDevReestablishJobContext with the same job handle and the same message id. A job is added to fax queue and its state matches the state before service went down. Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will always return with FSPI_E_NETWORK. Verify that: After service restarts, FaxDevReestablishJobContext is called with the initial message ids. Since the attempt to reestablish job context has failed with FSPI_E_NETWORK the service will attempt to reestablish job context again. => Fax Service  waits  a while and then calls FaxDevReestablishJobContext with the same job handle and the same message id. After several such tries the service  gives-up  and restarts the job from scratch. => FaxDevSendEx is called. Make sure that any faxes would be sent via a single EFSP that exports the optional FaxDevReestablishJobContext API, whose FaxDevSendEx returns message ids, and has registered with the FSPI_CAP_BROADCAST capability. Test Cases: Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will always return successfully. Verify that: After service restarts, FaxDevReestablishJobContext is called with the initial message ids (parent message id and all child message ids) Test Cases: Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_FAILED. Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_FAILED. Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_INVALID_JOB_HANDLE. Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_INVALID_JOB_HANDLE. Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_INVALID_MESSAGE_ID. Call FaxSendDocumentEx to send a broadcast fax to many (15) recipients. While some of the child jobs have completed, others are pending and one is sending, stop the fax service. Restart the fax service immediately.  Make sure that FaxDevReestablishJobContext will return with FSPI_E_INVALID_MESSAGE_ID. For each test case verify that: After service restarts, FaxDevReestablishJobContext is called with the initial message ids. When an attempt to reestablish job context fails the service will discard all the new job handles it has obtained and will restart the broadcast from scratch. => FaxDevSendEx is called. Make sure that any faxes would be sent via a single EFSP that exports the optional FaxDevReestablishJobContext API but whose FaxDevSendEx does not return message ids. Test Cases: Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Verify that: Job is restarted from scratch => FaxDevSendEx is called. Make sure that any faxes would be sent via an EFSP that does not export the optional FaxDevReestablishJobContext API but whose FaxDevSendEx does return message ids. Test Cases: Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Verify that: Job is restarted from scratch => FaxDevSendEx is called. Make sure that any faxes would be sent via a legacy FSP. Test Cases: Call FaxSendDocumentEx to send a fax. While job is sending, stop the fax service. Restart the fax service immediately.  Verify that: After service restarts, job is restarted from scratch => FaxDevStartJob is called to obtain a new handle and then FaxDevSend is called with that handle. Where both a legacy FSP and an EFSP that exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, are registered. Make sure that 1st fax is  handled  by legacy FSP and 2nd fax is  handled  by EFSP. Test Cases: Call FaxSendDocumentEx to send a fax, twice. While both jobs are sending, stop the fax service. Restart the fax service immediately.  Verify that: After service restarts, the 1st job is restarted from scratch => the legacy FSP s FaxDevStartJob is called to obtain a new handle and then FaxDevSend is called with that handle. 2nd job is reestablished => the EFSP s FaxDevReestablishJobContext is called with the 2nd job s message ids. FSPs/EFSPs that do not export all required APIs  Registration via FaxRegisterServiceProvider  Register a DLL using the FaxRegisterServiceProvider API. Test Cases: A VFSP DLL exporting all FSP APIs - the FaxDevReceive API. A VFSP DLL exporting all FSP APIs - the FaxDevSend API + the FaxDevSendEx API + the FaxDevInitializeEx API. An EFSP DLL exporting all mandatory EFSP APIs + the FaxDevSend API (missing the FaxDevInitialize API). For each test case verify that: FaxRegisterServiceProvider returned FALSE. FaxRegisterServiceProvider returned last error TBD (E_ILLEGAL_IMAGE?). No VFSP registry entries were added under  \CometFax\Device Providers  key (or anywhere else). A call to Fax Service Client API FaxEnumPorts before and after registration returns exactly the same information (no new VFSP devices are enumerated). Restart the Fax Service and call FaxEnumPorts yet again, make sure same information is returned. Send and receive a fax using the MS T.30 FSP. Registration via FaxRegisterServiceProviderEx  Register a DLL using the FaxRegisterServiceProviderEx API. Test Cases: An EFSP DLL exporting all mandatory EFSP APIs   the FaxDevSendEx API. A VFSP DLL exporting all FSP APIs + the FaxDevInitializeEx API + the FaxDevSendEx API + all optional EFSP APIs (missing the mandatory FaxDevShutdown EFSP API). For each test case verify that: FaxRegisterServiceProviderEx returned FALSE. FaxRegisterServiceProviderEx returned last error TBD (E_ILLEGAL_IMAGE?). No VFSP registry entries were added under  \CometFax\Device Providers  key (or anywhere else). A call to Fax Service Client API FaxEnumPorts before and after registration returns exactly the same information (no new EFSP devices are enumerated). Restart the Fax Service and call FaxEnumPorts yet again, make sure same information is returned. Send and receive a fax using the MS T.30 FSP. FSPs/EFSPs that export more than the required APIs  Registration via FaxRegisterServiceProvider  Register a DLL using the FaxRegisterServiceProvider API. Test Cases: An FSP DLL exporting all the FSP APIs + the FaxDevInitializeEx API + the FaxDevSendEx API + the FaxDevShutdown API + all other optional EFSP APIs. For each test case verify that: FaxRegisterServiceProvider returned TRUE. The FriendlyName (3rd) parameter given to FaxRegisterServiceProvider was used to add a registry key under the  ...\CometFax\Device Providers  registry key. Under the above key, three string entries (FriendlyName, ImageName and ProviderName) were added with data corresponding to the (3rd, 4th and 2nd) parameters given to FaxRegisterServiceProvider. As service is stopping (e.g. due to  net stop fax ) FaxDevShutdown is not invoked. After service restart, FaxDevInitialize is invoked (and not FaxDevInitializeEx). After service restart, a call to FaxSendDocumentEx (which will use this VFSP) invokes FaxDevSend (and not FaxDevSendEx). A call to Fax Service Client API FaxEnumPorts after registration (and after service restart) enumerates the new VFSP devices. Note that service can succeed to enumerate the devices only if the VFSP s FaxDevVirtualDeviceCreation and FaxDevInitialize behave legally and succeed. Registration via FaxRegisterServiceProviderEx  Register a DLL using the FaxRegisterServiceProviderEx API. Test Cases: An EFSP DLL exporting all mandatory EFSP APIs + the FaxDevInitialize API + the FaxDevSend API. For each test case verify that: FaxRegisterServiceProviderEx returned TRUE. The FriendlyName (3rd) parameter given to FaxRegisterServiceProviderEx was used to add a registry key under the  ...\CometFax\Device Providers  registry key. Under the above key, three string entries (FriendlyName, ImageName and ProviderName) were added with data corresponding to the (3rd, 4th and 2nd) parameters given to FaxRegisterServiceProvider. As service is stopping (e.g. due to  net stop fax ) FaxDevShutdown is invoked. After service restart, FaxDevInitializeEx is invoked (and not FaxDevInitialize). After service restart, a call to FaxSendDocumentEx (which will use this EFSP) invokes FaxDevSendEx (and not FaxDevSend). A call to Fax Service Client API FaxEnumPorts after registration (and after service restart) enumerates the new EFSP devices. Note that service can succeed to enumerate the devices only if the EFSP s FaxDevInitializeEx behaves legally and succeeds. EFSP which export optional APIs  Valid  Register a DLL using the FaxRegisterServiceProviderEx API. Test Cases: An EFSP DLL exporting all mandatory EFSP and none of the optional APIs. An EFSP DLL exporting all mandatory EFSP and all of the optional APIs. For each test case verify that: FaxRegisterServiceProviderEx returned TRUE. The FriendlyName (3rd) parameter given to FaxRegisterServiceProviderEx was used to add a registry key under the  ...\CometFax\Device Providers  registry key. Under the above key, three string entries (FriendlyName, ImageName and ProviderName) were added with data corresponding to the (3rd, 4th and 2nd) parameters given to FaxRegisterServiceProvider. A call to Fax Service Client API FaxEnumPorts after registration (and after service restart) enumerates the new EFSP devices. Note that service can succeed to enumerate the devices only if the EFSP s FaxDevInitializeEx behaves legally and succeeds. A call to FaxSendDocumentEx (which will use this new EFSP device) will invoke FaxDevSendEx and FaxDevEndJob. Note that the EFSP should implement these functions to behave legally and succeed. FSP Test Cases Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  4-Oct-99 uka\X |rh^YTLD |toe[VQID wqlg_WRH ~tj`VQLD vlgbZUKA vni_UKC> xndZPHC zpf\WRJB uphcYOE xndZPF> zuphc^VQLD }sniaYQLB zrjbZRJE wrh^YKE }xndZPF zumh^TJ@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\faxmdmlab.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Fax And Modem Sharing Lab Title _PID_GUIDFax And Modem Sharing Lab Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0Fax And Modem Sharing Lab Overall numbers: Machines 162 Machines to be located in lab. 18 Machines to be located in rooms. Outlook switches About 26 Outlook Switch boxes to be located in lab. 6 Outlook Switch boxes to be located in rooms. Every bullet group below should be using a single monitor,  where the machines are installed on an Outlook switch. Analog Lines 232 Internal Analog phone lines to be located in lab. 2 External Analog phone lines to be located in lab. 24 Internal Analog phone lines to be located in rooms. ISDN BRI Lines 6 ISDN BRI phone lines to be located in lab. E1 / ISDN PRI Lines We may require 1 E1 phone line and 1 ISDN PRI phone line, to be located in lab. We intend to try and acquire Fax boards that use E1 and ISDN PRI phone lines, but at this time we do not have any. Modems 220 Analog modems to be located in lab. 24 Analog modems to be located in rooms. Network  100 MHz network connections throughout the lab. 2 SBS domains, each on a separate 100 MHz network (see SBS bullet groups detailed below), to be located in lab. Separate domain for Scale tests (section 2.1.21), and domain network separated from the rest of the lab by a 100 MHz network switch. Separate domain for Stress and Performance tests (section 2.1.25), and domain network separated from the rest of the lab by a network switch. 1 Router to be located in lab. The router is required for testing a known MP issue. XX 100 MHz hubs to be located in lab. XX 100 MHz hubs to be located in rooms. Multi-ports  4 (24 port) multi-ports throughout the lab. See sections 2.1.8, 2.1.13, 2.1.20 and 2.1.25 below. 1 (48 port) multi-ports throughout the lab. See section 2.1.12 below. 2 (4 port) multi-ports throughout the lab. See section 2.2.2 below. Details Fax Test Areas BVT and System Tests For running our BVT suite - W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on server machine For running our UI (Visual Test ) System Test suite - W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on server machine Printing from applications For running PCT suites - W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on server machine Client UI 2 W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 4 modems and 4 analog lines on server machine Admin UI 2 W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on server machine BOS/SBS integration  For upgrading to SBS 5.0 and running SBS integration tests - SBS 4.5 NT4 server (domain) SBS 4.5 NT4 client SBS 4.5 Win95 client SBS 4.5 Win98 client SBS 4.5 W2K client SBS 4.5 Millennium client 2 modems and 2 analog lines on server machine For upgrading to BO 5.0 and running BO integration tests - BO 4.5 server (domain) BO 4.5 NT4 client BO 4.5 Win95 client BO 4.5 Win98 client BO 4.5 W2K client BO 4.5 Millennium client 2 modems and 2 analog lines on server machine Office integration No Lab requirements.  MAPI Outlook Extension Testing the Fax Outlook Extension - 1 W2K 2195 fre.srv 1 dual boot W2K fre.wks and NT4 fre.wks machine 1 dual boot W2K fre.wks and Win95 machine 1 dual boot W2K fre.wks and Win98 machine 1 dual boot W2K fre.wks and Millennium machine 4 usernames with mail in HAI-MSG-01 2 modems and 2 analog lines on server machine T.30 FSP For running Telegra suites - Telegra machine W2K 2195 fre.srv 2 modems and 2 analog lines on server machine analog line on Telegra machine For running Genoa suites - Genoa machine W2K 2195 fre.srv 2 modems and 2 analog lines on server machine analog line on Genoa machine Stress (many T30 sends and receives) - W2K 2195 fre.srv  Multi-port (with at least 24 ports) on server machine 24 modems and 24 analog lines on server machine MS Inbound Routing Extension Testing routing via the MS Inbound Routing Extension - W2K 2195 fre.srv  4 modems and 4 analog lines on server machine EFSP \ FSP Acceptance BVT suite on a server with 3rd party FSPs\EFSPs - W2K 2195 fre.srv Lines for Brooktrout (Q: how many and what kind?) Lines for AVM (Q: how many and what kind?) ISDN lines for ISDN emulation (Q: how many and what kind?) 2 modems and 2 analog lines on server machine EFSPI   EFSPI test suite - W2K 2195 fre.srv 2 modems and 2 analog lines on server machine Modem compatibility W2K 2195 fre.srv Multi-port (with at least 64 ports) Modems from as many different brands, with an analog line for every modem. Estimating we will reach a total of 48 brands, that is 48 modems with 48 analog lines. We actually plan to purchase 2 modems of every brand, where only one modem of every brand will be connected in the lab, and the other modem will be in storage as a backup. Outbound (FSP) routing Outbound Routing tests - W2K 2195 fre.srv 24 modems and 24 analog lines on server machine Setup (& uninstall) Setup tests - W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on server machine OS Upgrade Scenarios Testing upgrade of SBS server and client to W2K and SBS 5.0 - SBS 4.5 NT4 server (domain) SBS 4.5 NT4 client SBS 4.5 Win95 client SBS 4.5 Win98 client SBS 4.5 W2K client SBS 4.5 Millennium client 2 modems and 2 analog lines on server machine Testing upgrade of BO server and client to W2K and BO 5.0 - BO 4.5 NT4 server  BO 4.5 NT4 client BO 4.5 Win95 client BO 4.5 Win98 client BO 4.5 W2K client BO 4.5 Millennium client 2 modems and 2 analog lines on server machine Setup tests on BO 4.5 that was upgraded from SBS 4.5 (and therefor has fax) - BO 4.5 NT4 server  BO 4.5 NT4 client BO 4.5 Win95 client BO 4.5 Win98 client BO 4.5 W2K client BO 4.5 Millennium client 2 modems and 2 analog lines on server machine Inbound routing API Inbound Routing API test suite - W2K 2195 fre.srv 2 modems and 2 analog lines on server machine Co-existence with fax applications Testing co-existence of fax on the clients - W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on every machine, that is 12 modems and 12 analog lines in all. Adaptive answering Lab requirements are incorporated in the  Modem Compatibility  item. Queue functionality W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 6 modems and 6 analog lines on server machine Multi-port (with at least 6 ports) for server machine. Q[Miri]: aren t 2 modems enough? Logging For testing Logging on clients and server - W2K 2195 fre.srv 2 modems and 2 analog lines on server machine Q[Ronen]:Do we need clients (any logging on clients)? Scale Scalability tests - W2K 2195 fre.srv (strong machine) 6 W2K 2195 fre.wks machines. Each machine can simulate about 15 user sessions,  so we can have 90 W2K concurrent user sessions. 6 NT4 1381 fre.wks machines (strong machines). Each machine can simulate about 15 user sessions,  so we can have 90 NT4 concurrent user sessions. 3 Win95 latest machines (strong machines). Each machine can simulate about 15 user sessions,  so we can have 45 Win95 concurrent user sessions. 5 Win98 latest machines (strong machines). Each machine can simulate about 15 user sessions,  so we can have 75 Win98 concurrent user sessions. 1 Millennium machine (strong machine). Each machine can simulate about 15 user sessions,  so we can have 15 Millennium concurrent user sessions. 24 modems and 24 analog lines on server machine. Multi-port (with at least 24 ports) on server machine. At least 180 user accounts. Separate domain (for ease of user management). Network separated from rest of Lab by a network switch. Security 2 W2K 2195 fre.srv W2K 2195 fre.wks NT4 1381 fre.wks Win95 latest Win98 latest Millennium 2 modems and 2 analog lines on server machine 6 user accounts Server side rendering W2K 2195 fre.srv 2 modems and 2 analog lines on server machine Localization, globalization, Y2K For testing JPN Fax on JPN OS - W2K 2195 fre.srv JPN W2K 2195 fre.wks JPN NT4 1381 fre.wks JPN Win95 latest JPN Win98 latest JPN Millennium JPN 2 modems and 2 analog lines on server machine For testing GER Fax on GER OS - W2K 2195 fre.srv GER W2K 2195 fre.wks GER NT4 1381 fre.wks GER Win95 latest GER Win98 latest GER Millennium GER 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on GER OS - W2K 2195 fre.srv GER W2K 2195 fre.wks GER NT4 1381 fre.wks GER Win95 latest GER Win98 latest GER Millennium GER 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on JPN OS - W2K 2195 fre.srv JPN W2K 2195 fre.wks JPN NT4 1381 fre.wks JPN Win95 latest JPN Win98 latest JPN Millennium JPN 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on Intl ENG server with JPN clients - W2K 2195 fre.srv (Intl ENG) W2K 2195 fre.wks JPN NT4 1381 fre.wks JPN Win95 latest JPN Win98 latest JPN Millennium JPN 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on Intl ENG server with GER clients - W2K 2195 fre.srv (Intl ENG) W2K 2195 fre.wks GER NT4 1381 fre.wks GER Win95 latest GER Win98 latest GER Millennium GER 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on Intl ENG server with HEB clients - W2K 2195 fre.srv (Intl ENG) W2K 2195 fre.wks HEB NT4 1381 fre.wks HEB Win95 latest HEB Win98 latest HEB Millennium HEB 2 modems and 2 analog lines on server machine For Y2K tests - W2K 2195 fre.srv  W2K 2195 fre.wks  NT4 1381 fre.wks  Win95 latest  Win98 latest  Millennium 2 modems and 2 analog lines on server machine Stress and Performance 2 W2K 2195 fre.srv (strong machines). One of the server machines should be multi-processor.  6 W2K 2195 fre.wks (strong machines). 6 NT4 1381 fre.wks (strong machines). 3 Win95 latest (strong machines). 5 Win98 latest (strong machines). Millennium (strong machine). One of the above client machines should be multi-processor as well. Multi-port (with at least 24 ports) on server machine. 24 modems and 24 analog lines on server machine. At least 20 user accounts. Separate domain (for ease of user management). Network separated from rest of Lab by a network switch. Image viewer W2K 2195 fre.srv  W2K 2195 fre.wks  NT4 1381 fre.wks  Win95 latest  Win98 latest  Millennium  2 modems and 2 analog lines on server machine MS fax tiff tags W2K 2195 fre.srv  2 modems and 2 analog lines on server machine Cover page editor W2K 2195 fre.srv  W2K 2195 fre.wks  NT4 1381 fre.wks  Win95 latest  Win98 latest  Millennium  2 modems and 2 analog lines on server machine Performance counters W2K 2195 fre.srv  2 modems and 2 analog lines on server machine Client API (FXSAPI.DLL) W2K 2195 fre.srv  W2K 2195 fre.wks  NT4 1381 fre.wks  Win95 latest  Win98 latest  Millennium  2 modems and 2 analog lines on server machine Help files No Lab requirements. No Lab requirements. 64 bit  1 64 bit machine. 2 modems and 2 analog lines on server machine Modem Sharing Test Areas The machines detailed in this section are dedicated MP machines. In addition to the MP machines detailed below, MP tests will be installed on many other machines in the Lab, which will run the MP suites from time to time. Application Tests For running Application suites - 1 MP server W2K 2195 fre.srv 2 MP clients W2K 2195 fre.wks 2 MP clients NT4 2 MP clients Win9x  6 modems and 6 analog lines on server machine BVT (ComApi) 2 MP servers W2K 2195 fre.srv 1 MP clients W2K 2195 fre.wks 1 MP clients NT4 1 MP clients Win9x 1 Digi multi-port (for first server) 1 Equinex multi-port (for second server) 6 thick debug cables Other 1 W2K 2195 fre.srv (as a debugger for all MP machines) 12 debug cables (for debugging the drivers) 4 registrations of the   application.  Build Process Build Machine 1 W2K 2195 fre.srv  above should be a very strong machine above should have very large hard-disk for our drops above should have a fast Ethernet card and fast network connection (100 MHz). Archive Machine This machine will serve as our sources archive/backup machine - 1 W2K 2195 fre.srv  above should have very large hard-disk for our drops Personal Machines Development Machines Machines for developing test software - 1 W2K 2195 fre.srv per team human resource. 6 machines in all. Test Machines Machines for testing and debugging developed test software - 2 test machines per tester  W2K fre.srv, W2K fre.wks, NT4 fre.wks, and Win9x machine. 12 machines in all. 2 modems and 2 analog lines for every test machine. 24 modems and 24 lines in all. Machine Reuse Localization and Globalization Machines All Localization and Globalization tests will use a single set of GER clients. All Localization and Globalization tests will use a single set of JPN clients. All Localization and Globalization tests will use a single set of HEB clients. Y2K tests will be performed on other machines. In all 22 machines (7 servers, 15 clients) and 14 modems, as follows: Client machines  W2K 2195 fre.wks JPN NT4 1381 fre.wks JPN Win95 latest JPN Win98 latest JPN Millennium JPN W2K 2195 fre.wks GER NT4 1381 fre.wks GER Win95 latest GER Win98 latest GER Millennium GER W2K 2195 fre.wks HEB NT4 1381 fre.wks HEB Win95 latest HEB Win98 latest HEB Millennium HEB For testing JPN Fax on JPN OS - W2K 2195 fre.srv JPN 2 modems and 2 analog lines on server machine For testing GER Fax on GER OS - W2K 2195 fre.srv GER 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on GER OS - W2K 2195 fre.srv GER 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on JPN OS - W2K 2195 fre.srv JPN 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on Intl ENG server with JPN clients - W2K 2195 fre.srv (Intl ENG) 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on Intl ENG server with GER clients - W2K 2195 fre.srv (Intl ENG) 2 modems and 2 analog lines on server machine For testing Intl ENG Fax on Intl ENG server with HEB clients - W2K 2195 fre.srv (Intl ENG) 2 modems and 2 analog lines on server machine Run Y2K, Cover Page Editor and Image Viewer tests on same Machines In all 6 machines (1 server and 5 clients). Run Logging, Server Side Rendering, MS Fax Tiff Tags and Performance Counters tests on same Machines In all 6 machines (1 server and 5 clients). Run BOS/SBS Integration and OS Upgrade Scenarios on same Machines In all 18 machines (3 server and 15 clients). Run API BVT and UI System Tests on same Machines In all 6 machines (1 server and 5 clients). Run Queue Functionality tests, Security tests and Client API tests on same Machines In all 7 machines (2 server and 5 clients). Run Client UI tests and Admin UI tests on same Machines In all 7 machines (2 server and 5 clients). Fax & Modem Sharing Lab Page   PAGE   NUMPAGES  Microsoft Confidential  FILENAME  FaxLab1.doc Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  29-Feb-00 {me]OG? znke]UME= {se]UME xph`XUME xjg_WOGD zrj\YQI wogYVNF> yqi[XPH zrjbZROA> ume]UME }ume]UMJB yqiaYVNF yqiaSKC yqi[SK= {skcUM? xph`XPH yvh\YQC@ ~vnf^VNF }zrj\YKH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\fsp_api_test_spec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0+!1yJf ]#:&]FSP API Test Specification   Revision 0.2 Test the Comet Fax Service s invocation of and reaction to FSP APIs. Objectives Test Comet Fax Service distinction between legacy FSPs and EFSPs. Test Comet Fax Service reactions to illegal behavior of FSPs (AV in FSP, missing APIs, illegal error values, etc.). Test correct and timely invocation of optional EFSP APIs (such as delivery information, job context reestablishment, etc.) according to the EFSP s reported capabilities. Test that Comet Fax Service correctly responds to events generated and messages sent by EFSPs.  Test Comet Fax Service with many different FSPs installed at once. Emulate FOIP EFSP behavior and check that all likely user scenarios for FOIP are doable with EFSPI. Approach Implement different FSPs and EFSPs, targeting the different test areas. Use the Comet Fax Service Client APIs to implement test cases. Revision Information Revision Author Description 5-Jan-99 Sigalit Bar Initial version 4-Oct-99 Sigalit Bar FaxDevGetDeliveryInfo() was removed from API and accordingly all references to it were removed from this spec. Added a note regarding FaxRegisterServiceProvider() and FaxRegisterServiceProviderEx() at clause 5. Replaced references to FaxSendDocumentForBroadcast() with FaxSendDocumentEx(). Removed any references to FaxDevStartJob() as part of the EFSP sending process, because FaxDevSendEx() now includes this functionality. MS Fax Service Test Areas Note   At this point in time it is unclear whether FaxRegisterServiceProvider() and FaxRegisterServiceProviderEx() will be implemented. In case these APIs are not implemented the FSPs/EFSPs will create the appropriate registry entries themselves. That is to say, that the test cases will not require any changes, only the FSPs  DllRegisterServer() implementation may change. FSPs/EFSPs that do not export all required APIs  A DLL, which registered using the FaxRegisterServiceProvider Client API, must export all FSP APIs (and is allowed to export other functions as well). A DLL, which registered using the FaxRegisterServiceProviderEx Client API, must export all EFSP mandatory APIs (and is allowed to export other functions as well). A DLL, which does not meet the above conditions, must not be allowed to register. It should be immediately unloaded by the service. The service should log a warning describing the problem with the APIs exported by the DLL and state that this FSP/EFSP is considered invalid. Registration via FaxRegisterServiceProvider  An FSP exporting all FSP APIs - the FaxDevInitialize API. An FSP exporting all FSP APIs - the FaxDevAbortOperation API. An FSP exporting all FSP APIs - the FaxDevEndJob API. An FSP exporting all FSP APIs - the FaxDevStartJob API. An FSP exporting all FSP APIs - FaxDevSend API. An FSP exporting all FSP APIs - the FaxDevReceive API. An FSP exporting all FSP APIs - the FaxDevReportStatus API. An FSP exporting all FSP APIs - the FaxDevInitialize API + the FaxDevInitializeEx API. An FSP exporting all FSP APIs - the FaxDevSend API + the FaxDevSendEx API. An FSP exporting all FSP APIs - the FaxDevSend API + the FaxDevSendEx API + the FaxDevInitializeEx API. An EFSP exporting all mandatory EFSP APIs. An EFSP exporting all mandatory EFSP APIs + the FaxDevInitialize API. An EFSP exporting all mandatory EFSP APIs + the FaxDevSend API. Registration via FaxRegisterServiceProviderEx  An EFSP exporting all mandatory EFSP APIs - the FaxDevInitializeEx API. An EFSP exporting all mandatory EFSP APIs - the FaxDevInitializeEx API + the FaxDevInitialize API. An EFSP exporting all mandatory EFSP APIs - the FaxDevSendEx API. An EFSP exporting all mandatory EFSP APIs - the FaxDevSendEx API + all optional EFSP APIs. An EFSP exporting all mandatory EFSP APIs - the FaxDevShutdown API. An FSP exporting all FSP APIs. An FSP exporting all FSP APIs + the FaxDevInitializeEx API. An FSP exporting all FSP APIs + the FaxDevInitializeEx API + all other non-mandatory EFSP APIs. An FSP exporting all FSP APIs + the FaxDevInitializeEx API + the FaxDevSendEx API + all other non-mandatory EFSP APIs. FSPs/EFSPs that export more than the required APIs  A DLL, which registered using the FaxRegisterServiceProvider Client API, must export all FSP APIs (and is allowed to export other functions as well). A DLL, which registered using the FaxRegisterServiceProviderEx Client API, must export all EFSP mandatory APIs (and is allowed to export other functions as well). A DLL, which exports a mingle of FSP and EFSP APIs that meets the above conditions, must be allowed to register. The service should treat the DLL according to the Client API with which it registered and the version number with which it registers. Registration via FaxRegisterServiceProvider  An FSP exporting all FSP APIs + the FaxDevInitializeEx API. An FSP exporting all FSP APIs + the FaxDevInitializeEx API + all other non-mandatory EFSP APIs. An FSP exporting all FSP APIs + the FaxDevInitializeEx API + the FaxDevSendEx API + all other non-mandatory EFSP APIs.  An FSP exporting all FSP APIs + the FaxDevInitializeEx API + the FaxDevSendEx API + the FaxDevShutdown API + all other non-mandatory EFSP APIs. Registration via FaxRegisterServiceProviderEx  An EFSP exporting all mandatory EFSP APIs + the FaxDevInitialize API. An EFSP exporting all mandatory EFSP APIs + the FaxDevSend API. An EFSP exporting all mandatory EFSP APIs + the FaxDevInitialize API + the FaxDevSend API. EFSP which export optional APIs  Valid  The service should invoke these APIs as required. An EFSP which does not export optional APIs. An EFSP which exports the FaxDevGetLogData API. An EFSP which exports the FaxDevReestablishJobContext API. An EFSP which exports the FaxDevEnumerateDevices API. An EFSP which exports the FaxDevGetLogData and the FaxDevReestablishJobContext APIs. An EFSP which exports all optional APIs. Invalid  Such DLLs should be immediately unloaded by the service. The service should log a warning describing the problem with the APIs exported by the DLL and state that this FSP is considered invalid. An EFSP which does not export the FaxDevGetLogData API but registered with a  non-empty FSPI_LogInfo structure. Discrepancies (between exported APIs and capabilities)  The service should, at least, log that there exists a discrepancy between the exported APIs and the capabilities with which the FSP DLL was registered.  These APIs should never be invoked. An EFSP which exports the FaxDevGetLogData API but registered with an empty FSPI_LogInfo structure. Illegal FSP/EFSP behavior  When an FSP behaves illegally we expect the service to unload the FSP DLL at the first opportunity. The service will not invoke any API of that FSP until the DLL is reloaded. The service will log a warning describing the illegal behavior of the FSP and the action taken by the service. AV at different points in FSP/EFSP. EFSP sends illegal messages. FSP/EFSP post illegal packets to completion port. FSPs and EFSPs return illegal error values. APIs that allocate return TRUE but pointer to allocation is NULL. APIs that set information set it illegally. FSP that calls FaxServiceCallbackEx with legal device messages. FSP that calls FaxServiceCallback.  (?) Should service keep track of whoever calls FaxServiceCallback and unload it? Or do we just want to check that service doesn t start to misbehave after such a call? EFSP that calls FaxServiceCallback (and not FaxServiceCallbackEx). Legal FSP/EFSP behavior  The service should correctly respond to such behavior. An FSP where all APIs always succeed (FSP that successfully does nothing). An FSP where all APIs always fail (FSP that fails to do nothing). An FSP where all APIs sometimes fail. An FSP where APIs always succeed, but FaxDevInitialize always/sometimes fails. An FSP where APIs always succeed, but FaxDevStartJob always/sometimes fails. An FSP where APIs always succeed, but FaxDevEndJob always/sometimes fails. An FSP where APIs always succeed, but FaxDevVirtualDeviceCreation always/sometimes fails.  An FSP where APIs always succeed, but FaxDevReportStatus always/sometimes fails. An FSP where APIs always succeed, but FaxDevSend always/sometimes fails. An FSP where APIs always succeed, but FaxDevReceive always/sometimes fails. An FSP where APIs always succeed, but FaxDevAbortOperation always/sometimes fails. An FSP where APIs always succeed, but FaxDevSend, FaxDevReceive, and FaxDevAbortOperation always/sometimes fail. An EFSP where all APIs always succeed (EFSP that successfully does nothing). An EFSP where all APIs always fail (EFSP that fails to do nothing). An EFSP where all APIs sometimes fail. An EFSP where APIs always succeed, but FaxDevSendEx always/sometimes fails. An EFSP where APIs always succeed, but FaxDevReceive always/sometimes fails. An EFSP where APIs always succeed, but FaxDevAbortOperation always/sometimes fails. An EFSP where APIs always succeed, but FaxDevInitializeEx always/sometimes fails. An EFSP where APIs always succeed, but FaxDevShutdown always/sometimes fails. An EFSP where APIs always succeed, but FaxDevGetLogData always/sometimes fails. An EFSP where APIs always succeed, but FaxDevReestablishJobContext always/sometimes fails. An EFSP where APIs always succeed, but FaxDevGetEnumerateDevices always/sometimes fails. An EFSP where APIs always succeed, but FaxDevSendEx, FaxDevReceive, and FaxDevAbortOperation always/sometimes fail. New/Changed Functions in MS Fax Service -  FaxServiceCallbackEx  (FaxServiceCallback is [fax\service\server\faxdev.c]FaxDeviceProviderCallback) Code Review function Parameter check Error value check Correct handling of all message types Make sure that legal messages that EFSP (with handle hFSP) does not have capability for are treated as error. FaxRenderCoverPage. Code Review function Parameter check (pointers are Null, fields are Null, string fields are  Correct rendering of cover page Empty cover page (lpCoverPageInfo points to all empty fields, lpRecipientProfile points to all empty fields, lpRSenderProfile points to all empty fields). Broadcasting -  Using a legacy FSP device for sending, call the Fax Service Client API FaxSendDocumentEx (3 different recipients); make sure job is broken up into 3 single recipient jobs and a parent job. FaxDevSend should be called 3 times, once for each recipient. Using a legacy FSP device for sending, call the Fax Service Client API FaxSendDocumentEx (3 * same recipient); make sure job is broken up into 3 single recipient jobs.  FaxDevSend should be called 3 times, once for each recipient. Using a legacy FSP device for sending, call the Fax Service Client API FaxSendDocumentEx (300 different recipients); make sure job is broken up into 300 single recipient jobs and a parent job. FaxDevSend should be called 300 times, once for each recipient. Using a legacy FSP device for sending, call the Fax Service Client API FaxSendDocumentEx (300 * same recipient); make sure job is broken up into 300 single recipient jobs and a parent job. FaxDevSend should be called 300 times, once for each recipient. Using a legacy FSP device for sending, call the Fax Service Client API FaxSendDocumentEx (single recipient); make sure a single job is queued (treated like FaxSendDocument). FaxDevSend should be called once. Using an EFSP device without FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (1 recipient); make sure that FaxDevSendEx is called once and a single job is created (treated like FaxSendDocument). Using an EFSP device without FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (3 different recipients); make sure job is broken up into 3 single recipient jobs and a parent job. FaxDevSendEx should be called 3 times, once for each recipient. Using an EFSP device without FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (3 * same recipient); make sure job is broken up into 3 single recipient jobs and a parent job. FaxDevSendEx should be called 3 times, once for each recipient. Using an EFSP device without FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (300 different recipients); make sure job is broken up into 300 single recipient jobs and a parent job. FaxDevSendEx should be called 300 times, once for each recipient. Using an EFSP device without FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (300 * same recipient); make sure job is broken up into 300 single recipient jobs and a parent job. FaxDevSendEx should be called 300 times, once for each recipient. Using an EFSP device with FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (3 different recipients). Make sure that 3 child jobs and a parent job are created. FaxDevSendEx should be called just once. Using an EFSP device with FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (3 * same recipient). Make sure that 3 child jobs and a parent job are created. FaxDevSendEx should be called just once. Using an EFSP device with FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (300 different recipients). Make sure that 300 child jobs and a parent job are created. FaxDevSendEx should be called just once. Using an EFSP device with FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (300 * same recipient). Make sure that 300 child jobs and a parent job are created. FaxDevSendEx should be called just once. Using an EFSP device with FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx (1 recipient); make sure that FaxDevSendEx is called once and a single job is created. Using an EFSP device with FSPI_CAP_BROADCAST, and with the FSPI_CAP_ABORT_PARENT and the FSPI_CAP_ABORT_RECIPIENT capabilities for sending, call the Fax Service Client API FaxSendDocumentEx (5 recipients) then call Fax Service Client API FaxAbort for a child job. Make sure FaxDevAbortOperation is called with the child job handle. Then call FaxAbort for the parent job; make sure that FaxDevAbortOperation is called only once with the parent job handle. Using an EFSP device with FSPI_CAP_BROADCAST, and with the FSPI_CAP_ABORT_PARENT and the FSPI_CAP_ABORT_RECIPIENT capabilities for sending, call the Fax Service Client API FaxSendDocumentEx (many/single recipients) then call Fax Service Client API FaxAbort for every one of the child jobs. Make sure that each FaxAbort call invokes FaxDevAbortOperation with the appropriate child job handle. Make sure that after the last child job is aborted, the parent job ends (is considered completed with an aborted status). Using an EFSP device with FSPI_CAP_BROADCAST, and with the FSPI_CAP_ABORT_PARENT and the FSPI_CAP_ABORT_RECIPIENT capabilities for sending, call the Fax Service Client API FaxSendDocumentEx (many recipients). Create a situation where at least one child job is with status sending/paused/pending, then abort that child job. Make sure that FaxDevAbortOperation is called once and only that child job is aborted. Using an EFSP device with FSPI_CAP_BROADCAST, and with the FSPI_CAP_ABORT_PARENT and the FSPI_CAP_ABORT_RECIPIENT capabilities for sending, call the Fax Service Client API FaxSendDocumentEx (many recipients). Create a situation where all child jobs are with status sending/paused/pending, then abort the parent job. Make sure that FaxDevAbortOperation is called once and that all child jobs (+ parent job) are aborted. Using an EFSP device with FSPI_CAP_BROADCAST, and with the FSPI_CAP_ABORT_PARENT and the FSPI_CAP_ABORT_RECIPIENT capabilities for sending, call the Fax Service Client API FaxSendDocumentEx (many recipients). Create a situation where the child jobs have different statuses (some are sending, others pending, and others paused), then abort the parent job. Make sure that FaxDevAbortOperation is called once and that all child jobs (+ parent job) are aborted. Use an EFSP device with FSPI_CAP_BROADCAST, without the FSPI_CAP_ABORT_PARENT capability but with the FSPI_CAP_ABORT_RECIPIENT capability for sending. Call the Fax Service Client API FaxSendDocumentEx (with a single recipient). Make sure a single (ordinary) job is created and is treated as if a call to FaxSendDocument created it. Use an EFSP device with FSPI_CAP_BROADCAST, without the FSPI_CAP_ABORT_PARENT capability but with the FSPI_CAP_ABORT_RECIPIENT capability for sending. Call the Fax Service Client API FaxSendDocumentEx (many recipients) then call Fax Service Client API FaxAbort for a child job; make sure FaxDevAbortOperation is called with the child job handle. Then call FaxAbort for the parent job; make sure that FaxDevAbortOperation is called (many times) with each of the remaining child job handles and then with the parent job handle. Use an EFSP device with FSPI_CAP_BROADCAST, without the FSPI_CAP_ABORT_PARENT capability but with the FSPI_CAP_ABORT_RECIPIENT capability for sending. Call the Fax Service Client API FaxSendDocumentEx (many/single recipients) then call Fax Service Client API FaxAbort for each of the child jobs. Make sure that each FaxAbort call invokes FaxDevAbortOperation with the appropriate child job handle. Make sure that after the last child job is aborted, the parent job ends (is considered completed with an aborted status). Using an EFSP device with FSPI_CAP_BROADCAST, without the FSPI_CAP_ABORT_PARENT capability but with the FSPI_CAP_ABORT_RECIPIENT capability for sending. Call the Fax Service Client API FaxSendDocumentEx (many recipients). Create a situation where at least one child job is with status sending/paused/pending, and then abort that child job. Make sure that FaxDevAbortOperation is called once and only that child job is aborted. Using an EFSP device with FSPI_CAP_BROADCAST, without the FSPI_CAP_ABORT_PARENT capability but with the FSPI_CAP_ABORT_RECIPIENT capability for sending. Call the Fax Service Client API FaxSendDocumentEx (many recipients). Create a situation where all child jobs are with status sending/paused/pending, then abort the parent job. Make sure that FaxDevAbortOperation is called many times and that all child jobs (+ parent job) are aborted. Using an EFSP device with FSPI_CAP_BROADCAST, without the FSPI_CAP_ABORT_PARENT capability but with the FSPI_CAP_ABORT_RECIPIENT capability for sending. Call the Fax Service Client API FaxSendDocumentEx (many recipients). Create a situation where the child jobs have different statuses (some are sending, others pending, and others paused), then abort the parent job. Make sure that FaxDevAbortOperation is called many times and that all child jobs (+ parent job) are aborted. Check correct visualization of child and parent jobs (queue should correctly show X child jobs under their parent job, parent job type should be Broadcast etc.).  No child job should be removed from queue until the parent job completes (all child jobs have completed). Parent job should be removed from queue if and only if all child jobs completed successfully. Q: Pausing/resuming of child/parent job. Before FaxDevSendEx is called, any pause should succeed. What happens to a broadcast after one of the child jobs is successfully paused? For an EFSP with broadcast capability, what do we give FaxDevSendEx? => Do not allow pausing of a child job. Only a parent job can be paused (before FaxDevSendEx is called). What is service response when cannot pause (what error value is returned)? Check pausing/resuming of child job. Check pausing/resuming of parent job (when 2 out of 5 completed at time of pause, when 2 out of 5 were sending, etc.). Q: Logging of broadcast parent and child jobs. Log each child job separately (like ordinary jobs), plus an entry for the broadcast job (when all child jobs complete). Check logging information of a successful parent job (many/single/same recipients). Log should state that broadcast to such-and-such recipients has succeeded. Check logging information of a successful child job (from a broadcast with many different/same recipients). Check logging information of a failed (no_answer/busy/retrying) child job (from a broadcast with many different/same recipients). Check logging information of an aborted/aborting child job (from a broadcast with many different/same recipients). Check logging information of canceled parent job (when 2 transmissions out of 5 completed and only 3 were actually canceled). Check retries of parent job => each child job should be retried X times in correct order. Make sure that parent job itself is not also retried (and thus child jobs will be retried X*X times). Q: When FaxDevAbortOperation of a parent job fails, should server attempt to abort every child job (+ parent job) separately?  At least the child jobs that were actually successfully aborted should appear as such (in queue and log), the other child jobs should continue and the parent job status should indicate all this. Q: How is FaxDevEndJob invoked for a broadcast? FaxDevEndJob is called whenever a child job posts completed to the completion port. Check what happens when a   EFSP posts completed for the parent job before all the children have completed. Q: Can an EFSP register with Job Capabilities Null? That is without FSPI_CAP_ABORT_RECIPIENT and without FSPI_CAP_ABORT_PARENT? Q: When an EFSP registers with only FSPI_CAP_ABORT_PARENT what happens when you attempt to cancel a child job? What error values should FaxDevAbortOperation return in such a case? Multi-send -  Using an EFSP device with FSPI_CAP_MULTISEND send a very long fax. While that fax is still sending, send another fax. Make sure that after 2nd send job is queued Fax Service calls FaxDevSendEx immediately. Using an EFSP device with FSPI_CAP_MULTISEND and with FSPI_CAP_BROADCAST send a broadcast to many recipients. Make sure that Fax Service calls FaxDevSendEx immediately (just once).  Using an EFSP device with FSPI_CAP_MULTISEND and with FSPI_CAP_BROADCAST send a broadcast to many recipients. Make sure that Fax Service calls FaxDevSendEx immediately (just once). Then quickly send many non-broadcast faxes and make sure FaxDevSendEx are immediately called for each such job. Using an EFSP device with FSPI_CAP_MULTISEND and with FSPI_CAP_BROADCAST send a broadcast to many recipients and many other non-broadcast faxes. Make sure that APIs are invoked immediately. Then abort some of the jobs at different states. Make sure correct jobs (and only they) are aborted. Using an EFSP device with FSPI_CAP_MULTISEND and with FSPI_CAP_BROADCAST send a broadcast to many recipients and many other non-broadcast faxes. Make sure that APIs are invoked immediately. Then abort some of the jobs at different states. While these jobs are being aborted (and before FaxDevAbortOperation returned) send another fax. Make sure that FaxDevSendEx is immediately called for new job (service must not wait for abort to finish). Using an EFSP device with FSPI_CAP_MULTISEND and without FSPI_CAP_BROADCAST send a broadcast to many recipients. Make sure that Fax Service calls FaxDevSendEx for each of the child jobs (+ the parent job) immediately without first waiting for previous child jobs to finish. Using an EFSP device without FSPI_CAP_MULTISEND send a very long fax. While that fax is still sending, send another fax. Make sure that after 2nd send job is queued Fax Service calls does not call FaxDevSendEx (for 2nd job) until 1st job completes. Q: Order of job execution on a multi-send device. OP vs. a fax board with 3 outgoing lines? FSP scheduling -  Using an EFSP device with FSPI_CAP_SCHEDULING send a fax at a specific time. The Fax Service should call FaxDevSendEx immediately (specifying the correct scheduling time). Using an EFSP device without FSPI_CAP_SCHEDULING send a fax at a specific time. The Fax Service should delay calling FaxDevSendEx until the specified time. Q: what about an EFSP that has FSPI_CAP_SCHEDULING but no FSPI_CAP_MULTISEND?  Fax Service will call FaxDevSendEx with a job scheduled for tomorrow and EFSP will report its status FS_FSP_PENDING. But since this job has not yet ended the Fax Service will not send any other jobs to this EFSP device. Logging -  Use an EFSP, which registered (using FaxRegisterServiceProviderEx) with a non-empty FSPI_LogInfo, to send a fax. Make sure that Fax Service calls FaxDevGetLogData when job completes (successfully/aborted/failed). Use an EFSP, which registered (using FaxRegisterServiceProviderEx) with a non-empty FSPI_LogInfo, to receive a fax. Make sure that Fax Service calls FaxDevGetLogData when job completes (successfully/aborted/failed). Q: Should FaxDevGetLogData be called when job fails? Only 2 out of 3 pages are successfully sent/received? YES. Make sure that after FaxDevGetLogData returns with legal log data, Fax Service logs it correctly in the correct log. Make sure that if FaxDevGetLogData returns with illegal log data (too many columns, too few columns, null), Fax Service can handle it and some indication of this is logged. Virtual FSP recognition -  If a legacy FSP exports FaxDevVirtualDeviceCreation the Fax Service recognizes it as a Virtual Device. Thus the Fax Service will first call FaxDevVirtualDeviceCreation and only then FaxDevInitialize. If an EFSP exports the optional FaxDevEnumerateDevices function the Fax Service recognizes it as a Virtual Device. Thus the Fax Service will call FaxDevInitializeEx but will then call FaxDevEnumerateDevices. Write EFSP + FaxDevEnumerateDevices + FaxDevVirtualDeviceCreation and make sure that FaxDevEnumerateDevices in invoked while FaxDevVirtualDeviceCreation is never invoked. Q: For a virtual FSP/EFSP the FAX_LINECALLBACK function should never be invoked? => for every virtual FSP/EFSP we write, the implementation of this function will be like { ::lgLogError(LOG_SEV_1,  VFSP should never get here );  return; } Job Context Reestablishment -  Use an EFSP device, which exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, to send many faxes. While jobs are on queue bring down the service (net stop, kill process, boot). Make sure that FaxDevReestablishJobContext is called for every job. Make sure these jobs are correctly handled by service. Use an EFSP device, which exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, to send many faxes. Set retries to 5. Make some jobs fail and thus be retried. While  retrying  jobs are on queue bring down the service (net stop, kill process, boot). Make sure that jobs are retried exactly 5 times overall (and not 5 times since service came up again). Use an EFSP device, which exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, to send a fax. Bring down the service (net stop, kill, and boot) at different times during job life (sending, just before completion, pending, paused, initializing, failed, aborting), make sure all jobs (and only they) are reestablished.  Use an EFSP device, which exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, to send a fax. Bring down the service (net stop, kill, and boot). Bring service up again and when it calls FaxDevReestablishJobContext (before call returns), bring service down again. Make sure that job is correctly reestablished (when service comes up again).  Use an EFSP device, which exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, to receive a fax. Bring down the service (net stop, kill, and boot) at different times during job life (sending, just before completion, pending, paused, initializing, failed, aborting), make sure all jobs (and only they) are reestablished when service comes up again.  Use an EFSP device, which exports FaxDevReestablishJobContext and whose FaxDevSendEx returns message ids, to send a fax. While job is sending, take down the Fax Service. Make sure that when Fax Service comes up again it first calls FaxDevStartJob and then calls FaxDevReestablishJobContext with the new job handle and the previous job s message id (from the call to FaxDevSendEx before Fax Service went down).  Use an EFSP device, which exports FaxDevReestablishJobContext, with a FaxDevSendEx that returns message ids and supports broadcast, to send a broadcast to many recipients. While job is sending, take down the Fax Service. Make sure that when Fax Service comes up again it calls FaxDevStartJob and FaxDevReestablishJobContext for the parent job and then for each of the child jobs.  Use an EFSP device, which exports FaxDevReestablishJobContext but whose FaxDevSendEx does not return message ids, to send a fax. While job is sending, take down the Fax Service. Make sure that when Fax Service comes up again the EFSP is recognized as not supporting reestablishment and the Fax Service will restart the job from scratch.  Use an EFSP device, which does not export FaxDevReestablishJobContext but whose FaxDevSendEx returns message ids, to send a fax. While job is sending, take down the Fax Service. Make sure that when Fax Service comes up again the EFSP is recognized as not supporting reestablishment and the Fax Service will restart the job from scratch.  Q: What should the Fax Service do when a call to FaxDevReestablishJobContext fails? Should it re-start the job from scratch? What about an FSPI_E_NETWORK error value? Should it retry to establish job context? Make sure service responds correctly to error values when FaxDevReestablishJobContext fails. New Status Notification Mechanism -  Write an EFSP that does not use the new mechanism. Write an EFSP that uses the new mechanism (calls FaxServiceCallbackEx). Shutdown -  Make sure that for every EFSP loaded, Fax Service calls FaxDevShutdown before DLL is unloaded. Regression -  Make sure that T.30 FSP is not impaired because of changes in Fax Service (especially the code added to distinguish FSP-EFSP, logging and EFSP capabilities). Outbound routing  Where many different FSPs/EFSPs are installed, enable all devices as send enabled. Call FaxSendDocumentEx with 3 different recipients. Check that outbound routing is according to policy. Where many different FSPs/EFSPs are installed, enable all devices as send enabled. Call FaxSendDocumentEx with 300 different recipients so that according to outbound routing policy all calls should use same device. Check that outbound routing is according to policy. Where many different FSPs/EFSPs are installed, enable all devices as send enabled. Call FaxSendDocumentEx with 300 different recipients so that according to outbound routing policy calls should use many different devices (FSPs). Check that outbound routing is according to policy. Where many different FSPs/EFSPs are installed, enable all devices as send enabled. Call FaxSendDocumentEx with 300 * same recipient. Check that outbound routing is according to policy. Note: if policy is  SendPriority  based then many different FSPs will be used, however, if policy is phone-number based, same device will be used. Q: What to do when according to policy a job should go to FSP1 but all devices of FSP1 are send disabled? At least notify. Problem: while for a configuration of many FSPs the  SendPriority  outbound routing is still plausible, this is no longer so for a configuration of many EFSPs (especially where they export different capabilities). In any case this feature is planned to change. Outbound routing will be based on the dialed number area code (see  Preliminary Features Specification  clause 8). Stress -  Many devices of same FSP. Many devices of same EFSP, each device with different device capabilities. Note that device capabilities (DWORD) is yet TBD. Many FSPs and EFSPs with many devices each. FSP API Test Specification Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  4-Oct-99 zvqlg_[ ~vnf^ zrjb]UME |tld\TLD |tld\TLD {me]UME= wog_WOG? yqiaYKC }ume]UME= wog_QIA9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\fsp_acceptance.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0FSP Acceptance Tests Revision 0.2 Preface The goal of this document is to formulate an acceptance test specification for 3rd party FSPs and EFSPs. This document only lists the major test areas that require testing, and will be expanded in further detail in the future.  Test Strategy The concept is to provide 3rd party FSP \ EFSP implementers with information and tools that will enable them to perform quality testing of their product. First, we will compose a detailed FSP Acceptance specification document, which will layout exact test cases and the expected behavior. The 3rd parties will be responsible for carrying out these tests, which will serve as the minimum criteria for shipping with CometFax. This detailed specification document will be based on test categories listed in this document. Second, we will provide the 3rd parties with testing tools which they can use to carry out the test cases detailed in the FSP Acceptance specification document. This will include: Implementing a simple low-cost EFSP API driver to check API return values and invalid parameters. The driver will be designed in a way that will allow expending it in the future. For now we plan to give it the minimal functionality which will enable us to perform API calls and return value verification. Implementing an executable (based on our existing tools), which will use the Fax Service Client APIs to perform fax operations.  This will cause the Fax Service to invoke the FSP/EFSP APIs and we will test their behavior. Test Objectives To test correct implementation of the required FSP/EFSP APIs (parameters, error values, etc.) To test correct behavior of FSP \ EFSP under user scenarios (sending, receiving, aborting, broadcast, multi-send, etc.) Specific tests for specific FSP \ EFSP implementations. Revision Information Revision Author Description 5-Jan-99 Sigalit Bar Initial version 5-Oct-99 Sigalit Bar Minor formatting changes. Changed E_SUCCESS to FSPI_S_OK. Replaced references to FaxSendDocumentForBroadcast() with FaxSendDocumentEx() Removed references to FaxDevGetDeliveryInfo(), since this API was canceled. Added a  FSP \ EFSP administration  test area (section 5.12). Added a  General  test area (section 5.13).  FSP/EFSP Acceptance Test Areas Correct Implementation of Required APIs -  Every API returns FSPI_S_OK upon success. Every API returns the correct error return value upon failure. For an EFSP, which successfully registered with certain capabilities, API return values match those capabilities. E.g. for an EFSP that registered with FSPI_CAP_BROADCAST but without FSPI_CAP_ABORT_PARENT, a call to FaxDevAbortOperation with a parent job will return error (FALSE). Broadcasting -  An EFSP device with FSPI_CAP_BROADCAST for sending, call the Fax Service Client API FaxSendDocumentEx; make sure that the EFSP s FaxDevSendEx function is called and a parent job plus all children jobs handles are correctly returned.  Using an EFSP device with FSPI_CAP_BROADCAST and FSPI_CAP_ABORT_PARENT for sending, call the Fax Service Client API FaxSendDocumentEx with a broadcast job. Call Fax Service Client API FaxAbort for a child job.  Verify that FaxDevAbortOperation is called with the child job handle, that API returns FALSE and child job is not aborted. Then call FaxAbort for the parent job.  Verify that FaxDevAbortOperation is called only once with the parent job handle and FSP aborts parent job and all child jobs. Using an EFSP device with FSPI_CAP_BROADCAST and FSPI_CAP_ABORT_RECIPIENT for sending, call the Fax Service Client API FaxSendDocumentEx with a broadcast job. Call Fax Service Client API FaxAbort for the parent job.  Verify that FaxDevAbortOperation is called with the parent job handle, that API returns FALSE and no job is aborted. Then call FaxAbort for the child job.  Verify that FaxDevAbortOperation is called with the child job handle and FSP aborts the correct child job. Using an EFSP device with FSPI_CAP_BROADCAST, FSPI_CAP_ABORT_RECIPIENT  and FSPI_CAP_ABORT_PARENT for sending, call the Fax Service Client API FaxSendDocumentEx with a broadcast job with at least 3 recipients. Call Fax Service Client API FaxAbort for a child job.  Verify that FaxDevAbortOperation is called with the child job handle, that API returns TRUE and the correct child job is aborted. Then call FaxAbort for the parent job.  Verify that FaxDevAbortOperation is called only once with the parent job handle and FSP aborts parent job and all remaining child jobs. Multi-send -  Using an EFSP device with FSPI_CAP_MULTISEND create many send jobs for that device, make sure they are all executed together.  That is check that FaxDevSendEx is re-entrant.  Using an EFSP device with FSPI_CAP_MULTISEND create   many send jobs for that device. That is stress FaxDevSendEx, hopefully stressing EFSPs heap and other resources. It may even be worth writing a separate driver for this to really stress re-entering at all possible points. Using an EFSP device without FSPI_CAP_MULTISEND create many send jobs for that device, make sure they are executed sequentially.  Using an EFSP device with FSPI_CAP_MULTISEND send many non-broadcast faxes. Service should invoke FaxDevSendEx APIs immediately. Then abort some of the jobs at different states. While these jobs are being aborted (and before FaxDevAbortOperation returned) send another fax. Service should call FaxDevSendEx immediately for new job, make sure that FaxDevSendEx succeeds (immediately) regardless of FaxDevAbortOperation. FSP scheduling -  Using an EFSP device with FSPI_CAP_SCHEDULING send a fax at a specific time. The Fax Service should call FaxDevSendEx immediately (specifying the correct scheduling time) and the EFSP must perform the send on schedule. Using an EFSP device with FSPI_CAP_SCHEDULING send a fax at Y2K prone dates. Using an EFSP device with FSPI_CAP_SCHEDULING send a fax scheduled for a specific time in the past. Using an EFSP device which does not support FSPI_CAP_SCHEDULING send a fax at a specific time in the future, verify that the fax is sent as soon as possible. Logging -  For an EFSP, which registered (using FaxRegisterServiceProviderEx), with a non-empty FSPI_LogInfo, make sure that FaxDevGetLogData returns correct information for a completed single (non-broadcast) send job. For an EFSP, which registered (using FaxRegisterServiceProviderEx), with a non-empty FSPI_LogInfo, make sure that FaxDevGetLogData returns correct information for a complete broadcast (parent) job. For an EFSP, which registered (using FaxRegisterServiceProviderEx), with a non-empty FSPI_LogInfo, make sure that FaxDevGetLogData returns correct information for a completed receive job. Q: What should FaxDevGetLogData return when called with failed job? With job where only 2 out of 3 pages were successfully sent/received?  Job Context Reestablishment -  For an EFSP device, which exports FaxDevReestablishJobContext, take down the Fax Service while a single recipient job was pending/sending/aborting wait until job status (in remote application/server) has changed and bring up Fax Service again. Make sure that after call to FaxDevReestablishJobContext the job s handle maintains the updated state of that job. For an EFSP device, which exports FaxDevReestablishJobContext, take down the Fax Service while a multi-recipient broadcast job was active/pending wait until job status (in remote application/server) has changed and bring up Fax Service again.  Call FaxDevReestablishJobContext with parent job handle and all child handles. Make sure that all job handles (of parent and child jobs) are updated correctly. We might use a driver for this. Simply calling this function after EFSP posts a status change. Call FaxDevSendEx, when we see a packet indicating status change for that job handle, call FaxDevGetStatus for that job (for reference). Then call FaxDevStartJob with new handle and test that a call to FaxDevReestablishJobContext with the message id returns a FAX_DEV_STATUS equal to the reference. Abort a job while it is being reestablished. Reestablish a job while it is being aborted. For an EFSP device, which exports FaxDevReestablishJobContext, call FaxDevReestablishJobContext while a job is in progress (without first stopping the CometFax service). For an EFSP device, which exports FaxDevReestablishJobContext, call FaxDevReestablishJobContext subsequently several times while a job is in progress (without first stopping the CometFax service). Status Notification -  Make sure that any call to FaxDevSendEx reports a legitimate sequence of legal statuses. Every proprietary status id reported also has a resource string id and the resource can be loaded successfully. Q: Should we make sure that an EFSP invokes FaxServiceCallback or posts to completion port, but does not use both? Shutdown -  Make sure that after FaxDevShutdown is called EFSP has performed cleanup. We will talk with EFSP implementers to determine which resources are used by their EFSP and verify cleanup (e.g. all DLLs loaded by EFSP are unloaded, network connections are closed etc.)  Callbacks -  Make sure that EFSP responds correctly when FAX_SEND_CALLBACK returns FALSE (does not crash). Make sure that FSP never invokes FaxServiceCallback Make sure that EFSP never invokes FaxServiceCallback (only FaxServiceCallbackEx). EFSP APIs receiving a job handle -  Call all such EFSP APIs with a broadcast parent job handle and check that they react correctly (some such APIs may not support => must return relevant error value). Invalid parameters -  Null pointers (specifically for OUT params). Illegal values according to every parameter type.  I.e. for an API that receives date send 30-Feb-99. For structures with dwSizeOfStruct, supply an inappropriate value. FSP \ EFSP administration and configuration FSPs \ EFSPs will write administration property pages that the CometFax service will bring up as part of its Admin MMC. Activate these property pages from the CometFax MMC and verify the UI functions correctly and changes the FSP configuration appropriately. General Low memory \ disk \ registry conditions. Stress and scale. Fault injection. Tests for specific FSP\EFSP implementations  Open Port EFSP Assuming OP EFSP registers with FSPI_CAP_SCHEDULING. Break Internet connection and send scheduled faxes using OP EFSP. Wait until some of the jobs should have already been executed. Reconnect to Internet. Make sure all jobs are immediately sent to OP server and that their actual execution is on schedule. Test dependency on network connectivity between OP EFSP and OP Server. Check behavior with an intermittent connection, connection via proxy, LAN \ WAN etc. Receiving a fax via OP EFSP? FSP acceptance tests Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  14-Oct-99 }xsnfb] zrjd\TLD }ume]OG? }ug_QIA9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\globalizationtestplan.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft, Haifa. Globalization Testing Title _PID_HLINKSGlobalization Testing Yafit Gelchinski Normal Yafit Gelchinski Microsoft Word 9.07J88p V"TC0( Nx f\jY Pz89$  D`.Pz +Dfu{Cf Globalization test specbjbjU Globalization Testing Introduction: Globalization is the practice of designing and implementing software that is not locale dependent. Microsoft defines a locale as a set of user preferences associated with a user's language, which includes the following: formats for date, time, currency and numbers rules and tables for sorting and comparison tables of character classifications. Globalization testing has two major targets: To ensure that the final binaries need only to have their resources localized, in order to become a fully localized product that maintains the Microsoft standards (localization is the process of modifying an application so that its user interface is in the language of the user). To ensure that any group of servers and clients in any language can work side-by-side with our own application, no matter what languages the servers, the clients and the application are in. When developing a sub-component of the BackOffice Suite, both the developer and tester must take into account not only the locales in which the final product will be released, but also any existing locale that might serve as the base operating system for the BackOffice Server and its clients. This is because BackOffice promises full integration between its components and the locale on which it runs, regardless of what language each one of these two is in. BackOffice Server 5.0 Small Business Server 5.0 English English German German French French Japanese Japanese Spanish Spanish Italian Italian Swedish Dutch Brazilian Portuguese Czech Iberian Portuguese Hungarian Polish Korean Chinese Simplified Chinese Traditional Table 1: The current list of languages approved for BackOffice 5.0 Languages in italic are new languages for the BackOffice Suite. List 1: Localized editions of Windows. For some of these languages both localized and enabled versions are available. Arabic (English) Arabic (French) Basque Catalan Central and Eastern European Chinese (Simplified) Chinese (Traditional) Czech Danish Dutch English Farsi Finnish French German Greek Hebrew (English) Hungarian Indonesian Italian Japanese Korean Norwegian Polish Portuguese (Brazil) Portuguese (Standard) Russian Slovenian Spanish Swedish Turkish Basic Test Strategy: The tests will be planned to check all items on the   HYPERLINK "http://msdn.microsoft.com/library/books/devintl/S24AC.HTM"  Microsoft Win32 Internationalization Checklist  (from  Developing International Software for Windows 95 and Windows NT  by Nadine Kano) relevant to the BOS Fax Server application, and will follow the guidelines of the   HYPERLINK "http://boweb/bodocs/international/Globalization/Test/BoIntlChecklist.doc"  Microsoft BackOffice 5.0 Internationalization Checklist . These tests will take into consideration the different language groups in which the application will be distributed, the languages the older versions of the application were distributed in, as well as the existing and planned localized operating systems. Stage 1: The application does not take for granted the English system structure. The following tests will be done to ensure the application can be installed and run properly on any localized version of the server and the different clients. This ensures that the application does not contain any hidden hard-coded pathnames. As soon as this obstacle is overcome, the testing can proceed to localization specifics. The US English application will be installed on the following machines: Win2k server, German edition Win2k Professional, German edition WinNT 4 workstation, SP6, German Windows 98, 2nd edition, German Windows 95, German The application will be installed on the German machines after testing it on English versions of the operating systems, to ensure that any errors on the German machines are a result of language mismatch. Install the application on the German clients using an English server, to ensure all problems are caused by the language mismatch of the clients  operating systems and the application, and are not caused by the server. After installation, run the Setup/Uninstall test  tool, to ensure all entries were properly placed on the system. (Folder name changes must be taken into consideration when preparing the ini files for the tests.) English German Program Files Programme Control Panel Szstemsteuerung Printers Drucker Accessories Zubeh Table 2: Some folder names which were localized for the German editions of Windows (This list might change, according to the relevance of the folders to BOS Fax.) Check that the following components are working properly: Cover Page Editor Open the editor, open a cover page file, make changes in the format of the file and save under a different name. Try to open the editor by double-clicking the cover page. Client Console Send a fax, check that the outgoing and sent folders are updated accordingly. Fax Send Wizard Send a cover page. Print an Office document (English version of Office) to the BOSFax printer. Uninstall Run the uninstall component. Run the Setup/Uninstall test tool afterwards, and compare the results with those of the matching English client. Install the application on a German Win2k server. After installation, run the Setup/Uninstall test tool, to ensure all entries were properly placed on the system. Take into consideration the name changes mentioned above. Check that the following components are working properly: Cover Page Editor Open the editor, open a cover page file, make changes in the format of the file and save under a different name. Try to open the editor by double-clicking the cover page. Client Console Send a fax, check that the outgoing and sent folders are updated accordingly. Fax Send Wizard Send a cover page. Print an Office document (English version of Office) to the BOSFax printer. Admin Check that all admin components can be accessed and have their properties changed. Uninstall Run the uninstall component. Run the setup test afterwards, and compare the results with those of the matching English client. Install the application on the German clients using the installed German server. Repeat the test list of item 1.1. Text files are prepared for any possible environment (SBCS, Unicode). The application responds to changes in the Control Panel s international settings. Change the system s locale. After changing the system s locale, the following changes should occur: Windows 9x: The system will restart with the new locale. Windows NT: The system immediately changes to the new locale. Check that the items influenced by the locale have changed accordingly: Order of documents by document name in the Client Console boxes Order of recipients in the Fax Send Wizard recipients  table ([TBD] Check if this is intended to be ordered.) Date and hour on fax. ([TBD] Check if any more items should be influenced by the locale.) Stage 2: Localization readiness. The following group of tests will be done with a pseudo-localized build of the application. The application will be installed on the following English systems: Win2k server Win2k, Professional edition WinNT 4.0 Workstation, SP6 Millennium Windows 98, 2nd edition Windows 95, OSR2 All strings and dialogs appearing in the UI are localizable. Server side The following tests will be done on the server: Check that all server-side components  UI is pseudo-localized: Client Console Cover Page editor Send Wizard Uninstall component Admin / MMC snapin Readme file   link and file name only Note: Check that all regular UI was localized, including button captions and tool tips. Check that all error messages were localized (in popup dialogs and others) by intentionally making errors. Check that all messages in Event Log and all relevant Log Errors were localized. Check that command line strings were pseudo-localized. (FXSCOVER, FXSSEND Client side The following tests will be done on each of the clients: Check that all client-side components  UI is pseudo-localized: Client Console Cover Page editor Send Wizard Uninstall Note: Check all regular UI, including button captions, tool tips and error messages. Check all Event logs. (Is there any event logging for clients?) Check all command line strings. (Are there command line strings?) Buffers are large enough to handle translated words and phrases; menu and dialog-box designs leave room for text expansion (no word-wrapping or truncation occurs). Pseudo-localization expands strings by 30%, which is considered a good indication when checking application readiness for string expansion. As part of the expansion procedure, each such string is given a start and end delimiter. Each string will be checked to ensure that it appears with both its delimiters in the component space (text box, menu, etc.), both in client components and server components. Code doesn't concatenate strings to form sentences. All strings in the pseudo-localized version of the application have start and end delimiter sub-strings. Correct sentences do not contain these delimiters in the middle; therefore simply checking if a sentence contains these sub-strings in the middle can spot an incorrect sentence. To check that no concatenation is done, all dialog and error logs must be checked. This will be done alongside the testing of item 2.1. The following items are not hard-coded: Fonts: size and name Controls and Dialogs: size and position Tab orders and accelerator keys (due to field / text box order changes, tab order might need to be changed) Pathnames (all pathnames related to the installation source must be considered as  ready to be translated , but remain as-is during pseudo-translation, pathnames relevant to the system on which the application is installed are to be pseudo-localized). Filenames (specifically check what happens when the cover page file names are translated): setup.exe, *.lnk files and others. User group names: Administrator, Domain Admins etc URLs (URLs might need to be changed to the localized pages) Default values Character constants Numeric constants Shared folders  names are not localized, but their description is. The shared files created by BOS Fax Server s installation are: FxsSrvCp$ (common cover pages) BOSFax (BOSFax printer) ([TBD] Check where the remarks are kept in the resource files.) Strings or characters that should not be localized are marked. A search in the lc files (localization constraints) will be made to ensure that any such strings are locked. User Interface terminology is consistent (English). All text in the English version of the application will be checked to ensure that the terminology is consistent. The full text will be fully checked once the UI stabilizes and no more lengthy messages are expected to be entered into the code. Afterwards any additions will be checked as they become available, in each new US build (on a daily basis). Help documentation of all forms will be checked close to their closing, as they change rapidly and are expected to be sealed close to the Beta drop date. Partial checks will be done by the dev and test teams whenever these documents are distributed by the  HYPERLINK "mailto:v-moshch?subject=BOSFax UA documentation" UA team Stage 3: Cultural acceptance. The following items will be tested using the US version of the application, installed on US English editions of the following operating systems: Win2k server WinNT 4.0 workstation (represents NT clients) Windows 95 (represents Win9x clients) Text and messages are devoid of slang and specific cultural references. All text in the English version of the application will be checked to ensure no slang or cultural references are mentioned. The full text will be fully checked once the UI stabilizes and no more lengthy messages are expected to be entered into the code. A second check will be done near code-complete, which is expected in mid-April. Help documentation of all forms will be checked close to their closing, as they change rapidly and are expected to be sealed close to the Beta drop date. Partial checks will be done whenever these documents are distributed by the  HYPERLINK "mailto:v-moshch?subject=BOSFax UA documentation" UA team Icons, bitmaps and images of any other format are generic, make sense in all cultures and are not considered offensive in any culture. Icons are designed by Redmond, and will be checked to ensure they do not contain text and are culturally acceptable. As for other bitmaps, the generic Microsoft bitmaps used with applications such as Internet Explorer are reused, therefore no further checking is needed to ensure they are culturally acceptable ([TBD] waiting for Sam Kim to answer Or s letter regarding icons and bitmaps). Country lists do not contain politically sensitive place names. The BOS Fax application does not have its own country list, but rather uses the information embedded in the local operating system. Therefore the application must be checked to ensure the local list is the one displayed by the application. The only list which needs to be checked is the Location (Telephony) list in the Recipient Information, in both the clients  and the server s Fax Send Wizard components. The labels  Location  and  Country/Region  are used instead of  Country  to avoid problems concerning disputed areas. Check that any reference to geographical areas in the Send Fax Wizard is done correctly. This is the only BOS Fax component that contains any geographical reference. Server-side component Client-side component Features important to international markets are included in the application, and features that don't apply to international markets can be removed easily. There are no features in the application that apply only to certain international markets; therefore none can (or should) be removed. Stage 4: Correct character handling. The following tests will be done with the English-based pseudo-localized builds of the application, which will be installed on the following list of English systems: Win2k server Win2k, Professional edition WinNT 4.0 Workstation, SP6 Windows 95, OSR2 Windows 98, 2nd edition The pseudo-localized builds will be made for code pages 1252 (Latin1), 1250 (Eastern-European languages) and Japanese. The following tests will be done to ensure characters are displayed and handled correctly by the application: All characters are displayed properly in dialog controls and edit boxes. The pseudo-localized builds will be thoroughly checked for mistakes in the dialog control displaying of characters, for each of the following components: Server Client Console Cover Page editor Send Wizard Uninstall component Admin / MMC snap-in Clients Client Console Cover Page editor Send Wizard Uninstall component Text boxes accept the same number of Multi-byte characters as Single-byte characters. Text boxes which accept a limited number of characters: Fax Send Wizard: To field (63 characters) Fax number country prefix (10 characters) Fax number (50 characters) User information: Full name field (80 characters) Fax number field (80 characters) E-mail field (80 characters) Title field (80 characters) Company field (80 characters) Office location field (80 characters) Department field (80 characters) Home phone field (80 characters) Work phone field (80 characters) Address fields: Street field (80 characters) City field (80 characters) State/Province field (80 characters) Zip/Postal code field (80 characters) Country/Region field (80 characters) Billing code field (80 characters) For each text box that accepts a limited number of characters, three strings will be prepared; one containing only single-byte characters, a second containing only double-byte characters and the third containing mixed characters. Special delimiters will start and end each such string, and they will be copied into the text/edit box. If both prefix delimiter and suffix delimiter can be entered, and no additional characters can be entered for each such string, the application has passed the test. (Do we need to check zero-width characters?) Accented characters are handled correctly. The 1252 pseudo-localized application will have accented characters in the text. Accented characters will be entered by their ASCII codes, to ensure the application handles correctly any accented characters entered into its text boxes. Typing, cutting, pasting, saving and printing extended ASCII and complex characters is possible for all documents and dialog boxes. With the 1252 pseudo-localized version of the application, for each text/edit box, a string with extended ASCII and complex characters will be typed to, cut from and pasted to the box. The only data which needs to be checked for bugs during a save operation is the user information and cover pages which are designed. After creating a cover page with such characters, it will be used to send a fax. The fax s preview display will be checked and printed. ([TBD] Japanese character handling.) Stage 5: Multi-lingual environments. As stated in   HYPERLINK "http://boweb/bodocs/backoffice suite 5.0 products/product specifications/international/bo50internationalplan.htm"  http://boweb/bodocs/backoffice suite 5.0 products/product specifications/international/bo50internationalplan.htm , the goal for BackOffice 5.0 globalization is to have any client function with any language server, and for the Intl. English version of the server to install successfully on any localized Win2k server. To cover most of the possible scenarios, we will have the following pseudo-localized builds of the application and the English version installed on a variety of localized systems: Japanese-based pseudo-localized build German-based pseudo-localized build Czech-based pseudo-localized build (These builds will localize any reference to system specifics, such as special folders.) The English application works correctly on localized versions of windows. The English application must work correctly on all localized servers and clients. To test that the application runs smoothly on localized versions, the following installations will be made: English BOS on German operating systems English BOS Fax Server on German Win2k server English BOS Fax Client on German clients: Win2k Professional WinNT 4 Workstation, SP6 Millennium Windows 98, 2nd edition Windows 95, OSR2 English BOS on Japanese operating systems English BOS Fax Server on Japanese Win2k server English BOS Fax Client on Japanese clients: Win2k Professional WinNT 4 Workstation, SP6 Millennium Windows 98, 2nd edition Windows 95, OSR2 English BOS on Hebrew operating systems English BOS Fax Server on Hebrew Win2k server English BOS Fax Client on Hebrew clients: Win2k Professional WinNT 4 Workstation, SP6 Millennium Windows 98, 2nd edition Windows 95, OSR2 The localized application works correctly on localized versions of windows, not necessarily the same language. German BOS on German server and different clients Pseudo-German BOS Fax Server on German Win2k server Pseudo-German BOS Fax Client on different clients: Win2k Professional (Japanese, English, Hebrew) WinNT 4 Workstation, SP6 (Japanese, English, Hebrew) Millennium (Japanese, English, Hebrew) Windows 98, 2nd edition (Japanese, English, Hebrew) Windows 95, OSR2 (Japanese, English, Hebrew) Japanese BOS on Japanese server and different clients Pseudo-Japanese BOS Fax Server on Japanese Win2k server Pseudo-Japanese BOS Fax Client on different clients: Win2k Professional (German, English, Hebrew) WinNT 4 Workstation, SP6 (German, English, Hebrew) Millennium (German, English, Hebrew) Windows 98, 2nd edition (German, English, Hebrew) Windows 95, OSR2 (German, English, Hebrew) English BOS on English server and different clients English BOS Fax Server on English Win2k server English BOS Fax Client on different clients: Win2k Professional (German, Japanese, Hebrew) WinNT 4 Workstation, SP6 (German, Japanese, Hebrew) Millennium (German, Japanese, Hebrew) Windows 98, 2nd edition (German, Japanese, Hebrew) Windows 95, OSR2 (German, Japanese, Hebrew) The application runs correctly on non-homogeneous network environments. The tests mentioned in items 5.1, 5.2 will be done simultaneously, and therefore they cover this item. The application works fine when the server s locale or language doesn t match the client This item is covered by 5.2. All language editions can read one another s documents. This item refers only to TIFF documents. The following tests will be done: Read a file whose name has not been changed, or contains only ASCII characters. Tiff files are given names made up of ASCII characters. Therefore no problems are expected while opening a file taken from the German edition by the Japanese edition. Steps: For each of the three languages (English, German, Japanese) complete a full installation of localized BOS on localized systems: Win2k server Win2k Professional WinNT 4 workstation, SP6 Millennium Windows 98 Windows 95 For each client and server, prepare a tiff file. There should be a total of 18 tiff files. For each language, try to open the tiff files of the other two languages. Table x contains the complete list of tests: System opening the file Tiff file location English Win2k client German Win2k client English WinNT 4 client German WinNT 4 client English Millennium German Millennium English Windows 98 German Windows 98 English Windows 95 German Windows 95 English Win2k client German WinNT 4 client English WinNT 4 client German Windows 98 English Millennium German Win2k client English Windows 95 German Windows 98 English Win2k client Japanese Win2k client English WinNT 4 client Japanese WinNT 4 client English Millennium Japanese Millennium English Windows 98 Japanese Windows 98 English Windows 95 Japanese Windows 95 English Win2k client Japanese Windows 95 English WinNT 4 client Japanese Win2k client English Millennium Japanese Windows 95 English Windows 95 Japanese Win2k client German Win2k client Japanese Win2k client German WinNT 4 client Japanese WinNT 4 client German Millennium Japanese Millennium German Windows 98 Japanese Windows 98 German Windows 95 Japanese Windows 95 German Win2k client Japanese WinNT 4 client German Win2k client Japanese Windows 98 German Millennium Japanese WinNT 4 client German Windows 98 Japanese Millennium German Win2k client English Win2k client German WinNT 4 client English WinNT 4 client German Millennium English Millennium German Windows 98 English Windows 98 German Windows 95 English Windows 95 German Win2k client English Millennium German WinNT 4 client English Win2k client German Millennium English Windows 98 German Windows 98 English Win2k client Japanese Win2k client English Win2k client Japanese WinNT 4 client English WinNT 4 client Japanese Millennium English Millennium Japanese Windows 98 English Windows 98 Japanese Windows 95 English Windows 95 Japanese Win2k client English WinNT 4 client Japanese WinNT 4 client English Millennium Japanese Windows 95 English WinNT 4 client Japanese Windows 95 English Millennium Japanese Win2k client German Win2k client Japanese WinNT 4 client German WinNT 4 client Japanese Millennium German Millennium Japanese Windows 98 German Windows 98 Japanese Windows 95 German Windows 95 Japanese WinNT 4 client German Win2k client Japanese WinNT 4 client German Windows 95 Japanese Windows 98 German WinNT 4 client Japanese Windows 98 German Windows 95 Table 3: Tiff file reading but different localized systems   test matrix. Read a file whose name contains extended-ASCII or DBCS characters. (Check: Are problems expected while opening a file taken from the German edition by the Japanese edition?) [TBD] Installation of BOSFax in a new language, on top of an old edition of BOSFax, e.g. upgrade an existing Spanish BOSFax server and its clients, all Italian systems, to the Italian edition of BOSFax 5.0 (Italian is a new language to be supported by BackOffice 5.0). Revision Information Revision Author Description 15/03/2000 Yafit Gelchinski Initial version 04/04/2000 Yafit Gelchinski Changed according to remarks made by   HYPERLINK "mailto:janf?subject=BOSFax Globalization test plan"  Globalization Testing Page   PAGE   NUMPAGES  Microsoft Confidential  AUTHOR  Yafit Gelchinski  DATE  4/5/2000 PAGE \# "'Page: '#'  Originally this test was scheduled to be done with a pseudo-localized version of the Intl English Win2k server. Apparently in the pseudo-localized version of the server, a few of the frequently used folders remained with their original name (such as  Documents and Settings ). This prevents from making a thorough check of the application regarding hard-coded path names, and so a German server replaced the pseudo-localized one for this test. PAGE \# "'Page: '#'  The Setup/Uninstall test tool runs a check on the system and checks that all registry entries and file system items used by the application, exist on the local system. The tool uses an ini file to list all such entries, since they might differ between the server and the different clients. (Please refer any questions about this tool to  HYPERLINK "mailto:yafit?subject=Setup/Uninstall test tool" mailto:yafit?subject=Setup/Uninstall test tool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\modemcomptc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot micky snir Microsoft Word 9.03F54:fbjbjU CometFax Modem Compatibility Test Cases: Preface  All following test cases refer to the modems installed on the server machine and should be run on NT5 server platform. Test Strategy: Compose a list of  most used  modems. These modems will be tested threefold. Modems will be used in  Scale Lab  (for scale testing) and on Self-Host. Each modem will run  against  the Telegra FaxTrace system test suites. Once as originating side (and Telegra as answering) and once as answering side (and Telegra as originating). Modems will be connected to a CometFax server machine (a  Modems Machine ) via a Multi Port Serial Adapter (1 modem per type) where we will run an  Acceptance test  on each of the modems. There will be a  Send Acceptance Test  and a  Receive Acceptance Test Modems Acceptance Test Suite  will set up one modem to send, another to receive, and will disable all others. It will then run the  Send Acceptance Test  (on the send modem) and the matching  Receive Acceptance Test  (on the receive modem) simultaneously. The suite will go over all modems, testing each in both send and receive roles. Issues: Modems may remain off hook if they fail to correctly respond.  How can we automatically detect an  off hook  situation? sanity check  after every step is too costly. Implementation Strategy: Implementation will be incremental. Compose a list of  most used  modems, obtain hardware and set up the  Modems Machine No further implementation is needed for Telegra tests. Use PCT tests when half installed modems are   enabled and the others are  receive  enabled. Then change modem roles. Verify all files were correctly received (use Reference directory). Enhance BVT to a  Send Acceptance Test  and a separate matching  Receive Acceptance Test Manually enable a   modem and a  receive  modem, and disable all other modems. Run the acceptance tests, switch roles between the two modems and run again. Do so for all possible pairs on the  Modem Machine Implement a tool that  pairs  two modems. Tool will receive two modem ids, will set the first as  , the second as  receive  and will disable all other modems. Use above tool to automate the  send-receive pair  acceptance suite. [TBD]: Should we use the MedetectStub tool to simulate many  types  of modems? Test Categories: Installation. Make sure every installed device is recognized by the CometFax service. * Add devices while CometFax service is running Basic send and receive functionality. Answering incoming calls. Verify that when service turns device Receive  on, it answers all incoming calls. When  Receive  is turned off, modem does not answer call. Manual Answer. We will not have this feature. Printing from applications. Run PCT and compare sent \ received images to reference directory. T.30 protocol  Telegra Regression suites. Fax operations  Cancel \ Zap \ Delete \ Pause (?) \ Resume \ Restart. Make sure modem responds correctly. Most importantly that it hangs up. Fax INF file entries. Fax Boards. Make sure service recognizes and uses efficiently. Modem class 1, 2, and 2.0 Adaptive Answer support. International calls. May have gaps in carrier, may have delays. Supported modulations. Verify modem can send and receive faxes in all of the modulations that it supports. TAPI events. Verify that all generated TAPI events are valid. Prolonged carrier loss. Make sure that modem reports that line was lost when you unplug the line. Send \ Receive to \ from Non-CometFax modems and machines. Modem Compatibility test parameters: Modem Send \ Receive settings. Modem class. Modulation used for sending \ receiving. Hardware settings. E.g. volume, dial control, port speed. Incoming ring signal. Call data  E.g. empty document, complex image (very long page), many pages, etc. Device (port) has \ has not previously been opened by service. That is, the service has \ has not previously initialized the device (device has entries under the CometFax\Devices registry key). [TBD] list of modems to be tested CometFax Modem Compatibility Test Cases  TIME \@ "d-MMM-yy"  6-Oct-99 Microsoft Confidential Sigalit Bar (sigalitb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\mapitc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot micky snir Microsoft Word 9.03F14:fbjbjU MAPI Fax Extension Test Cases: Preface  All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). All test cases will be applied to Outlook2000, Outlook98, Exchange client and other applications which have a  SendTo Fax recipient  option (i.e. Word) Test Strategy: The test suite will consist of two sub-suites.  The first sub-suite s purpose is to activate the MAPI client, making it perform the test cases described below. The second sub-suite will perform verification, making sure that the faxes were sent, received and correctly rendered. We will go over the results of the first run visually ( manually ) and create a reference directory to which we will compare every subsequent CometFax run. Issues: Integration with Outbound routing rules may require all numbers to be entered in canonical form. Fax servers must be configured with Branding = FALSE to prevent printing of banner. The banner includes date and time, which will interfere with fax image verification ( TiffCompare [TBD] Implementation Strategy: Sub-Suite 1 and 2 will both be manual and the  Reference  directory will be created. Automate Sub-Suite 2 incrementally. Start with  TiffCompare ReceivedFaxes  directory and the  Reference  directory. Same for  SentFaxes  archive directory. Verification of mail notifications and errors will be manual. Further enhance Sub-Suite 2. Investigate automation for received mail notifications and if possible automate (using VBA?). Automate Sub-Suite 1 (using VT or VBA). Test Categories: Outlook settings  Tools Services Tools Options Tools Out of Office Assistant  (with an automatic reply to a fax recipient),  Tools Rules wizard (with an automatic forward to a fax recipient) A fax recipient in the following message options:  Forward Reply Reply to All Outlook Message Options (i.e. delivery notification, voting buttons, message importance) [CometFax: name@number] syntax e.g. check [CometFax: @valid_number], [CometFax: name@invalid_number] * check with a valid but non-canonical number (what happens with our outbound routing rules?) Notifications of sent faxes (success and failure). Received faxes (MS Inbound Routing Extension   mail). How do I choose cover pages and can I configure a default CP? What goes into CP  subject  and   fields? From where does the sender information is taken, from the Mapi profile or from the CometFax CPL? Reply to an email, which has a fax recipient (this will verify that the fax recipients info were forwarded correctly). Send a  meeting request  to a fax recipient. On a previously sent fax message, use  Resend  and  Recall  message options. Print (print a message to the CometFax printer). Mind the  Print Style  and  Print attached files with items  options. Coexistence with MSFax Extension and Add-In. Sender information  * CometFax Control Panel applet information. * No sender information (all fields empty). * Some sender information. * Very long values in sender information fields. Recipient information  * Recipient is in Address Book (Personal \ Global \ etc) and has only a Fax number. * Recipient is in Address Book (Personal \ Global \ etc) and has both email and a Fax number. * Recipient is not in Address Book. * Very long values in recipient information fields. Broadcast (?)  * Have 1 fax recipient and 1 non-fax recipient in the to field. * Have many fax recipients * Have many fax recipients and many non-fax recipients. * DL of many fax recipients. * DL of 1 fax recipient * DL of 1 fax recipient and 1 non-fax recipient. * DL of many fax recipients and many non-fax recipients. * Some of the broadcast recipients are in Address Book and some not. Outlook Message test parameters: Inserted documents. Inserted Objects. Tools-> Fax Attributes  Add-In options Check names function. Paper size, orientation, margins Text   RTF vs. Plain text, fonts, format, amount Anything that can be pasted to file (bmp, text, binary files) Paste special. Fax recipients are in the TO, CC and BCC fields. MAPI Fax Extension Test Cases Page   PAGE   NUMPAGES  Microsoft Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  6-Oct-99 IDATx f{0en ^v+gr/ jZG)S s|2ZL C1|$pp k!wb$ ~J!7' V$,&; uD1=0 SNoy|> ~6R?~ '\9Ou "$P?{ (?MyI JY-!=K-% T|8`! <hlw9 g_R(+ 2;p&s &0;&v @peha .#_\s go[o]m~ J#{V[J ]mGP6 RNA(LlK Lo6Z_o <?Z?rK( T8\l/ xr#Do OWRzsg d);*/ l=T/=0 1OY4l !'C?7 +IDAT[<
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\inroutetc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot micky snir Microsoft Word 9.03F+4:fbjbjU CometFax Inbound Routing Extension Test Cases: Preface  All following test cases refer to the Inbound Routing Extensions that are registered on the server machine and should be run on NT5 platform. Test Strategy: Our intention is to test how the CometFax service responds to different Inbound Routing Extension implementations. We will implement a generic Inbound Routing Extension that will be  programmable  to the level of each API behavior, and thus achieving a fully programmable Routing Extension. This is similar to our EFSP testing strategy. Issues: [TBD] Implementation Strategy: Implementation will be incremental. Convert the EFSP named pipes framework to work with Routing APIs. Should be trivial. Implement different API behaviors (as described in test cases),  pluggable  to above framework. Test Categories: Number of Routing Methods per Ext. E.g. Implement a routing extension with a very-large number of routing methods. Implement a routing extension with zero routing methods. Exported APIs. Implement a routing extension that does not export all required APIs. Verify that registration fails. * Also check an Ext. that exports more than required. Actions on the Fax File List   within the same routing extension. This is a list of files to which any routing method may add files or remove files from. The list is controlled by the service and routing methods may call service APIs asking the service to perform action on the list in their behalf. Verify that any legal action is carried out by the service and that any illegal action (E.g. attempting to erase the original received tiff file from the list) is not carried out. Actions on the Fax File List   across routing extensions. That is, methods from one routing extension-performing actions on files added by a routing method from another extension. Fax File List limitations. File size, total list size, number of files, file names, file formats, etc. The FAX_ROUTE structure and its RoutingInfoData member. The service passes this structure from one routing method to the next, as each routing method is invoked (in order of priority). A routing method may call the FaxRouteModifyRoutingData service API to modify the RoutingInfoData member of this structure. The new (modified) structure will be passed to the routing method next in priority. Verify that service modifies the RoutingInfoData as requested by routing methods. Adding and removing Devices. Verify that the service calls the FaxRouteDeviceChangeNotification routing extension API, for every registered routing extension, whenever a device is added or removed. APIs causing AV. API failures with legal and illegal error values. API out parameters. Implement APIs that do not set their out parameters, that set them illegally, etc. hangs The API will sleep for a given (long) time. Verify that service has a timeout and returns a failure status. Inbound Routing Extension test parameters: Which APIs the Routing Ext. exports. How many routing methods the Routing Ext. exports. API return values and error values. Setting of API out parameter values (NULL, invalid, illegal) Calls to service callback routines. Actions API performs on the fax file list. CometFax Inbound Routing Extension Test Cases  TIME \@ "d-MMM-yy"  6-Oct-99 Microsoft Confidential Sigalit Bar (sigalitb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\msroutetc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot micky snir Microsoft Word 9.03F64:fbjbjU CometFax MS Inbound Routing Test Cases: Preface  All following test cases refer to the MS routing extension installed on the server machine and should be run on Win2K server platform. Test Strategy: The MS Routing Extension will be tested in the CometFax service context. If time permits we will also thoroughly test it by directly invoking its APIs. In the  Scale Lab  (see  Scale Test Cases ) we will configure and install several printers, file folders, mail inboxes and email accounts that will be used in the  MS Routing Ext. Suite We will implement the test suite using CometFax Client APIs and the  TiffCompare  tool. Issues: Four routing methods are implemented (FaxRouteEmail, FaxRouteStore, FaxRouteInBox, FaxRoutePrint) but FaxRouteEmail cannot be enabled from GUI. Why? What? => FaxRouteEmail never tested? FaxRouteEmail stores file in any (even not local) inbox while FaxRouteInBox only stores in local inbox. Routing APIs pass routing information as a blob. Structure of blob is private. Do we rely on internal knowledge of MS Routing Extension implementation (that may change) in implementing tests? This will contribute to automation   setting and getting per device routing information using the FaxRouteGetRoutingInfo and FaxRouteSetRoutingInfo APIs. Emphasis should be on the FaxRouteInBox and FaxRouteEmail methods. Investigate ways to automate verification of received email messages and their content. [TBD] Implementation Strategy: Implementation is straightforward. We may resort to manual testing where automation is too costly, as may be the case for testing job operation on  Routing  jobs (test categories no. 9 and 10 below). Test Categories: Code Review the MS Routing Extension. Handling of multiple received files simultaneously. Make sure that many instances of same method can run simultaneously. Method Parameters. Each method also takes a parameter (printer_name, folder_name or profile_name). Verify extension can handle invalid values, NULL, etc. Account under which the service is running. Low disk space. For FaxRouteStore method. Installed Printers on server. Local \ Network \ Shared with no permissions \ Offline \ Malfunctioning \ Busy \ Other CometFax and MSFax printers For FaxRoutePrint method. Per Device Routing Information. Verify that routing method information (enabled \ disabled and parameter) is maintained consistently per device. That is, verify that many processes can invoke the FaxRouteSetRoutingInfo and FaxRouteGetRoutingInfo APIs for the same device simultaneously and that the MS Routing Extension maintains consistency of the above fields. E.g. if a change is in progress (1st field write completed but 2nd and 3rd have not) then a Get request will wait until change completes (to return 1st, 2nd and 3rd new values and NOT 1st new and others old) Per Server Routing Information. Method priorities. Routing  jobs on the CometFax queue. Verify that when a fax reception has completed and it is in the process of being routed, the job status changes to  Routing  until all enabled routing methods (on the receiving device) have completed.  Actions performed on  Routing  jobs. Cancel \ Zap \ Delete \ Pause \ Resume \ Restart. Other Routing Extensions. Functionality of MS routing is not affected. Routing Extension registration \ un-registration. * What happens when MS Ext. is the only routing ext. and we un-register? Extension registry entries. Service should recover from missing \ bad Extension registry entries. MS Routing Extension API testing. If time permits. Logging. Especially of failures. MS Inbound Routing test parameters: FaxRoutePrint printer_name parameter  Null, invalid, not installed, installed but without print permissions, local, network, the local CometFax printer, a remote CometFax printer, etc. FaxRouteStore folder_name parameter  Null, invalid, non-existent, no write permissions, local, network (UNC name and mapped drive), relative, absolute, to a drive with FAT / FAT32 / NTFS file system, to a disk with no space, to floppy, etc. FaxRouteInBox profile_name parameter  Null, invalid, non-existent, not local, no room in inbox,   FaxRouteEmail profile_name parameter  Requires further investigation. Network connectivity. E.g. route to remote folder \ printer when network is down. Proxy connectivity (?) Assuming FaxRouteEmail routes to any email account. Requires further investigation. Fax document size. [TBD] CometFax MS Inbound Routing Test Cases  TIME \@ "d-MMM-yy"  6-Oct-99 Microsoft Confidential Sigalit Bar (sigalitb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\opt-stp-fsp01.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Open Port Technology, Inc. FSP_Microssoft_Testplan Title _PID_GUIDFSP_Microssoft_Testplan Muhammad Mutahir NORMAL.DOT Fred Brunner Microsoft Word 8.0@Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT HP LaserJet 4/4M Plus PS Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3Lb{2. CJ5'*' VUzR%E [t#/rK <KY,y _>C]V= f0U+tI GU3Zk /B</| IO8xXU *nBYo xCc1\ Y[qzB H4I^sl A?&,3Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKMicrosoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95Microsoft Word Picture MSWordDoc Word.Picture.6Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqK Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized User EMBED Word.Picture.6   Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized UserOpen Port Technology Quality Assurance Group TEST PLAN DOCUMENT FSP Microsoft Revision   KEYWORDS  \* MERGEFORMAT  Authors: Muhammad Mutahir Fred Brunner Original: September 23, 1998 Revised: File: FSP_Mirosoft_TestPlan.doc Printed: APPROVALS TITLE SIGNATURE: DATE: Manager of Quality Assurance VP of Engineering This document is confidential and proprietary and is the exclusive property of Open Port Technology, Inc. This document is unpublished and is protected by copyright and trade secret laws. This document has been provided for review by the recipient only. Any other reproduction or distribution of this document without the express written consent of Open Port Technology, Inc. is strictly prohibited. RECORD OF REVISIONS ORIGINATOR: REVISED SECTION/PARAGRAPH:  REVISION LEVEL: RELEASE DATE: Initial Revision 09/23/98 Printed on  date \@ "MMMM d, yyyy" October 6, 1998 1:43 PM File Name = develop/sys2: dev/nas/nmg/projfld/<???>/fs.doc Table of Contents  TOC \o "1-1"  1. TEST PLAN IDENTIFIER  GOTOBUTTON _Toc381699905    PAGEREF _Toc381699905  2. INTRODUCTION  GOTOBUTTON _Toc381699906    PAGEREF _Toc381699906  3. TEST ITEMS  GOTOBUTTON _Toc381699907    PAGEREF _Toc381699907  Error! Bookmark not defined. 4. FEATURES TESTED  GOTOBUTTON _Toc381699908    PAGEREF _Toc381699908  5. FEATURES NOT TESTED  GOTOBUTTON _Toc381699909    PAGEREF _Toc381699909  6. APPROACH  GOTOBUTTON _Toc381699910    PAGEREF _Toc381699910  7. PASS/FAIL CRITERIA  GOTOBUTTON _Toc381699911    PAGEREF _Toc381699911  8. TESTING SUSPENSION/RESUMPTION REQUIREMENTS  GOTOBUTTON _Toc381699912    PAGEREF _Toc381699912  9. TEST DELIVERABLES  GOTOBUTTON _Toc381699913    PAGEREF _Toc381699913  10. TESTING TASKS  GOTOBUTTON _Toc381699914    PAGEREF _Toc381699914  11. ENVIRONMENTAL NEEDS  GOTOBUTTON _Toc381699915    PAGEREF _Toc381699915  12. RESPONSIBILITIES  GOTOBUTTON _Toc381699916    PAGEREF _Toc381699916  13. STAFFING & TRAINING  GOTOBUTTON _Toc381699917    PAGEREF _Toc381699917  14. SCHEDULE  GOTOBUTTON _Toc381699918    PAGEREF _Toc381699918  Error! Bookmark not defined. 15. RISKS AND CONTINGENCIES  GOTOBUTTON _Toc381699919    PAGEREF _Toc381699919  Test Plan Identifier OPT-STP-xx Introduction This document is prepared according to the guidelines in IEEE Std 829-1983  IEEE Standard for Software Test Documentation Objectives Open Port is developing Fax Service Provider (FSP) software modules for Microsoft that will be bundled with NT 5.0 Proxy Server, NT 5.0 Small Business Server (SBS) and NT 5.0 BackOffice Server.   An FSP shall allow faxes that are originated from a Microsoft Fax Client (MFC) to be more cost-effectively delivered via the public Internet.   At a high-level, the FSP acts as a link between the Microsoft Fax Server (MFS) application and an Internet Service Provider s (ISP s) IP Fax service. References [1] Open Port Technology s Fax Service Provider (FSP) Market Requirement Document for Microsoft   Omey Nandyal and Jennifer Schuster 08/26/98. Scope This document is intended to finding strategies to thoroughly test the FSP and its functionality against MFS and MFC bound faxes. Platform Requirements The FSP shall be compatible with the following platforms. Windows NT Server 5.0 Windows NT 5.0 Microsoft Management Console Windows NT 5.0 Proxy Server Windows NT 5.0 Small Business Server Windows NT 5.0 BackOffice Server Intel x86 Hardware DEC Alpha Hardware Features Tested This test plan is intended to exercise the functions of the Microsoft FSP Deliverables and verify that it behaves as specified in the document in ref [1]. Login to FSP Network Login to the FSP Network will involve getting connection to FSP Host machine with a valid IP address and Port Number and then initiating a Login command.  Login will require a Phone Number as an Account Id and Password with an IP address of the name of the authenticating server.  IGAPI/FSP-API. Logout of FSP Network A user has to be logged in before testing this functionality.  Logging out of the FSP Network will be tested without having to adopt a particular format. IGAPI/FSP-API. Getting MFS User Defaults In order to make any necessary changes or to view an End User Defaults (End Users  Personal Defaults for Fax Transmission) an FSP Administration will be able to get the desired information from the MFS upon request.  The Administrator will make a function call to accomplish this task.  FSP Administrator will make several of these function calls for proper functionality check.  Negative function calls will also be made for proper error notification. Please note that the Getting of Defaults also include Getting information such as Number of Retries, Maximum Retries, Fax Header, and the option whether to use Fax Header or not.   IGAPI/FSP-API. Setting MFS Defaults A function call will enable FSP Administrator to set the MFS Account Default in the FSP Network.  A number of function calls with various settings for a particular user will help testing this functionality of the FSP.   This test should not involve any fax send to the FSP Network.  Please note that the Setting of Defaults also include Setting information such as Retries, Maximum Retries, Fax Header, and the option whether to use Fax Header or not. IGAPI/FSP-API. Sending Fax A send function without any particular format will direct An MFS issued Fax to its destination via FSP Network.  Different methods and routes will be used to test the Send Functionality of the FSP. Please note that a Fax can only be sent with the following information at hand: Number of Recipients, Fax Body, Coversheet, and/or attachments.  MFS currently does not support Broadcast Faxes.  Faxes that are bound to more than one recipients are called Broadcast Faxes.  Assembly of faxes is done at the MFC level with TIFF Group 3 format.  FSP will make sure to keep the integrity of fax when issuing Send Fax call.  Quality and Integrity of the Faxes will be maintained and will thoroughly be tested by gradually increasing the load in the FSP system. Receiving Faxes Note: At this time I am unaware of the protocol with which MFS would like to Receive the Faxes from FSP Network.  There are two ways with which MSF can download Faxes from the ISP Network.  FSP can download all Faxes at once or it can download a list of Faxes in the server and then down load the actual Faxes associated with each listed Faxes in the list one at time. Depending on the method with which  MFS will download Faxes from the ISP Network appropriate test mechanism will be used.  Load testing will also be performed with either of the methods adopted by MSF. IGAPI/FSP-API. Fax Status Since the error codes of the NSP Provider and MFS are different measures will be taken to map the error codes from the NSP Network with that of MFS error codes.  Testing the status functionality of the NSP Server will be done according to MSF based error codes.  Positive and Negative testing for the Status Message will be done to reflect each and every mapped error code.  Please note that the errors will be reported to the NT event log. IGAPI/FSP-API. Routing Routing modules (Inbound & Outbound) are being handled by Microsoft.  Testing?? Polling Interval FSP will be tested with a number of Polling Intervals for Logging in to the FSP Network.  To thoroughly test the Polling Interval functionality a number of Polling Intervals will be introduced in the FSP Server in a timely manner.  FSP will also be tested beyond the Polling Intervals upon the notification from the ISP Network.  Provisioning The Administration User Interface, Open Port Technology FSP Property Page, provisioning of critical information before FSP can be used will be tested both positively and negatively.  NT Event Logs, Outbound Fax logs, and Inbound Fax logs will be monitored for proper provision settings. Feature Matrix Feature Identifier Title Description Requirement Reference OPT-TDS-FSP100 FSP backbone Provisioning Verification of ISP Server, Port Number, Account Ids, Realm, password etc. OPT-TDS-FSP200 Basic Functionality Logins, Logouts, sessions etc. OPT-TDS-FSP300 Fax Transport Sending, Receiving, Statusing of Faxes. etc.  OPT-TDS-FSP400 Load Testing Sending Thousands of Faxes through the FSP. Features Not Tested Test Approach Approach Test designs and test cases will be developed from existing test software and procedures in existence for the previous generation application code testing, existing test cases and software in use in the QA, and new tools and test cases developed by the QA organization. Test States 6.1.1. Initial Verification Testing  6.1.2. Regression Testing 6.1.3. Testing Improvement Test Network Design Pass / Fail Criteria Specific pass/fail criteria for all features will be identified in the test procedure documentation for each feature.  The following general comments apply. Standards Compliance For all features identified as conforming to applicable standards, verification will be performed by reference to these standards. Where such standards identify potentially ambiguous implementation requirements, design intent as represented in product functional specifications will be used. Functional Specification Design Documentation Pass/Fail criteria may have to be extracted from available design documentation where Functional Specifications or standards documentation cannot be used to establish desired behavior. If this does not exist or still cannot be used to define pass criteria, test engineering will consult with the appropriate development staff to determine them. Defect Severity Assessment All features should have failure criteria defined for each severity level defined in ref [TBD]. Where specific failure criteria are not defined in test procedures, this document s general definitions will apply. Testing Suspension / Resumption Requirements In general, QA will attempt to complete all test procedures defined for the test plan. The only cause for immediate unilateral suspension of testing will be the failure of a submitted load to boot/start-up on the target platform. Otherwise, testing suspension will be a decision made by project management. Resumption is likewise a project management decision, and a decision to suspend testing should be identified as either a withdrawal of the submission or a with a target time to resume testing. QA Deliverables   ????????? The following iteFSP will be delivered as part of the standard output of the QA test process. Integration Test Documentation The following iteFSP will we generated by QA prior to the start of formal testing on product submissions. These will be archived and maintained in a configuration control system. 9.1.1. Test Design Specifications 9.1.2. Test Case Specifications 9.1.3. Test Procedure Specifications Test Cycle Deliverables These iteFSP will be deliverables of every test cycle executed on a product submission. 9.2.1. Defect Records All defects identified during testing will be demonstrated to development engineering and entered into the defect database using the procedure defined in [ref]. 9.2.2. Test Summary Report This contains the completed test logs/checklists for the product test plan. 9.2.3. Test Output Data Test result output from tests conducted on the target systeFSP will be maintained as part of the archive of the submission.  Testing Tasks 10.1. General Testing Breakdown 10.2. Specific Testing Tasks Environmental Needs Responsibilities 12.1. Quality Assurance Overall responsibility for management and execution of testing activities for System Test. Responsible for maintaining a record of defects found, and in tracking and closing such defect reports. Repository of knowledge of testing process and procedure and responsible for instituting control of testing to known best practice. Provides assessment of product quality based on completed testing. 12.2. Project Management Determines relative priority of testing activities where schedule or resource constraints exist. Determines whether testing should be suspended or stopped on a load. Makes final ship decision based on business needs and quality assessment provided by QA and Customer Support. 12.3. Product Marketing Identifies equipment to be used for competitive benchmarking, and compatibility testing. 12.4. Development Project Group Responsible for system implementation and correction of defects. 12.5. Customer Support Receives final product submissions from QA after conclusion of test and is responsible for customer beta testing and field support. Staffing & Training 13.1. Staffing 13.2. Training Risks and Contingencies Availability of time and resources is the primary risk associated with successful completion of this test plan.  15.1. Staffing 15.2. Test Stand Hardware 15.3. Third Party Components 15.4. Schedule (END DOC) EMBED Word.Picture.8 Test Plan Document DOC#: OPT-STP-xx REVISION:   KEYWORDS  \* MERGEFORMAT  PAGE  page  \* mergeformat  numpages  \* mergeformat  Copyright Open Port Technology, Inc.  All rights reserved.  May not be reproduced without permission.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\opt-tds-fsp01.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Open Port Technology, Inc. FSP_Microssoft_Testplan Title _PID_GUIDFSP_Microssoft_Testplan Muhammad Mutahir Normal.dot Muhammad Mutahir Microsoft Word 8.0@Printer 3 Direct Ne00: winspool HP LaserJet 4/4M Plus PS 600 Printer 3 Direct Letter Printer 3 Direct LetterLb{2. CJ5'*' VUzR%E [t#/rK <KY,y _>C]V= f0U+tI GU3Zk /B</| IO8xXU *nBYo xCc1\ Y[qzB H4I^sl A?&,3Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKMicrosoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95Microsoft Word Picture MSWordDoc Word.Picture.6Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqK Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized User EMBED Word.Picture.6   Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized UserOpen Port Technology Quality Assurance Group TEST DESIGN SPECIFICATION OPT-TDS-FSP01 FSP Microsoft Revision   KEYWORDS  \* MERGEFORMAT  Authors: Muhammad Mutahir Original: September 23, 1998 Revised: File: FSP_Mirosoft_TestPlan.doc Printed: APPROVALS TITLE SIGNATURE: DATE: Manager of Quality Assurance VP of Engineering This document is confidential and proprietary and is the exclusive property of Open Port Technology, Inc. This document is unpublished and is protected by copyright and trade secret laws. This document has been provided for review by the recipient only. Any other reproduction or distribution of this document without the express written consent of Open Port Technology, Inc. is strictly prohibited. RECORD OF REVISIONS ORIGINATOR: REVISED SECTION/PARAGRAPH:  REVISION LEVEL: RELEASE DATE: Initial Revision 09/30/98 Printed on  date \@ "MMMM d, yyyy" October 5, 1998 3:37 PM File Name = develop/sys2: dev/nas/nmg/projfld/<???>/fs.doc Table of Contents  TOC \o "1-1"  1. TEST SPECIFICATION IDENTIFIER  GOTOBUTTON _Toc381699905    PAGEREF _Toc381699905  2. DOCUMENTS REFERENCED  GOTOBUTTON _Toc381699906    PAGEREF _Toc381699906  3. FEATURES TESTED  GOTOBUTTON _Toc381699908    PAGEREF _Toc381699908  5. teST CASES  GOTOBUTTON _Toc381699909    PAGEREF _Toc381699909  5. teST PROCEDURES  GOTOBUTTON _Toc381699910    PAGEREF _Toc381699910  6. PASS/FAIL CRITERIA  GOTOBUTTON _Toc381699919    PAGEREF _Toc381699919  Test SPECIFICATION Identifier OPT-STP-FSP01 ReferenceD dOCUMENT This document is prepared according to the guidelines in IEEE Std 829-1983  IEEE Standard for Software Test Documentation [1] Open Port Technology s Fax Service Provider (FSP) Market Requirement Document for Microsoft   Omey Nandyal and Jennifer Schuster 08/26/98. Features Tested This test plan is intended to exercise the functions of the Microsoft FSP Deliverables and verify that it behaves as specified in the document IN ref[1]. Summary Polling Interval FSP will be tested with a number of Polling Intervals for Logging in to the FSP Network.  To thoroughly test the Polling Interval functionality a number of Polling Intervals will be introduced in the FSP Server in a timely manner.  FSP will also be tested beyond the Polling Intervals upon the notification from the ISP Network.  Provisioning The Administration User Interface, Open Port Technology FSP Property Page, provisioning of critical information before FSP can be used will be tested both positively and negatively.  NT Event Logs, Outbound Fax logs, and Inbound Fax logs will be monitored for proper provision settings. # OF TEST CASES # OF POSITIVE TEST CASES # OF NEGATIVE TEST CASES Feature Matrix Feature Identifier Title Description Requirement Reference OPT-TDS-FSP01 FSP backbone Provisioning Verification of ISP Server, Port Number, Account Ids, Realm, password etc. OPT-TDS-FSP01 Basic Functionality Logins, Logouts, sessions etc. OPT-TDS-FSP01 Fax Transport Sending, Receiving, Statusing of Faxes. etc.  OPT-TDS-FSP01 Load Testing Sending Thousands of Faxes through the FSP. Features Not Tested Test Approach Test CASES Definitions: Valid user A user recognized by the FSP Invalid user A user not recognized by the FSP Destination A valid Account ID in the target FSP Coversheet QA Standard Coversheet Fax Body QA Standard 45K Fax Body Abbreviations: Radio Button Check Box Text Box Selection Box OPT FSP Property Page OPT FSP Property Page General Tab OPT FSP Property Page Advances Tab OPT FSP Property Page Logging Tab OPT FSP Property Page Alerts for Critical condition Test Case Specification Input Specification Output Specification Features Tested OPT-TCS-FSP101 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL deselect Debug_CK and select Enable logging_RB.   On PPGA put   in Use Retries_TB.   On PPGG put incorrect information in ISP Port Number_TB . Press OK. OPTFSP Login Failed  Alert will be shown.   Error log will be generated on the location specified in Log Location_TB in PPGL. OPT-TDS-FSP01 OPT-TCS-FSP102 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL deselect Debug_CK and select Disable logging_RB.   On PPGA put   in Use Retries_TB.   On PPGG put incorrect information in ISP Port Number_TB . Press OK. OPTFSP Login Failed  Alert will be shown.   Error log will NOT be generated on the location specified in Log Location_TB in PPGL. OPT-TDS-FSP01 OPT-TCS-FSP103 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL deselect Debug_CK and select Enable logging_RB.   On PPGA put   in Use Retries_TB and no number in Max_retries_TB.   On PPGG provide incorrect information in ISP AccountID_TB and other TB. Press OK. OPTFSP Login Failed  Alert will be shown.   Error log will NOT be generated on the location specified in Log Location_TB in PPGL.   Warnings will also appear in the log for Max Retries. OPT-TDS-FSP01 TEST PROCEDURES PASS/FAIL CRITERIA All test cases are to produce expected results. Any deviation will be considered a failure, including failure of the backbone system to behave properly. (END DOC) EMBED Word.Picture.8 Test Plan Document DOC#: OPT-TDS-FSP100 REVISION:   KEYWORDS  \* MERGEFORMAT  PAGE  page  \* mergeformat  numpages  \* mergeformat  Copyright Open Port Technology, Inc.  All rights reserved.  May not be reproduced without permission. {uoifc`] yqgb^Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\opt-stp-msfsp-01.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Open Port Technology, Inc. FSP_Microssoft_Testplan Title _PID_GUIDFSP_Microssoft_Testplan Muhammad Mutahir NORMAL.DOT Fred Brunner Microsoft Word 8.0S3YJwD @Fax_Client_Printer FAXPORT: Image Maker Win98 Driver Image Maker Win98 Driver Fax_Client_Printer Image Maker Win98 Driver Fax_Client_Printer Image Maker Win98 DriverLb{2. CJ5'*' VUzR%E [t#/rK <KY,y _>C]V= f0U+tI GU3Zk /B</| IO8xXU *nBYo xCc1\ Y[qzB H4I^sl A?&,3Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKMicrosoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95Microsoft Word Picture MSWordDoc Word.Picture.6Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqK Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized User EMBED Word.Picture.6   Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized UserOpen Port Technology Quality Assurance Group TEST PLAN DOCUMENT Microsoft FSP Revision   KEYWORDS  \* MERGEFORMAT  Authors: Muhammad Mutahir Fred Brunner Original: September 23, 1998 Revised:  SAVEDATE  \* MERGEFORMAT  10/09/98 11:39 AM File:  FILENAME  OPT-STP-MSFSP-01.doc Printed: APPROVALS TITLE SIGNATURE: DATE: Manager of Quality Assurance Fred Brunner VP of Engineering Neta Hittleman This document is confidential and proprietary and is the exclusive property of Open Port Technology, Inc. This document is unpublished and is protected by copyright and trade secret laws. This document has been provided for review by the recipient only. Any other reproduction or distribution of this document without the express written consent of Open Port Technology, Inc. is strictly prohibited. RECORD OF REVISIONS ORIGINATOR: REVISED SECTION/PARAGRAPH:  REVISION LEVEL: RELEASE DATE: Initial Revision 09/23/98 Printed on  date \@ "MMMM d, yyyy" October 9, 1998 11:38 AM File Name = develop/sys2: dev/nas/nmg/projfld/<???>/fs.doc Table of Contents  TOC \o "1-1"  Test Plan Identifier  PAGEREF _Toc432558219 \h  Introduction  PAGEREF _Toc432558220 \h  Features Tested  PAGEREF _Toc432558221 \h  Approach  PAGEREF _Toc432558222 \h  Pass / Fail Criteria  PAGEREF _Toc432558223 \h  Testing Suspension / Resumption Requirements  PAGEREF _Toc432558224 \h  QA Deliverables  PAGEREF _Toc432558225 \h  Testing Tasks  PAGEREF _Toc432558226 \h  Environmental Needs  PAGEREF _Toc432558227 \h  Responsibilities  PAGEREF _Toc432558228 \h  Staffing & Training  PAGEREF _Toc432558229 \h  Risks and Contingencies  PAGEREF _Toc432558230 \h  Test Plan Identifier OPT-STP-FSP01 Introduction This document is prepared according to the guidelines in IEEE Std 829-1983  IEEE Standard for Software Test Documentation Objectives Open Port is developing Fax Service Provider (FSP) software modules for Microsoft that will be bundled with NT 5.0 Proxy Server, NT 5.0 Small Business Server (SBS) and NT 5.0 BackOffice Server.   An FSP shall allow faxes that are originated from a Microsoft Fax Client (MFC) to be more cost-effectively delivered via the public Internet.   At a high-level, the FSP acts as a link between the Microsoft Fax Server (MFS) application and an Internet Service Provider s (ISP s) IP Fax service. References Open Port Technology s Fax Service Provider (FSP) Market Requirement Document for Microsoft  Omey Nandyal and Jennifer Schuster 08/26/98. Open Port QA Software Submission Process v1.1  Fred Brunner 09/20/98. Scope This document is intended to define strategies to thoroughly test the FSP and its functionality against MFS and MFC bound faxes. It is NOT intended as a general test plan for the functionality of the Microsoft Fax Server product, which will be tested by Microsoft. This means that the primary goal is to exercise the IGAPI SDK functions called by the FSP as implemented to verify correct operation. Platform Requirements The FSP shall be compatible with the following platforms. Windows NT Server 5.0 Windows NT 5.0 Microsoft Management Console Windows NT 5.0 Proxy Server Windows NT 5.0 Small Business Server Windows NT 5.0 BackOffice Server Intel x86 Hardware DEC Alpha Hardware Features Tested This test plan is intended to exercise the functions of the Microsoft FSP Deliverables and verify that it behaves as specified in the document in ref [1]. Login to FSP Network Logout of FSP Network Getting MFS User Defaults Setting MFS Defaults Sending Fax Receiving Faxes Fax Status Routing Polling Interval Provisioning General requirements for test input deliverables See ref [2].  Specific test input deliverables The following test deliverables will be expected to support System Testing of the OPT FSP for Microsoft Fax Server system. Development engineering must identify which compatibility of versions of HW and SW of the various components of the system release. If all components are not submitted together, desired test versions of the non-submitted components must be indicated in the submission document.  Hardware Components There are no Open Port hardware components delivered with this product Software Components The following system component deliverables will be tested as part of the system test activity for the Microsoft FSP: Component Name Platform Submitted As Comments OPT ASP FSP NT 5.0 (x86) (need defined) OPT ASP FSP NT 5.0 (Alpha) (need defined) Deliverable Packaging and Media The expected format for the delivery of the components listed above is as follows: Package Name Components Installed Package format Install format  The following delivery media formats will be tested by QA: Electronic submission (ftp site/Web server) CD-ROM QA Release Request Form A form containing the information necessary to build and submit a product load to SQA must be submitted in electronic form to the QA test lead for each product component. Feature Matrix Test Design Specification Title Description Requirement Reference OPT-TDS-FSP100 FSP backbone Provisioning Verification of ISP Server, Port Number, Account Ids, Realm, password etc. OPT-TDS-FSP200 Basic Functionality Logins, Logouts, sessions etc. OPT-TDS-FSP300 Fax Transport Sending, Receiving, Statusing of Faxes. etc.  OPT-TDS-FSP400 Load Testing Sending Thousands of Faxes through the FSP. Features Not Tested As noted in section 2.3 above, features generic to the Microsoft functionality independent of the selected FSP type will not be explicitly tested as part of this test plan.  Test Approach The general test approach/strategy will be to execute standard user operations on the Fax Server to send and receive faxes via the FSP.  Approach Test designs and test cases will be developed from existing test software and procedures in existence for the previous generation application code testing, existing test cases and software in use in the QA, and new tools and test cases developed by the QA organization. Test States The following test states will be referenced in test design specifications in describing the criticality or level of detail covered by a given test case. Initial Integration  Initial testing to verify basic interoperability of system modules/components. System Testing Full system testing, including load and stress tests. Beta Testing Release of code to external groups for more customer-focused testing. Test Improvement Additions to test cases for problems discovered during testing and development of additional automation/tools. Test Network Design [see network diagram] Pass / Fail Criteria Specific pass/fail criteria for all features will be identified in the test procedure documentation for each feature.  The following general comments apply. Standards Compliance For all features identified as conforming to applicable standards, verification will be performed by reference to these standards. Where such standards identify potentially ambiguous implementation requirements, design intent as represented in product functional specifications will be used. Functional Specification The Functional Specification is the fundamental document used to generate test cases and testing strategy. Where the details of intended operation are ambiguous, assumptions will be stated in the test design specifications. Design Documentation Pass/Fail criteria may have to be extracted from available design documentation where Functional Specifications or standards documentation cannot be used to establish desired behavior. If this does not exist or still cannot be used to define pass criteria, test engineering will consult with the appropriate development staff to determine them. Defect Severity Assessment All features should have failure criteria defined for each severity level defined in ref [TBD]. Where specific failure criteria are not defined in test procedures, this document s general definitions will apply. Testing Suspension / Resumption Requirements In general, QA will attempt to complete all test procedures defined for the test plan. The only cause for immediate unilateral suspension of testing will be the failure of a submitted load to boot/start-up on the target platform. Otherwise, testing suspension will be a decision made by project management. Resumption is likewise a project management decision, and a decision to suspend testing should be identified as either a withdrawal of the submission or a with a target time to resume testing. QA Deliverables The following items will be delivered as part of the standard output of the QA test process. Integration Test Documentation The following items will we generated by QA prior to the start of formal testing on product submissions. These will be archived and maintained in a configuration control system. Test Design Specifications Test Case Specifications Test Procedure Specifications Test Cycle Deliverables These deliverables will be generated every test cycle executed on a product submission. Defect Records All defects identified during testing will be demonstrated to development engineering and entered into the defect database using the procedure defined in [ref]. Test Summary Report This contains the completed test logs/checklists for the product test plan and describes the detailed findings of the QA group. This will include all uncorrected defects found during testing, as well as any corrections to manuals or other documentation.  Test Output Data Test result output from tests conducted on the target system will be maintained as part of the archive of the submission.  Testing Tasks General Testing Breakdown Initial Verification Testing  These are very basic tests of the core functionality of the system tested in an end-end fashion. Failure of any test cases executed as part of IVT indicates a bad build or other major problem. Regression Testing Feature regression per features identified in Functional Specification, Design Specifications, and/or User documentation. Load/Stress/Performance Testing Testing designed to identify the limits of the system from a performance standpoint. The system under test should degrade gracefully if it requires resources that are not available, either temporarily or permanently. Specific Testing Tasks Specific test items for this test plan are identified in the individual Test Design Specifications in Section 3.1. Environmental Needs [see Network diagram] Responsibilities Quality Assurance Overall responsibility for management and execution of testing activities for System Test. Responsible for maintaining a record of defects found, and in tracking and closing such defect reports. Repository of knowledge of testing process and procedure and responsible for instituting control of testing to known best practice. Provides assessment of product quality based on completed testing. Project Management Determines relative priority of testing activities where schedule or resource constraints exist. Determines whether testing should be suspended or stopped on a load. Makes final ship decision based on business needs and quality assessment provided by QA and Customer Support. Product Marketing Identifies equipment to be used for competitive benchmarking, and compatibility testing. Development Project Group Responsible for system implementation and correction of defects. Customer Support Receives final product submissions from QA after conclusion of test and is responsible for customer beta testing and field support. Staffing & Training Staffing Required staffing level for executing required testing for this project is minimally 1 dedicated QA engineer. Training Required training will be dependent on knowledge background of allocated test engineering staff, but will need to include installation and operation of Windows NT 5.0 and the Microsoft Fax Server. Knowledge of the OPT Messaging Backbone and some knowledge of fax technology will also be needed, primarily as regards the handling of TIFF format images. Risks and Contingencies Availability of time and resources is the primary risk associated with successful completion of this test plan.  Staffing Test Stand Hardware Third Party Components Schedule (END DOC) EMBED Word.Picture.8 Test Plan Document DOC#: OPT-STP-MSFSP01 REVISION:   KEYWORDS  \* MERGEFORMAT  PAGE  page  \* mergeformat  numpages  \* mergeformat  Copyright Open Port Technology, Inc.  All rights reserved.  May not be reproduced without permission.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\opt-tds-fsp02.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Open Port Technology, Inc. FSP_Microssoft_Testplan Title _PID_GUIDFSP_Microssoft_Testplan Muhammad Mutahir Normal.dot Muhammad Mutahir Microsoft Word 8.0@Printer 3 Direct Ne00: winspool HP LaserJet 4/4M Plus PS 600 Printer 3 Direct Letter Printer 3 Direct LetterLb{2. CJ5'*' VUzR%E [t#/rK <KY,y _>C]V= f0U+tI GU3Zk /B</| IO8xXU *nBYo xCc1\ Y[qzB H4I^sl A?&,3Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKMicrosoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95Microsoft Word Picture MSWordDoc Word.Picture.6Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqK Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized User EMBED Word.Picture.6   Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized UserOpen Port Technology Quality Assurance Group TEST DESIGN SPECIFICATION OPT-TDS-FSP02 FSP Microsoft Revision   KEYWORDS  \* MERGEFORMAT  Authors: Muhammad Mutahir Original: September 23, 1998 Revised: File: FSP_Mirosoft_TestPlan.doc Printed: APPROVALS TITLE SIGNATURE: DATE: Manager of Quality Assurance VP of Engineering This document is confidential and proprietary and is the exclusive property of Open Port Technology, Inc. This document is unpublished and is protected by copyright and trade secret laws. This document has been provided for review by the recipient only. Any other reproduction or distribution of this document without the express written consent of Open Port Technology, Inc. is strictly prohibited. RECORD OF REVISIONS ORIGINATOR: REVISED SECTION/PARAGRAPH:  REVISION LEVEL: RELEASE DATE: Initial Revision 09/30/98 Printed on  date \@ "MMMM d, yyyy" October 5, 1998 3:45 PM File Name = develop/sys2: dev/nas/nmg/projfld/<???>/fs.doc Table of Contents  TOC \o "1-1"  1. TEST SPECIFICATION IDENTIFIER  GOTOBUTTON _Toc381699905    PAGEREF _Toc381699905  2. DOCUMENTS REFERENCED  GOTOBUTTON _Toc381699906    PAGEREF _Toc381699906  3. FEATURES TESTED  GOTOBUTTON _Toc381699908    PAGEREF _Toc381699908  5. teST CASES  GOTOBUTTON _Toc381699909    PAGEREF _Toc381699909  5. teST PROCEDURES  GOTOBUTTON _Toc381699910    PAGEREF _Toc381699910  6. PASS/FAIL CRITERIA  GOTOBUTTON _Toc381699919    PAGEREF _Toc381699919  Test SPECIFICATION Identifier OPT-STP-FSP01 ReferenceD dOCUMENT This document is prepared according to the guidelines in IEEE Std 829-1983  IEEE Standard for Software Test Documentation [1] Open Port Technology s Fax Service Provider (FSP) Market Requirement Document for Microsoft   Omey Nandyal and Jennifer Schuster 08/26/98. Features Tested This test plan is intended to exercise the functions of the Microsoft FSP Deliverables and verify that it behaves as specified in the document IN ref[1]. Summary Login to FSP Network Login to the FSP Network will involve getting connection to FSP Host machine with a valid IP address and Port Number and then initiating a Login command.  Login will require a Phone Number as an Account Id and Password with an IP address of the name of the authenticating server.  IGAPI/FSP-API. Logout of FSP Network A user has to be logged in before testing this functionality.  Logging out of the FSP Network will be tested without having to adopt a particular format. IGAPI/FSP-API. # OF TEST CASES # OF POSITIVE TEST CASES # OF NEGATIVE TEST CASES Feature Matrix Feature Identifier Title Description Requirement Reference OPT-TDS-FSP01 FSP backbone Provisioning Verification of ISP Server, Port Number, Account Ids, Realm, password etc. OPT-TDS-FSP02 Basic Functionality Logins, Logouts, sessions etc. OPT-TDS-FSP03 Fax Transport Sending, Receiving, Statusing of Faxes. etc.  OPT-TDS-FSP04 Load Testing Sending Thousands of Faxes through the FSP. Features Not Tested Test Approach Test CASES Definitions: Valid user A user recognized by the FSP Invalid user A user not recognized by the FSP Destination A valid Account ID in the target FSP Coversheet QA Standard Coversheet Fax Body QA Standard 45K Fax Body Abbreviations: Radio Button Check Box Text Box Selection Box OPT FSP Property Page OPT FSP Property Page General Tab OPT FSP Property Page Advances Tab OPT FSP Property Page Logging Tab OPT FSP Property Page Alerts for Critical condition Test Case Specification Input Specification Output Specification Features Tested OPT-TCS-FSP201 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL select Debug_CK and select Enable logging_RB.   On PPGA put   in Use Retries_TB and   in Max_retries_TB. On PPGG provide correct information in ISP AccountID_TB and other TBs . Press OK. Login Successful. OPT-TDS-FSP02 OPT-TCS-FSP202 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL select Debug_CK and select Enable logging_RB.   On PPGA put   in Use Retries_TB and   in Max_retries_TB and appropriate information on Header_TBs.   On PPGG provide incorrect information in ISP Realm_TB and other TBs . Press OK. Login Failed. OPT-TDS-FSP02 OPT-TCS-FSP203 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL select Debug_CK and select Enable logging_RB.   On PPGA put   in Use Retries_TB and   in Max_retries_TB and appropriate information on Header_TBs.   On PPGG provide correct information in ISP Realm_TB and other TBs . Press OK. Login Successful. OPT-TDS-FSP02 OPT-TCS-FSP204 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL select Debug_CK and select Enable logging_RB.  On PPGA put   in Use Retries_TB and   in Max_retries_TB and appropriate information on Header_TBs.   On PPGG provide incorrect information in ISP ISP Server_TB and other TBs . Press OK. Login Failed. OPT-TDS-FSP02 OPT-TCS-FSP205 On PPGC select Login Failed Condition SB and put down the Alert Name_TB.   On PPGL select Debug_CK and select Enable logging_RB.   On PPGA put   in Use Retries_TB and   in Max_retries_TB and appropriate information on Header_TBs.   On PPGG provide correct information in ISP ISP Server_TB and other TBs . Press OK. Login Successful. OPT-TDS-FSP02 OPT-TCS-FSP206 Set Polling Interval to a higher number of seconds.   Login to FSP with a valid user.   Do nothing for a while. FSP will not execute a Login to ISP Network since there are no faxes to be delivered and polling interval is way too high to check in for Received Faxes. OPT-TDS-FSP01 OPT_TDS-FSP02 OPT-TCS-FSP207 Set Polling Interval to THREE seconds.   Login to FSP with a valid user.   Do nothing. FSP will Login to ISP Network every Three seconds. OPT-TDS-FSP01 OPT_TDS-FSP02 TEST PROCEDURES PASS/FAIL CRITERIA All test cases are to produce expected results. Any deviation will be considered a failure, including failure of the backbone system to behave properly. (END DOC) EMBED Word.Picture.8 Test Plan Document DOC#: OPT-TDS-FSP200 REVISION:   KEYWORDS  \* MERGEFORMAT  PAGE  page  \* mergeformat  numpages  \* mergeformat  Copyright Open Port Technology, Inc.  All rights reserved.  May not be reproduced without permission.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\opt-tds-fsp04.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Open Port Technology, Inc. FSP_Microssoft_Testplan Title _PID_GUIDFSP_Microssoft_Testplan Muhammad Mutahir Normal.dot Muhammad Mutahir Microsoft Word 8.0@Printer 3 Direct Ne00: winspool HP LaserJet 4/4M Plus PS 600 Printer 3 Direct Letter Printer 3 Direct LetterLb{2. CJ5'*' VUzR%E [t#/rK <KY,y _>C]V= f0U+tI GU3Zk /B</| IO8xXU *nBYo xCc1\ Y[qzB H4I^sl A?&,3Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKMicrosoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95Microsoft Word Picture MSWordDoc Word.Picture.6Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqK Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized User EMBED Word.Picture.6   Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized UserOpen Port Technology Quality Assurance Group TEST DESIGN SPECIFICATION OPT-TDS-FSP04 FSP Microsoft Revision   KEYWORDS  \* MERGEFORMAT  Authors: Muhammad Mutahir Original: September 23, 1998 Revised: File: FSP_Mirosoft_TestPlan.doc Printed: APPROVALS TITLE SIGNATURE: DATE: Manager of Quality Assurance VP of Engineering This document is confidential and proprietary and is the exclusive property of Open Port Technology, Inc. This document is unpublished and is protected by copyright and trade secret laws. This document has been provided for review by the recipient only. Any other reproduction or distribution of this document without the express written consent of Open Port Technology, Inc. is strictly prohibited. RECORD OF REVISIONS ORIGINATOR: REVISED SECTION/PARAGRAPH:  REVISION LEVEL: RELEASE DATE: Initial Revision 09/30/98 Printed on  date \@ "MMMM d, yyyy" October 5, 1998 3:52 PM File Name = develop/sys2: dev/nas/nmg/projfld/<???>/fs.doc Table of Contents  TOC \o "1-1"  1. TEST SPECIFICATION IDENTIFIER  GOTOBUTTON _Toc381699905    PAGEREF _Toc381699905  2. DOCUMENTS REFERENCED  GOTOBUTTON _Toc381699906    PAGEREF _Toc381699906  3. FEATURES TESTED  GOTOBUTTON _Toc381699908    PAGEREF _Toc381699908  5. teST CASES  GOTOBUTTON _Toc381699909    PAGEREF _Toc381699909  5. teST PROCEDURES  GOTOBUTTON _Toc381699910    PAGEREF _Toc381699910  6. PASS/FAIL CRITERIA  GOTOBUTTON _Toc381699919    PAGEREF _Toc381699919  Test SPECIFICATION Identifier OPT-STP-FSP01 ReferenceD dOCUMENT This document is prepared according to the guidelines in IEEE Std 829-1983  IEEE Standard for Software Test Documentation [1] Open Port Technology s Fax Service Provider (FSP) Market Requirement Document for Microsoft   Omey Nandyal and Jennifer Schuster 08/26/98. Features Tested This test plan is intended to exercise the functions of the Microsoft FSP Deliverables and verify that it behaves as specified in the document IN ref[1]. Summary Sending Fax A send function without any particular format will direct An MFS issued Fax to its destination via FSP Network.  Different methods and routes will be used to test the Send Functionality of the FSP. Please note that a Fax can only be sent with the following information at hand: Number of Recipients, Fax Body, Coversheet, and/or attachments.  MFS currently does not support Broadcast Faxes.  Faxes that are bound to more than one recipients are called Broadcast Faxes.  Assembly of faxes is done at the MFC level with TIFF Group 3 format.  FSP will make sure to keep the integrity of fax when issuing Send Fax call.  Quality and Integrity of the Faxes will be maintained and will thoroughly be tested by gradually increasing the load in the FSP system. Receiving Faxes Note: At this time I am unaware of the protocol with which MFS would like to Receive the Faxes from FSP Network.  There are two ways with which MSF can download Faxes from the ISP Network.  FSP can download all Faxes at once or it can download a list of Faxes in the server and then down load the actual Faxes associated with each listed Faxes in the list one at time. Depending on the method with which  MFS will download Faxes from the ISP Network appropriate test mechanism will be used.  Load testing will also be performed with either of the methods adopted by MSF. IGAPI/FSP-API. # OF TEST CASES # OF POSITIVE TEST CASES # OF NEGATIVE TEST CASES Feature Matrix Feature Identifier Title Description Requirement Reference OPT-TDS-FSP01 FSP backbone Provisioning Verification of ISP Server, Port Number, Account Ids, Realm, password etc. OPT-TDS-FSP02 Basic Functionality Logins, Logouts, sessions etc. OPT-TDS-FSP03 Fax Transport Sending, Receiving, Statusing of Faxes. etc.  OPT-TDS-FSP04 Load Testing Sending Thousands of Faxes through the FSP. Features Not Tested Test Approach Test CASES Definitions: Valid user A user recognized by the FSP Invalid user A user not recognized by the FSP Destination A valid Account ID in the target FSP Coversheet QA Standard Coversheet Fax Body QA Standard 45K Fax Body Abbreviations: Radio Button Check Box Text Box Selection Box OPT FSP Property Page OPT FSP Property Page General Tab OPT FSP Property Page Advances Tab OPT FSP Property Page Logging Tab OPT FSP Property Page Alerts for Critical condition Test Case Specification Input Specification Output Specification Features Tested OPT-TCS-FSP401 Login with a valid Account ID. Send 1000 Faxes with a Coversheet only to your self one by one in a loop. 1000 Faxes will be delivered successfully OPT-TDS-FSP03 OPT-TDS-FSP04 OPT-TCS-FSP402 Login with a valid Account ID. Send 1000 Faxes with a Coversheet and Fax Body to a valid user within the ISP Network one by one in a loop. 1000 Faxes will be delivered successfully OPT-TDS-FSP03 OPT-TDS-FSP04 OPT-TCS-FSP403 Login with a valid Account ID. Send 1000 Faxes with a Coversheet and Fax Body to a Fax Machine via ISP Network one by one in a loop. 1000 Faxes will be delivered successfully OPT-TDS-FSP03 OPT-TDS-FSP04 OPT-TCS-FSP404 Login with a valid Account ID. Send 3000 Faxes with a Coversheet and Fax Body to a valid user within the ISP Network one by one in a loop. 3000 Faxes will be delivered successfully OPT-TDS-FSP03 OPT-TDS-FSP04 OPT-TCS-FSP405 Login with a valid Account ID. Send 5000 Faxes with a Coversheet and Fax Body to a valid user within the ISP Network one by one in a loop. 5000 Faxes will be delivered successfully OPT-TDS-FSP03 OPT-TDS-FSP04 TEST PROCEDURES PASS/FAIL CRITERIA All test cases are to produce expected results. Any deviation will be considered a failure, including failure of the backbone system to behave properly. (END DOC) EMBED Word.Picture.8 Test Plan Document DOC#: OPT-TDS-FSP400 REVISION:   KEYWORDS  \* MERGEFORMAT  PAGE  page  \* mergeformat  numpages  \* mergeformat  Copyright Open Port Technology, Inc.  All rights reserved.  May not be reproduced without permission.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\qfunctionalitytc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Titlemiris Normal.dot miris Microsoft Word 9.0-)#Dx Xtb>4 `Txy  6Gc|@QbjbjU Outbound queue functionality test cases Server Scheduling Beta2 features acceptation: no support of SCHEDULED_NOW Scheduling guidelines: There is no scheduling of parent jobs. The recipient s jobs are independent jobs and their scheduling is not effected from the fact that some recipients share a common father. Which means one should not observe execution of a broadcast job as unit but each recipient job is scheduled as a separated job.  Specific Time Submit a job initially scheduled to some time in the past. Expected: The job will be treated as if scheduled to current system time thus being scheduled for execution. Queue state:  There are jobs of type  Retried job scheduled to time T Job whose initial schedule time has arrived but the server did not attempt to execute it yet.        Submit a new job C scheduled to T - (.        Expected:        Job of type B will be executed before job C even though by the time a job of         Type B starts its actual execution it is past T - (.        Job of type C is executed before job of type A even though by the time the         Jobs is handled it is past time T.        Scenario: Submit the job C scheduled to the current system time.        Expected:        Job of type B will be executed before job C.         Job of type C is executed before job of type A only if T < the initial schedule Time of job C. The delay between retries is set to ( < (. Queue state:  There are jobs of type  Jobs scheduled to time T. The jobs are failing and will end in the retry state.        Submit a new job B scheduled to (.        Expected:        Job of type A will be executed before job B even though by the time a job of         Type B starts its actual execution it is past T + (.        Job of type A, which are in retry state will be retried before job of type B if         The retry schedule time is less then T + (.        Scenario: Submit the job B scheduled to the current system time.        Expected:        Job of type B will be executed before job A if initial schedule time of job B is Earlier than T.        Job of type A, which are in retry state will be retried after job of type B. Change system time while there are jobs in queue of type: in progress, retry state, pending. Expected: Jobs that are in progress are not affected but job which are failing will be rescheduled to execution time (according to new system time) + delay between retries. Pending jobs will not exchange the schedule time. Set the current system time of a client machine to time and time zone that is different form server machine. Submit a job form the client machine, initially scheduled to current system time. Will the server translate the client s schedule time to its current time? Expected: No. The job schedule time is not expressed in Coordinated Universal Time (UTC) (and we won t have the SCHEDULED_NOW feature). Set the current system time of a client machine to time and time zone that is different form server machine.  Open the client private outbox viewer & the general out box viewer (must be a client with appropriate permissions). Expected: The schedule time of jobs in queue does not match the client system clock. Which means the client will observe jobs which their schedule time has not arrived yet but are being executed and vice versa. This issue should be further tested. Also check fax printer time configuration parameters (such as discount period). Discount Period Set discount rate to some time in the future, submit a job initially scheduled to discount rate time. Change the discount rate time before the job is starting execution. Expected: Job will be executed during the new discount period. Set discount period to a range of 5 minutes. Configure device on machine to fail on send. Set number of retries to 2 and delay between retries to 10 minutes. Submit a job initially scheduled to discount rate time. The job will fail on first attempt. When it will be retried? Expected:  The job will be retried the next day, during the discount period (?). A similar scenario for pausing & resuming jobs initially scheduled to discount period is in PauseResumeTC.doc A similar scenario for pausing & resuming the queue while there are jobs initially scheduled to discount period is in this document under Pausing & Resuming the Queue. A similar scenario for blocking & resuming the queue while there are jobs initially scheduled to discount period is in this document under Blocking & Resuming the Queue. A similar scenario for resending a job initially scheduled to discount period will be present in appropriate document. Set discount period to a range of 2 minutes. Submit a job with many pages (over 100) and initially scheduled to discount rates time. Sending the fax lasts longer than the discount rates period. Expected: Job starts execution during the discount period and is completed even though the discount period for the day has ended. Change the system date, time and time zone while there are jobs scheduled to the discount period in queue. Expected: The discount period is not changing. Therefore if the new system time has passed the discount period for today, the pending jobs will not be executed. Set the discount range of an ~hour. Submit jobs schedules for a specific time, which falls in the discount period. Part of the jobs will fail & reach the retry state. Receive jobs during the period. Receive jobs, which will be routed and fail routing and retried. Expected:  The execution of those jobs should not be affected because of being executed in the discount period. Set discount rate to start in the same day and continue to the next day. Set delay between retries such that a failing job will be retried within the discount period, more exactly if the job starts at the same day it will be retried during the second part of the discount period, the next day. Submit a job initially scheduled to discount rate time that will fail.  Expected: First attempt to execute the job will be during the first discount period and the second attempt during the second part of the discount period. (Set the discount period to last the whole day. Submit jobs scheduled to discount period and jobs scheduled to specific time. Expected: Queue should behave as if all jobs are scheduled to specific time. The jobs that are initially scheduled to discount period are treated as scheduled for now. Pausing & Resuming the Queue Pause the queue. Stop and restart the fax service. Is the queue paused? Expected: Pause the queue. Reinstall the fax application. Is the queue paused? Expected: Pause the queue while it is in progress of receiving jobs. Does the process of receiving continue on? Expected: Select for the receiving device a routing method. Pause the queue while it is in progress of receiving jobs. Does the process of routing continue on? Expected: Select for the receiving device a routing method. Scenario: Make sure the routing will fail on First try only. Pause the queue after the routing first try fails and the job is in the retry state. Does the process of routing continue on? Expected: No (?) If the routing job is paused yes, resume the queue before/after schedule time of retry arrived. Expected: Before schedule time the job is pending, after schedule time the job is executed immediately. Queue state: There are jobs of type Retried job scheduled to time T Job whose initial schedule time has arrived but the server did not attempt to execute it yet. Job with canceled recipients. Job paused. Job in progress. Retried routing jobs scheduled to time P. Failed (maximum retried) routing and send jobs.       Pause the queue.       Submit a new broadcast job scheduled to current system time / some time in the future / some time in the past.       Resume the queue.       Expected:       New jobs submitted are queued but do not start execution.       Retrying / pending / paused / completed / failed are paused.       Jobs in progress will continue execution.       Retried routing jobs?        After resuming the queue job that were paused will continue execution according to schedule rules.        If the queue was resumed before time T the retried jobs will remain pending until time T.       If the queue is resumed after time T the retried jobs are executed (depends on devices  capabilities). Queue state: There are jobs of type Retried recipients of a client X. Maximum retries recipients of client X. Retried routing jobs to a client X (folder). Maximum retries routing jobs (folder)..       Pause the queue.       From the client machine, try to restart the retried jobs.       Expected:       Retried broadcast jobs are not restarted.       Maximum retries broadcast jobs are not restarted.       Retried routing jobs & Maximum retries routing jobs are restarted. Set discount rate to some time in the future, submit jobs initially scheduled to discount period. Scenario: Pause the queue before the discount period and let it paused only part of the discount period. Resume before end of discount period.       Expected:       The service will start execution of the jobs. But if there are too many jobs and  The service will not terminate to execute all of them the remaining jobs will be executed the next day in the discount period. Scenario: Pause the queue before the discount period and let it be paused the whole period. Resume after discount period of the same day.       Expected:      The jobs are not executed. They will be executed in the discount period the next day. Overflow queue quota by stressing with many failing fax requests. Pause the queue. Send many faxes. Resume the queue. Expected: All the sent jobs are not accepted and are lot. There should be appropriate notification to client and administrator in log file and better as a pop up screen. Administrator should be notified when queue usage is very close to its quota.  Submit some multi-recipients jobs. Pause the queue. Scenario: Pause a parent job and a recipient job while pending. Pause from client & server machine. Resume the queue. Are the paused jobs remains paused after resuming the queue? Expected: Scenario: Pause a parent job and a recipient job while in retry state. Pause from client & server machine. Resume the queue. Are the paused jobs remains paused after resuming the queue? Expected: Submit some multi-recipients jobs. Pause the queue. Cancel a parent job and a recipient job. Cancel from client machine & server machine. Resume the queue. Are the canceled jobs are canceled after resuming the queue? Expected: Queue state: as described in scenario 6. Pause the queue. Change system time, day and time zone. Resume the queue. Expected: Dirty days Send a fax that will fail with days to keep set to 0, a reasonable days amount, and to max value. Expected:  What is the meaning of 0 dirty days? The fax is kept in queue for dirty days as set. Set days to keep in queue to 1.  Set delay between retries to over a day, say 2 days. Set number of retries to 2. Send a fax that will fail. Is the fax kept in queue? Expected:  Yes. The dirty days in queue should be counted start from job s failure.  Set days to keep in queue to 1. Set number of retries to a bi number and delay between retry to be very long. Send a single recipient (try it with parent with multi-recipients and one selected) job, which fail for every retry and will end in maximum retries state. Just before end of a day since the job ended in the failed state, resend it. Expected:  Job is sent and retried and is not deleted from queue. Send a fax with more then a recipient. Pause the recipient. Set days to keep set to 0, a reasonable days amount, and to max value. Expected: The job is kept in queue and is not deleted (nor its parent) after dirty days. Submit some fax jobs, which part will end in retry state, maximum retries and completed. Set days to keep set to 0, a reasonable days amount, and to max value. Pause the queue in different parent jobs states. Expected: Parent jobs with recipients in progress, which will not be paused and eventually will fail, will stay in queue for dirty days. Parent jobs with recipients that were pending/ retying will stay in queue. Parent jobs with all recipients in one of the states completed or failed will be deleted from queue. There are failed jobs in queue, which are already kept in queue for dirty days (or dirty days  Stop the service. Restart the service after more than a day. Expected: The jobs, which are kept in queue for over dirty days, are deleted. Blocking & Resuming the Queue New feature.   Y2K YY2K   Y2K YY2K   Y2K YY2K
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\osupgrade_spec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0+!1yJfOS Upgrade Test Specification   Revision 0.1 Preface The goal of this set of tests is to verify that CometFax correctly survives OS upgrade. Test Strategy Setup. We will enhance our setup test tools to include specific tests for BOS \ SBS upgrade setup scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5 Issues Currently it is not clear which upgrade scenarios of SBS we can commit to supporting. Thus the  Upgrade  section below should be considered as an initial assessment. Revision Information Revision Author Description 22-Nov-99 Sigalit Bar Initial version Test Categories  Server OS Upgrade paths SBS 4.5 Server (on NT4) -> NT5 -> SBS 5.0 BOS 4.5 Server (on NT4) -> NT5 -> BOS 5.0 SBS 4.5 Server (on NT4) -> SBS 5.0 (on NT5) BOS 4.5 Server (on NT4) -> BOS 5.0 (on NT5) SBS 4.5 Server (on NT4) -> BOS 4.5 Server (on NT4 & has SBS fax) -> BOS 5.0 (on NT5) Client OS Upgrade paths SBS 4.5 clients (on NT4) -> NT 5 -> SBS 5.0 (on NT5)  SBS 4.5 clients (on Win9x) -> NT 5 -> SBS 5.0 (on NT5) This one is going to be tricky because when you upgrade SBS 4.5 client to Win2K, fax (and modem sharing?) can be rendered broken.   BOS 4.5 clients (on NT4 no Fax) -> NT 5 -> BOS 5.0 (on NT5) BOS 4.5 clients (on Win9x no Fax) -> NT 5 -> BOS 5.0 (on NT5)  BOS 4.5 clients (on NT4 has Fax) -> NT 5 -> BOS 5.0 (on NT5) BOS 4.5 clients (on Win9x has Fax) -> NT 5 -> BOS 5.0 (on NT5)  SBS 5.0 clients (on NT4) -> NT5 ? SBS 5.0 clients (on Win9x) -> NT5 ? BOS 5.0 clients (on NT4) -> NT5 ? BOS 5.0 clients (on Win9x) -> NT5 ? SBS 5.0 clients (on Win9x) -> Millenium ? BOS 5.0 clients (on Win9x) -> Millenium ? Server Upgrade Migration of server cover page files. Migration of archived faxes (sent and received). Migration of device settings. Migration of FSPs. Migration of Routing Extensions. Migration of Outbound Routing Rules. Migration of Dialing properties (?) Queue persistance (?) Client Upgrade Migration of personal cover page files. Migration of user information. Migration of last Send Fax Wizard settings. OS Upgrade Test Specification Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  22-Nov-99 {me]UME=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\opt-tds-fsp03.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Open Port Technology, Inc. FSP_Microssoft_Testplan Title _PID_GUIDFSP_Microssoft_Testplan Muhammad Mutahir Normal.dot Muhammad Mutahir Microsoft Word 8.0@Printer 3 Direct Ne00: winspool HP LaserJet 4/4M Plus PS 600 Printer 3 Direct Letter Printer 3 Direct LetterLb{2. CJ5'*' VUzR%E [t#/rK <KY,y _>C]V= f0U+tI GU3Zk /B</| IO8xXU *nBYo xCc1\ Y[qzB H4I^sl A?&,3Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKMicrosoft Word Times New Roman Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95Microsoft Word Picture MSWordDoc Word.Picture.6Microsoft Word Times New Roman AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqKOpen Port Technology, Inc.Authorized User Normal.dot Authorized User Microsoft Word for Windows 95AYcfQhQO}F vVQdJZZJwQmnf] CT\vvpv\Wic] vSZFHaeIsv BF~kv ][pvG AHKaZFX JK~Ka`] `cSovozxa Xagmvpvv A_KfqydbZFAB Pl\vvthw ]HadqkriqOK HKQmpvpvolThQffOeOfyIzln\v \nyZA A_EdyikVslkiQOdKaZA} YJfVv CY}xhTmvp vosTyc AFJeqTmovv hnVlkkkkUlVsn[\v GJcLOfffOxca v\my|B DovvTA]` dcKaGD \sSQyQiV\ GLj[\u\mqK Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized User EMBED Word.Picture.6   Normal Default Paragraph Font @Engineering - Printer 3 \\lmnosferatu\printer3_1 PSCRIPT Engineering - Printer 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Engineering - Printer 3 Custom page 1 Custom page 2 Custom page 3 Times New Roman Symbol Arial Authorized User Authorized UserOpen Port Technology Quality Assurance Group TEST DESIGN SPECIFICATION OPT-TDS-FSP03 FSP Microsoft Revision   KEYWORDS  \* MERGEFORMAT  Authors: Muhammad Mutahir Original: September 23, 1998 Revised: File: FSP_Mirosoft_TestPlan.doc Printed: APPROVALS TITLE SIGNATURE: DATE: Manager of Quality Assurance VP of Engineering This document is confidential and proprietary and is the exclusive property of Open Port Technology, Inc. This document is unpublished and is protected by copyright and trade secret laws. This document has been provided for review by the recipient only. Any other reproduction or distribution of this document without the express written consent of Open Port Technology, Inc. is strictly prohibited. RECORD OF REVISIONS ORIGINATOR: REVISED SECTION/PARAGRAPH:  REVISION LEVEL: RELEASE DATE: Initial Revision 09/30/98 Printed on  date \@ "MMMM d, yyyy" October 5, 1998 3:48 PM File Name = develop/sys2: dev/nas/nmg/projfld/<???>/fs.doc Table of Contents  TOC \o "1-1"  1. TEST SPECIFICATION IDENTIFIER  GOTOBUTTON _Toc381699905    PAGEREF _Toc381699905  2. DOCUMENTS REFERENCED  GOTOBUTTON _Toc381699906    PAGEREF _Toc381699906  3. FEATURES TESTED  GOTOBUTTON _Toc381699908    PAGEREF _Toc381699908  5. teST CASES  GOTOBUTTON _Toc381699909    PAGEREF _Toc381699909  5. teST PROCEDURES  GOTOBUTTON _Toc381699910    PAGEREF _Toc381699910  6. PASS/FAIL CRITERIA  GOTOBUTTON _Toc381699919    PAGEREF _Toc381699919  Test SPECIFICATION Identifier OPT-STP-FSP03 ReferenceD dOCUMENT This document is prepared according to the guidelines in IEEE Std 829-1983  IEEE Standard for Software Test Documentation [1] Open Port Technology s Fax Service Provider (FSP) Market Requirement Document for Microsoft   Omey Nandyal and Jennifer Schuster 08/26/98. Features Tested This test plan is intended to exercise the functions of the Microsoft FSP Deliverables and verify that it behaves as specified in the document IN ref[1]. Summary Getting MFS User Defaults In order to make any necessary changes or to view an End User Defaults (End Users  Personal Defaults for Fax Transmission) an FSP Administration will be able to get the desired information from the MFS upon request.  The Administrator will make a function call to accomplish this task.  FSP Administrator will make several of these function calls for proper functionality check.  Negative function calls will also be made for proper error notification. Please note that the Getting of Defaults also include Getting information such as Number of Retries, Maximum Retries, Fax Header, and the option whether to use Fax Header or not.   IGAPI/FSP-API. Setting MFS Defaults A function call will enable FSP Administrator to set the MFS Account Default in the FSP Network.  A number of function calls with various settings for a particular user will help testing this functionality of the FSP.   This test should not involve any fax send to the FSP Network.  Please note that the Setting of Defaults also include Setting information such as Retries, Maximum Retries, Fax Header, and the option whether to use Fax Header or not. IGAPI/FSP-API. Sending Fax A send function without any particular format will direct An MFS issued Fax to its destination via FSP Network.  Different methods and routes will be used to test the Send Functionality of the FSP. Please note that a Fax can only be sent with the following information at hand: Number of Recipients, Fax Body, Coversheet, and/or attachments.  MFS currently does not support Broadcast Faxes.  Faxes that are bound to more than one recipients are called Broadcast Faxes.  Assembly of faxes is done at the MFC level with TIFF Group 3 format.  FSP will make sure to keep the integrity of fax when issuing Send Fax call.  Quality and Integrity of the Faxes will be maintained and will thoroughly be tested by gradually increasing the load in the FSP system. Receiving Faxes Note: At this time I am unaware of the protocol with which MFS would like to Receive the Faxes from FSP Network.  There are two ways with which MSF can download Faxes from the ISP Network.  FSP can download all Faxes at once or it can download a list of Faxes in the server and then down load the actual Faxes associated with each listed Faxes in the list one at time. Depending on the method with which  MFS will download Faxes from the ISP Network appropriate test mechanism will be used.  Load testing will also be performed with either of the methods adopted by MSF. IGAPI/FSP-API. # OF TEST CASES # OF POSITIVE TEST CASES # OF NEGATIVE TEST CASES Feature Matrix Feature Identifier Title Description Requirement Reference OPT-TDS-FSP01 FSP backbone Provisioning Verification of ISP Server, Port Number, Account Ids, Realm, password etc. OPT-TDS-FSP02 Basic Functionality Logins, Logouts, sessions etc. OPT-TDS-FSP03 Fax Transport Sending, Receiving, Statusing of Faxes. etc.  OPT-TDS-FSP04 Load Testing Sending Thousands of Faxes through the FSP. Features Not Tested Test Approach Test CASES Definitions: Valid user A user recognized by the FSP Invalid user A user not recognized by the FSP Destination A valid Account ID in the target FSP Coversheet QA Standard Coversheet Fax Body QA Standard 45K Fax Body Abbreviations: Radio Button Check Box Text Box Selection Box OPT FSP Property Page OPT FSP Property Page General Tab OPT FSP Property Page Advances Tab OPT FSP Property Page Logging Tab OPT FSP Property Page Alerts for Critical condition Test Case Specification Input Specification Output Specification Features Tested OPT-TCS-FSP301 Login with a valid Account.   Send a Fax with a Coversheet Only to a valid user within the same ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP302 Login with a valid Account.   Send a Fax with a coversheet Only to yourself. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP303 Login with a valid Account.   Send a Fax with a Coversheet Only to a Fax Machine via ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP304 Login with a valid Account.   Send a Fax with a Coversheet Only to an invalid user. Send Failure. OPT-TDS-FSP03 OPT-TCS-FSP305 Send a Fax from a Fax Machine with a Coversheet Only to a user in ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP306 Login with a valid Account.   Send a Fax with a Fax Body Only to a valid user within the same ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP307 Login with a valid Account.   Send a Fax with a Fax Body Only to yourself. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP308 Login with a valid Account.   Send a Fax with a Fax Body Only to a Fax Machine via ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP309 Login with a valid Account.   Send a Fax with a Fax Body Only to an invalid user. Send Failure. OPT-TDS-FSP03 OPT-TCS-FSP310 Send a Fax from a Fax Machine with a Fax Body Only to a user in ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP311 Login with a valid Account.   Send a Fax with a Coversheet and Fax Body to a valid user within the same ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP312 Login with a valid Account.   Send a Fax with a Coversheet and Fax Body to yourself. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP313 Login with a valid Account.   Send a Fax with a Coversheet and Fax Body to a Fax Machine via ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP314 Login with a valid Account.   Send a Fax with a Coversheet and Fax Body to an invalid user. Send Failure. OPT-TDS-FSP03 OPT-TCS-FSP315 Send a Fax from a Fax Machine with a Coversheet and Fax Body to a user in ISP Network. Send Successful. OPT-TDS-FSP03 OPT-TCS-FSP316 Login with a valid Account.   ReceiveFaxes() will be executed according to the Polling Interval settings under PPGA.  Fax Message ID numbers can identify individual faxes. All Faxes in the ISP Network will be received at once. OPT-TDS-FSP03 OPT-TCS-FSP317 Login with a valid Account.   Send a Fax with a Coversheet and Fax Body to a valid user within the same ISP Network.   Execute GetFaxStatus() using Fax Message ID number. Fax Status information will be returned.   FSP Administrations transaction log can be used for details. OPT-TDS-FSP03 OPT-TCS-FSP318 Login with a valid Account. Send a Fax with a Coversheet and Fax Body to valid user within the same ISP Network. Execute GetFaxStatus() using an invalid Fax Message ID number. Status Error will be returned.   Message ID not Found FSP Administrations transaction log can be used for details. OPT-TDS-FSP03 OPT-TCS-FSP319 Login with a valid Account. Send a Fax with a Coversheet and Fax Body to an invalid user within the same ISP Network. Look for Received Faxes at the polling specific time interval. No Faxes will be received. OPT-TDS-FSP03 OPT-TCS-FSP320 Login with a valid Account. Send a Fax with an invalid Coversheet and Fax Body to valid user within the same ISP Network.   Fax will not be submitted to the ISP Network. OPT-TDS-FSP03 TEST PROCEDURES PASS/FAIL CRITERIA All test cases are to produce expected results. Any deviation will be considered a failure, including failure of the backbone system to behave properly. (END DOC) EMBED Word.Picture.8 Test Plan Document DOC#: OPT-TDS-FSP300 REVISION:   KEYWORDS  \* MERGEFORMAT  PAGE  page  \* mergeformat  numpages  \* mergeformat  Copyright Open Port Technology, Inc.  All rights reserved.  May not be reproduced without permission.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\outroute_spec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0+!1yJf !2:fr3:f@3:f"Outbound Routing Test Specification   Revision 0.1 Preface The goal of this set of tests is to verify that CometFax performs outbound routing correctly. This includes: Configuration of device groups and rules. Assignment (routing) of outbound jobs to the appropriate groups and devices. Test Strategy We will completely automate the  Job Assignment  tests, utilizing our  Client Stress Manager EFSPI Framework  and the  C API Test Framework  tools. C API Test Framework  will be used to drive the service to send faxes, implementing specific test scenarios, and the  Client Stress Manager  will be used to bombard the service with calls to randomly selected area \ country codes. The idea is to use the  smart  EFSPs of the  EFSPI Framework  to verify that every device receives jobs with recipient phone numbers according to the Outbound Routing Policy.  Configuration  tests will be performed manually, using the CometFax Admin UI, with manual verification that relevant registry entries are changes accordingly. Issues The propagation of error information from the EFSPs to the test managers will be via the job status notification mechanism.  A proprietary job status code will be defined to indicate  received phone number not according to policy , thus indicating test case failure. In order to convey the  inappropriate  recipient phone number an FSP will set the FaxDevStatus.CSI field when posting this status, and an EFSP will set the FSPI_JOB_STATUS.lpwstrCallerId field. Implementation Strategy Enhance the  Client Stress Manager  to randomly select area and country codes from a given list. Enhance the  EFSPI Platform  to verify recipient phone numbers against a list of area and country codes. Revision Information Revision Author Description 5-Oct-99 Miriam Scortzario Sigalit Bar Initial version Test Categories  Configuration Device Group Empty group, group with single device, group with all devices. Overlapping groups, foreign groups. Only the default group. Group with devices from several different FSPs. Group containing some but not all of the FSP devices. Rules Only the default rules exist. Different combination of international and domestic rules. Mapping form different area \ country codes to the same device group. For further details regarding creating \ deleting \ changing the device groups and the outbound routing rules, refer to the  Admin UI Test Specification Job Assignment Default Rules Verify that a domestic call with an area code that doesn t match any existing rule (falls into the default domestic rules category) is carried out. Verify that an international call with a country code that doesn t match any existing rule (falls into the default international rules category) is carried out. Verify that a domestic/international call that match an existing rule that can not be carried out (devices are not send enabled, not responding etc.) is directed to the all devices group. Device Priority within a Group Send several jobs concurrently with the same area code, verify they are directed to the same group and assigned to devices according to device s priority. When all devices in the group are busy and can not handle a new outbound job, the job will remain in pending state until one of the devices in the group becomes available (the job will not be directed to another group). Broadcast Send a broadcast job with all recipients of the same area code and verify they are all directed to the same group. Send a broadcast job with recipients from different area codes and verify each is directed to the appropriate group. Dialing Location The local area code and local country code used to determine whether the call is domestic or international are defined according to the server s dialing location settings (and not the client Stress Send multiple broadcasts with variant number of recipients, to variant area \ country codes, concurrently. Outbound Routing Test Specification Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  6-Oct-99 zupkgb] zrje`[M
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\qfunctionalityspec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Sent Items Queue Functionality Specification TitleSent Items Queue Functionality Specification miris Normal.dot miris Microsoft Word 9.0eDvJ"ibjbjU Outbound Queue Functionality Specification Preface This document describes the tests cases that we will run in order to test the outbound queue functionality. Specific test cases regarding the UI view and UI functionality aspects of the outbound queue are detailed in the document ClientUISpec.doc. Test Strategy Ad-hoc. Enhancing the existing automation tools:  Service Monitor  tool and the C APIs test framework. Implementation Strategy Enhancing the  Service Monitor  tool to support  Monitoring broadcast jobs The new job Status States model. Monitoring job s execution according to schedule rules. Enhance the C APIs framework to support controlling the queue state and new Job Status model.  Test Categories Guidelines: All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). Every test case below must be invoked using the public C APIs and when possible using the Print mechanism and the client UI. The following test cases are detailed and listed in the document: QfunctionalityTC.doc Scheduling Rules. Scenarios should be designed to consider the following parameters:   states: Jobs in progress. Paused. Retry state. Canceled.  initial schedule: Scheduled to a specific time. Scheduled to some time in the past. Scheduled to a specific time in the future. Scheduled to the discount period. Queue state: Resuming the queue after it was paused. Unblocking the queue. Stopping and restarting the service. Scheduling parameters such as: Retry delay. Discount rate. Dirty day. More scenarios considering outbound routing rules, group device priority and FSPs capabilities are detailed in the document OutRoute_spec.doc. Queue s settings  Number of retries. Retries delay. Dirty days Queue s state Pausing & Resuming the Queue. Blocking & Resuming the Queue. Queue s state after stopping and restarting the service. The following test categories need more detailed test cases specification: Invoking client operations while jobs are in the queue. Cancel a recipient job Cancel a broadcast job. Print a job. Pause and resume a job. Retry a job. Tests under extreme conditions No disk space. Low memory conditions. Huge number of jobs in the queue. Stressing the queue with many jobs submitted and client operations invoked simultaneously. State of jobs in queue. Verify jobs  state and all state dependent operations on job, follows the state s diagram and the spec. Verify jobs are archived to the sent items queue according to archiving rules and job s state. Security issues. Specified in SecuritySpec.doc. Queue s directory operations. Deleting the directory while there are jobs in the queue. Setting a different directory while queue is paused or blocked. Setting a different directory while queue is active. Renaming the directory.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\ri_candidate.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft I'm composing an RI testing ToDo list which we will run as an RI verifier TitleI'm composing an RI testing ToDo list which we will run as an RI verifier Guy Merin Normal.dot MiriS Microsoft Word 9.0SI4VZbjbjU RI Test verification The following Spec describes a checklist of ToDo items that should be used as verification to an RI Whistler Build. This checklist is not a test cycle (that is done in Haifa prior and post an RI checkin). This is a checklist of critical tests that are used to verify that the RI build is good; the cycle should be as short as possible and should try to cover as many DLL as possible (the idea is to  touch  every DLL). Clean build Prepare the machine to test on Unplug the modems from it. Install the RI candidate build (select a clean installation). Run the following scenarios: CD Layout: Verify the following directories contains fax bits: System32: fax binaries Help: Fax help files (currently there're 4 help files on desktop SKUs and 7 files on server SKUs) Setup: FxsOcm.dll and FxsOcm.inf Verify fax files have the correct version (build number and CHK/FRE), this can be done using FileVer tool. Client console: Verify first invocation launches the Configuration wizard. Invoke the printer properties UI through the client console. Invoke the fax monitor through the client console. On Server SKUs: invoke the MMC admin through the client console. Invoke the send wizard through the client console. Once you have jobs, try to delete / view these jobs, do this on all 4 folders.  Click the  Answer now  icon. Verify the enabled device is opening the line attempting to receive a call. Invoke help through F1. Verify context sensitive help is ok (Using the "?" button). Fax printer: Verify Fax printer is installed. Double click the fax printer and verify client console is invoked. Select a fax device, enable send and receive.  On Server SKUs verify that the results are shown correctly in the Fax MMC snap-in. On a receiving device, select all routing methods.  On Server SKUs verify that the results are shown correctly in the Fax MMC snap-in. Change the archive directories;         On Server SKUs verify that the results are shown correctly in the Fax MMC snap-in. Try to share and unshare the fax printer (on desktop SKUs it should be unable to share the fax). On desktop SKUs: verify tracking options are enabled by default (when there are installed devices). On server SKUs: verify that tracking options are not enabled by default. Invoke help through F1. Verify context sensitive help is ok (Using the "?" button). Fax MMC snap-in: Select a fax device, enable send and receive, verify that the results are shown correctly in the Fax printer properties. On a receiving device, select all routing methods; verify that the results are shown correctly in the Fax printer properties. Change the archive directories; verify that the results are shown correctly in the Fax printer properties. Select a Modem device and verify its properties have a T30 Tab added. Verify the MS Routing Methods have added tabs. Invoke the client console through the MMC admin. Fax->Properties: browse through all tabs and play around, verify the layout is good, and that you can select and unselect the various settings. Verify you can open all nodes and sub nodes.  Send wizard: Verify you can send a fax using a dialing rule and using "dial as entered", verify jobs are queued. Try to add more than one recipient. Invoke the preview; see that the Image viewer is invoked. Try to set User info on a specific job. Invoke help through F1. Verify context sensitive help is ok (Using the "?" button). Coverpage editor: Try to open and save a coverpage, verify that cov files are associated correctly. Compose a coverpage and save it. Invoke help through F1. Verify context sensitive help is ok (Using the "?" button). Configuration wizard: Try to set all fields. Invoke the configuration wizard again and verify user info is saved correctly. Fax Monitor: On server SKUs, configure the tracking options via the printer properties UI. Send a fax. The fax monitor should appear on the sys tray, open the monitor dialog. While the fax is in progress of sending, click the  Disconnect  button. Send a fax. When fax is sent successfully the monitor should show a balloon with appropriate message. When double clicking the monitor, it should launch the client console with sent archives as selected view. Receive a fax. The monitor should ring and display an appropriate balloon when the fax is received successfully.  When double clicking the monitor, it should launch the client console with incoming or inbox folder as selected view.  Apply the monitor button  Answer now . Verify the enabled device is opening the line attempting to receive a call. Other system components: Image viewer: Verify tiff files are associated to Image viewer. Verify you can open a tiff file and that the fax looks ok. Spooler: Using notepad, print a file to our fax printer, try with and without a coverpage, verify the jobs are queued. Tapi: Install a modem; verify the modem is shown as a fax device in the MMC admin. Uninstall Fax, and all the modems, delete all dialing rules, and then install fax again, invoke the client console, you get a prompt to  add a dialing rule Delete the fax printer, install a modem, and verify a fax printer is installed. This feature is in question but if it's there then do the following: uninstall fax and then install a modem, you get a popup: "Do you want to install fax", click Yes and verify fax is installed, click no and verify fax is not installed. Shell: Select a tiff file and hit properties, verify you see correct fax attributes. Mapi spooler: Using outlook try sending a fax, select a recipient from the address book, and supply one on your own, try to open the Outlook Fax extension through Tools->Fax properties (note this is a 2nd priority test). Run the BVT. Stop and Start the service. Security Run some tests (send / view queue / view MMC) from user that is not an Admin on the machine (on service machine). Client - Server test verification: Install a whistler server machine. Share the local printer of the server machine. Install another whistler server/personal machine. Add the fax component. Logon as a client that is not an administrator on the server s machine. Add printer connection to the server s fax printer. Fax printer: Verify the remote Fax printer is installed. Double click the fax printer and verify client console is invoked. Client console: Verify you can see the status of both printers. Invoke the send wizard through the client console. Send a fax to the remote fax printer. Once you have jobs, try to delete / view these jobs, on outbox and sent items folders. Send wizard: Select the remote fax server based cover page, which is different from the cover pages locally installed. Invoke the preview; see that the Image viewer is invoked. Other system components: Spooler: Using notepad, print a file to the remote fax printer, try with and without a cover page, verify, using the client console, the jobs are queued and you can perform actions on them. Mapi spooler: Using outlook try sending a fax to the remote printer, select a recipient from the address book, and supply one on your own, try to open the Outlook Fax extension through Tools->Fax properties (note this is a 2nd priority test). Security Verify you do not see your faxes in the incoming and the inbox folders. From the server machine send a fax. Verify, on the client machine, you don t see the fax queued in the outbox and in the sent items folder. Run the BVT. Upgrade build Prior to upgrading, install fax, supply user info and start the OS upgrade. In General run a small set of the above. Verify user info, device state, and other server properties are persistent. Verify coverpage are not deleted (add a server coverpage prior to the upgrade). Run the BVT.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\scalespec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server Title _PID_GUIDCover Page Rendering On Server Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0Fax Scale Test Specification: Preface  The following document specifies the scale tests we will run. All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on different machines (where client is NT5 \ Win9x \ NT4). Test Strategy: We recognize 2 main categories of scale  Client   Server scale. Providers   Server scale (i.e. EFSPs and Inbound Routing Extensions on server). To cover the above we will use two separate environments, the Self-Host and a  Scale Lab The lab will be used to test different configurations of clients (e.g. clients of all platforms) and different configurations of providers on the server. Using enhanced (DCOM) versions of existent tools, perform simultaneous and concurrent fax operations (sending \ receiving \ aborting \ etc.) from many clients. Issues: Define best realistic  Scale Lab  configuration, and resources allocated for lab. Our current plan includes 10 client machines, each simulating about 30 concurrent client sessions (based on BOS demand for 300 client scale). We are still unclear about  What the ratio between NT5, NT4, Win95 and Win98 clients should be? How many modems or boards should be installed on server and of what kind (transmission rates)? What are the specifications for the server machine? What network and what other network flow? Any concurrent inbound fax rate requirements? Implementation Strategy: Implementation will be incremental. Set up lab. Implement a  Logon and Invoke  tool that logs-on as a given user and invokes a given application. The tool will also include a synchronization mechanism that will allow us to  launch  several applications (logged-on under different users and on different machines) simultaneously. Activation with minimal verification. Use existing tools (e.g. SendBroadcastFax, StressTool, qFax and AbortTest) as the application that the  Logon and Invoke  tool will invoke, to continuously invoke actions from different clients of the same server. While doing so run Micky Service Monitor  tool on the server. Better Verification. Reconstruct BVT to use DCOM to allow simultaneously invoking BVT on all client machines in configuration. Continuously invoke BVT on all clients (over and over). To allow for different Server configurations  Create different EFSPs and Inbound Routing Extensions, based upon Sigalit s VFSP and the existent MS Inbound Routing Extension. Above DLLs will take a single parameter for installation   an ini file that includes the number of devices \ methods the DLL supports and any needed unique ids (such as registry entries  image name friendly name device prefix ). Thus DLLs will be able to install themselves in different configurations (as described by the ini file). Automate Server setup. Implement a tool (using batch files?) that installs different configurations of our EFSPs and Inbound Routing Extensions. E.g. when tool is invoked with parameter 1, the tool will install 10 EFSPs (each having 25 devices) and 4 routing extensions (each having 4 routing methods). Use the Client Stress Manager to implement client invocation (send faxes and perform action on jobs) stress and enhance it to use DCOM model. Test Categories: Many T.30 devices on server. Many kinds of modems. Many modem boards on server. Many FOIP configurations. Many kinds of EFSPs installed on server. Each having many devices. Many installed Inbound Routing Extensions. Each having many Routing Methods. * We can simply  duplicate  the MS Routing Ext. using different names for registry entries and methods. Many clients for the same server. From different platforms. A client with many SBS Fax printers. Many Server \ Personal cover pages (?) Many simultaneous RPC connections. Many jobs on queue simultaneously. Many processes sending faxes simultaneously \ concurrently (using APIs \ Print architecture). Including very widespread broadcasts. Connection. * Many clients connecting \ connected to server simultaneously.  * Many clients disconnecting from server simultaneously. Receive many simultaneous \ concurrent faxes. Actions on many jobs simultaneously \ concurrently. Cancel \  Delete \ Pause \ Resume \ Restart. * Check invocation via simultaneous API calls and via multiple selection from GUI. * Check many clients, each performing actions on many jobs. Administration. Investigate usability and completeness of administration GUI and APIs in a large-scale system. Outbound Routing Rules. Many routing rules. At least one for every EFSP. * Any limitation to number of routing rules? Pause and resume the sent items queue while many clients are sending faxes \ many client operations Are invoked on the jobs. Same for blocking and restarting the sent items queue. Stopping and restarting the service while many clients connecting\ connected to the Server simultaneously. Stopping and restarting the service while many jobs are in queue \ many client operations Are invoked on the jobs. Same for crashing the service: kill the service \ reboot the computer. Scale test parameters: Number of receive\send jobs on queue simultaneously. Number of EFSPs installed on server. Number of installed devices per EFSP. Number of send \ receive enabled devices per EFSP \ per Server. Device TSID and CSID settings. Number of Inbound Routing Extensions installed on server. Number of Routing methods installed per Routing Extension. Number of Routing methods enabled per device. A device s enabled Routing methods  settings. E.g. the  Store in directory  routing method directory  setting. Number of installed clients on server. Number of simultaneously connected clients per server. Number of simultaneously  active  (connected \ sending \ aborting \ etc.) clients per server. Number of installed SBS Fax printers on a single client. Number of  active  (connected \ sending \ aborting \ etc.) SBS Fax printers on a single client (with more than one SBS Fax printer installed). CometFax Scale Test Cases  TIME \@ "d-MMM-yy"  11-Nov-99 Microsoft Confidential Sigalit Bar (sigalitb) ~{xuog_WO {skc`]UROLI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\setuptc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server TitleCover Page Rendering On Server Sigalit Bar Normal.dot Guy Merin Microsoft Word 9.0bjbjU CometFax Setup Test Cases: Preface  All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). Test Strategy: Manually invoke setup and uninstall under different conditions and settings. After each such invocation run an automated check that verifies components were added \ removed. Perform a sanity check on CometFax and MSFax. Use a tool that takes snapshots of the registry and the file system, this tool can be used to verify that all added keys were removed during uninstall, verify successful roll-back, and verify that unneeded keys were not added. Issues: None. Implementation Strategy: Implementation will be incremental. Implement a tool that verifies correct install \ uninstall of CometFax Server. Tool will verify the following items were added / removed to / from the correct places, and with an appropriate version: CometFax printer. Server \ Personal Cover page files. Application directories (e.g. queue, default  Sent Faxes  and  Received Faxes Program group. Shortcuts (none today). Files. CPL applet. Registry entries. Folder shares (i.e. client installation share, CometFax, Fax$). The following components will be verified manually: CometFax MAPI Extension and Add-In. Kodak  Imaging Use a tool that can take a snapshot of the current registry and File-System, and can compare 2 given snapshots. Investigate automation for verification of other CometFax components (e.g. printer in  Printers  folder, Program group, etc.) Test Categories: Server Setup. Server Uninstall. Client Setup through server share. Client Setup through  Add Printer  in the Printers CPL applet. Client Uninstall through the added Comet Client group. Client Uninstall through the  Add Remove programs  CPL applet. Client Uninstall through the  Remove Printer  in the Printers CPL applet. Upgrade \ Clean.  Upgrade from previously SBS versions should copy all configuration and settings. MsFax Service integration Clean install when MSFax is installed (mostly the case). All device settings are copied from the MSFax service. Copy installed MSFax CPs. CometFax setup disables the MSFax service?  CometFax uninstall restores the previous MsFax settings (i.e. enables the service),[TBD]:should we rollback to the previous CoverPages? Residue files after uninstall. Residues in registry after uninstall. Previously installed applications. E.g.  Imaging  \ CPE already installed (version differences). State of related services at time of install / uninstall. E.g. spooler, MSFax etc. State of CometFax service at time of install / uninstall: All devices are IDLE. A device is in the Sending state. A device is in the SendRetry state. A device is in the Receiving state. A device is in the ReceiveRetry state. A device is in the Routing state. A device is in the RoutingRetry state. A device is in the Reestablish state. Verify all CometFax components are installed \ uninstalled correctly. CometFax printer. CometFax MAPI Extension and Add-In. Kodak  Imaging Server \ Personal Cover page files. Application directories (e.g. queue, default  Sent Faxes  and  Received Faxes Program group. Shortcuts (none today). Files (all EXEs, DLLs, help etc.) CPL applet (will be removed). Registry. Folder shares (i.e. client installation share, CometFax, Fax$). Installation of several CometFax printers on same Client machine (with \ without other Comet Client components). * What happens when printers have different DLL versions? All DLLs are installed to system32   DLL hell. Modem devices present at time of installation. Verify that all are correctly set-up in service. * Known issue   modem-dialing properties must be set or service will not be able to dial. Setup on a machine without modems / FSPs. Unattended setup and unattended uninstall. Setup test parameters: Custom installation options (with \ without other Comet components). Upgrade or clean install (option not available at this time). Reinstall. Add \ Remove components. Remove All (uninstall) from original \ local setup location. Cancel setup while installation is in progress. At GUI  Cancel  points. Using window s exit button (the X at top right corner). Using  End Process CometFax Setup Test Cases  TIME \@ "d-MMM-yy"  6-Oct-99 Microsoft Confidential Sigalit Bar (sigalitb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\srvrrender_spec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8FSP testing  Title _PID_GUIDFSP testing  Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0+!1yJf *:FD,:F;,:F"Server Side Rendering Test Specification   Revision 0.1 Preface The goal of this set of tests is to verify that any rendering done by the server is performed correctly.  This Includes: Rendering the cover pages of any jobs directed to FSPs. Rendering cover pages via the FaxRenderCoverPage() API. Note that correct rendering of cover pages relies upon the correct conveyance of the cover page template and the User information from the Comet Fax Client to the Server.  Test Strategy We will create an arsenal of cover page template files that will be used for  Server Side Rendering  tests. The tests will be packaged into three suites: Automated API test suite for FaxRenderCoverPage() API. Automated  SendDocument  test suite that will send faxes with cover pages via FaxSendDocumentEx() API, and verify the results. SendCoverPage  test suite that will send cover page faxes from Comet Fax client via the Comet Fax Send Wizard (fxssend.exe), and verify the results. We will not implement a test suite for sending faxes with cover pages from Comet Fax Clients via the printing mechanism, because this will be partially covered by the  Printing from Applications  tests. Since  Printing from Applications  does not provide complete coverage (it always uses the same cover page template) we will also Ad-Hoc printing documents with different cover pages. Issues Comet Fax server must be configured with Branding = FALSE to prevent printing of banner. The banner includes date and time, which will interfere with fax image verification ( TiffCompare Similarly the cover page templates should not contain date or time fields. Note that all the  Printing from Applications  tests will use the same cover page template (a template containing all non time-date fields), because it is too costly to integrate changing the cover page into the PCT suite.  So in fact, we will not be testing many different documents with many different cover page templates. For further details refer to the  Printing from Applications  test specification document. Implementation Strategy For every implemented test will we first verify the rendering results visually and save the TIFF file for future reference. Any subsequent runs will automatically use our existent  TiffCompare  tool to verify the test results against the reference. Implementation of the API testing and the  SendDocument  suite are straightforward.  We will implement a command line tool ( FakeRecipientConfig ) which will configure the registry entries related to the  FakeRecipient  registry hack (that prevents the pop-up of the Comet Fax Send Wizard). This tool will be used to set the recipient name, recipient number and the cover page that will be used when printing a fax (without invoking UI). SendCoverPage  suite will be implemented as a script. For every cover page we wish to test we will first use the  FakeRecipientConfig  tool to set the registry, then we will invoke the fxssend.exe to  print  the cover page, and finally we will use the  TiffCompare  to verify the resulting TIFF against the reference. We can change the User (Sender) information and re-run the  SendCoverPage  suite. Eventually we will automate this also. Revision Information Revision Author Description 5-Oct-99 Sigalit Bar Initial version Test Categories  FaxRenderCoverPage() API Tests Parameters lpctstrTargetFile file exists \ file doesn t exist \ file is read only \ is remote \ name of target file is longer than MAX_FILE_PATH \ NULL. lpCoverPageInfo.lpwstrCoverPageFileName file exists \ file doesn t exist \ file is read only \ is remote \ file is bad format \ NULL Strings are NULL \ empty \ very long. dwSizeOfStruct of structures is invalid. Cover pages Invoke API with every cover page template in our arsenal. Concurrency Invoke API from several threads (of same application) concurrently. Invoke API from several applications concurrently. Server state Invoke API while Comet Fax service is started \ stopped \ stopping \ starting. Clients Invoke API from Comet Fax Client machines on every platform. Invoke API from Comet Fax server machine. Cover Page Templates Fields Cover pages with no information fields \ duplicate fields. Paper Size Cover pages in all possible paper sizes. Pasting Cover pages with anything that can be pasted (bitmaps \ jpg \ clipart \ etc.). User (Sender) Information Fields All sender information fields are empty. Only one sender information field available. Sender information strings are very long. Multiple User Accounts on Machine Verify that when multiple user accounts exist on a Comet Fax Client machine, the information to appear on the cover page  belongs  to the logged on user. Server Side Rendering Test Specification Page   PAGE   NUMPAGES  MS Confidential Sigalit Bar (sigalitb),   TIME \@ "d-MMM-yy"  5-Oct-99 {skc[XU }xrjb\WQ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\suggestnewfeatures.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Suggestions for new features Title _PID_GUIDSuggestions for new features micky snir Normal.dot micky snir Microsoft Word 8.0Suggestions for new features Inbound routing (or whoever) should log the quality of the received fax (how many line errors, what baud, compression etc.) Do we send receipts for faxes that we receive? Is there a threshold for max num of errors when receiving a fax? Is there a command line send wizard?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\sp2 test plan2.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Windows 2000 Service Pack 2 Fax Test Plan Title _PID_HLINKSWindows 2000 Service Pack 2 Fax Test Plan Guy Merin Normal sigalitb Microsoft Word 9.0e(HZOJbjbjU Windows 2000 Fax Service Pack 2 Test Plan This document describes the Test cases and Test lab needed to test the Fax on Windows 2000 SP2. Since Fax didn t have any checkin or fix for this Service Pack, we need to verify that other components didn t break the fax service (for example: Tapi, RPC or kernel binaries). The idea behind the test plan is to  touch  each of the fax components and binaries. Each component will have a test case that is a  must run  and other test cases that should be ran if time permits. The test cases are sorted by priorities according to the key: Priority 1: A must run test. Tests major functionality of the component. Priority 2: If time permits test. Additional tests on a component, the component is generally functioning fine and running these tests will increase the component s coverage. Please note this document is a draft and is the base for W2K SP2 Beta testing, for the SP2 RTM we will have an additional test plan which will be based on many automatic test tools. Test Lab: The SP2 lab will have 8 machines, 4 English OS machines and 4 German OS machines. The configuration of the machine is as follows Priority 1 Machines: The below machine are for English OS and German OS (total 8 machines). W2K SP2 Professional: Target: W2K Professional with SP2. Upgrade from: Clean W2K Pro (No Sp installed). Upgrade method: Upgrade using SP2 share. W2K SP2 Server: Target: W2K Server with SP2. Upgrade from: W2K Server with SP1. Upgrade method: Upgrade using SP2 Setup.MSI. W2K SP2 Advanced Server: Target: W2K Advanced Server with SP2. Upgrade from: Not relevant. Upgrade method: Install using SP2 slipstream CD. W2K SP2 Data Center: Target: W2K DTC with SP2. Upgrade from: Clean W2K DTC (No Sp installed). Upgrade method: Upgrade using SP2 CD. Priority 2 Machines: CHK W2K SP2 Server: Target: Checked W2K Server with SP2. Upgrade from: Clean CHK W2K DTC (No Sp installed). Upgrade method: Upgrade using SP2 CD. Windows Powered: Target: W2K Advanced Server with SP2. Upgrade from: Not relevant. Upgrade method: Install using SP2 slipstream CD. Applications on each machine: The above machines need the following configuration: Ghosted prior to running the upgrade. Office installed (to run the Outlook test). Machines are on the corporate domain (to be able to have access to printers). IDW and MSTOOLS (to run FileVer and other tools). VC installed at least on the SRV machine. VB installed at least on the SRV machine. AutoCom test tool installed. Terminal Server installed. Test Areas: The test cases in this section should be run on all platforms (PRO, SRV, ADV, DTC). Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional applications installed: W2K BVT Test suite (written by W2K Fax team). Run the BVT and verify all test cases pass (priority: 1). The test cases in this section should be run on all platforms (PRO, SRV, ADV, DTC). Legacy C Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional applications installed: Legacy C test tool (written by W2K Fax team and maintained by  HYPERLINK "mailto:Liors?subject=Legacy C Test tool" LiorS ), the tool has 480 C Api test cases. Run the Legacy C test tool (priority: 1). Legacy COM Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional applications installed: Legacy COM BVT test tool (written by   HYPERLINK "mailto:Liors?subject=Legacy Com BVT Test tool"  LiorS ), the tool has 800 COM Api test cases. Run the Legacy COM test tool (priority: 1). Fax Verifier Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional applications installed: Legacy C test tool (written by W2K Fax team), the tool runs modem verifications and Adaptive answering tests. Run the Win2K Fax verifier test tool (priority: 1). Fax UI: MMC Admin Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. In the below tests we will want to verify the persistency of the various Fax properties, this can be achieved by restarting the MMC admin and by restarting the fax service and verifying that the properties are persistent.  Devices Node, General Tab: Change devices from receiving to sending and vice versa (priority: 1). Devices Node, General Tab: Change TSID and CSID of devices (priority: 2). Devices Node, General Tab: Change number of rings on receiving devices (priority: 2). Devices Node, Received Faxes Tab: When no printers are installed, verify that you cannot select any printer (priority: 2). Devices Node, Received Faxes Tab: Add an additional printer and see that it s added to the Printers list box (priority: 2). Devices Node, Received Faxes Tab: Choose the following directories in the Save in Folder edit Box: a UNC directory, a mapped directory a local directory (priority: 2). General: Verify that the Context sensitive help is invoked correctly, this can be invoked through the   button (priority: 1). General: Invoke help through F1 (priority: 1).  Logging Node: Change logging levels (priority: 2). Fax properties: Changed various settings (Retries, Minutes between retries, Days kept and send settings) (priority: 1). Fax properties: Change the Archive directory to a local folder (priority: 1). Fax properties: Change the Archive directory to a UNC folder (priority: 2). Fax properties: Change the Archive directory to a mapped folder (priority: 2). Fax properties: Change the discount rates (priority: 2). Fax properties: Change the service to run under a user account and verify the user s Mapi profile is shown in the Email profiles list (priority: 1). Fax properties, security Tab: Add and remove users, verify that the  add a user  dialog pops up correctly (priority: 1). Fax properties, security Tab: Add and remove a group of users, verify that the  add a user  dialog pops up correctly and that you can add a group (priority: 2). Fax properties, security Tab: Change an random user fax privileges, deny and grant access to it (priority: 1). Send Wizard Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. In the following test, invoke the Send Wizard through Notepad, and verify the fax is queued (no need to actually send the fax). Verify that first invocation of the Send Wizard pops up the dialog:  Edit user info details  (priority: 1). Recipients page: Verify that all dialing rules are present, add additional dialing rules and verify they re present (priority: 2). Recipients page: Verify country list is ok, see that you can scroll down the list and choose a random country (priority: 2). Recipients page: verify that the Address book button pops up the contacts list (priority: 1). Recipients page: Add a recipient and remove it (using the Add and Remove buttons) (priority: 2). Coverpages page: Send a fax without a coverpage (priority: 1). Add a new Coverpage and see that it s added to the list (priority: 2). Send a fax with a coverpage but don t supply a Subject and Note (priority: 2). Schedule page: Send a fax with any of the 3 Time To Send options (priority: 2). Summary page: Verify info is correct, user info, recipients etc (priority: 1). Queue viewer Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional setup required: Send a fax to the Device Y. Verify job status of sending and receiving job is OK (priority: 1). Verify Job Type is send, receive or routing (priority: 1). Verify number of pages is shown correctly in the Pages column (priority: 1). Verify Document name is shown correctly in the Document name column (priority: 1). Job properties: Verify sender and recipient info are correct (priority: 1). Job operations: Pause and resume a send job (priority: 1.5). Job operations: Delete a sending job while it s in a sending state (priority: 1.5). Job operations: Delete a receiving job while it s in a receiving state (priority: 1.5). Job actions: Select a fax and right click on it, verify that the actions are valid (for example you can t pause a sending job while it s in a transmitting state) (priority: 1). Verify that a job that is sent to a busy line is shown in the correct state (priority: 1). Verify that a job that is sent to a no answer line is shown in the correct state (priority: 1). Task bar icon Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed Right click on the Task bar icon -> invoke the fax monitor properties (priority: 1). Right click on the Task bar icon -> invoke the fax queue (priority: 1). Right click on the Task bar icon -> invoke  My faxes  folder and verify it s in  E:\Documents and Settings\All Users\Documents\My Faxes  (priority: 1). Left click on the Task bar icon -> Invoke the fax monitor (priority: 1). Fax Monitor Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional setup required: Send a fax to the Device Y. Verify job status of a sending and receiving job is OK (priority: 1). Verify that a job that is sent to a busy line is shown in the correct state (priority: 2). Verify that a job that is sent to a no answer line is shown in the correct state (priority: 2). End a fax call while it s in a transmitting / dialing state (priority: 2). (TBD: How is this done, on first device only?) Configure device Y to answer calls manually and not automatically, send a fax to Device Y and verify the answer button dialog pops up (priority: 1). (TBD: How is this done, on first device only?) Configure device Y to answer calls automatically and not manually, send a fax to Device Y and verify the fax is answered with  no questions asked  (priority: 1). Fax control Panel applet Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed Open the CPL and verify it contains 4 tabs: Users Info, Coverpages, Status monitor and advanced options  (priority: 1). User Info tab: Verify that old User info is migrated from W2K (priority: 1). Coverpages tab: Try to add a new coverpage and verify that the coverpage editor is invoked  (priority: 1). Coverpages tab: Try to add an existing coverpage and verify that the coverpage editor is invoked  (priority: 2). Coverpages tab: Try to open and delete and existing coverpage (priority: 2).  Status monitor Tab: Change the various settings and verify there re applied correctly (priority: 2). Advanced options Tab: Verify the various links are not broken (help is invoked, printer is created and Admin console is opened) (priority: 1). Fax Printer in Printers CPL. Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed Open the Printer Control panel applet and choose the fax printer -> Properties, verify that the Fax control panel is invoked (priority: 1). Open the Printer Control panel applet and choose the fax printer, double click on it and verify that the Fax queue is invoked (priority: 1). Printing from Applications Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: Office is installed Try to print to our fax printer from the various office applications (Word, Excel, PowerPoint and Outlook) (priority: 1 for printing from Word, Priority 2 for the rest). Try to print to our fax printer a graphical image (BMP, JPEG, GIFF) (priority: 2). Try to print to our fax printer a text file (through Notepad) (priority: 1). Outlook extension and Mapi transport Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: Outlook is installed and the Fax transport provider is added to the default Mapi profile. Send a mail to a fax recipient selected from the address book and has a fax number  (priority: 1). Send a mail to a fax recipient in the format: Mail To:   HYPERLINK "mailto:[fax:Name@Number]"  [fax:Name@Number]  (priority: 2). Send a mail to a DL with a fax and email recipients in it (priority: 2). Compose a mail to a fax recipient, resolve the recipients (CTRL K), invoke the fax properties (Through Message Menu->Tools->Fax options) verify that the dialog is invoked on fax recipients (priority: 1). Compose a mail to a non-fax recipient, resolve the recipients (CTRL K), invoke the fax properties (Through Message Menu->Tools->Fax options) verify that the dialog is not invoked on non-fax recipients (priority: 2). Add and remove the fax transport provider (through Outlook -> Tools -> Services -> Fax properties) (priority: 1). Invoke the fax transport properties and verify you can change the various settings (coverpage, fax printer, font) (priority: 2). Setup: Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 CDs and Shares On the below test cases, we will want to verify the installation succeeded by sending a fax and verifying it is queued and in a pending state. On a clean W2K machine install SP2 from an SP2 CD update (priority: 2). On a clean W2K machine install SP2 from an SP2 share (priority: 1). On a clean W2K machine install SP2 from an SP2 patch (priority: 2). On a clean W2K machine install SP2 from an SP2 Update.MSI file (priority: 2). On a clean W2K machine install SP2 from an SP2 Cabs file (priority: 2). On a W2K SP1 machine install SP2 from an SP2 CD update (priority: 2). On a W2K SP1 machine install SP2 from an SP2 share (priority: 1). On a W2K SP1 machine install SP2 from an SP2 patch (priority: 2). On a W2K SP1 machine install SP2 from an SP2 Update.MSI file (priority: 2). On a W2K SP1 machine install SP2 from an SP2 Cabs file (priority: 2). Install a full SP2 Slip stream (priority: 1). Binary verifications: Registry layout Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: Prior to the SP2 installation, export the fax registry key and save it. Export the fax registry key and run a WinDiff tool and verify no registry changes happened due to the SP2 upgrade (priority: 1). Run the same test case with a modem installed (priority: 1).  Symbols verify. Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 Slipstream. The test case is valid only for SP2 Slipstream; all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). Verify fax files have corresponding symbols files (priority: 1). File layout verifications Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 Slipstream. The test case is valid only for SP2 Slipstream; all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). Verify all fax files are present and installed in the correct folder (Winnt\system32) (priority: 1). File version verifications Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 Slipstream. The test case is valid only for SP2 Slipstream; all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). Verify all fax binaries have the correct file version (depended on the build) (priority: 1). MS Routing Extensions Store to folder Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Configure Device Y to store faxes in a local folder (for example: c:\MyFaxes), send a fax to device Y and verify the received fax is located in the configured folder (priority: 1). Configure Device Y to store faxes in a UNC folder (for example: \\ServerName\ShareName\MyFaxes), send a fax to device Y and verify the received fax is located in the configured folder (priority: 2). Configure Device Y to store faxes in a mapped folder (for example: map drive I to \\ServerName\ShareName\MyFaxes), send a fax to device Y and verify the received fax is located in the configured folder (priority: 2). Configure Device Y to store faxes in folder which you don t have write access privileges, send a fax to device Y and verify the received fax is not located in the configured folder (priority: 2). Configure Device Y to store faxes in folder that is located on a drive that has no disk space, send a fax to device Y and verify the received fax is not located in the configured folder (priority: 2). Configure Device Y to store faxes in folder that doesn t exist, send a fax to device Y and verify the received fax is not located in the configured folder and that the folder is not created (priority: 2). Print Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Install a printer (Printer Z) Configure Device Y to Print to the printer Z.  Send a fax to device Y and verify the received fax is printed on printer Z (priority: 1). Send to Local Inbox Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Configure the Fax service to run as a local user account, supply a username with a Mapi profile. Admin console: Verify that device Y has the option to  Send to local inbox  available to select from (priority: 1). Configure Device Y to send to local inbox, send a fax to device Y and verify the fax is received in your local inbox (priority: 1). Kodak imaging Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed Tiff file associations: Verify that Tiff extension is associated with Kodak imaging application (priority: 1). MS Fax Tags: Verify a received and sent fax can be viewed using the Kodak imaging (priority: 1). Coverpage editor Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed Prior to running these tests you ll need to invoke the Coverpage editor once. Cov file associations: Verify that Cov extension is associated with the coverpage editor application (priority: 1). Try to Open an existing Coverpage file, and verify it s opened in the coverpage editor and that it looks good (priority: 1). Create a new coverpage and try to send a fax with it (priority: 2). Open an existing coverpage, edit it and save it (priority: 2). Tapi Devices: Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Install a new modem, stop and start the Fax service and verify it s added to the Devices node in the Fax Admin console (priority: 1.5). Uninstall an existing modem, stop and start the Fax service and verify it s added to the Devices node in the Fax Admin console (priority: 1.5). Adaptive answering and Ras interoperability Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional applications installed: Ras server configured with the following devices: Device X configured to not receive incoming Ras calls.  Device Y configured to receive incoming Ras calls. Data call answered by Fax service and handed off to Ras, Ras fully authenticates the Ras client (priority: 2). Fax call answered by Fax service, not handed off to Ras, and fax is received well (priority: 2). Security Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Try to send a fax with a user that has  submit access  (priority: 1).  Try to send a fax with a user that has no  submit access  (priority: 1). Try to view a fax with a user that has  viewing job access  (priority: 1). Try to view a fax with a user that has no  viewing job access  (priority: 1). Try to delete a fax with a user that has  manage job access  (priority: 1). Try to delete a fax with a user that has no  manage job access  (priority: 1). Try to view fax properties with a user that has  view fax service access  (priority: 2). Try to view fax properties with a user that has no  view fax service access  (priority: 2). Try to change fax properties with a user that has  manage fax service access  (priority: 2). Try to change fax properties with a user that has no  manage fax service access  (priority: 2). Try to view devices properties with a user that has  view fax device access  (priority: 2). Try to view devices properties with a user that has no  view fax device access  (priority: 2). Try to manage devices properties with a user that has  manage fax device access  (priority: 2). Try to manage devices properties with a user that has no  manage fax device access  (priority: 2). Fax tags and Fax counters Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: Install the fax performance counters, this is done using MMC -> Performance Log -> Counter Logs -> Add and choose the fax server counters. Send a fax and verify performance counters are valid (priority: 1). TBD: How can we view the Tiff tags. Event Log Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Configure Device Y to store incoming faxes in a local Folder Z. Send a fax to device Y. Verify that you see an event log entry for the sent fax, received fax and routing job (stored in folder) (priority: 1). Send a fax to a busy line, after the retries exceeds, verify you see an appropriate event log message (priority: 2). Receive a fax and route it to an invalid folder, verify you see an appropriate event log message (priority: 2). W2K Fax Service Pack 2 Test Plan PAGE    AUTHOR  Guy Merin Page   PAGE   DATE  2/5/2001 e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ e(HZOJ bjbjU  install SP2 from the following aOn the below scenarios install from a W2K machine with SP1 and a clean W2K machinethe theupdateshareOn a clean W2K machine install SP2 from an SP2 patch. patchUpdate.MSI file.TBD: Fix all this section. clean On a clean W2K On a clean W2K On a clean W2K On a clean W2K Install from CD Install from Share Install from patch Install from full slip stream Install from Update.MSI Install from Cabs 2 CD update. 2 CD update. On a W2K SP1 machine install SP2 from an SPf 2 CD update. sAdaptive answering and Ras interoperability Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Additional applications installed: Ras server configured with the following devices: Device X configured to not receive incoming Ras calls.  Device Y configured to receive incoming Ras calls. Data call answered by Fax service and handed off to Ras, Ras fully authenticates the Ras client. Fax call answered by Fax service, not handed off to Ras, and fax is received well.  Test Lab: LegacyC test toolSigalitB and maintained by  HYPERLINK "mailto:Liors?subject=Legacy C Test tool" LiorS , the tool has 480 C Api test cases. verifingsuccededOutlook is installed and the Fax transport provider is added to the default Mapi profile. CDs and SharesOn the below test cases, we will want to verify the installation succeeded by sending a fax and verifying it is queued and in a pending state. ''checkings Slip streamStore to folder Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Configure Device Y to store faxes in a local folder (for example: c:\MyFaxes), send a fax to device Y and verify the received fax is located in the configured folder. Configure Device Y to store faxes in a UNC folder (for example: \\ServerName\ShareName\MyFaxes), send a fax to device Y and verify the received fax is located in the configured folder. Configure Device Y to store faxes in a mapped folder (for example: map drive I to \\ServerName\ShareName\MyFaxes), send a fax to device Y and verify the received fax is located in the configured folder. Configure Device Y to store faxes in folder which you don t have write access privileges, send a fax to device Y and verify the received fax is not located in the configured folder. Configure Device Y to store faxes in folder that is located on a drive that has no disk space, send a fax to device Y and verify the received fax is not located in the configured folder. Configure Device Y to store faxes in folder that doesn t exist, send a fax to device Y and verify the received fax is not located in the configured folder and that the folder is not created. Test Areas: Test Areas: Run the BVT and verify all test cases pass prorityprioritypriority: 1priority: 1platformRun the Legacy C test tool. test tool.iving to sending and vice versa.Change TSID and CSID of devices.1Allr of rings on receiving devices.1Allcan not.ped directory a local directory.ped directory a local directory oked correctly (the   button).2 SKU: All (priority: 1 SKU: All). Run the Legacy COM test tool (priority: 1 SKU: All). Fax UI: Fax UI:  (priority: 1 SKU: All). (priority: 2 SKU: SRV).1 SKU: SRV SKU: SRV SKU: SRV SKU: SRV SKU: SRV, priority 2: Restitive help is invoked correctly ()General: Invoke help through F1..1..)12.11..1.12.1.1the 3 options scheduled actions.1ssssrect, user info, recipients etc.sending and receiving job is OK.ype is either send or receive.n correctly in the Pages column.tly in the Document name column.and recipients info are correct.sns: Pause and resume a send job.b while it s in a sending state.11while it s in a receiving state.12 262voke the fax monitor properties.ar icon -> invoke the fax queue. icon -> Invoke the fax monitor.us monitor and advanced options.UserInfo.the coverpage editor is invoked.1 editor is invoked.12d delete and existing coverpage.1rify there re applied correctly.1ed and Admin console is opened).he Fax control panel is invoked. Excel, PowerPoint and Outlook).ion, Priority 2 for all the rest1 applicationaphical image (BMP, JPEG, GIFF).1r a text file (through NotePad).12NotePaddress book and has a fax number.1a DL with a fax recipient in it.1t invoked on non fax recipients.1notog is invoked on fax recipients.Compose a mail to a fax recipient and try to invoke the fax properties (Through Message Menu->Tools->Fax options) verify that the dialog is invoked on fax recipients (priority: 1). non faxnon faxstall SP2 from an SP2 CD update.1e install SP2 from an SP2 share.e install SP2 from an SP2 patch.1SP2 from an SP2 Update.MSI file.1stall SP2 from an SP2 Cabs file.1n SP2 CD update.1e install SP2 from an SP2 share.e install SP2 from an SP2 patch.1.MSI file.1stall SP2 from an SP2 Cabs file.1Install a full SP2 Slip stream.ave corresponding symbols files.1correct folder (Winnt\system32).2version (depended on the build).ocated in the configured folder.ocated in the configured folder.1ocated in the configured folder.1ocated in the configured folder.ocated in the configured folder.created.ved fax is printed on printer Z.inbox  available to select from.is received in your local inbox.22ng application. viewed using the Kodak imaging.he coverpage editor application.2e and try to send a fax with it. coverpage, edit it and save it.see that 'e editor and that it looks good.2s node in the Fax Admin console.onsole.he answer button dialog pops up.2wered with  no questions asked .2ly authenticates the Ras client. Ras, and fax is received well. priority.PpriorityprioritypriorityTBD no spOS configured ENG Machine #1: Clean W2K configured cofigurationW2K machine with SRV SRV TCSRV Pro ProffesonalClean W2K Professional (No SP installed). CCCCSp2 machineW2K ServerGhosted clean Ghosted clean Ghosted clean Data Center  Professional (No SP installed).English machines: W2K SP2 Proffesinal: Proffesinal(No SP installed):ProfessionalProfessional Clean (No Sp installed)This machine will be installed from a clean ServerServer sProW2K Pro with SP1.No Upgrade, slipUpgrade using SP2 shareW2K Server (No SP installed). W2K Advanced Server (No SP installed). W2K Data Center (No SP installed). Ghosted clean W2K Professional (No SP installed). Ghosted clean W2K Server (No SP installed). Ghosted clean W2K Data Center (No SP installed). Ghosted clean W2K Advanced Server (No SP installed). , this machine wil Advanced Server:Advanced Server Not relevant.Upgrade from: W2K Server with SP1. Pro Upgrade method: Install using SP2 slipstream CD. shareshare.English machines: on of the machine is as follows:Each machinMachines: Each of twill have the following applicatimachine need Ghosted prior to running the upgrade. middleeast corpretMstools  need to be nd German OS (total 8 machines), Windoesindows 'fiixfix 'Concept: Priority 1generalyadditionalsiadditionalscomponetPriority 1:Priority 2:,, t rRun this test as well, uUsually these test cases are afine, "" touch  "fine,,have'will increase the components 'case which is a must""cases which should beOMachine are a test case The test cases in this section are not really test cases,  isranranThis test case should be run on all platforms (PRO, SRV, ADV, DTC).This document describes the Test cases and Test lab needed to test the Fax on Windows 2000 SP2. Since Fax didn t have any checkin or fix for this Service Pack, we need to verify that other components didn t break the fax service (for example: Tapi, RPC or kernel binaries). The idea behind the test plan is to  touch  each of the fax components and binaries. Each component will have a test case that is a  must run  and other test cases that should be ran if time permits. The test cases are sorted by priorities according to the key: Priority 1: A must run test. Tests major functionality of the component. Priority 2: If time permits test. Additional tests on a component, the component is generally functioning fine and running these tests will increase the component s coverage. Fax SPWindows 2000 Service Pack 2 Fax Test Plan Windows 2000 Service Pack 2 Fax Test Plan Windows 2000 Service Pack 2 Fax Test Plan 2or end options scheduled actions22222Dynamic configurationled at least on the SRV machine, 1Data CenterDTC W2K SP2 Data Center: Target: W2K DTC with SP2. Upgrade from: Clean W2K DTC (No Sp installed). Upgrade method: Upgrade using SP2 CD.CHK W2K SP2 ServerWindoesWChecked Server CHK Clean W2K DTC (No Sp installed)Windows Powered: Target: W2K Powered with SP2. Upgrade from: Not relevant. Upgrade method: Upgrade using SP2 CD.W2K SP2 Advanced Server Run the Legacy COM test tool (priority: 1). Fax Verifier Fax Verifier Fax Verifier  and maintained by  HYPERLINK "mailto:Liors?subject=Legacy C Test tool" LiorS )has 480 C Api test casesLegacyverfier C test tool he Win2K Fax verifier test tool  zZIn achivedverifingvaroius(2,. UNC folder and mapped folder  (priority: 1).1localUNC HWhen 'ser account and verify the users 'Change the Archive directory to a mapped folder2service to run under a user account and verify the user s Mapi profile is shown in the Email profiles list1user dialog pops up correctly, p""" 1Add and remove a group of users, verify that the  add a user  dialog pops up correctly and that you can add a group2preveligiesexisting random , deny and grant access to a user. Device Y configured for Fax receive only.Device Y configured for Fax receive only. operations: Verify 'it;stransmitiinge it s in a transmitting state)..5TBDis eithery line is shown in a busy state.busy line is shown in a busy Verify that a job that is sent to a busy line is shown in a busy state (priority: 1).no answer 11'dailingtransmitingmanualy Configure device Y to answer calls manually and not automatically, send a fax to Device Y and verify the answer button dialog pops up (priority: 1). Configure device Y to answer calls automatically and not manually, send a fax to Device Y and verify the fax is answered with  no questions asked  (priority: 1). Answer a call manually.  -> Properties, control panel Send a mail to a fax recipient in the format: Mail To:   HYPERLINK "mailto:[fax:Name@Number]"  [fax:Name@Number]  (priority: 2). recipeint and an email recipient recipeints and try toCompose a mail to a non-fax recipient and try to non non fax(through Outlook -> Tools -> Services -> Fax properties)(, 2 verfiy(coverpage, fax printer, font), 1Registry Layout installation Slipstream. registy est case with a modem installed..The below test cases are valid only for SP2 Slip stream, all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 Slipstream. The below test cases are valid only for SP2 Slip stream, all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). below sare  Slipstream,Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 Slipstream. The below test cases are valid only for SP2 Slip stream, all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix).Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: SP2 Slipstream. The below test cases are valid only for SP2 Slip stream, all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix).TBDAdd The test case is valid only for SP2 Slipstream; all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). SP2 Slipstream.  The test case is valid only for SP2 Slipstream; all other SP2 installation methods don t have Fax binaries (the Fax binaries don t have an SP2 update or bug fix). Add the fax performance counters performance counters are valid.'(TBD: How is this done) Security the following users2user which is an not is an administrator on the machineTry to send a fax with a user that is not an administrator on the machine (priority: 1).SS""""no Deny send a submit no view a fax with ing no 11viewview Job change manage faxTry to change fax properties with a user that has no  manage fax service access  (priority: 2). no serviceservice view no  no change change faxservice fax Try to view properties with a user that has no  view fax service access  (priority: 2).Try to change fax device properties with a user that has  manage fax devices access  (priority: 2). Try to change fax properties with a user that has  manage fax devices access  (priority: 2).view view Try to view devices properties with a user that has no  view fax device access  (priority: 2).view viewing Try to view a fax with a user that has no  viewing job access  (priority: 1).Try to manage devices properties with a user that has no  manage fax device access  (priority: 2). Security Security Security"Event Log Manual answer Test case configuration:  Win2K machine Modems devices with telephone lines: Device X configured for Fax send only. Device Y configured for Fax receive only. Event Log:Try to send a fax with a user that has  submit access  (priority: 1).  Send a fax and receive a fax , cand receive a fax execeds verify you see an  routing job (stored in folder).2eventlogSend a fax to a busy line, after the retries exceeds, verify you see an appropriate event log message (priority: 2). LLTest Lab: The SP2 lab will have 8 machines, 4 English OS machines and 4 German OS machines. The configuration of the machine is as follows Priority 1 Machines: The below machine are for English OS and German OS (total 8 machines). W2K SP2 Professional: Target: W2K Professional with SP2. Upgrade from: Clean W2K Pro (No Sp installed). Upgrade method: Upgrade using SP2 share. W2K SP2 Server: Target: W2K Server with SP2. Upgrade from: W2K Server with SP1. Upgrade method: Upgrade using SP2 Setup.MSI. W2K SP2 Advanced Server: Target: W2K Advanced Server with SP2. Upgrade from: Not relevant. Upgrade method: Install using SP2 slipstream CD. W2K SP2 Data Center: Target: W2K DTC with SP2. Upgrade from: Clean W2K DTC (No Sp installed). Upgrade method: Upgrade using SP2 CD. Priority 2 Machines: CHK W2K SP2 Server: Target: Checked W2K Server with SP2. Upgrade from: Clean CHK W2K DTC (No Sp installed). Upgrade method: Upgrade using SP2 CD. Windows Powered: Target: W2K Advanced Server with SP2. Upgrade from: Not relevant. Upgrade method: Install using SP2 slipstream CD. Applications on each machine: The above machines need the following configuration: Ghosted prior to running the upgrade. Office installed (to run the Outlook test). Machines are on the corporate domain (to be able to have access to printers). IDW and MSTOOLS (to run FileVer and other tools). VC installed at least on the SRV machine. VB installed at least on the SRV machine. AutoCom test tool installed. Terminal Server installed. Fax tags and Fax counters Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: Install the fax performance counters, this is done using MMC -> Performance Log -> Counter Logs -> Add and choose the fax server counters. Send a fax and verify performance counters are valid (priority: 1). TBD: How can we view the Tiff Tags. Fax tags and Fax counters Test case configuration:  Win2K machine Modems devices with telephone lines: No modems needed, we can verify the outgoing fax is queued. Additional applications installed: Install the fax performance counters, this is done using MMC -> Performance Log -> Counter Logs -> Add and choose the fax server counters. Send a fax and verify performance counters are valid (priority: 1). TBD: How can we view the Tiff tags. TBD check if W2K supports dynamic configuration: TBD check if W2K supports dynamic configuration: Uninstall an existing modem and verify its remove to the Devices node in the Fax Admin console (priority: 1.5).I newautomatticPlease note this document is a draft and is the base for W2K SP2 Beta testing, for the SP2 RTM we will have an additional test plan which will be based on many automatic test tools. Please note this document is a draft and is the base for W2K SP2 Beta testing, for the SP2 RTM we will have an additional test plan which will be based on many automatic test tools. PAGE   PAGE   PAGE   PAGE    PAGE  PAGE    PAGE   AUTHOR  Guy Merin Page   PAGE   DATE  11/16/2000 PAGE   Page   PAGE   DATE  11/16/2000 PAGE    DATE  11/16/2000 PAGE    DATE  11/16/2000 PAGE   Micro Micro  TIME \@ "h:mm AM/PM"  7:38 PM Microsoft Confidential Windows 2000 Service Pack 2 Fax Test Plan Microsoft Confidential Fax Windows 2000 Service Pack 2 Fax Test Plan W2Kindows 2000 Service Pack 2 Fax Test Plan W2K Fax Service Pack 2 Fax Test Plan  AUTHOR  Guy Merin Page   PAGE   DATE  11/16/2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\upgradescenariostestspec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft, Haifa. Things to check in Performance Monitoring   new counters TitleThings to check in Performance Monitoring   new counters Yafit Gelchinski Normal Yafit Gelchinski Microsoft Word 9.0R[&,\ V"TC0( kxVNv Performance Monitoring test spec.docbjbjU Upgrade Scenario Testing Preface: Upgrade scenario testing is done to ensure a smooth upgrade for the consumers of older versions of BackOffice products to the new BackOffice products, and to ensure that after the new BackOffice product has been installed and used, any upgrade of the underlying operating system does not result in any data loss. Introduction: The testing covers both server upgrades and client upgrades, and is divided into three logical parts: Server upgrade scenarios including operating system upgrade, since usually such an upgrade will be required as part of the BackOffice server upgrade BackOffice client upgrade scenarios: upgrading a workstation from an older version of the BackOffice client to version 5.0, which includes the Fax and Modem Sharing services BackOffice 5.0 client and server operating system upgrade scenarios: ensuring the upgrade of a client s operating system does not damage its BackOffice history regarding the Fax and Modem Sharing services, and ensure that an upgrade of the BOS server to Whistler does not damage the existing services or causes any loss of related data. (Waiting for an answer from Erin or Lisa, since upgrades can t be smooth by definition   the Fax clients differ in drivers) While the tests are logically divided into three parts, they will be conducted alongside one another, since each test s results relies on the others. Test Strategy: The test goals are: Ensure that all older data remains intact after upgrade. Ensure that all the entries specified by the product development team as crucial to the product s correct execution are found on the system after the upgrade action. Ensure the upgrade itself runs smoothly, from a user s point-of-view. The testing will be done according to the order in the Test Scheme (Appendix B). The tests will start with a base scenario, on which upgrade actions will be made. Following the test goals, the list of items which will be tested after the upgrade has completed are: Server-side: Basic file system and registry entries are found on the system (goal 2) Migration of server cover page files (if changed since creation) (goal 1) Migration of device settings (goal 1) Migration of FSPs (goal 1) Migration of Routing Extensions (goal 1) Migration of Outbound Routing Rules (goal 1) Client-side: Basic file system and registry entries are found on the system (goal 2) Migration of personal cover page files (goal 1) Migration of user information (goal 1) Migration of the last Send Fax Wizard settings (goal 1) The upgrades will be done manually, to ensure that goal no. 3 is met   the upgrade runs smoothly from the user s point of view. Besides the first item of each group - basic file system and registry data is complete   for which there exists an automatic test tool, the rest of the items will be checked manually. All these test items apply to all three groups of tests. The following sections contain the full lists of upgrades to be tested, divided according to the three logical groups mentioned above. The Test Scheme appendix describes the order in which the tests will be performed. Remarks: During the pre-Beta test cycle no testing will be done for the upgrading of the Quick-Fixed SBS 4.5, since this component will not be completed by then. Testing for upgrades from BackOffice 4.0 will be done on a small basis, since it is similar to BackOffice 4.5 in its structure of the Fax and Modem Pooling services. Servers Upgrade Testing: BackOffice servers vary in their roles in the network, from stand-alone servers to domain controllers, terminal servers and data center servers, all must be able to upgrade to the BackOffice 5.0 suite s products. The following types of servers will be tested: Standard Terminal Server The following tests will be done with a standard server. Clean machine SBS 5.0 ( Win2k w/ SBS 5.0 Fax Server Win2k w/ NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server Win2k w/ SBS 5.0 Fax Server BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/ qfe SBS 5.0 ( Win2k w/ SBS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/o qfe SBS 5.0 ( Win2k w/ SBS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/ qfe BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/o qfe BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ BOS 4.5 BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/ qfe BOS 4.5 ( WinNT 4 w/ BOS 4.5 Fax Server BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/o qfe BOS 4.5 ( WinNT 4 w/ BOS 4.5 Fax Server BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ BOS 4.5 Win2k ( Win2k w/ BOS 4.5 BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/ qfe BOS 4.5 ( WinNT 4 w/ Fax Server 4.5 w/ qfe on BOS 4.5 Win2k ( Win2k w/ BOS 4.5 and NT Fax *BREAK* BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server WinNT 4 w/ SBS 4.5 Fax Server w/o qfe BOS 4.5 ( WinNT 4 w/ Fax Server 4.5 w/o qfe on BOS 4.5 Win2k ( Win2k w/ BOS 4.5 and NT Fax *BREAK* BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server The following tests of upgrading BackOffice Suite 4.0 products to BackOffice 5.0 will be done on a small scale, since they are similar to the BackOffice Suite 4.5 products: WinNT 4 w/ SBS 4.0 Fax Server SBS 5.0 ( Win2k w/ SBS 5.0 Fax Server WinNT 4 w/ BOS 4.0 BOS 5.0 ( Win2k w/ BOS 5.0 Fax Server For each of these tests a group of clients will be tested as well: Win2k Professional WinNT 4 workstation Millennium client Windows 98  Windows 95 The following tests will be conducted on terminal servers: Win2k terminal server BOS 5.0 ( Win2k terminal server w/ BOS 5.0 Fax services This installation will be done from a remote computer (a terminal client of the server). The server will also have the following terminal clients upgraded with it: Win2k Professional terminal client WinNT 4 workstation terminal client Millennium terminal client Win98 terminal client Win95 terminal client WinNT 4 w/ SBS 4.5 (with qfe) SBS 5.0 ( Win2k terminal server w/ SBS 5.0 Fax services This installation will be done from locally (not from a terminal client). The server will also have the following terminal clients upgraded with it: Win2k Professional terminal client WinNT 4 workstation terminal client Millennium terminal client Win98 terminal client Win95 terminal client BackOffice Client Upgrade Testing: The following clients and flavors must be supported by all BackOffice 5.0 server applications: Windows 95, Gold edition Windows 95, OSR2 edition Windows 98, 1st edition Windows 98, 1st edition, Customer Service Pack Windows 98, 2nd edition Millennium Windows NT 4.0 Workstation, SP3 Windows NT 4.0 Workstation, SP4 Windows NT 4.0 Workstation, SP5 Windows NT 4.0 Workstation, SP6 Windows NT 4.0 Workstation, SP7 Windows 2000 Workstation, Professional edition Windows 2000 Workstation, SP1 Whistler, Standard edition Whistler, Professional edition Each such client must be able to install or upgrade to the Fax and Modem Sharing services client. Furthermore, the client must successfully work alongside a personal fax, if the user system has one or wishes to install one after the Fax and Modem Sharing services client has already been installed. The client upgrade scenarios are divided into two main stages of the upgrade and several sub-stages, according to the following: Stage 1   installing Fax Server client 5.0 for the first time. The following cases belong to this stage: The client doesn t have a fax client or a personal fax installed. The client has a personal fax installed. The client has an older version of the fax client installed. The client had an older version of the fax client, but removed it (some of the data might still exist in the system). The client has both an older version of the fax client and a personal fax installed. The client has NT Fax service installed (Win2k clients only). The client has both NT Fax server and an older version of the fax client installed, with qfe (Win2k clients only). The NT client has an older non-working Fax client (an SBS 4.5 without qfe). Stage 2   the client already has Fax Server client 5.0 installed. The following cases belong to this stage: Upgrade client from SBS 5.0 client to BOS 5.0 client. Installing a personal fax on the client (Win2k clients do not need testing, since this is a non-optional component of the operating system). Appendix A sums up the client upgrade tests that must be done, according to these groups of tests. Client and Server Operating System Upgrades The third part of upgrade scenarios testing is checking that any BackOffice 5.0 system can upgrade its underlying operating system without damaging the data related to Fax and Modem Sharing services. Unfortunately, clients of different groups need different drivers: The Win9x clients group includes the Windows 95, Windows 98 and Millennium clients The NT4 client group includes all WinNT 4 workstations, no matter what service pack is installed, as long as the system has at least SP3 installed. The NT5 client group includes Win2k Professional (a service pack is expected soon), and both Whistler clients: Standard and Professional For each of these groups there exists a different driver. Therefore the tests will check the following: If the upgrade leaves the client in its old driver group, we expect the Fax services client to continue working after the upgrade has completed. If the upgrade moves the client from one group to another, another installation of the BOSFax client should leave the client working and all the old data intact, as if nothing happened. Besides these cases, there are some special scenarios of an existing SBS 4.5 client upgraded to Win2k. Such an upgrade can lead to broken connections between the SBS 4.5 Fax Server client and the server. Testing will be done for client operating systems to ensure that after the installation of SBS 5.0 or BOS 5.0 client, the system recovers and the connection between server and client is restored. Appendix A sums up the client operating system upgrade tests that must be done. As for the server, currently only one operating system is possible: upgrading a BOS 5.0 server to Whistler w/ BOS 5.0. A given set of a BOS 5.0 server and 15 clients will be used. The server will have its operating system upgraded to Whistler. Afterwards the server will be checked to ensure that the services are running and that all the file system and registry entries for BOS Fax and Modem Sharing services are exactly the same as before the upgrade, including: Cover page files Device settings Routing extensions Outbound routing rules A BVT test will be run to ensure the services are running correctly, both on the server and its clients (which have not been changed). Appendixes: Appendix A   Client Upgrade Tests Appendix B   Test Scheme (scheduled tests) Upgrade Scenario Testing Page   PAGE   NUMPAGES  Microsoft Confidential  AUTHOR  Yafit Gelchinski  DATE  4/18/2000 Waiting for answer from Lisa / Erin if older versions of the Fax client must be uninstalled first.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\testplan.ppt ===
Comet Fax  Test Plan  Review micky snir October 28th, 1998 Updated: Oct 6th, 1999 Agenda The test team. Some statistics. Test areas. Test strategy. Test areas in details. Test areas that need spec. Existing automation. New automation that we added. Manual testing. Automation strategy. Current time estimates. The test team. Micky Snir. Sigalit Bar. Guy Merin. Miriam Scortzario Yafit Gelchinski Some bug statistics 300 NT5 fax bugs opened by the CometFax Haifa test team since July 15, 1998. 84 Fixed. 100 Comet fax bugs since February 9th, 1999  Total of 200 P1 or S1 bugs, (400 active Comet fax bugs). Fixed Comet fax bugs: 115. Test Areas and Owners Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). BOS/SBS integration (Sigalit).  Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). Open Port: proprietary, T.37 FSPs) (Sigalit & Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Client API (FXSAPI.DLL) (Miri). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Guy). Inbound routing API (Guy). Co-existence with fax applications (Guy). Testing strategy Code review. Automation where possible. Ad hoc (especially UI). Validation. Each operation should be validated by the test-case. For example all sent faxes are received correctly (tiff compare), and routed correctly. Massive system and stress tests. Self-host. Extensive API testing - especially scenarios (also tests the server). Hardware coverage (server side modems & fax-boards, other side fax-devices). Tools: - gflags (memory corruption) - OH, POOLMON etc. (resource leaks) - BoundsChecker(?) - injector (fault injection) - W2K kernel-mode driver-verifier - Run under debugger - typo.pl Testing strategy, continued Extreme conditions. Memory, disk, registry, fault-inject, MPS machine. Test matrix (not all items are independent). - (Win95 x Win98 x NT4 x NT5) x (Single x MP) x (chk x fre) - (clean OS) x (OS w/ installed apps) - FSP devices, routing extensions, coexist with/out other Comet components.. - Printing applications - MAPI client applications (Outlook) Test areas in detail. Printing from applications (client side) Client UI ClientUITC.doc, \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc  Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas:  - user info - send wizard  - managing faxes (outbox, sent items) - confirmation selection - cover-page management Admin UI AdminTC.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas: - user access rights - folder management - device & provider management - server cover pages - outbound routing - logging - reports BOS/SBS integration BosInteg_spec.doc Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5  Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Office integration MapiTC.doc, \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Use the Outlook COM object to automate scenarios. Straightforward test cases of sending faxes from MAPI clients. Self-host - sending faxes from outlook client. Outlook97, O2K, exchange clients. Co-existence with NT5 fax. Rendering attachments. Resolving names. Using address book. Broadcast. Add in. T.30 FSP FaxTraceRegSuites.xls, FaxTraceScripts.xls Telegra FaxTrace. Test suites of send & receive faxes to & from the fax server, that exercise the T.30 protocol. Most test suites can run un-attendant. Genoa FaxLAb. Emulation of most common 79 fax-modems to send & receive faxes to & from the fax server. Most test cases are manual. Send & receive faxes from fax service providers around the world & state. Receive faxes from fax-back services. System test - sent & received faxes will be compared. Add-hoc tests for bug fixes that are risky (like the abort-during-dialing test). Will not test class 2 / 2.0. Will not write an FSP driver. Will not use Modem-Stub to test T.30 protocol. MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Modem compatibility (remote side) Telegra & Genoa. Sending faxes to arbitrary fax number around the world / country, preferably such that return reply faxes. Analyze the T.30 log for errors. Fax client API. BroadcastTC.doc, COM_API_Issues.doc, CPRenderTC.doc Test each function, ANSI & UNICODE versions. Try to extract every possible return value. In the error case verify that the state does not change. Verify results if possible. (e.g. abort a job, verify that the job gets aborted). Verify that each property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback Illegal parameters.  Only one at a time, unless it seems reasonable. Legal parameters - equivalence classes. States. Call an API at several states (--> define scenarios). Aborting / closing / exiting while operations are performed. Multi-threading. Low resources. Use the dynamic resource-hogger tool & call the API many times, hoping that memory will run out at different places in the code. Low disk space. After each case perform a sanity check, to verify a stable state. Special coverage for broadcast API. Link W2K apps & tools with FXSAPI.LIB and test them to verify backward compatibility. Outbound (FSP) routing Setup & uninstall Inbound routing API. InRouteTC.doc We will write an inbound routing test-module that will emulate different scenarios, especially error conditions. For example emulation of routing methods that fail, faulty routing extensions that cause AV. We will use the same design and building blocks as with EFSPI testing. Co-existence with fax applications. CoExistTC.doc Manual testing mainly.  Server side Client side (Win9X, NT4, NT5) Adaptive answering. Queue functionality BroadcastTC.doc ServiceMonitor tool. API testing (pause, resume & restart a job, etc.). Specific test cases, like verifying FIFO & scheduling rules (FIFO is NOT enforced today!). A combination of client API, test FSPs and test inbound routing extensions can be used as a controlled environment that verifies operations. Scale ScaleTC.doc Lab scale tests. - many connected clients (queuing jobs and viewing them). - many concurrent fax sessions (many fax ports used concurrently).     Per FSP, and mixed FSPs. - we will define the maximum number of concurrent (uni)modem sessions.    Per FSP where applicable. SBS scale requirement is 4 modems and ~25 connected clients. For BOS we will measure our scalability. Self-host. Manual testing. other: Political issues (PoliScan). Performance. Ad-Hoc.doc CPRenderTC.doc, SrvrRender_spec.doc Adopted Automation: Cover page editor VT suite. \\nttest\ntct\slm\src\ntfax\specs\cpe.doc SimpleFax - a simple fax sending utility. Qfax - very similar to SimpleFax, but with a matrix of files x coverpage enhancement. FaxVrfy - test adaptive answering, given that it is supported. PCT & GDI tests. Automates only the printing part of several applications, with different fonts etc. No verification. We may augment it for verification that is manual today.  New automation that we added: New automation (cont.): Automation strategy and plans. Use the DCOM DTM framework for executing distributed tests.  API testing is not only simple API calls, but also tests complex scenarios, therefor automation is achieved for complex scenarios as well. C API testing is implemented in a pluggable way to the DCOM-DTM framework, and thus enables testing distributed (and system) scenarios. Note that the C API also extensively tests the server, since all client calls are RPCed to the server. The end. Click to edit Master title style Click to edit Master text styles Second Level Third Level Fourth Level Fifth Level Click to edit Master title style Click to edit Master subtitle style Click to edit Master text styles Second level Third level Fourth level Fifth level micky snir Comet fax test plan summary Help files (Yafit). SDK (Guy, Sigalit & Miri).  Adaptive answering (Guy). Queue functionality (Miri). Logging (Miri). Scale (Miri). Security (Miri). Server side rendering (Sigalit). Performance (Miri & Guy). Localization, globalization, Y2K (Miri). Modem Sharing (Guy). Image viewer. Performance counters (Yafit). MS fax tiff tags. Cover page editor. Test specs are in \\haifaslm\slmcomet\src\fax\faxtest\docs Comet fax test plan summary micky snir Sigalit Bar Microsoft PowerPoint 7.0 "Arial Narrow Comet Fax Test Plan Review4 "Arial micky snir October 28th, 1998 Updated: Oct 6th, 1999 "System Overhead Times New Roman Arial Narrow Arial Monotype Sorts Default Design Comet Fax  Test Plan  Review Agenda The test team. Some bug statistics Test Areas and Owners Testing strategy Testing strategy, continued Test areas in detail. Printing from applications (client side) Client UI Admin UI BOS/SBS integration Office integration T.30 FSP MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Modem compatibility (remote side) Fax client API. Outbound (FSP) routing Setup & uninstall Inbound routing API. Co-existence with fax applications. Adaptive answering. Queue functionality Scale Manual testing. other: Adopted Automation: New automation that we added: New automation (cont.): Automation strategy and plans. The end. Fonts Used Design Template Slide Titles _PID_HLINKS eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeC eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeee( eeeeeeeeeeeeeeeeeeeeeeee( eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeee8 eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee Comet Fax  Test Plan  Review micky snir October 28th, 1998 Updated: Oct 6th, 1999 Agenda The test team. Some statistics. Test areas. Test strategy. Test areas in details. Test areas that need spec. Existing automation. New automation that we added. Manual testing. Automation strategy. Current time estimates. The test team. Micky Snir. Sigalit Bar. Guy Merin. Miriam Scortzario Yafit Gelchinski Some bug statistics 300 NT5 fax bugs opened by the CometFax Haifa test team since July 15, 1998. 84 Fixed. 100 Comet fax bugs since February 9th, 1999  Total of 200 P1 or S1 bugs, (400 active Comet fax bugs). Fixed Comet fax bugs: 115. Test Areas and Owners Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). BOS/SBS integration (Sigalit).  Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). Open Port: proprietary, T.37 FSPs) (Sigalit & Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Client API (FXSAPI.DLL) (Miri). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Guy). Inbound routing API (Guy). Co-existence with fax applications (Guy). Testing strategy Code review. Automation where possible. Ad hoc (especially UI). Validation. Each operation should be validated by the test-case. For example all sent faxes are received correctly (tiff compare), and routed correctly. Massive system and stress tests. Self-host. Extensive API testing - especially scenarios (also tests the server). Hardware coverage (server side modems & fax-boards, other side fax-devices). Tools: - gflags (memory corruption) - OH, POOLMON etc. (resource leaks) - BoundsChecker(?) - injector (fault injection) - W2K kernel-mode driver-verifier - Run under debugger - typo.pl Testing strategy, continued Extreme conditions. Memory, disk, registry, fault-inject, MPS machine. Test matrix (not all items are independent). - (Win95 x Win98 x NT4 x NT5) x (Single x MP) x (chk x fre) - (clean OS) x (OS w/ installed apps) - FSP devices, routing extensions, coexist with/out other Comet components.. - Printing applications - MAPI client applications (Outlook) Test areas in detail. Printing from applications (client side) Client UI ClientUITC.doc, \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc  Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas:  - user info - send wizard  - managing faxes (outbox, sent items) - confirmation selection - cover-page management Admin UI AdminTC.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas: - user access rights - folder management - device & provider management - server cover pages - outbound routing - logging - reports BOS/SBS integration BosInteg_spec.doc Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5  Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Office integration MapiTC.doc, \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Use the Outlook COM object to automate scenarios. Straightforward test cases of sending faxes from MAPI clients. Self-host - sending faxes from outlook client. Outlook97, O2K, exchange clients. Co-existence with NT5 fax. Rendering attachments. Resolving names. Using address book. Broadcast. Add in. T.30 FSP FaxTraceRegSuites.xls, FaxTraceScripts.xls Telegra FaxTrace. Test suites of send & receive faxes to & from the fax server, that exercise the T.30 protocol. Most test suites can run un-attendant. Genoa FaxLAb. Emulation of most common 79 fax-modems to send & receive faxes to & from the fax server. Most test cases are manual. Send & receive faxes from fax service providers around the world & state. Receive faxes from fax-back services. System test - sent & received faxes will be compared. Add-hoc tests for bug fixes that are risky (like the abort-during-dialing test). Will not test class 2 / 2.0. Will not write an FSP driver. Will not use Modem-Stub to test T.30 protocol. MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Modem compatibility (remote side) Telegra & Genoa. Sending faxes to arbitrary fax number around the world / country, preferably such that return reply faxes. Analyze the T.30 log for errors. Fax client API. BroadcastTC.doc, COM_API_Issues.doc, CPRenderTC.doc Test each function, ANSI & UNICODE versions. Try to extract every possible return value. In the error case verify that the state does not change. Verify results if possible. (e.g. abort a job, verify that the job gets aborted). Verify that each property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback Illegal parameters.  Only one at a time, unless it seems reasonable. Legal parameters - equivalence classes. States. Call an API at several states (--> define scenarios). Aborting / closing / exiting while operations are performed. Multi-threading. Low resources. Use the dynamic resource-hogger tool & call the API many times, hoping that memory will run out at different places in the code. Low disk space. After each case perform a sanity check, to verify a stable state. Special coverage for broadcast API. Link W2K apps & tools with FXSAPI.LIB and test them to verify backward compatibility. Outbound (FSP) routing Setup & uninstall Inbound routing API. InRouteTC.doc We will write an inbound routing test-module that will emulate different scenarios, especially error conditions. For example emulation of routing methods that fail, faulty routing extensions that cause AV. We will use the same design and building blocks as with EFSPI testing. Co-existence with fax applications. CoExistTC.doc Manual testing mainly.  Server side Client side (Win9X, NT4, NT5) Adaptive answering. Queue functionality BroadcastTC.doc ServiceMonitor tool. API testing (pause, resume & restart a job, etc.). Specific test cases, like verifying FIFO & scheduling rules (FIFO is NOT enforced today!). A combination of client API, test FSPs and test inbound routing extensions can be used as a controlled environment that verifies operations. Scale ScaleTC.doc Lab scale tests. - many connected clients (queuing jobs and viewing them). - many concurrent fax sessions (many fax ports used concurrently).     Per FSP, and mixed FSPs. - we will define the maximum number of concurrent (uni)modem sessions.    Per FSP where applicable. SBS scale requirement is 4 modems and ~25 connected clients. For BOS we will measure our scalability. Self-host. Manual testing. other: Political issues (PoliScan). Performance. Ad-Hoc.doc CPRenderTC.doc, SrvrRender_spec.doc Adopted Automation: Cover page editor VT suite. \\nttest\ntct\slm\src\ntfax\specs\cpe.doc SimpleFax - a simple fax sending utility. Qfax - very similar to SimpleFax, but with a matrix of files x coverpage enhancement. FaxVrfy - test adaptive answering, given that it is supported. PCT & GDI tests. Automates only the printing part of several applications, with different fonts etc. No verification. We may augment it for verification that is manual today.  New automation that we added: New automation (cont.): Automation strategy and plans. Use the DCOM DTM framework for executing distributed tests.  API testing is not only simple API calls, but also tests complex scenarios, therefor automation is achieved for complex scenarios as well. C API testing is implemented in a pluggable way to the DCOM-DTM framework, and thus enables testing distributed (and system) scenarios. Note that the C API also extensively tests the server, since all client calls are RPCed to the server. The end. Comet Fax  Test Plan  Review micky snir October 28th, 1998 Updated: Oct 6th, 1999 Agenda The test team. Some statistics. Test areas. Test strategy. Test areas in details. Test areas that need spec. Existing automation. New automation that we added. Manual testing. Automation strategy. Current time estimates. The test team. Micky Snir. Sigalit Bar. Guy Merin. Miriam Scortzario Yafit Gelchinski Some bug statistics 300 NT5 fax bugs opened by the CometFax Haifa test team since July 15, 1998. 84 Fixed. 100 Comet fax bugs since February 9th, 1999  Total of 200 P1 or S1 bugs, (400 active Comet fax bugs). Fixed Comet fax bugs: 115. Test Areas and Owners Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). BOS/SBS integration (Sigalit).  Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). Open Port: proprietary, T.37 FSPs) (Sigalit & Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Client API (FXSAPI.DLL) (Miri). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Guy). Inbound routing API (Guy). Co-existence with fax applications (Guy). Testing strategy Code review. Automation where possible. Ad hoc (especially UI). Validation. Each operation should be validated by the test-case. For example all sent faxes are received correctly (tiff compare), and routed correctly. Massive system and stress tests. Self-host. Extensive API testing - especially scenarios (also tests the server). Hardware coverage (server side modems & fax-boards, other side fax-devices). Tools: - gflags (memory corruption) - OH, POOLMON etc. (resource leaks) - BoundsChecker(?) - injector (fault injection) - W2K kernel-mode driver-verifier - Run under debugger - typo.pl Testing strategy, continued Extreme conditions. Memory, disk, registry, fault-inject, MPS machine. Test matrix (not all items are independent). - (Win95 x Win98 x NT4 x NT5) x (Single x MP) x (chk x fre) - (clean OS) x (OS w/ installed apps) - FSP devices, routing extensions, coexist with/out other Comet components.. - Printing applications - MAPI client applications (Outlook) Test areas in detail. Printing from applications (client side) Client UI ClientUITC.doc, \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc  Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas:  - user info - send wizard  - managing faxes (outbox, sent items) - confirmation selection - cover-page management Admin UI AdminTC.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas: - user access rights - folder management - device & provider management - server cover pages - outbound routing - logging - reports BOS/SBS integration BosInteg_spec.doc Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5  Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Office integration MapiTC.doc, \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Use the Outlook COM object to automate scenarios. Straightforward test cases of sending faxes from MAPI clients. Self-host - sending faxes from outlook client. Outlook97, O2K, exchange clients. Co-existence with NT5 fax. Rendering attachments. Resolving names. Using address book. Broadcast. Add in. T.30 FSP FaxTraceRegSuites.xls, FaxTraceScripts.xls Telegra FaxTrace. Test suites of send & receive faxes to & from the fax server, that exercise the T.30 protocol. Most test suites can run un-attendant. Genoa FaxLAb. Emulation of most common 79 fax-modems to send & receive faxes to & from the fax server. Most test cases are manual. Send & receive faxes from fax service providers around the world & state. Receive faxes from fax-back services. System test - sent & received faxes will be compared. Add-hoc tests for bug fixes that are risky (like the abort-during-dialing test). Will not test class 2 / 2.0. Will not write an FSP driver. Will not use Modem-Stub to test T.30 protocol. MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Sigalit Bar Modem compatibility (remote side) Telegra & Genoa. Sending faxes to arbitrary fax number around the world / country, preferably such that return reply faxes. Analyze the T.30 log for errors. Fax client API. BroadcastTC.doc, COM_API_Issues.doc, CPRenderTC.doc Test each function, ANSI & UNICODE versions. Try to extract every possible return value. In the error case verify that the state does not change. Verify results if possible. (e.g. abort a job, verify that the job gets aborted). Verify that each property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback Illegal parameters.  Only one at a time, unless it seems reasonable. Legal parameters - equivalence classes. States. Call an API at several states (--> define scenarios). Aborting / closing / exiting while operations are performed. Multi-threading. Low resources. Use the dynamic resource-hogger tool & call the API many times, hoping that memory will run out at different places in the code. Low disk space. After each case perform a sanity check, to verify a stable state. Special coverage for broadcast API. Link W2K apps & tools with FXSAPI.LIB and test them to verify backward compatibility. Outbound (FSP) routing Setup & uninstall Inbound routing API. InRouteTC.doc We will write an inbound routing test-module that will emulate different scenarios, especially error conditions. For example emulation of routing methods that fail, faulty routing extensions that cause AV. We will use the same design and building blocks as with EFSPI testing. Co-existence with fax applications. CoExistTC.doc Manual testing mainly.  Server side Client side (Win9X, NT4, NT5) Adaptive answering. Queue functionality BroadcastTC.doc ServiceMonitor tool. API testing (pause, resume & restart a job, etc.). Specific test cases, like verifying FIFO & scheduling rules (FIFO is NOT enforced today!). A combination of client API, test FSPs and test inbound routing extensions can be used as a controlled environment that verifies operations. Scale ScaleTC.doc Lab scale tests. - many connected clients (queuing jobs and viewing them). - many concurrent fax sessions (many fax ports used concurrently).     Per FSP, and mixed FSPs. - we will define the maximum number of concurrent (uni)modem sessions.    Per FSP where applicable. SBS scale requirement is 4 modems and ~25 connected clients. For BOS we will measure our scalability. Self-host. Manual testing. other: Political issues (PoliScan). Performance. Ad-Hoc.doc CPRenderTC.doc, SrvrRender_spec.doc Adopted Automation: Cover page editor VT suite. \\nttest\ntct\slm\src\ntfax\specs\cpe.doc SimpleFax - a simple fax sending utility. Qfax - very similar to SimpleFax, but with a matrix of files x coverpage enhancement. FaxVrfy - test adaptive answering, given that it is supported. PCT & GDI tests. Automates only the printing part of several applications, with different fonts etc. No verification. We may augment it for verification that is manual today.  New automation that we added: New automation (cont.): Automation strategy and plans. Use the DCOM DTM framework for executing distributed tests.  API testing is not only simple API calls, but also tests complex scenarios, therefor automation is achieved for complex scenarios as well. C API testing is implemented in a pluggable way to the DCOM-DTM framework, and thus enables testing distributed (and system) scenarios. Note that the C API also extensively tests the server, since all client calls are RPCed to the server. The end. Comet Fax  Test Plan  Review micky snir October 28th, 1998 Updated: Oct 6th, 1999 Agenda The test team. Some statistics. Test areas. Test strategy. Test areas in details. Test areas that need spec. Existing automation. New automation that we added. Manual testing. Automation strategy. Current time estimates. The test team. Micky Snir. Sigalit Bar. Guy Merin. Miriam Scortzario Yafit Gelchinski Some bug statistics 300 NT5 fax bugs opened by the CometFax Haifa test team since July 15, 1998. 84 Fixed. 100 Comet fax bugs since February 9th, 1999  Total of 200 P1 or S1 bugs, (400 active Comet fax bugs). Fixed Comet fax bugs: 115. Test Areas and Owners Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). BOS/SBS integration (Sigalit).  Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). EFSP \ FSP Acceptance (Sigalit & Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Client API (FXSAPI.DLL) (Miri). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Guy). Inbound routing API (Guy). Co-existence with fax applications (Guy). Testing strategy Code review. Automation where possible. Ad hoc (especially UI). Validation. Each operation should be validated by the test-case. For example all sent faxes are received correctly (tiff compare), and routed correctly. Massive system and stress tests. Self-host. Extensive API testing - especially scenarios (also tests the server). Hardware coverage (server side modems & fax-boards, other side fax-devices). Tools: - gflags (memory corruption) - OH, POOLMON etc. (resource leaks) - BoundsChecker(?) - injector (fault injection) - W2K kernel-mode driver-verifier - Run under debugger - typo.pl Testing strategy, continued Extreme conditions. Memory, disk, registry, fault-inject, MPS machine. Test matrix (not all items are independent). - (Win95 x Win98 x NT4 x NT5) x (Single x MP) x (chk x fre) - (clean OS) x (OS w/ installed apps) - FSP devices, routing extensions, coexist with/out other Comet components.. - Printing applications - MAPI client applications (Outlook) Test areas in detail. Printing from applications (client side) Client UI ClientUITC.doc, \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc  Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas:  - user info - send wizard  - managing faxes (outbox, sent items) - confirmation selection - cover-page management Admin UI AdminTC.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas: - user access rights - folder management - device & provider management - server cover pages - outbound routing - logging - reports BOS/SBS integration BosInteg_spec.doc Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5  Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Office integration MapiTC.doc, \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Use the Outlook COM object to automate scenarios. Straightforward test cases of sending faxes from MAPI clients. Self-host - sending faxes from outlook client. Outlook97, O2K, exchange clients. Co-existence with NT5 fax. Rendering attachments. Resolving names. Using address book. Broadcast. Add in. T.30 FSP FaxTraceRegSuites.xls, FaxTraceScripts.xls Telegra FaxTrace. Test suites of send & receive faxes to & from the fax server, that exercise the T.30 protocol. Most test suites can run un-attendant. Genoa FaxLab. Emulation of most common 79 fax-modems to send & receive faxes to & from the fax server. Most test cases are manual. Send & receive faxes from fax service providers around the world & state. Receive faxes from fax-back services. System test - sent & received faxes will be compared. Add-hoc tests for bug fixes that are risky (like the abort-during-dialing test). Will not test class 2 / 2.0. Will not write an FSP driver. Will not use Modem-Stub to test T.30 protocol. MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Modem compatibility (remote side) Telegra & Genoa. Sending faxes to arbitrary fax number around the world / country, preferably such that return reply faxes. Analyze the T.30 log for errors. Fax client API. BroadcastTC.doc, COM_API_Issues.doc, CPRenderTC.doc Test each function, ANSI & UNICODE versions. Try to extract every possible return value. In the error case verify that the state does not change. Verify results if possible. (e.g. abort a job, verify that the job gets aborted). Verify that each property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback Illegal parameters.  Only one at a time, unless it seems reasonable. Legal parameters - equivalence classes. States. Call an API at several states (--> define scenarios). Aborting / closing / exiting while operations are performed. Multi-threading. Low resources. Use the dynamic resource-hogger tool & call the API many times, hoping that memory will run out at different places in the code. Low disk space. After each case perform a sanity check, to verify a stable state. Special coverage for broadcast API. Link W2K apps & tools with FXSAPI.LIB and test them to verify backward compatibility. Outbound (FSP) routing Setup & uninstall Inbound routing API. InRouteTC.doc We will write an inbound routing test-module that will emulate different scenarios, especially error conditions. For example emulation of routing methods that fail, faulty routing extensions that cause AV. We will use the same design and building blocks as with EFSPI testing. Co-existence with fax applications. CoExistTC.doc Manual testing mainly.  Server side Client side (Win9X, NT4, NT5) Adaptive answering. Queue functionality BroadcastTC.doc ServiceMonitor tool. API testing (pause, resume & restart a job, etc.). Specific test cases, like verifying FIFO & scheduling rules (FIFO is NOT enforced today!). A combination of client API, test FSPs and test inbound routing extensions can be used as a controlled environment that verifies operations. Scale ScaleTC.doc Lab scale tests. - many connected clients (queuing jobs and viewing them). - many concurrent fax sessions (many fax ports used concurrently).     Per FSP, and mixed FSPs. - we will define the maximum number of concurrent (uni)modem sessions.    Per FSP where applicable. SBS scale requirement is 4 modems and ~25 connected clients. For BOS we will measure our scalability. Self-host. Manual testing. other: Political issues (PoliScan). Performance. Ad-Hoc.doc CPRenderTC.doc, SrvrRender_spec.doc Adopted Automation: Cover page editor VT suite. \\nttest\ntct\slm\src\ntfax\specs\cpe.doc SimpleFax - a simple fax sending utility. Qfax - very similar to SimpleFax, but with a matrix of files x coverpage enhancement. FaxVrfy - test adaptive answering, given that it is supported. PCT & GDI tests. Automates only the printing part of several applications, with different fonts etc. No verification. We may augment it for verification that is manual today.  New automation that we added: New automation (cont.): Automation strategy and plans. Use the DCOM DTM framework for executing distributed tests.  API testing is not only simple API calls, but also tests complex scenarios, therefor automation is achieved for complex scenarios as well. C API testing is implemented in a pluggable way to the DCOM-DTM framework, and thus enables testing distributed (and system) scenarios. Note that the C API also extensively tests the server, since all client calls are RPCed to the server. The end. Help files (Yafit). SDK (Guy, Sigalit & Miri).  Adaptive answering (Guy). Queue functionality (Miri). Logging (Miri). Scale (Miri). Security (Miri). Server side rendering (Sigalit). Performance (Miri & Guy). Localization, globalization, Y2K (Miri). Modem Sharing (Guy). Image viewer. Performance counters (Yafit). MS fax tiff tags. Cover page editor. Test specs are in \\haifaslm\slmcomet\src\fax\faxtest\docs Comet Fax  Test Plan  Review micky snir October 28th, 1998 Updated: Oct 6th, 1999 Agenda The test team. Some statistics. Test areas. Test strategy. Test areas in details. Test areas that need spec. Existing automation. New automation that we added. Manual testing. Automation strategy. Current time estimates. The test team. Micky Snir. Sigalit Bar. Guy Merin. Miriam Scortzario Yafit Gelchinski Some bug statistics 300 NT5 fax bugs opened by the CometFax Haifa test team since July 15, 1998. 84 Fixed. 100 Comet fax bugs since February 9th, 1999  Total of 200 P1 or S1 bugs, (400 active Comet fax bugs). Fixed Comet fax bugs: 115. Test Areas and Owners Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). BOS/SBS integration (Sigalit).  Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). EFSP \ FSP Acceptance (Sigalit & Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Client API (FXSAPI.DLL) (Miri). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Guy). Inbound routing API (Guy). Co-existence with fax applications (Guy). Testing strategy Code review. Automation where possible. Ad hoc (especially UI). Validation. Each operation should be validated by the test-case. For example all sent faxes are received correctly (tiff compare), and routed correctly. Massive system and stress tests. Self-host. Extensive API testing - especially scenarios (also tests the server). Hardware coverage (server side modems & fax-boards, other side fax-devices). Tools: - gflags (memory corruption) - OH, POOLMON etc. (resource leaks) - BoundsChecker(?) - injector (fault injection) - W2K kernel-mode driver-verifier - Run under debugger - typo.pl Testing strategy, continued Extreme conditions. Memory, disk, registry, fault-inject, MPS machine. Test matrix (not all items are independent). - (Win95 x Win98 x NT4 x NT5) x (Single x MP) x (chk x fre) - (clean OS) x (OS w/ installed apps) - FSP devices, routing extensions, coexist with/out other Comet components.. - Printing applications - MAPI client applications (Outlook) Test areas in detail. Printing from applications (client side) Client UI ClientUITC.doc, \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc  Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas:  - user info - send wizard  - managing faxes (outbox, sent items) - confirmation selection - cover-page management Admin UI AdminTC.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas: - user access rights - folder management - device & provider management - server cover pages - outbound routing - logging - reports BOS/SBS integration BosInteg_spec.doc Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5  Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Office integration MapiTC.doc, \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Use the Outlook COM object to automate scenarios. Straightforward test cases of sending faxes from MAPI clients. Self-host - sending faxes from outlook client. Outlook97, O2K, exchange clients. Co-existence with NT5 fax. Rendering attachments. Resolving names. Using address book. Broadcast. Add in. T.30 FSP FaxTraceRegSuites.xls, FaxTraceScripts.xls Telegra FaxTrace. Test suites of send & receive faxes to & from the fax server, that exercise the T.30 protocol. Most test suites can run un-attendant. Genoa FaxLab. Emulation of most common 79 fax-modems to send & receive faxes to & from the fax server. Most test cases are manual. Send & receive faxes from fax service providers around the world & state. Receive faxes from fax-back services. System test - sent & received faxes will be compared. Add-hoc tests for bug fixes that are risky (like the abort-during-dialing test). Will not test class 2 / 2.0. Will not write an FSP driver. Will not use Modem-Stub to test T.30 protocol. MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Modem compatibility (remote side) Telegra & Genoa. Sending faxes to arbitrary fax number around the world / country, preferably such that return reply faxes. Analyze the T.30 log for errors. Fax client API. BroadcastTC.doc, COM_API_Issues.doc, CPRenderTC.doc Test each function, ANSI & UNICODE versions. Try to extract every possible return value. In the error case verify that the state does not change. Verify results if possible. (e.g. abort a job, verify that the job gets aborted). Verify that each property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback Illegal parameters.  Only one at a time, unless it seems reasonable. Legal parameters - equivalence classes. States. Call an API at several states (--> define scenarios). Aborting / closing / exiting while operations are performed. Multi-threading. Low resources. Use the dynamic resource-hogger tool & call the API many times, hoping that memory will run out at different places in the code. Low disk space. After each case perform a sanity check, to verify a stable state. Special coverage for broadcast API. Link W2K apps & tools with FXSAPI.LIB and test them to verify backward compatibility. Outbound (FSP) routing Setup & uninstall Inbound routing API. InRouteTC.doc We will write an inbound routing test-module that will emulate different scenarios, especially error conditions. For example emulation of routing methods that fail, faulty routing extensions that cause AV. We will use the same design and building blocks as with EFSPI testing. Co-existence with fax applications. CoExistTC.doc Manual testing mainly.  Server side Client side (Win9X, NT4, NT5) Adaptive answering. Queue functionality BroadcastTC.doc ServiceMonitor tool. API testing (pause, resume & restart a job, etc.). Specific test cases, like verifying FIFO & scheduling rules (FIFO is NOT enforced today!). A combination of client API, test FSPs and test inbound routing extensions can be used as a controlled environment that verifies operations. Scale ScaleTC.doc Lab scale tests. - many connected clients (queuing jobs and viewing them). - many concurrent fax sessions (many fax ports used concurrently).     Per FSP, and mixed FSPs. - we will define the maximum number of concurrent (uni)modem sessions.    Per FSP where applicable. SBS scale requirement is 4 modems and ~25 connected clients. For BOS we will measure our scalability. Self-host. Manual testing. other: Political issues (PoliScan). Performance. Ad-Hoc.doc CPRenderTC.doc, SrvrRender_spec.doc Adopted Automation: Cover page editor VT suite. \\nttest\ntct\slm\src\ntfax\specs\cpe.doc SimpleFax - a simple fax sending utility. Qfax - very similar to SimpleFax, but with a matrix of files x coverpage enhancement. FaxVrfy - test adaptive answering, given that it is supported. PCT & GDI tests. Automates only the printing part of several applications, with different fonts etc. No verification. We may augment it for verification that is manual today.  New automation that we added: New automation (cont.): Automation strategy and plans. Use the DCOM DTM framework for executing distributed tests.  API testing is not only simple API calls, but also tests complex scenarios, therefor automation is achieved for complex scenarios as well. C API testing is implemented in a pluggable way to the DCOM-DTM framework, and thus enables testing distributed (and system) scenarios. Note that the C API also extensively tests the server, since all client calls are RPCed to the server. The end. Comet Fax  Test Plan  Review micky snir October 28th, 1998 Updated: Oct 6th, 1999 Agenda The test team. Some statistics. Test areas. Test strategy. Test areas in details. Test areas that need spec. Existing automation. New automation that we added. Manual testing. Automation strategy. Current time estimates. The test team. Micky Snir. Sigalit Bar. Guy Merin. Miriam Scortzario Yafit Gelchinski Some bug statistics 300 NT5 fax bugs opened by the CometFax Haifa test team since July 15, 1998. 84 Fixed. 100 Comet fax bugs since February 9th, 1999  Total of 200 P1 or S1 bugs, (400 active Comet fax bugs). Fixed Comet fax bugs: 115. Test Areas and Owners Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). BOS/SBS integration (Sigalit).  Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). EFSP \ FSP Acceptance (Sigalit & Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Client API (FXSAPI.DLL) (Miri). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Guy). Inbound routing API (Guy). Co-existence with fax applications (Guy). Testing strategy Code review. Automation where possible. Ad hoc (especially UI). Validation. Each operation should be validated by the test-case. For example all sent faxes are received correctly (tiff compare), and routed correctly. Massive system and stress tests. Self-host. Extensive API testing - especially scenarios (also tests the server). Hardware coverage (server side modems & fax-boards, other side fax-devices). Tools: - gflags (memory corruption) - OH, POOLMON etc. (resource leaks) - BoundsChecker(?) - injector (fault injection) - W2K kernel-mode driver-verifier - Run under debugger - typo.pl Testing strategy, continued Extreme conditions. Memory, disk, registry, fault-inject, MPS machine. Test matrix (not all items are independent). - (Win95 x Win98 x NT4 x NT5) x (Single x MP) x (chk x fre) - (clean OS) x (OS w/ installed apps) - FSP devices, routing extensions, coexist with/out other Comet components.. - Printing applications - MAPI client applications (Outlook) Test areas in detail. Printing from applications (client side) Client UI ClientUITC.doc, \\nttest\ntct\slm\src\ntfax\specs\faxsend.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc  Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas:  - user info - send wizard  - managing faxes (outbox, sent items) - confirmation selection - cover-page management Admin UI AdminTC.doc, \\nttest\ntct\slm\src\ntfax\specs\printer.doc Ad-hoc & manual testing. Use Visual test to automate test cases. Test the underlying API. Sub areas: - user access rights - folder management - device & provider management - server cover pages - outbound routing - logging - reports BOS/SBS integration BosInteg_spec.doc Setup integration. We will enhance our setup test tools to include specific tests for BOS \ SBS setup and upgrade scenarios. We will develop additional tools to verify the migration of settings and files from SBS 4.5  Computer Management.  Tests will be mainly manual, targeting the initial integration point, namely the Computer Management Console, verifying that our MMC snapin is loaded and responsive. Office integration MapiTC.doc, \\nttest\ntct\slm\src\ntfax\specs\mapi.doc Use the Outlook COM object to automate scenarios. Straightforward test cases of sending faxes from MAPI clients. Self-host - sending faxes from outlook client. Outlook97, O2K, exchange clients. Co-existence with NT5 fax. Rendering attachments. Resolving names. Using address book. Broadcast. Add in. T.30 FSP FaxTraceRegSuites.xls, FaxTraceScripts.xls Telegra FaxTrace. Test suites of send & receive faxes to & from the fax server, that exercise the T.30 protocol. Most test suites can run un-attendant. Genoa FaxLab. Emulation of most common 79 fax-modems to send & receive faxes to & from the fax server. Most test cases are manual. Send & receive faxes from fax service providers around the world & state. Receive faxes from fax-back services. System test - sent & received faxes will be compared. Add-hoc tests for bug fixes that are risky (like the abort-during-dialing test). Will not test class 2 / 2.0. Will not write an FSP driver. Will not use Modem-Stub to test T.30 protocol. MS Inbound routing extension. EFSP \ FSP Acceptance EFSPI Modem compatibility (server side) Modem compatibility (remote side) Telegra & Genoa. Sending faxes to arbitrary fax number around the world / country, preferably such that return reply faxes. Analyze the T.30 log for errors. Fax client API. BroadcastTC.doc, COM_API_Issues.doc, CPRenderTC.doc Test each function, ANSI & UNICODE versions. Try to extract every possible return value. In the error case verify that the state does not change. Verify results if possible. (e.g. abort a job, verify that the job gets aborted). Verify that each property can be set, without affecting other properties. We are especially interested in the cases where the set operation fails, in order to verify rollback Illegal parameters.  Only one at a time, unless it seems reasonable. Legal parameters - equivalence classes. States. Call an API at several states (--> define scenarios). Aborting / closing / exiting while operations are performed. Multi-threading. Low resources. Use the dynamic resource-hogger tool & call the API many times, hoping that memory will run out at different places in the code. Low disk space. After each case perform a sanity check, to verify a stable state. Special coverage for broadcast API. Link W2K apps & tools with FXSAPI.LIB and test them to verify backward compatibility. Outbound (FSP) routing Setup & uninstall Inbound routing API. InRouteTC.doc We will write an inbound routing test-module that will emulate different scenarios, especially error conditions. For example emulation of routing methods that fail, faulty routing extensions that cause AV. We will use the same design and building blocks as with EFSPI testing. Co-existence with fax applications. CoExistTC.doc Manual testing mainly.  Server side Client side (Win9X, NT4, NT5) Adaptive answering. Queue functionality BroadcastTC.doc ServiceMonitor tool. API testing (pause, resume & restart a job, etc.). Specific test cases, like verifying FIFO & scheduling rules (FIFO is NOT enforced today!). A combination of client API, test FSPs and test inbound routing extensions can be used as a controlled environment that verifies operations. Scale ScaleTC.doc Lab scale tests. - many connected clients (queuing jobs and viewing them). - many concurrent fax sessions (many fax ports used concurrently).     Per FSP, and mixed FSPs. - we will define the maximum number of concurrent (uni)modem sessions.    Per FSP where applicable. SBS scale requirement is 4 modems and ~25 connected clients. For BOS we will measure our scalability. Self-host. Manual testing. other: Political issues (PoliScan). Performance. Ad-Hoc.doc CPRenderTC.doc, SrvrRender_spec.doc Adopted Automation: Cover page editor VT suite. \\nttest\ntct\slm\src\ntfax\specs\cpe.doc SimpleFax - a simple fax sending utility. Qfax - very similar to SimpleFax, but with a matrix of files x coverpage enhancement. FaxVrfy - test adaptive answering, given that it is supported. PCT & GDI tests. Automates only the printing part of several applications, with different fonts etc. No verification. We may augment it for verification that is manual today.  New automation that we added: New automation (cont.): Automation strategy and plans. Use the DCOM DTM framework for executing distributed tests.  API testing is not only simple API calls, but also tests complex scenarios, therefor automation is achieved for complex scenarios as well. C API testing is implemented in a pluggable way to the DCOM-DTM framework, and thus enables testing distributed (and system) scenarios. Note that the C API also extensively tests the server, since all client calls are RPCed to the server. The end.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\upgradescenariostest_appendixa.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft, Haifa. Things to check in Performance Monitoring   new counters TitleThings to check in Performance Monitoring   new counters Yafit Gelchinski Normal Yafit Gelchinski Microsoft Word 9.0R[&,\ V"TC0( kxVNv Performance Monitoring test spec.docbjbjU Appendix A   Client Upgrade Tests The full list of tests which are to be covered in the scope of setup and upgrade testing is included here. I ve noted which tests will include Win2k and Whistler clients, since a personal fax (NT Fax) is a non-optional component of these operating systems. Note that some of the tests will be done for only half of the clients, the other half to be used for a similar test. This is because there is no difference between the SBS 5.0 Fax and Modem Sharing services binaries and the binaries of BOS 5.0. Stage 1   installing Fax Server client 5.0 for the first time. The client doesn t have a fax client or a personal fax installed. In this case the client either has no BackOffice client installed, or has the BOS 4.5 client installed. The following tests will not be done for Win2k and Whistler clients, since their NT Fax component is a non-optional component of the operating system. Client SBS 5.0 ( Client w/ SBS 5.0 fax client (50% coverage, due to full coverage of item A2.) Client BOS 5.0 ( Client w/ BOS 5.0 fax client Client w/ BOS 4.5 BOS 5.0 ( Client w/ BOS 5.0 fax client The client has a personal fax installed. In this case the client is not Win2k. The case of Win2k is covered by item G. Client w/ personal fax SBS 5.0 ( Client w/ SBS 5.0 fax client and personal fax (50% coverage, due to full coverage of item B2.) Client w/ personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax Client w/ BOS 4.5 and personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax The client has an older version of the fax client installed, with qfe In this case the client either has SBS 4.5 with qfe installed, or BOS 4.5 with fax client 4.5 qfe installed. The latter is a result of a SBS 4.5 client with qfe upgraded to BOS 4.5, since the fax service was not removed when the server was upgraded. Client w/ SBS 4.5 with qfe fax client SBS 5.0 ( Client w/ SBS 5.0 fax client (50% coverage, the other possibilities covered by C2.) Client w/ SBS 4.5 with qfe fax client BOS 5.0 ( Client w/ BOS 5.0 fax client (50%) Client w/ fax client 4.5 with qfe on BOS 4.5 BOS 5.0 ( Client w/ BOS 5.0 fax client The client has an older version of the fax client installed, without qfe In this case the client either has SBS 4.5 (without qfe) installed, or BOS 4.5 with fax client 4.5 installed. The latter is a result of a SBS 4.5 client (without qfe) upgraded to BOS 4.5, since the fax service was not removed when the server was upgraded. Client w/ SBS 4.5 w/o qfe fax client SBS 5.0 ( Client w/ SBS 5.0 fax client (50% coverage, the other possibilities covered by D2.) Client w/ SBS 4.5 w/o qfe fax client BOS 5.0 ( Client w/ BOS 5.0 fax client (50%) Client w/ fax client 4.5 w/o qfe on BOS 4.5 BOS 5.0 ( Client w/ BOS 5.0 fax client The client has both an older version of the fax client with qfe, and a personal fax installed. In this case the client can have either SBS 4.5 w/qfe fax client installed or BOS 4.5 with the SBS 4.5 w/ qfe fax client installed. For Win2k and Whistler clients, these tests are covered by item H. Client w/ SBS 4.5 fax client and personal fax SBS 5.0 ( Client w/ SBS 5.0 fax client and personal fax (50% coverage, the other possibilities covered by E2.) Client w/ SBS 4.5 fax client and personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax (50%) Client w/ fax client 4.5 on BOS 4.5 and personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax The client has both an older version of the fax client (without qfe), and a personal fax installed. In this case the client can have either SBS 4.5 fax client installed or BOS 4.5 with the SBS 4.5 fax client installed. For Win2k and Whistler clients, these tests are covered by item I. Client w/ SBS 4.5 fax client and personal fax SBS 5.0 ( Client w/ SBS 5.0 fax client and personal fax (50% coverage, the other possibilities covered by F2.) Client w/ SBS 4.5 fax client and personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax (50%) Client w/ fax client 4.5 on BOS 4.5 and personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax The following tests will be done only on Win2k and Whistler clients, which have a non-optional fax component as part of their underlying operating system, as well as needing the Quick Fix installed on any Fax Server 4.5 of which they are clients. The client has NT Fax service installed (Win2k clients only). In this case the client s base operating system is Win2k or Whistler, and it may have BOS 4.5 installed. Win2k+ w/ NT Fax SBS 5.0 ( Win2k w/ SBS 5.0 fax client and NT Fax Win2k+ w/ NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax Win2k+ w/ BOS 4.5 and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax The client has NT Fax server and a working fax client 4.5 installed (SBS 4.5 fax client w/ qfe, Win2k and Whistler clients only). Win2k and Whistler can have a working SBS 4.5 fax client installed or BOS 4.5 with the SBS 4.5 fax client installed, after a quick fix has been added to the server. Win2k+ w/ SBS 4.5 fax client w/ qfe and NT Fax SBS 5.0 ( Win2k w/ SBS 5.0 fax client and NT Fax Win2k+ w/ SBS 4.5 fax client w/ qfe and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax Win2k+ w/ fax client 4.5 w/ qfe on BOS 4.5 and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax The client NT Fax server and a non-working fax client 4.5 installed (SBS 4.5 fax client without qfe, on Win2k and Whistler clients only). Win2k and Whistler can have SBS 4.5 fax client installed or BOS 4.5 with the SBS 4.5 fax client installed, but not working properly. Win2k+ w/ SBS 4.5 fax client without qfe and NT Fax SBS 5.0 ( Win2k w/ SBS 5.0 fax client and NT Fax Win2k+ w/ SBS 4.5 fax client without qfe and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax Win2k+ w/ fax client 4.5 without qfe on BOS 4.5 and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax Stage 2   the client already has Fax Server client 5.0 installed.  Upgrade client from SBS 5.0 client to BOS 5.0 client. The client can be of any of the operating systems supported, with or without a personal fax (or NT Fax for Win2k and Whistler). Each operating system will be checked with only one of the possibilities (w/ personal fax or w/o personal fax). Client w/ SBS 5.0 fax client BOS 5.0 ( Client w/ BOS 5.0 fax client (50% of the operating systems which don t include NT Fax.) Client w/ SBS 5.0 fax client and personal fax BOS 5.0 ( Client w/ BOS 5.0 fax client and personal fax (The remaining client operating systems.)  Installing a personal fax on the client. In this case the client can have either SBS 5.0 or BOS 5.0 fax client installed, but the operating system is not Win2k or Whistler (for which the personal (NT) fax is not an optional component of the basic system). Client w/ SBS 5.0 fax client fax ( Client w/ SBS 5.0 fax client and personal fax (50% of the client operating systems.) Client w/ BOS 5.0 fax client fax ( Client w/ BOS 5.0 fax client and personal fax  Upgrade the client s operating system. In this case the client can have either SBS 5.0 or BOS 5.0 fax client, and be with or without a personal fax (or NT Fax service installed, in the case of Win2k and Whistler). Only some of the cases will be tested to cover most of the possible scenarios, others will be tested if time (see explanation below). Client w/ SBS 5.0 fax client OS upgrade ( Client w/ SBS 5.0 fax client Client w/ BOS 5.0 fax client OS upgrade ( Client w/ BOS 5.0 fax client Client w/ SBS 5.0 fax client and personal fax OS upgrade ( Client w/ SBS 5.0 fax client and personal fax Client w/ BOS 5.0 fax client and personal fax OS upgrade ( Client w/ BOS 5.0 fax client and personal fax Following is a matrix of the operating system upgrades existing today or which will exist in the near future, that Fax and Modem Sharing must support. Win95, Gold Win95, OSR2 Win98, 1st ed. Win98, CSP Win98, 2nd ed. Millennium WinNT 4, SP3 WinNT 4, SP4 WinNT 4, SP5 WinNT 4, SP6 WinNT 4, SP7 Win2k, Pro Win2k, SP1 Whistler, Std Whistler, Pro Win95, Gold Win95, OSR2 Win98, 1st ed. Win98, CSP Win98, 2nd ed. Millennium WinNT 4, SP3 WinNT 4, SP4 WinNT 4, SP5 WinNT 4, SP6 WinNT 4, SP7 Win2k, Pro Win2k, SP1 Whistler, Std Whistler, Pro Table 1: Client operating system upgrade matrix. In order to cover most scenarios (the rare scenarios will be left aside, to be checked if time allows us), and taking into consideration that upgrading from a base operating system to the same operating system with a service pack is a two-step process, the following tests will be done: Win95, Gold edition ( Win98, 1st edition Win95, Gold edition ( Win98, 2nd edition Win95, Gold edition ( Millennium Win95, Gold edition ( Win2k Professional edition Win95, Gold edition ( Whistler, Standard edition Win95, Gold edition ( Whistler, Professional edition Win95, OSR2 edition ( Win98, 1st edition Win95, OSR2 edition ( Win98, 2nd edition Win95, OSR2 edition ( Millennium Win95, OSR2 edition ( Win2k Professional edition Win95, OSR2 edition ( Whistler, Standard edition Win95, OSR2 edition ( Whistler, Professional edition Win98, 2nd edition ( Millennium Win98, 2nd edition ( Win2k Professional edition Win98, 2nd edition ( Whistler, Standard edition Win98, 2nd edition ( Whistler, Professional edition Millennium ( Win2k Professional edition Millennium ( Whistler, Standard edition Millennium ( Whistler, Professional edition WinNT 4 workstation ( WinNT 4 workstation, SP3 WinNT 4 workstation ( WinNT 4 workstation, SP4 WinNT 4 workstation ( WinNT 4 workstation, SP5 WinNT 4 workstation ( WinNT 4 workstation, SP6 WinNT 4 workstation ( WinNT 4 workstation, SP7 WinNT 4 workstation, SP3 ( WinNT 4 workstation, SP4 WinNT 4 workstation, SP3 ( Win2k Professional edition WinNT 4 workstation, SP3 ( Whistler, Standard edition WinNT 4 workstation, SP3 ( Whistler, Professional edition WinNT 4 workstation, SP4 ( WinNT 4 workstation, SP5 WinNT 4 workstation, SP5 ( WinNT 4 workstation, SP6 WinNT 4 workstation, SP6 ( WinNT 4 workstation, SP7 WinNT 4 workstation, SP7 ( Win2k Professional edition WinNT 4 workstation, SP7 ( Whistler, Standard edition WinNT 4 workstation, SP7 ( Whistler, Professional edition Win2k, Professional edition ( Win2k, SP1 Win2k, Professional edition ( Whistler, Professional edition Win2k, SP1 ( Whistler, Professional edition Whistler, Standard edition ( Whistler, Professional edition Since some of these operating systems are similar to others, each of the four test items mentioned above will be tested with only part of these upgrades. The specific tests and their schedule can be found in Appendix C (the test scheme). SBS 4.5 clients upgraded to Win2k. There are special scenarios of an existing SBS 4.5 client upgraded to Win2k are to be partially tested. For each test a list of clients is given. Testing will be done for client operating systems to ensure that after the installation of SBS 5.0 or BOS 5.0 client, the system recovers and the connection between server and client is restored. Client w/ SBS 4.5 fax client Win2k ( Win2k w/ SBS 4.5 fax client SBS 5.0 ( Win2k w/ SBS 5.0 fax client Clients: Win95, Gold edition Millennium WinNT 4, SP3 Client w/ SBS 4.5 fax client Win2k ( Win2k w/ SBS 4.5 fax client BOS 5.0 ( Win2k w/ BOS 5.0 fax client Clients: Win95, OSR2 edition Win98, 1st edition WinNT 4, SP4 Client w/ SBS 4.5 fax client and personal fax Win2k ( Win2k w/ SBS 4.5 fax client and NT Fax SBS 5.0 ( Win2k w/ SBS 5.0 fax client and NT Fax Clients: Win95, OSR2 edition Win98, 2nd edition WinNT 4, SP5 Client w/ SBS 4.5 fax client and personal fax Win2k ( Win2k w/ SBS 4.5 fax client and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax Clients: Win95, Gold edition Win98, 1st edition WinNT 4, SP6 Client w/ fax client 4.5 on BOS 4.5 Win2k ( Win2k w/ fax client 4.5 on BOS 4.5 BOS 5.0 ( Win2k w/ BOS 5.0 fax client Clients: Win95, OSR2 edition Millennium WinNT 4, SP7 Client w/ fax client 4.5 on BOS 4.5 and personal fax Win2k ( Win2k w/ fax client 4.5 on BOS 4.5 and NT Fax BOS 5.0 ( Win2k w/ BOS 5.0 fax client and NT Fax Clients: Win95, Gold edition Win98, 2nd edition WinNT 4, SP4 Upgrade Scenario Testing Page   PAGE   NUMPAGES  Microsoft Confidential  AUTHOR  Yafit Gelchinski  DATE  4/17/2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\old\clientuitc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server Title _PID_GUIDCover Page Rendering On Server Sigalit Bar Normal.dot Sigalit Bar Microsoft Word 8.0CometFax Client UI Test Cases: Preface  All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). Test Strategy: Ad-hoc & Manual testing.  UI automation is dangerous because -  It may miss simple bugs that the eye catches easily.  UI may change, thus tests need to be changed accordingly.  Ad hoc is the best in UI testing. Strive to automatically test the UI all the way from the GUI to functionality verification. Due to lack of time we may settle for verification of information propagation (from GUI to the service), as opposed to complete functionality verification.  We will only test that GUI changes the CometFax COM objects correctly, relying on the COM layer tests to validate further functionality. Issues: At the time this document is written (30-Mar-99) the Development specification for the Client UI has not yet been completed. No matter whether Client UI implementation uses internal C API or COM API we want to use COM API to examine the service and verify information propagation. Any special  handling  required if UI uses C API? [TBD] Implementation Strategy: For manual testing we will compose a detailed specification for all test cases, including instructions explaining how to carry out each test case and a description of each test case s expected results. Test Categories: Code Review.  MS code.   MS code (?). Win9X   3rd party (?). Several printers installed on same client machine. Verify UI can  connect  to all installed printers. Verify UI show Co-existence with other MS fax applications Fax Send Wizard. Verify all installed printers are enumerated on  Select Printer  page (1st page). Verify proper enforcement of canonical number. Verify proper interaction with  Address book  of default email provider. Verify all server \ personal cover pages are enumerated on the wizard Select Cover Page  page. Verify that many recipients can be  Added  and  Removed  to create a broadcast fax. Verify all information the user specifies in the wizard is passed on correctly. E.g. the send job is scheduled correctly; the correct cover page is used, etc. Verify the wizard allows going to the next page, only after all required (non-optional) information in current page has been set. Outbox. Verify that broadcast jobs are properly displayed. Verify job states are correctly (and automatically) updated. Verify jobs are displayed in correct order. Verify only logged on user outgoing jobs are displayed. Verify job actions (Cancel \ Pause \ etc) are correctly carried-out. Verify jobs are removed from Outbox as soon as they complete.  Especially check broadcast jobs where some recipients were canceled, others failed, and some succeeded. Sent Items. Verify that all sent items of logged on user on all installed servers (printers) are enumerated. Verify that a proper indication exists for any unavailable installed server. Verify that concluded broadcast jobs are correctly displayed. Verify job actions (Open \ Save as \ Delete \ Properties) are correctly carried-out. Cover Pages. Verify that all server cover pages are enumerated. Verify all logged on user personal cover pages are enumerated according if  Allow Personal Cover Pages  server is set to TRUE. Verify that UI prevents deletion of server cover pages by a non-admin user. User Information. Located under the  Tools  menu item. Options   TBD. Located under the  Tools  menu item. Functionality in a system where user security is not available. UI Enabled \ Disabled items. Verify that menu items are enabled or disabled according to the state of the selected object. Same for fields in property pages and wizard. Same for any buttons. UI Multiple Selection. UI Refresh. UI Action Menu items. Verify all menu items defined for the selected object appear in the Actions menu. UI Right Click Menu items Verify all menu items defined for the selected object appear in the  Right Click  menu. UI Layout.  Verify all UI entities are of correct size, color, font, etc.  [TBD] Client UI test parameters: Number of CometFax printers installed. User permissions on installed printers. Address Book Contact List Entries in  Address Book E.g. entries using canonical numbers, no entries at all, etc. Server \ Personal cover pages. Fields in  Send Fax Wizard E.g. send a broadcast job scheduled for discount rates or send to a single recipient now. Outgoing jobs queued. E.g. many jobs queued simultaneously, many concurrent jobs, jobs from many users, jobs to many servers, etc. Incoming jobs. E.g. no incoming jobs, many incoming jobs on single server, incoming jobs on all servers, etc. Archived (completed) jobs. E.g. no archived jobs, many archived jobs on all servers, archived jobs of many users, etc. [TBD] CometFax Client UI Test Cases  TIME \@ "d-MMM-yy"  31-Mar-99 Microsoft Confidential Sigalit Bar (sigalitb) |tld\T wog_WOG? }ume]UME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\whistler\whistlertestplan.ppt ===
Fax Test Plan Whistler Sigalit Bar March 16th, 2000 Agenda Test Automation to be ported to WhistlerFax  New Automation Required Manual testing. Automation strategy. Current time estimates (?) The test team Sigalit Bar Guy Merin Lior Shmueli 1 TBH WhistlerFax Test Areas  Test Areas common to Whistler and BOS Fax Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Yafit). Inbound routing API (Guy). Co-existence with fax applications (Guy). Help files (Sigalit). SDK (Guy, Sigalit & Miri).  WhistlerFax Test Areas  Whistler only Test Areas OCM Setup & Uninstall Upgrade Scenarios 64 bit UI Functionality (new Whistler UI) Send Wizard     - BOS Fax UI Client Console  - BOS Fax UI Admin MMC    - BOS Fax UI Status Monitor (?) Control Panel applet (?) Outlook Extension (?) Sent Items Folder Shell Extension (?) Image Viewer (new Whistler Viewer) Legacy C\COM Client API  WINFAX.DLL FAXCOM.DLL Extended COM Client API  FAXCOMEX.DLL Routing Extension and  FSP Registration directly to Registry  (and not via FaxRegister* API) Archives on FAT Whistler Testing strategy Utilize existing BOS5.0 Fax test tools. Salvage what we can from the existing W2K Fax automated tests. Extensive Legacy API and Extended COM API testing. Test all Whistler flavors (as Server) wks standard / wks professional / srv / dtc / ent, free and checked. Test Win95, Win98, Millennium, NT4, NT5, Whistler wks, in both checked and free versions as Clients. Whistler Testing strategy continued Much of the test strategy for BOS5.0 Fax is also applicable here. Code Review Ad hoc (especially UI). Validation in Automation. Massive system and stress tests. Self-Host. Hardware Coverage. Extreme Conditions. Using tools like gflags, OH, injector, etc. Test areas in detail Whistler  Test Area Details Test Areas that need spec Existing W2K Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing continued Existing BOS5.0 Automation available for Whistler Fax testing continued New Test Automation we will develop Manual Tests Manual Tests continued Image Viewer. MS Fax Tiff Tags.  Modem Compatibility.  It is very possible we will not have time to develop automation for this. Co-existence with fax applications. Performance Counters. Queue functionality. Logging. The End Click to edit Master title style Click to edit Master text styles Second Level Third Level Fourth Level Fifth Level Click to edit Master title style Click to edit Master subtitle style Click to edit Master text styles Second level Third level Fourth level Fifth level Whistler Fax Test Plan MS Confidential Sigalit Bar (sigalitb), * The test team. WhistlerFax Test Areas. WhistlerFax Test Strategy. WhistlerFax Test areas in details - TBD Test areas that need spec (?) Existing BosFax automation. Adaptive answering (Guy). Queue functionality (Miri). Logging (Miri). Scale (Miri). Security (Miri). Server side rendering (Sigalit). Performance (Miri & Guy). Localization, globalization, Y2K  (Yafit & Miri). Performance counters (Yafit). MS fax tiff tags (Yafit). Cover page editor (Yafit). * Parenthesis indicate test member responsible for the test area in BOS Fax Devices Cache and outbound routing device information  DRT to Local MAPI Inbox (DRT_INBOX) enabled when sending via local fax service, disabled when sending via remote fax service. Whistler as SBS/BOS Client (Server?) SBS/BOS4.5 (with / without QFE) and SBS/BOS5.0 Personal Fax only on Whistler Personal Sharing is enabled only on Whistler Professional and higher flavors.  On Personal Whistler Fax is a personal fax. Shell notifications Inbound routing to local Inbox Fax Configuration Wizard Fax Printer Properties Manual Answer Test specs will be available at: \\haifaslm\slmcomet\src\fax\faxtest\docs\whistler ETA: 27-Mar ETA: 27-Mar Automated tests to be ported from BOS5.0 Fax to Whistler Fax with minimal effort: Automated tests to be ported from BOS5.0 Fax to Whistler Fax with minimal effort: (continued) Automated tests to be ported from BOS5.0 Fax to Whistler Fax with minimal effort: (continued) We will examine developing the following automated tests and tools: Comet fax test plan summary micky snir Sigalit Bar Microsoft PowerPoint 7.0 Times New Roman Fax Test Plan Times New Roman Whistler5 Times New Roman Sigalit Bara March 16th, 2000 "System Overhead Times New Roman Arial Narrow Arial Monotype Sorts Symbol Default Design Fax Test Plan   Whistler Agenda The test team WhistlerFax Test Areas  Test Areas common to Whistler and BOS Fax WhistlerFax Test Areas  Whistler only Test Areas Whistler Testing strategy Whistler Testing strategy continued Test areas in detail Whistler  Test Area Details Test Areas that need spec Existing W2K Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing continued Existing BOS5.0 Automation available for Whistler Fax testing continued New Test Automation we will develop Manual Tests Manual Tests continued The End Fonts Used Design Template Slide Titles _PID_GUID _PID_HLINKS Sigalit Bar Fax Test Plan Whistler Sigalit Bar March 16th, 2000 Agenda Test Automation to be ported to WhistlerFax  New Automation Required Manual testing. Automation strategy. Current time estimates (?) The test team Sigalit Bar Guy Merin Lior Shmueli 1 TBH WhistlerFax Test Areas  Test Areas common to Whistler and BOS Fax Printing from applications (Sigalit). Client UI (Miri).  Admin UI (Miri). Office integration (Guy). T.30 FSP (Sigalit). MS Inbound routing extension (Guy). EFSPI (Sigalit).  Modem compatibility (Guy). Outbound (FSP) routing (Sigalit). Setup (& uninstall) (Yafit). Inbound routing API (Guy). Co-existence with fax applications (Guy). Help files (Sigalit). SDK (Guy, Sigalit & Miri).  WhistlerFax Test Areas  Whistler only Test Areas OCM Setup & Uninstall Upgrade Scenarios 64 bit UI Functionality (new Whistler UI) Send Wizard     - BOS Fax UI Client Console  - BOS Fax UI Admin MMC    - BOS Fax UI Status Monitor (?) Control Panel applet (?) Outlook Extension (?) Sent Items Folder Shell Extension (?) Image Viewer (new Whistler Viewer) Legacy C\COM Client API  WINFAX.DLL FAXCOM.DLL Extended COM Client API  FAXCOMEX.DLL Routing Extension and  FSP Registration directly to Registry  (and not via FaxRegister* API) Archives on FAT Whistler Testing strategy Utilize existing BOS5.0 Fax test tools. Salvage what we can from the existing W2K Fax automated tests. Extensive Legacy API and Extended COM API testing. Test all Whistler flavors (as Server) wks standard / wks professional / srv / dtc / ent, free and checked. Test Win95, Win98, Millennium, NT4, NT5, Whistler wks, in both checked and free versions as Clients. Whistler Testing strategy continued Much of the test strategy for BOS5.0 Fax is also applicable here. Code Review Ad hoc (especially UI). Validation in Automation. Massive system and stress tests. Self-Host. Hardware Coverage. Extreme Conditions. Using tools like gflags, OH, injector, etc. Test areas in detail Whistler  Test Area Details Test Areas that need spec Existing W2K Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing continued Existing BOS5.0 Automation available for Whistler Fax testing continued New Test Automation we will develop Manual Tests Manual Tests continued Image Viewer. MS Fax Tiff Tags.  Modem Compatibility.  It is very possible we will not have time to develop automation for this. Co-existence with fax applications. Performance Counters. Queue functionality. Logging. The End ETA: 15-Jun ETA: 15-Jun Overhead Times New Roman Arial Narrow Arial Monotype Sorts Symbol Default Design Fax Test Plan   Whistler Agenda The test team WhistlerFax Test Areas  Test Areas common to Whistler and BOS Fax WhistlerFax Test Areas  Whistler only Test Areas Whistler Testing strategy Whistler Testing strategy continued Test areas in detail Whistler  Test Area Details Test Areas that need spec Existing W2K Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing Existing BOS5.0 Automation available for Whistler Fax testing continued Existing BOS5.0 Automation available for Whistler Fax testing continued New Test Automation we will develop Manual Tests Manual Tests continued The End Fonts Used Design Template Slide Titles _PID_GUID _PID_HLINKS Sigalit Bar
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\old\admintc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Cover Page Rendering On Server Title _PID_GUIDCover Page Rendering On Server Sigalit Bar Normal.dot micky snir Microsoft Word 8.0CometFax Admin COM Interface & UI Test Cases: Preface  All following test cases refer to a client server constellation and should be run once when server and client are installed on the same machine, and once when they are installed on two different machines (where client is NT5 \ Win9x \ NT4). Every test case below must be invoked using C\C++ COM and again using VB COM. Test Strategy: Ad-hoc & Manual testing.  UI automation is dangerous because -  It may miss simple bugs that the eye catches easily.  UI may change, thus tests need to be changed accordingly.  Ad hoc is the best in UI testing. Test the COM layer separately from the UI layer. Strive to automatically test the UI all the way from the GUI to the verify functionality, but if no time, will only test that GUI changes the COM object correctly, and relying on the COM layer tests to validate further functionality. Use AutoCOM to implement a basic  Set-Get Test  suite for all object properties. Suite will focus on R\W characteristics and valid \ invalid values.  Compose a  Behavior Verification Test  suite that verifies the service behaves according to the objects  settings. Test cases will be property specific, that is, each test case will set a single object property and verify its affect on service behavior.  If time permits we will also implement more complex test cases. We will try to plug the behavior verification test into the AutoCom code, and code reusing. Note that AutoCom will provide only simple test cases, so complex scenarios cannot easily use AutoCom code. We will strive to use the COM interface in other tests wherever possible. Specifically in  Scale Lab  tests, and in writing any additional testing tools. Issues: At the time this document is written (29-Mar-99) the Development specification for the Admin COM interface and UI has not yet been completed. Since Admin COM and UI development is progressing slowly we are forced to develop testing tools (for other test areas) using the internal C APIs. At least some, if not most, of these tools are relevant for Admin COM & UI testing and thus will have to be converted to use the COM interface. [TBD] Implementation Strategy: Implementation will be incremental. Implement the basic  Set-Get Test  suite. Due to vast scope of the  Behavior Verification Test  suite we will first determine the properties more crucial (important and higher risk) for testing and the extent of coverage each should receive. We will compose a fully detailed test case list for each property (in addition to this document). Serially implement the above test cases. Test Categories: Code Review. Concurrent admin sessions We accept inconsistencies due to concurrent sessions, but we do not accept AV s, unstable COM objects etc. Verify that concurrent admin sessions of completely different areas are successful as if they were not concurrent. Verify that concurrent admin sessions that should have been mutually exclusive leave the admin in a stable and coherent state. Client: verify that each logged on user has its own settings, and where possible import from DS of NT fax settings.. COM Objects in general. Verify setting and getting of properties complies with property R\W specifications. Verify setting properties to valid \ invalid values. Verify Enumeration and Item methods for collections function correctly (for zero \ one \ many items). Verify all object properties are persistent through service stop and start. Fax Device settings. Verify devices answer calls and send faxes according to send \ receive settings. Verify setting of a device s priority affects the priorities of all other devices on the same server, and does not affect priorities of devices on other servers in the array. Array. Verify Admin enumerates devices, incoming jobs, outgoing jobs, archived files, and routing rules from all the servers in the array, indicating the correct server name for each. Make sure that COM objects and UI properly indicate that servers in the array are down. Outgoing Queue. Object and UI must show only outgoing jobs of all users. First release will have a single Outgoing queue for all the servers in the array, but later releases will have an Outgoing queue per server. Verify   and  Submit  properties of COM object (see  Fax COM Functionality  p.8) induce correct service functionality. That is, if Send=FALSE then send jobs should be queued but not executed (queue is paused) and if Submit=FALSE then jobs cannot be queued. Send & Submit also affects the behavior of the Send method. Check behavior for Send=TRUE and Submit=FALSE. Incoming Queue. Object and UI must show only incoming jobs of all users. Verify persistence. Especially make sure object correctly  loads up  at service start up, according to state of incoming queue directory. Sent & Received Archive. Verify the relation between  Documents  sub-object and the  ArchivePolicy  sub-object, especially what  Documents  enumerates in relation to  ArchivePolicy.FolderName  value.  Check what happens when there are other \ invalid files in the  ArchivePolicy.FolderName  directory? What will  Documents  show? Verify  Resend  of an archived document (broadcast \ regular). Send functionality. Verify a fax is sent according to send method settings. Make sure a broadcast to one \ many recipients are sent according to method settings. Server settings   IFaxApplication object properties. Verify sending behaves according to server settings. Make sure faxes scheduled for sending during discount rates are sent according to server  Discount Time  settings. Check that queued  discount  documents are rescheduled when  discount  setting change. Queued jobs are rescheduled according to  Retries  and  RetryDelay Verify a banner is printed according to  Branding  property settings. Verify an unsent job (regular \ broadcast) is kept in queue for  DirtyDays  days before it is removed. Also verify removal of job is logged. Multi threading. Verify all operations on objects withstand multi threading. Check setting and getting of properties. Check Send and other objects  methods. Inbound Routing Methods. Verify that for every device object the proper IFaxRoutingMethods object is created at service start up and it contains all installed Inbound Routing Extensions  routing methods. Verify that routing methods are invoked according to routing method priority. Verify that changing the priority of a routing method affects the priorities of all other routing methods on that server (array? propagation?). Outbound Routing Rules. Verify default rules cannot be deleted. Verify an outbound call is handled by the desired FSP, as indicated by the  Device Type  property of the corresponding IFaxOutgoingRule. Verify selection of the device within above FSP is according to device priority, unless the rule indicates a specific device. Two rules for the same area code   specification is not clear on what happens. Adding \ Removing Devices. Verify that service correctly enumerates all devices that support fax. Add \ remove devices while service is down, and verify Admin objects and UI are correctly refreshed at service start up. Dynamically add \ remove devices while service is up, and verify Admin objects and UI are automatically refreshed. Verify Admin objects and UI correctly indicate when other services or applications are using ports. E.g. use Micky s keepopen.exe to open one of the fax ports and then start the service. Service should enumerate all devices and indicate the above port is  Verify  Cached Devices  registry entry correctly stores removed devices  information, and that when a  cached  modem is installed its settings are restored according to the relevant registry entry. Abort Current Job  feature (see  Comet Admin Spec  p.85). Verify that the job that the currently selected device is executing is aborted, device state changes accordingly, and that the device is then   to handle other jobs. UI Enabled \ Disabled menu items. Verify that menu items are enabled or disabled according to the state of the selected object. UI Multiple Selection. UI Refresh. UI Action Menu items. Verify all menu items defined for the selected object appear in the Actions menu. UI Right Click Menu items Verify all menu items defined for the selected object appear in the  Right Click  menu. Remote Admin. Accessing Admin COM objects and activating Admin UI from Client machines - TBD.  [TBD] Admin COM interface & UI test parameters: COM object property settings -  E.g. IFaxApplication object  RetryDelay  and  Retries  settings, IFaxRoutingMethod object  RoutingData  sub-object, etc. Device Configuration -  E.g. how many modems, FOIPs, boards, etc. Array configuration -  E.g. single \ many servers in the array. Inbound Routing Extensions installed. Priority among routing methods. Enabled routing methods on a device. FSPs installed. Installing \ removing devices Send \ Receive \ Routing jobs -  E.g. single \ many jobs of each kind, in different states. Actions on jobs -  E.g.  Abort Cancel All Restart  etc. Number of Outbound Routing Rules -  E.g. only default rules, many different rules, many duplicates of same rule, etc. [TBD] CometFax Admin COM & UI Test Cases  TIME \@ "d-MMM-yy"  30-Mar-99 Microsoft Confidential Sigalit Bar (sigalitb) xuroia[S }ume_WOIA |vpjd^XR qqqqqqqqnqq
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\docs\sbsqfe\qfetestplan.ppt ===
K]{bb [g/Zl s{=-3z!o Lo{v, H,r*>Y .9MSu Na!pX pd6GT =-ol( e/_Qg Y]lTE |/yvU|4Q 2}%d\ 8C!sPY%|/ )"c3>kf Fax Test Plan SBS4.5 QFE Sigalit Bar March 15th, 2000 Updated: 27-Apr-00 Agenda Existing Test Automation to be back ported from BOS5.0 Fax to SBS4.5 Fax Initial Time Estimates Test Resources Yossi Ran (STE) Will own running the tests. Sigalit Bar (SDE) Will own the test specs and resource management. SBS4.5 QFE Test Areas  W2K Client Areas SBS Client Setup & Uninstall OS Upgrade Scenarios Full UI Functionality Send Wizard Printer Queue Service Management (remote?) Status Monitor (?) Control Panel applet Outlook Extension Printing from applications  Co-existence with W2K PFW SBS4.5 QFE Test Areas  Server Areas QFE Setup (no Uninstall support) SBS and BOS server Upgrade Scenarios Partial UI Functionality Printer Queues Service Management Status Monitor (?) Control Panel applet SBS Console Multiple Fax Printers on Server original SBS printer plus new W2K clients printer SBS4.5 QFE Test Areas  Non-W2K Client Areas Sniff test UI Functionality Send Wizard Printer Queue Service Management (remote?) Control Panel applet Outlook Extension Sniff test Printing from applications  Use NT4 Client for reference testing to differentiate new W2K bugs from old SBS bugs SBS4.5 QFE Test Areas Continued Modem Compatibility Fax Hardware  (Providers and Devices) T.30 FSP MS Inbound Routing Extension Security Performance counters Performance SBS4.5 QFE Testing strategy Testing will be mostly manual. Testing will include reviewing all new code and any changes introduced to existing SBS4.5 Fax code. Examine which of our BOS Fax tests can be quickly  utilized/converted for testing SBS4.5 Fax. Concentrate testing on ship (free) version of SBS/BOS and QFE. Will test W2K workstation (wks) only (no srv, ent, dtc testing) Test QFE on SBS/BOS 4.0a, 4.5 USA. HanifaW will help test GER, JPN, KOR, CHT & CHS. Use NT4 Client for reference testing. Test Areas in detail SBS 4.5 QFE  Test Area Details Test Automation to be ported to SBS4.5 Test Automation to be ported to SBS4.5 continued Initial Time Estimates Initial Time Estimates Summary Initial Time Estimates Impact on BOS5.0 Schedule The End Click to edit Master title style Click to edit Master text styles Second Level Third Level Fourth Level Fifth Level Click to edit Master title style Click to edit Master subtitle style Click to edit Master text styles Second level Third level Fourth level Fifth level *micky snir *Comet fax test plan summary Test Resources. Test Areas. Test Strategy. SBS4.5 QFE Test areas in details - TBD Test areas that need spec - TBD Will *Not* Test: Scale Image viewer  Will only sniff test on W2K Client MS fax tiff tags Cover page editor Will only sniff test on W2K Client QFE replaces files on both W2K Client and SBS4.5 Server.  Therefor we are planning to verify that:      QFE allows W2K machines to act as SBS4.5 Fax clients.      QFE does not break existing SBS4.5 Server functionality. Test specs will be available at: \\haifaslm\slmcomet\src\fax\faxtest\docs\sbsqfe ETA: 28-Jun The following automated tests can be back ported from BOS5.0 Fax to SBS4.5 Fax with minimal effort: We will examine porting the following automated tests from BOS5.0 Fax to SBS4.5 Fax: Original Time Estimate was - 3 SDE Work Months Updated Time Estimate -  7 STE Work Weeks plus 6 SDE Work Weeks. Original Impact Estimate was -  Delay of 10 Work Weeks in BOS5.0 Schedule. Updated Impact Estimate is -  Delay of 8 Work Weeks in BOS5.0 Schedule. 3w~d9 W^T9k 3fSG,i^l T~`O+ .JCQz @Yak' */\{KC NT-'4z ~/a/fA6m ;Aa6y #9}E> Comet fax test plan summary micky snir Sigalit Bar Microsoft PowerPoint 7.0 Times New Roman Fax Test Plan Times New Roman SBS4.5 QFE Times New Roman Sigalit Bara March 15th, 2000 "System Overhead Times New Roman Arial Narrow Arial Monotype Sorts Wingdings 2 Default Design Microsoft Excel Worksheet Fax Test Plan   SBS4.5 QFE Agenda Test Resources SBS4.5 QFE Test Areas  W2K Client Areas SBS4.5 QFE Test Areas  Server Areas SBS4.5 QFE Test Areas  Non-W2K Client Areas SBS4.5 QFE Test Areas Continued SBS4.5 QFE Testing strategy Test Areas in detail SBS 4.5 QFE  Test Area Details Test Automation to be ported to SBS4.5 Test Automation to be ported to SBS4.5 continued Initial Time Estimates Initial Time Estimates Summary Initial Time Estimates Impact on BOS5.0 Schedule The End Fonts Used Design Template Embedded OLE Servers Slide Titles _PID_GUID _PID_HLINKS Sigalit Bar
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\docs\file.txt ===
Fax Service BVT

Goal:
To verify that the Fax Server can correctly perform the basic functions required.

Test Areas:
Send a fax (with/without CP, single/broadcast, from applications/wizard/API).
Receive a fax (verify bit map, banner, number of pages).
Automated image verification is not implemented.
Abort an outgoing/incoming fax (while pending, sending, receiving).
Inbound Routing (to Folder, to printer, to mail).
Testing of inbound to mail is not implemented.
Simultaneous use of multiple devices (for send/receive).
Test not implemented (due to 2 device limit => needs 2 machines)
Fax Management settings (device settings, user profile, routing).
Test not implemented.

Pre-requisites:
In order to run this BVT a machine with the build in question must be properly installed. 
Two modems must be installed on the machine (device#1 and device#2).
A printer must be installed on the machine.
See additional BVT setup information in appendix A. 
Any test case specific setup is described in the "Setup" section of each test case.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\docs\file.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Fax Service BVT TitleFax Service BVT Guy Merin Normal.dot Guy Merin Microsoft Word 9.0bjbjU Fax Service BVT Goal: To verify that the Fax Server can correctly perform the basic functions required. Test Areas: Send a fax (with/without CP, single/broadcast, from applications/wizard/API). Receive a fax (verify bit map, banner, number of pages). Automated image verification is not implemented. Abort an outgoing/incoming fax (while pending, sending, receiving). Inbound Routing (to Folder, to printer, to mail). Testing of inbound to mail is not implemented. Simultaneous use of multiple devices (for send/receive). Test not implemented (due to 2 device limit => needs 2 machines) Fax Management settings (device settings, user profile, routing). Test not implemented. Pre-requisites: In order to run this BVT a machine with the build in question must be properly installed.  Two modems must be installed on the machine (device#1 and device#2). A printer must be installed on the machine. See additional BVT setup information in appendix A.  Any test case specific setup is described in the "Setup" section of each test case.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\nt_placefil.txt ===
BasicBVT.exe         Test\BasicBVT
params_example.ini   Test\BasicBVT
file.bmp             Test\BasicBVT\Docs
file.doc             Test\BasicBVT\Docs
file.htm             Test\BasicBVT\Docs
file.txt             Test\BasicBVT\Docs
SubNote.COV          Test\BasicBVT\Docs
TC3.tif              Test\BasicBVT\Docs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\basicbvt\params_example.ini ===
[ G e n e r a l ] 
 
 b o s b v t s r v 1 
 
 1 3 6 3 
 
 1 3 6 4 
 
 t e s t . t i f Qm
 
 f : \ b v t \ f a x b v t \ s u b n o t e . c o v 
 
 f : \ b v t \ f a x b v t \ f a x e s \ 1 3 6 4 R e c e i v e 
 
 f : \ b v t \ f a x b v t \ f a x e s \ S e n t F a x e s 
 
 f : \ b v t \ f a x b v t \ f a x e s \ I n b o x A r c h i v e   
 
 f : \ b v t \ f a x b v t \ f a x e s \ R e f e r e n c e 
 
 f : \ b v t \ f a x b v t 
 
 
 
 [ R e c i p i e n t s ] 
 
 R e c i p i e n t 1 
 
 R e c i p i e n t 2 
 
 R e c i p i e n t 3 
 
 
 
 [ R e c i p i e n t 1 ] 
 
 N a m e   =   R e c i p i e n t   N u m b e r 1 
 
 F a x N u m b e r   = 
 
 C o m p a n y   =   R e c i p i e n t   N u m b e r 1   C o m p a n y                   
 
 S t r e e t A d d r e s s   =   R e c i p i e n t   N u m b e r 1   C o m p a n y                   
 
 C i t y   =   R e c i p i e n t   N u m b e r 1   C i t y                 
 
 S t a t e   =   R e c i p i e n t   N u m b e r 1   S t a t e                       
 
 Z i p   =   R e c i p i e n t   N u m b e r 1   Z i p                   
 
 C o u n t r y   =   R e c i p i e n t   N u m b e r 1   C o u n t r y                       
 
 T i t l e   =   R e c i p i e n t   N u m b e r 1   T i t l e                   
 
 D e p a r t m e n t   =   R e c i p i e n t   N u m b e r 1   D e p a r t m e n t             
 
 O f f i c e L o c a t i o n   =   R e c i p i e n t   N u m b e r 1   O f f i c e L o c a t i o n                               
 
 H o m e P h o n e   =   R e c i p i e n t   N u m b e r 1   H o m e P h o n e                               
 
 O f f i c e P h o n e   =   R e c i p i e n t   N u m b e r 1   O f f i c e P h o n e                             
 
 E m a i l   =   R e c i p i e n t   N u m b e r 1   E m a i l                               
 
 B i l l i n g C o d e   =   R e c i p i e n t   N u m b e r 1   B i l l i n g C o d e                               
 
 T S I D   =   R e c i p i e n t   N u m b e r 1   T S I D 
 
 
 
 [ R e c i p i e n t 2 ] 
 
 
 
 [ R e c i p i e n t 3 ] 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\params_example.ini ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; ExtendedBVT ini file.
;;
;; This file is widely describied in the ExtendedBVT.doc file.
;; As well, brief comments are embedded in the file itself.
;;
;; Before running the ExtendedBVT with this ini file, please make sure to adapt
;; it to your lab configuration.
;; All entries in the ini file may be devided into three categories:
;;
;; 1. Entries, dependent only on the desired suite configuration.
;;    These entries typically should not be changed when a predefined
;;    suite is used.
;;
;; 2. Entries, dependent on particular environment - machine names, fax numbers
;;    and so on.
;;    These entries should be adapted on each invironment change: replication
;;    of the suite to a new lab, replacement of an analog line,
;;    renaming/replacement of one of the machines etc.
;;    Environment dependent entries are enclose within
;;    BEGIN_ENVIRONMENT_DEPENDENT - END_ENVIRONMENT_DEPENDENT blocks.
;;
;; 3. Entries, dependent on the OS language.
;;    These entries should be adapted on each OS language change, typically on
;;    replication of the suite to a localization lab.
;;    Language dependent entries are enclose within
;;    BEGIN_LANGUAGE_DEPENDENT - END_LANGUAGE_DEPENDENT blocks.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




[Suite]
TestSuite = TestSuite_HaifaDailyFre
Macros = Macros
ContinueOnFailure = 1




[Macros]
;;BEGIN_ENVIRONMENT_DEPENDENT
Flag_UseOffice = 0
RemoteMachine = yuryb1
LocalNumber = 1532
RemoteNumber = 7162
;;BEGIN_LANGUAGE_DEPENDENT
ServerCoverPage = confdent.cov
ConfidentCoverPage = %AllUsersProfile%\Application Data\Microsoft\Windows NT\MSFax\Common Coverpages\confdent.cov
FYICoverPage = %AllUsersProfile%\Application Data\Microsoft\Windows NT\MSFax\Common Coverpages\fyi.cov
GeneralCoverPage = %AllUsersProfile%\Application Data\Microsoft\Windows NT\MSFax\Common Coverpages\generic.cov
UrgentCoverPage = %AllUsersProfile%\Application Data\Microsoft\Windows NT\MSFax\Common Coverpages\urgent.cov
FaxConsoleShortcut = %AllUsersProfile%\Start Menu\Programs\Accessories\Communications\Fax\Fax Console.lnk
FaxCoverPageEditorShortcut = %AllUsersProfile%\Start Menu\Programs\Accessories\Communications\Fax\Fax Cover Page Editor.lnk
FaxServiceManagerShortcut = %AllUsersProfile%\Start Menu\Programs\Accessories\Communications\Fax\Fax Service Manager.lnk
SendAFaxShortcut = %AllUsersProfile%\Start Menu\Programs\Accessories\Communications\Fax\Send a Fax....lnk
;;END_LANGUAGE_DEPENDENT
;;END_ENVIRONMENT_DEPENDENT




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Available Suites
;;

[TestSuite_Full]
TestCase_ReportGeneralInfo = 1
TestContainer_Full-SetAndRun = 1
TestCase_SuiteCleanup = 1


[TestSuite_HaifaDailyFre]
TestCase_ReportGeneralInfo = 1
TestContainer_HaifaDailyFre-SetAndRun = 1
TestCase_SuiteCleanup = 1


[TestSuite_HaifaDailyChk]
TestCase_ReportGeneralInfo = 1
TestContainer_HaifaDailyChk-SetAndRun = 1
TestCase_SuiteCleanup = 1


[TestSuite_RedmondFre]
TestCase_ReportGeneralInfo = 1
TestContainer_RedmondFre-SetAndRun = 1
TestCase_SuiteCleanup = 1


[TestSuite_RedmondChk]
TestCase_ReportGeneralInfo = 1
TestContainer_RedmondChk-SetAndRun = 1
TestCase_SuiteCleanup = 1

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Test containers
;;

[TestContainer_Full-SetAndRun]
CLSID = StandardTestContainer
ContinueOnFailure = 0
TestCase_SuiteSetup = 1
TestContainer_Full-Run


[TestContainer_HaifaDailyFre-SetAndRun]
CLSID = StandardTestContainer
ContinueOnFailure = 0
TestCase_SuiteSetup = 1
TestContainer_HaifaDailyFre-Run


[TestContainer_HaifaDailyChk-SetAndRun]
CLSID = StandardTestContainer
ContinueOnFailure = 0
TestCase_SuiteSetup = 1
TestContainer_HaifaDailyChk-Run


[TestContainer_RedmondFre-SetAndRun]
CLSID = StandardTestContainer
ContinueOnFailure = 0
TestCase_SuiteSetup = 1
TestContainer_FileSystemLayout = 1
TestCase_LocalSendAndReceiveSetup = 1
TestCase_Single-PerCP-BMP-API = 1
TestCase_Single-SrvCP-API = 1
TestCase_Broadcast-PerCP-DOC-SPOOLER = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1
TestCase_LocalSendRemoteReceiveSetup
TestCase_Single-DOC-API = 1
TestCase_Single-BMP-SPOOLER = 1
TestCase_Broadcast-PerCP-SPOOLER = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1
TestCase_RemoteSendLocalReceiveSetup
TestCase_Single-PerCP-SPOOLER = 1
TestCase_Broadcast-PerCP-API = 1
TestCase_Broadcast-SrvCP-TIF-API = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1


[TestContainer_RedmondChk-SetAndRun]
CLSID = StandardTestContainer
ContinueOnFailure = 0
TestCase_SuiteSetup = 1
TestContainer_FileSystemLayout = 1
TestCase_LocalSendAndReceiveSetup = 1
TestCase_Single-PerCP-BMP-API = 1
TestCase_Single-SrvCP-API = 1
TestCase_Broadcast-PerCP-DOC-SPOOLER = 1
TestCase_Single-DOC-API = 1
TestCase_Single-BMP-SPOOLER = 1
TestCase_Broadcast-PerCP-SPOOLER = 1
TestCase_Single-PerCP-SPOOLER = 1
TestCase_Broadcast-PerCP-API = 1
TestCase_Broadcast-SrvCP-TIF-API = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1


[TestContainer_Full-Run]
CLSID = StandardTestContainer
ContinueOnFailure = 1
TestContainer_FileSystemLayout = 1
TestContainer_LocalSendAndReceive = 1
TestContainer_LocalSendRemoteReceive = 1
TestContainer_RemoteSendLocalReceive = 1
TestContainer_RemoteSendAndReceive = 1


[TestContainer_HaifaDailyFre-Run]
CLSID = StandardTestContainer
ContinueOnFailure = 1
TestContainer_FileSystemLayout = 1
TestContainer_LocalSendRemoteReceive = 1
TestContainer_RemoteSendLocalReceive = 1
TestContainer_RemoteSendAndReceive = 1


[TestContainer_HaifaDailyChk-Run]
CLSID = StandardTestContainer
ContinueOnFailure = 1
TestContainer_FileSystemLayout = 1
TestContainer_LocalSendAndReceive = 1


[TestContainer_FileSystemLayout]
CLSID = StandardTestContainer
Description = Checks fax file system layout.
TestCase_FaxFiles = 1
TestCase_CoverPages = 1
TestCase_Shortcuts = 1


[TestContainer_LocalSendAndReceive]
CLSID = StandardTestContainer
Description = Checks sending and receiving on local server.
ContinueOnFailure = 0
TestCase_LocalSendAndReceiveSetup = 1
TestContainer_FullSendAndReceive = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1


[TestContainer_LocalSendRemoteReceive]
CLSID = StandardTestContainer
Description = Checks sending on local and receiving on remote server.
ContinueOnFailure = 0
TestCase_LocalSendRemoteReceiveSetup = 1
TestContainer_FullSendAndReceive = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1


[TestContainer_RemoteSendLocalReceive]
CLSID = StandardTestContainer
Description = Checks sending on remote and receiving on local server.
ContinueOnFailure = 0
TestCase_RemoteSendLocalReceiveSetup = 1
TestContainer_FullSendAndReceive = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1


[TestContainer_RemoteSendAndReceive]
CLSID = StandardTestContainer
Description = Checks sending and receiving on remote server.
ContinueOnFailure = 0
TestCase_RemoteSendAndReceiveSetup = 1
TestContainer_FullSendAndReceive = 1
TestCase_WaitForRouting = 1
TestContainer_SendAndReceiveTiffComparison = 1


[TestContainer_FullSendAndReceive]
CLSID = StandardTestContainer
Description = Checks Fax Service send / receive functionality.
ContinueOnFailure = 1
TestCase_Single-SrvCP-XLS-API = Flag_UseOffice
TestCase_Single-SrvCP-TXT-API = !Flag_UseOffice
TestCase_Single-PerCP-BMP-API = 1
TestCase_Single-SrvCP-API = 1
TestCase_Single-PerCP-API = 1
TestCase_Single-DOC-API = 1
TestCase_Broadcast-SrvCP-TIF-API = 1
TestCase_Broadcast-PerCP-TXT-API = 1
TestCase_Broadcast-SrvCP-API = 1
TestCase_Broadcast-PerCP-API = 1
TestCase_Broadcast-PPT-API = Flag_UseOffice
TestCase_Broadcast-TXT-API = !Flag_UseOffice
TestCase_Single-SrvCP-TIF-SPOOLER = 0
TestCase_Single-PerCP-PPT-SPOOLER = Flag_UseOffice
TestCase_Single-PerCP-TXT-SPOOLER = !Flag_UseOffice
TestCase_Single-SrvCP-SPOOLER = 0
TestCase_Single-PerCP-SPOOLER = 1
TestCase_Single-BMP-SPOOLER = 1
TestCase_Broadcast-SrvCP-TXT-SPOOLER = 0
TestCase_Broadcast-PerCP-DOC-SPOOLER = 1
TestCase_Broadcast-SrvCP-SPOOLER = 0
TestCase_Broadcast-PerCP-SPOOLER = 1
TestCase_Broadcast-XLS-SPOOLER = Flag_UseOffice
TestCase_Broadcast-TXT-SPOOLER = !Flag_UseOffice


[TestContainer_BasicSendAndReceive]
CLSID = StandardTestContainer
Description = Checks Fax Service send / receive functionality.
TestCase_Single-PerCP-BMP-API = 1
TestCase_Single-SrvCP-API = 1
TestCase_Single-DOC-API = 1
TestCase_Broadcast-SrvCP-TIF-API = 1
TestCase_Broadcast-PerCP-API = 1
TestCase_Single-PerCP-SPOOLER = 1
TestCase_Single-BMP-SPOOLER = 1
TestCase_Broadcast-PerCP-DOC-SPOOLER = 1
TestCase_Broadcast-PerCP-SPOOLER = 1


[TestContainer_SendAndReceiveTiffComparison]
CLSID = StandardTestContainer
Description = Performs tiff comparison of the service directories and empties them if successfull.
ContinueOnFailure = 0
TestContainer_ServiceDirectoriesTiffComparison = 1
TestCase_DeleteNewTiffFilesFromBVTDirectories = 1


[TestContainer_ServiceDirectoriesTiffComparison]
CLSID = StandardTestContainer
ContinueOnFailure = 1
TestCase_CompareSentItemsWithInbox = 1
TestCase_CompareSentItemsWithRouting = 1

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CReportGeneralInfo test cases
;;
;; *******
;; General
;; *******
;; 
;; The class defines a test case, using the "Test Suite Manager" model.
;; The test case adds to the suite log general information: OS version,
;; logged on user, fax version.
;;
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; No test case specific parameters.
;;

[TestCase_ReportGeneralInfo]
CLSID = CReportGeneralInfo
Description = Reports general information about local machine.

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CExtendedBVTSetup test cases
;;
;; *******
;; General
;; *******
;; 
;; The class defines a test case, using the "Test Suite Manager" model.
;; The test case performs global configuration changes, needed to run
;; the ExtendedBVT suite.
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; DocumentsDirectory = <directory>
;;   Mandatory.
;;   Defines the subdirectory of the BVT directory that contains all
;;   needed documents.
;;
;; InboxDirectory = <directory>
;;   Mandatory.
;;   Defines the subdirectory of the BVT directory to be used as the
;;   Inbox archive.
;;
;; SentItemsDirectory = <directory>
;;   Mandatory.
;;   Defines the subdirectory of the BVT directory to be used as the
;;   SentItems archive.
;;
;; RoutingDirectory = <directory>
;;   Mandatory.
;;   Defines the subdirectory of the BVT directory to be used by the
;;   "Store In Folder" routing method.
;;

[TestCase_SuiteSetup]
CLSID = CExtendedBVTSetup
Description = Makes all global configuration changes needed to run the Extended BVT.
DocumentsDirectory = Documents
InboxDirectory = Faxes\Inbox
SentItemsDirectory = Faxes\SentItems
RoutingDirectory = Faxes\Routing

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CExtendedBVTCleanup test cases
;;
;; *******
;; General
;; *******
;; 
;; The class defines a test case, using the "Test Suite Manager" model.
;; The test case restores the major changes, applied to the system during
;; the ExtendedBVT suite.
;;
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; No test case specific parameters.
;;

[TestCase_SuiteCleanup]
CLSID = CExtendedBVTCleanup
Description = Restores the major changes, applied to the system during the Extended BVT.

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; StandardShellExecute test cases
;;
;; *******
;; General
;; *******
;; 
;; Standard test case, provided by the "Test Suite Manager" model.
;; Allows to execute shell commands.
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; Verb = <verb>
;;   Optional.
;;   Specifies the lpVerb field of the SHELLEXECUTEINFO structure.
;;
;; File = <file>
;;   Optional.
;;   Specifies the lpFile field of the SHELLEXECUTEINFO structure.
;;
;; Parameters = <parameters>
;;   Optional.
;;   Specifies the lpParameters field of the SHELLEXECUTEINFO structure.
;;
;; ResultMatters = <1/0>
;;   Optional.
;;   Specifies whether the failure of the command should be reported as a
;;   failure of the test case.
;;

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; StandardDelay test cases
;;
;; *******
;; General
;; *******
;; 
;; Standard not reported test case, provided by the "Test Suite Manager" model.
;; Allows to insert delays between tests without a need to rebuild.
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; Duration = <duration (msec)>
;;   Mandatory.
;;   Defines the duration of the delay.
;;

[TestCase_WaitForRouting]
CLSID = StandardDelay
Description = Waits for all messages to be received and routed.
Duration = 10000

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; StandardPause test cases
;;
;; *******
;; General
;; *******
;; 
;; Standard not reported test case, provided by the "Test Suite Manager" model.
;; Allows to insert user controlled pauses between tests without a need
;; to rebuild.
;; Invocation of the test case pops up a message box with "Ok" buttton and
;; pauses the test until the message box is dismissed.
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; No test case specific parameters.
;;

[TestCase_Pause]
CLSID = StandardPause

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; StandardDebugBreak test cases
;;
;; *******
;; General
;; *******
;; 
;; Standard not reported test case, provided by the "Test Suite Manager" model.
;; Allows to insert user breakpoints between tests without a need to rebuild.
;; Invocation of the test case causes a user breakpoint in the suite code.
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;; No test case specific parameters.
;;

[TestCase_DebugBreak]
CLSID = StandardDebugBreak

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CCheckFiles test cases
;;
;;
;; *******
;; General
;; *******
;; 
;; The class defines a test case, using the "Test Suite Manager" model.
;; The test case allows to check existence of files (platform dependent) and
;; other properites.
;; 
;; 
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;; 
;; List of entries in the form <filename> = <properties>, where:
;; 
;;    <filename> is a full path (environment variables allowed) of a file to check
;; 
;;     <properties> is a bit mask (in the decimal format) that defines required
;;     file "properties"
;;
;;     Currently supported properties:
;;         FILE_WANTED_NEVER         = 0x00000000
;;         FILE_WANTED_ON_WIN9X      = 0x00000001
;;         FILE_WANTED_ON_NT4        = 0x00000002
;;         FILE_WANTED_ON_WINME      = 0x00000004
;;         FILE_WANTED_ON_WIN2K      = 0x00000008
;;         FILE_WANTED_ON_XP_DESKTOP = 0x00000010
;;         FILE_WANTED_ON_XP_SERVER  = 0x00000020
;;         FILE_WANTED_ALWAYS        = 0x000000FF
;;         FILE_VERSION_IGNORE       = 0x00000000
;;         FILE_VERSION_BUILD        = 0x00000100
;;         FILE_VERSION_FULL         = 0x00000F00
;;


[TestCase_FaxFiles]
CLSID = CCheckFiles
Description = Checks existence and version correspondence of fax files according to a platform.
%windir%\system32\winfax.dll = 3888
%windir%\system32\fxsadmin.dll = 3872
%windir%\system32\fxsapi.dll = 3888
%windir%\system32\fxscfgwz.dll = 3888
%windir%\system32\fxsclntr.dll = 3888
%windir%\system32\fxscom.dll = 3888
%windir%\system32\fxscomex.dll = 3888
%windir%\system32\fxsdrv.dll = 304
%windir%\system32\fxsevent.dll = 3888
%windir%\system32\fxsext32.dll = 3888
%windir%\system32\fxsmon.dll = 3888
%windir%\system32\fxsperf.dll = 3888
%windir%\system32\fxsres.dll = 3888
%windir%\system32\fxsroute.dll = 3888
%windir%\system32\fxsrtmtd.dll = 3872
%windir%\system32\fxsst.dll = 3888
%windir%\system32\fxst30.dll = 3888
%windir%\system32\fxst30p.dll = 3872
%windir%\system32\fxstiff.dll = 3888
%windir%\system32\fxsui.dll = 3888
%windir%\system32\fxswzrd.dll = 3888
%windir%\system32\fxsxp32.dll = 3888
%windir%\system32\setup\fxsocm.dll = 3888
%windir%\system32\spool\drivers\w32x86\3\fxsapi.dll = 3888
%windir%\system32\spool\drivers\w32x86\3\fxsdrv.dll = 304
%windir%\system32\spool\drivers\w32x86\3\fxstiff.dll = 3888
%windir%\system32\spool\drivers\w32x86\3\fxsui.dll = 3888
%windir%\system32\spool\drivers\w32x86\3\fxswzrd.dll = 3888
%windir%\system32\fxsclnt.exe = 3888
%windir%\system32\fxscover.exe = 3888
%windir%\system32\fxssend.exe = 3888
%windir%\system32\fxssvc.exe = 3888
%windir%\inf\fxsocm.inf = 48


[TestCase_CoverPages]
CLSID = CCheckFiles
Description = Checks existence of cover page files, shipped with Fax Service.
ConfidentCoverPage = 48
FYICoverPage = 48
GeneralCoverPage = 48
UrgentCoverPage = 48


[TestCase_Shortcuts]
CLSID = CCheckFiles
Description = Checks existence of shortcuts.
FaxConsoleShortcut = 48
FaxCoverPageEditorShortcut = 48
FaxServiceManagerShortcut = 32
SendAFaxShortcut = 48

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CSendAndReceiveSetup test cases
;;
;;  *******
;;  General
;;  *******
;;  
;;  The class defines a test case, using the "Test Suite Manager" model.
;;  The test case performs configuration changes, needed to run CSendAndReceive
;;  test case.
;;
;;
;;  **************************************
;;  Test case specific INI file parameters
;;  **************************************
;;
;;  SendingServer = <machine name>
;;      Optional.
;;      Specifies a machine to be used as a sending server. If not specified,
;;      the server is used.
;;
;;  SendingDevice = <device name>
;;      Optional.
;;      Specifies a device on the sending server to be used to send faxes.
;;      If not specified, the first device on the sending server is used.
;;
;;  ReceivingServer = <machine name>
;;      Optional.
;;      Specifies a machine to be used as a receiving server. If not specified,
;;      the server is used.
;;
;;  ReceivingDevice = <device name>
;;      Optional.
;;      Specifies a device on the receiving server to be used to receive faxes.
;;      If not specified, the last device on the receiving server is used.
;;
;;  NumberToDial = <fax number>
;;      Mandatory.
;;      Specifies a fax number to be dialed to send faxes. Obviously, it's the
;;      number of a line, attached to the receiving device.
;;
;;  NotificationTimeout = <notification timeout (msec)>
;;      Optional.
;;      Specifies the maximal amount of time, allowed to elapse between two
;;      subsequent notifications in a single fax transmission.
;;      If not specified, the default value (#defiened as 3 min) is used.
;;
;;  EmptyArchivesAndRouting = <1/0>
;;      Optional.
;;      Specifies whether the archives and the routing directory should be emptied.
;;      If not specified, the archives and the routing directory are not emptied.
;;

[TestCase_LocalSendAndReceiveSetup]
CLSID = CSendAndReceiveSetup
Description = Makes additional configuration changes needed to check sending and receiving on local server.
;;SendingServer = <local>
;;SendingDevice = <first>
;;ReceivingServer = <local>
;;ReceivingDevice = <last>
NumberToDial = LocalNumber
;;NotificationTimeout = <default>
;;EmptyArchivesAndRouting = <0>


[TestCase_LocalSendRemoteReceiveSetup]
CLSID = CSendAndReceiveSetup
Description = Makes additional configuration changes needed to check sending on local and receiving on remote server.
;;SendingServer = <local>
;;SendingDevice = <first>
ReceivingServer = RemoteMachine
;;ReceivingDevice = <last>
NumberToDial = RemoteNumber
;;NotificationTimeout = <default>
;;EmptyArchivesAndRouting = <0>


[TestCase_RemoteSendLocalReceiveSetup]
CLSID = CSendAndReceiveSetup
Description = Makes additional configuration changes needed to check sending on remote and receiving on local server.
SendingServer = RemoteMachine
;;SendingDevice = <first>
;;ReceivingServer = <local>
;;ReceivingDevice = <last>
NumberToDial = LocalNumber
;;NotificationTimeout = <default>
;;EmptyArchivesAndRouting = <0>


[TestCase_RemoteSendAndReceiveSetup]
CLSID = CSendAndReceiveSetup
Description = Makes additional configuration changes needed to check sending and receiving on remote server.
SendingServer = RemoteMachine
;;SendingDevice = <first>
ReceivingServer = RemoteMachine
;;ReceivingDevice = <last>
NumberToDial = RemoteNumber
;;NotificationTimeout = <default>
;;EmptyArchivesAndRouting = <0>

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CSendAndReceive test cases
;;
;;  *******
;;  General
;;  *******
;;  
;;  The class defines a test case, using the "Test Suite Manager" model.
;;  The test case allows to send a fax with a variety of parameters and track
;;  the send/receive process.
;;
;;
;;  **************************************
;;  Test case specific INI file parameters
;;  **************************************
;;
;;  CoverPage = <cover page file name>
;;      Optional. Eihter a cover page or a document must be specified.
;;      Defines a coverpage to be used to send a fax. If not specified,
;;      no cover page is used.
;;
;;  ServerBasedCoverPage = <1/0>
;;      Mandatory if CoverPage parameter defined. Ignored if no cover page
;;      defined.
;;      Specifies whether the cover page is server or client based ("personal").
;;      
;;  Document = <document file name>
;;      Optional. Eihter a cover page or a document must be specified.
;;      Defines a document to be used to send a fax. If not specified,
;;      no document is used.
;;
;;  Broadcast - <1/0>
;;      Mandatory.
;;      Specifies whether the fax should be sent to single or multiple
;;      recipients.
;;
;;  SendMechanism = <number>
;;      Mandatory.
;;      Specifies a sending machanism to be used.
;;
;;      Currently supported mechanisms are:
;;          SEND_MECHANISM_API     = 1
;;          SEND_MECHANISM_SPOOLER = 2
;;
;;  NotificationTimeoutFactor = <number>
;;      Optional.
;;      Specifies the factor, that should be applied to the maximal amount of
;;      time, allowed to elapse between two subsequent notifications in a single
;;      fax transmission, which is specified in by SendAndReceiveSetup test case.
;;      If not specified, the default value 1 (no factor) is used.
;;


[TestCase_Single-SrvCP-XLS-API]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a server coverpage and an Excel document using extended API.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
Document = file.xls
Broadcast = 0
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Single-SrvCP-TXT-API]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a server coverpage and a text document using extended API.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
Document = file.txt
Broadcast = 0
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Single-PerCP-BMP-API]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a personal coverpage and a bitmap using extended API.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
Document = file.bmp
Broadcast = 0
SendMechanism = 1
NotificationTimeoutFactor = 2.5


[TestCase_Single-SrvCP-API]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a server coverpage only using extended API.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
;;Document = <none>
Broadcast = 0
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Single-PerCP-API]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a personal coverpage only using extended API.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
;;Document = <none>
Broadcast = 0
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Single-DOC-API]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a Word (Wordpad) document only using extended API.
;;CoverPage = <none>
;;ServerBasedCoverPage = <N/A>
Document = file.doc
Broadcast = 0
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-SrvCP-TIF-API]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a server coverpage and a tiff document using extended API.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
Document = file.tif
Broadcast = 1
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-PerCP-TXT-API]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a personal coverpage and a text document using extended API.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
Document = file.txt
Broadcast = 1
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-SrvCP-API]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a server coverpage only using extended API.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
Broadcast = 1
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-PerCP-API]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a personal coverpage only using extended API.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
;;Document = <none>
Broadcast = 1
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-PPT-API]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a Power Point document only using extended API.
;;CoverPage = <none>
;;ServerBasedCoverPage = <N/A>
Document = file.ppt
Broadcast = 1
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-TXT-API]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a text document only using extended API.
;;CoverPage = <none>
;;ServerBasedCoverPage = <N/A>
Document = file.txt
Broadcast = 1
SendMechanism = 1
;;NotificationTimeoutFactor = <1>


[TestCase_Single-SrvCP-TIF-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a server coverpage and a tiff document using system spooler.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
Document = file.tif
Broadcast = 0
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Single-PerCP-PPT-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a personal coverpage and a Power Point document using system spooler.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
Document = file.ppt
Broadcast = 0
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Single-PerCP-TXT-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a personal coverpage and a text document using system spooler.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
Document = file.txt
Broadcast = 0
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Single-SrvCP-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a server coverpage only using system spooler.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
;;Document = <none>
Broadcast = 0
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Single-PerCP-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a personal coverpage only using system spooler.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
;;Document = <none>
Broadcast = 0
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Single-BMP-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to a single recipient which consists of a bitmap document only using system spooler.
;;CoverPage = <none>
;;ServerBasedCoverPage = <N/A>
Document = file.bmp
Broadcast = 0
SendMechanism = 2
NotificationTimeoutFactor = 2.5


[TestCase_Broadcast-SrvCP-TXT-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a server coverpage and a text document using system spooler.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
Document = file.txt
Broadcast = 1
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-PerCP-DOC-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a personal coverpage and a Word (Wordpad) document using system spooler.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
Document = file.doc
Broadcast = 1
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-SrvCP-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a server coverpage only using system spooler.
CoverPage = ServerCoverPage
ServerBasedCoverPage = 1
;;Document = <none>
Broadcast = 1
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-PerCP-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a personal coverpage only using system spooler.
CoverPage = subnote.cov
ServerBasedCoverPage = 0
;;Document = <none>
Broadcast = 1
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-XLS-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of an Excel document only using system spooler.
;;CoverPage = <none>
;;ServerBasedCoverPage = <N/A>
Document = file.xls
Broadcast = 1
SendMechanism = 2
;;NotificationTimeoutFactor = <1>


[TestCase_Broadcast-TXT-SPOOLER]
CLSID = CSendAndReceive
Description = Sends a fax to multiple recipients which consists of a text document only using system spooler.
;;CoverPage = <none>
;;ServerBasedCoverPage = <N/A>
Document = file.txt
Broadcast = 1
SendMechanism = 2
;;NotificationTimeoutFactor = <1>

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CTiffComparison test cases
;;
;;  *******
;;  General
;;  *******
;;  
;;  The class defines a test case, using the "Test Suite Manager" model.
;;  The test case performs tiff comparison of files or directories.
;;
;;
;;  **************************************
;;  Test case specific INI file parameters
;;  **************************************
;;
;;  ComparisonType = <number>
;;      Mandatory.
;;      Specifies how the Source and Destination entries should be interpreted.
;;
;;      Currently supported values are:
;;          COMPARISON_TYPE_FILE          = 1
;;          COMPARISON_TYPE_DIRECTORY     = 2
;;          COMPARISON_TYPE_BVT_DIRECTORY = 3
;;
;;  Source = <filename | directory name | SentItems | Inbox | Routing>
;;      Specifies a source for the comparison.
;;
;;  Destination = <filename | directory name | SentItems | Inbox | Routing>
;;      Specifies a destination for the comparison.
;;
;;  SkipFirstLine = <1/0>
;;  Specifies whether the file comparison should skip the first line.
;;


[TestCase_CompareSentItemsWithInbox]
CLSID = CTiffComparison
Description = Compares SentItems archive with Inbox archive.
ComparisonType = 3
Source = SentItems
Destination = Inbox
SkipFirstLine = 1


[TestCase_CompareSentItemsWithRouting]
CLSID = CTiffComparison
Description = Compares SentItems archive with routing folder .
ComparisonType = 3
Source = SentItems
Destination = Routing
SkipFirstLine = 1

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEmptyBVTDirectories test cases
;;
;; *******
;; General
;; *******
;; 
;;  The class defines a test case, using the "Test Suite Manager" model.
;;  The test case allows to empty the BVT directories: Inbox, SentItems
;;  and Routing, as specified by the CExtendedBVTSetup test case.
;;
;;
;; **************************************
;; Test case specific INI file parameters
;; **************************************
;;
;;  DeleteNewFilesOnly = <1/0>
;;    Optional.
;;    Specifies whether only new or all files should be deleted.
;;    If not specified, all files deleted.
;;
;;  DeleteTiffFilesOnly = <1/0>
;;    Optional.
;;    Specifies whether only tiff or all files should be deleted.
;;    If not specified, all files deleted.
;;

[TestCase_DeleteNewTiffFilesFromBVTDirectories]
CLSID = CEmptyBVTDirectories
Description = Deletes new tiff files from the BVT directories.
DeleteNewFilesOnly = 1
DeleteTiffFilesOnly = 1

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\extendedbvt\nt_placefil.txt ===
ExtendedBVT.exe         Test\ExtendedBVT
params_example.ini      Test\ExtendedBVT
file.bmp                Test\ExtendedBVT\Documents
file.doc                Test\ExtendedBVT\Documents
file.ppt                Test\ExtendedBVT\Documents
file.tif                Test\ExtendedBVT\Documents
file.txt                Test\ExtendedBVT\Documents
file.xls                Test\ExtendedBVT\Documents
SubNote.COV             Test\ExtendedBVT\Documents
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\bvt\vt_bvt\params.ini ===
[ G e n e r a l ] 
 
 b o s b v t s r v 1 
 
 5 9 5 9 
 
 5 9 6 0 
 
 t e s t . t i f 
 
 f : \ b v t \ f a x b v t \ s u b n o t e . c o v 
 
 f : \ b v t \ f a x b v t \ f a x e s \ 5 9 6 0 R e c e i v e 
 
 f : \ b v t \ f a x b v t \ f a x e s \ S e n t F a x e s 
 
 f : \ b v t \ f a x b v t \ f a x e s \ I n b o x A r c h i v e   
 
 f : \ b v t \ f a x b v t \ f a x e s \ R e f e r e n c e 
 
 f : \ b v t \ f a x b v t 
 
 t r u e 
 
 
 
 [ R e c i p i e n t s ] 
 
 R e c i p i e n t 1 
 
 R e c i p i e n t 2 
 
 R e c i p i e n t 3 
 
 
 
 [ R e c i p i e n t 1 ] 
 
 N a m e   =   R e c i p i e n t   N u m b e r 1 
 
 F a x N u m b e r   = 
 
 C o m p a n y   =   R e c i p i e n t   N u m b e r 1   C o m p a n y                   
 
 S t r e e t A d d r e s s   =   R e c i p i e n t   N u m b e r 1   C o m p a n y                   
 
 C i t y   =   R e c i p i e n t   N u m b e r 1   C i t y                 
 
 S t a t e   =   R e c i p i e n t   N u m b e r 1   S t a t e                       
 
 Z i p   =   R e c i p i e n t   N u m b e r 1   Z i p                   
 
 C o u n t r y   =   R e c i p i e n t   N u m b e r 1   C o u n t r y                       
 
 T i t l e   =   R e c i p i e n t   N u m b e r 1   T i t l e                   
 
 D e p a r t m e n t   =   R e c i p i e n t   N u m b e r 1   D e p a r t m e n t             
 
 O f f i c e L o c a t i o n   =   R e c i p i e n t   N u m b e r 1   O f f i c e L o c a t i o n                               
 
 H o m e P h o n e   =   R e c i p i e n t   N u m b e r 1   H o m e P h o n e                               
 
 O f f i c e P h o n e   =   R e c i p i e n t   N u m b e r 1   O f f i c e P h o n e                             
 
 I n t e r n e t M a i l   =   R e c i p i e n t   N u m b e r 1   I n t e r n e t M a i l                               
 
 B i l l i n g C o d e   =   R e c i p i e n t   N u m b e r 1   B i l l i n g C o d e                               
 
 T S I D   =   R e c i p i e n t   N u m b e r 1   T S I D 
 
 
 
 [ R e c i p i e n t 2 ] 
 
 N a m e   =   R e c i p i e n t   N u m b e r 1 
 
 F a x N u m b e r   = 
 
 C o m p a n y   =   ><;  C o m p a n y                   
 
 S t r e e t A d d r e s s   =   B0`0000  C o m p a n y                   
 
 C i t y   =   R e c i p i e n t   N u m b e r 1   C i t y                 
 
 S t a t e   =   R e c i p i e n t   N u m b e r 1   S t a t e                       
 
 Z i p   =   R e c i p i e n t   N u m b e r 1   Z i p                   
 
 C o u n t r y   =   R e c i p i e n t   N u m b e r 1   C o u n t r y                       
 
 T i t l e   =   R e c i p i e n t   N u m b e r 1   T i t l e                   
 
 D e p a r t m e n t   =   A  D e p a r t m e n t             
 
 O f f i c e L o c a t i o n   =   X  O f f i c e L o c a t i o n                               
 
 H o m e P h o n e   =   R e c i p i e n t   N u m b e r 1   H o m e P h o n e                               
 
 O f f i c e P h o n e   =   R e c i p i e n t   N u m b e r 1   O f f i c e P h o n e                             
 
 I n t e r n e t M a i l   =   R e c i p i e n t   N u m b e r 1   I n t e r n e t M a i l                               
 
 B i l l i n g C o d e   =   R e c i p i e n t   N u m b e r 1   B i l l i n g C o d e                               
 
 T S I D   =     T S I D 
 
 
 
 [ R e c i p i e n t 3 ] 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\readme.txt ===
Whistler Fax Configuration Wizard test suite
=============================================

General
-------
Testing of Configuration Wizard can be divided into three major areas:
invocation, functionality, GUI.
The suite implements only invocation and functionality tests.
Automation of GUI tests is postponed for now as very time consuming.

The suite is implemented using "generic suite format".


Invocation Area
---------------
This area checks that the wizard is invoked implicitly under appropriate
circumstances. Also it checks that the wizard contains user and/or service
parts accordingly to invocation details (either implicit or explicit).

Invocation may be characterized with four parameters:
1. implicit by Client Console, implicit by Send Wizard or explicit
2. in context of currently logged on or other user
3. by a user who has service configuration access or a "regular" user
4. on a machine with or without modems installed

Note: invocation without modems is not currently supported.

In addition, it's possible to take some actions prior to an invocation, which
will influence it. Each test case performs some set of "pre-actions" and then
tries all possible invocations. Actual results are compared to expected results,
which are calculated accordingly to "pre-actions" and invocation details.


Functionality Area
------------------
This area checks that the wizard correctly saves any valid configurations and
doesn't alter existing configuration when canceled.


Instructions
------------
1. Log on as a user who is an administrator on a machine.
2. Create a local user account and grant it "batch logon" privilege
3. Create a directory and copy following files:
   a. CfgWzrdVT.exe
   b. TestParams.ini
   c. t4ctrl.dll 
   d. elle.dll
   e. elle.ini
   f. mtview.exe
   g. mtview.ini
4. Edit [Strings] section of TestParams.ini file to reflect your settings
5. Edit [Devices] section of TestParams.ini file to reflect your settings
6. Edit other sections of TestParams.ini accordingly to planned test cases
7. From a command prompt start the suite: CfgWzrdVT <inifile>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\cfgwzrdvt\testparams.ini ===
[Areas]
Invocation = 1
Functionality = 1

[Invocation]
Clean = 1
Cancel = 1
ConfigureUI = 1
ConfigureAll = 1

[Functionality]
SaveSettings = 4
DontSaveWhenCanceled = 1

[ConfigureUI0]
Name = 2A0 => Fax User Name
FaxNumber = 2A0 => +972 (4) 1532
Email = 2A0 => FaxUser@FaxDomain.com
Title = 2A0 => Fax User Title
Company = 2A0 => Fax User Company
Office = 2A0 => Fax User Office
Department = 2A0 => Fax User Department
HomePhone = 2A0 => +999 (999) 9999999
WorkPhone = 2A0 => +888 (888) 8888888
BillingCode = 2A0 => Fax User Billing Code
Street = 2A0 => Fax User Street
City = 2A0 => Fax User City
State = 2A0 => Fax User State
Zip = 2A0 => Fax User ZIP
Country = Israel

[ConfigureAll0]
Type0 = 1
Type1 = 2
Priority0 = 1
Priority1 = 2
TSID = TSID 0
CSID = CSID 0
Rings = 3
PrinterEnabled = 1
FolderEnabled = 1
InboxEnabled = 1
PrinterName = \\haifasrv\HP LaserJet 4Si/4Si MX PS
FolderName = c:\faxes0
InboxName = MS Exchange Settings
Name = SaveSettings0 => Fax User Name
FaxNumber = SaveSettings0 => +972 (4) 1532
Email = SaveSettings0 => FaxUser@FaxDomain.com
Title = SaveSettings0 => Fax User Title
Company = SaveSettings0 => Fax User Company
Office = SaveSettings0 => Fax User Office
Department = SaveSettings0 => Fax User Department
HomePhone = SaveSettings0 => +999 (999) 9999999
WorkPhone = SaveSettings0 => +888 (888) 8888888
BillingCode = SaveSettings0 => Fax User Billing Code
Street = SaveSettings0 => Fax User Street
City = SaveSettings0 => Fax User City
State = SaveSettings0 => Fax User State
Zip = SaveSettings0 => Fax User ZIP
Country = China

[SaveSettings0]
Type0 = 1
Type1 = 2
Priority0 = 1
Priority1 = 2
TSID = TSID 0
CSID = CSID 0
Rings = 3
PrinterEnabled = 1
FolderEnabled = 1
InboxEnabled = 1
PrinterName = \\haifasrv\HP LaserJet 4Si/4Si MX PS
FolderName = c:\faxes0
InboxName = MS Exchange Settings
Name = SaveSettings0 => Fax User Name
FaxNumber = SaveSettings0 => +972 (4) 1532
Email = SaveSettings0 => FaxUser@FaxDomain.com
Title = SaveSettings0 => Fax User Title
Company = SaveSettings0 => Fax User Company
Office = SaveSettings0 => Fax User Office
Department = SaveSettings0 => Fax User Department
HomePhone = SaveSettings0 => +999 (999) 9999999
WorkPhone = SaveSettings0 => +888 (888) 8888888
BillingCode = SaveSettings0 => Fax User Billing Code
Street = SaveSettings0 => Fax User Street
City = SaveSettings0 => Fax User City
State = SaveSettings0 => Fax User State
Zip = SaveSettings0 => Fax User ZIP
Country = China

[SaveSettings1]
Type0 = 1
Type1 = 3
Priority0 = 2
Priority1 = 1
TSID = TSID 1
CSID = CSID 1
Rings = 7
PrinterEnabled = 0
FolderEnabled = 1
InboxEnabled = 0
PrinterName = AGFA-AccuSetSF v52.3
FolderName = c:\faxes1
InboxName =  MS Exchange Settings
Name = SaveSettings1 => Fax User Name
FaxNumber = SaveSettings1 => +972 (4) 1532
Email = SaveSettings1 => FaxUser@FaxDomain.com
Title = SaveSettings1 => Fax User Title
Company = SaveSettings1 => Fax User Company
Office = SaveSettings1 => Fax User Office
Department = SaveSettings1 => Fax User Department
HomePhone = SaveSettings1 => +999 (999) 9999999
WorkPhone = SaveSettings1 => +888 (888) 8888888
BillingCode = SaveSettings1 => Fax User Billing Code
Street = SaveSettings1 => Fax User Street
City = SaveSettings1 => Fax User City
State = SaveSettings1 => Fax User State
Zip = SaveSettings1 => Fax User ZIP
Country = Afganistan

[SaveSettings2]
Type0 = 0
Type1 = 0
Priority0 = 2
Priority1 = 1
TSID = TSID 2
CSID = CSID 2
Rings = 1
PrinterEnabled = 0
FolderEnabled = 1
InboxEnabled = 0
PrinterName = \\haifasrv\HP LaserJet 4Si/4Si MX PS
FolderName = c:\faxes2
InboxName =  MS Exchange Settings
Name = SaveSettings2 => Fax User Name
FaxNumber = SaveSettings2 => +972 (4) 1532
Email = SaveSettings2 => FaxUser@FaxDomain.com
Title = SaveSettings2 => Fax User Title
Company = SaveSettings2 => Fax User Company
Office = SaveSettings2 => Fax User Office
Department = SaveSettings2 => Fax User Department
HomePhone = SaveSettings2 => +999 (999) 9999999
WorkPhone = SaveSettings2 => +888 (888) 8888888
BillingCode = SaveSettings2 => Fax User Billing Code
Street = SaveSettings2 => Fax User Street
City = SaveSettings2 => Fax User City
State = SaveSettings2 => Fax User State
Zip = SaveSettings2 => Fax User ZIP
Country = Ghana

[SaveSettings3]
Type0 = 0
Type1 = 2
Priority0 = 2
Priority1 = 1
TSID = TSID 3
CSID = CSID 3
Rings = 1
PrinterEnabled = 1
FolderEnabled = 0
InboxEnabled = 0
PrinterName = \\haifasrv\HP LaserJet 4Si/4Si MX PS
FolderName = c:\faxes3
InboxName =  MS Exchange Settings
Name = SaveSettings3 => Fax User Name
FaxNumber = SaveSettings3 => +972 (4) 1532
Email = SaveSettings3 => FaxUser@FaxDomain.com
Title = SaveSettings3 => Fax User Title
Company = SaveSettings3 => Fax User Company
Office = SaveSettings3 => Fax User Office
Department = SaveSettings3 => Fax User Department
HomePhone = SaveSettings3 => +999 (999) 9999999
WorkPhone = SaveSettings3 => +888 (888) 8888888
BillingCode = SaveSettings3 => Fax User Billing Code
Street = SaveSettings3 => Fax User Street
City = SaveSettings3 => Fax User City
State = SaveSettings3 => Fax User State
Zip = SaveSettings3 => Fax User ZIP
Country = Nepal

[Devices]
Askey 56K Data Fax Voice Modem PnP
56K Data Fax Modem PnP

[Strings]
CommandLineClient = d:\windows\system32\fxsclnt.exe
CommandLineSendWzrd = d:\windows\system32\fxssend.exe
CommandLineCfgWzrd = d:\windows\system32\rundll32.exe FxsCfgWz.dll,FaxCfgWzrdDll
RegKeyNameDevicePart = SOFTWARE\Microsoft\Fax
RegKeyNameUserPart = SOFTWARE\Microsoft\Fax\Setup
RegValueNameDevice = CfgWzdrDevice
RegValueNameUser = CfgWzdrUserInfo
RegKeyNameUserInfo = SOFTWARE\Microsoft\Fax\UserInfo
RegValueNameUserName = FullName
RegValueNameFaxNumber = FaxNumber
RegValueNameEmail = Mailbox
RegValueNameTitle = Title
RegValueNameCompany = Company
RegValueNameOffice = Office
RegValueNameDepartment = Department
RegValueNameHomePhone = HomePhone
RegValueNameWorkPhone = OfficePhone
RegValueNameBillingCode = BillingCode
RegValueNameStreet = Address
RegValueNameCity = City
RegValueNameState = State
RegValueNameZip = ZIP
RegValueNameCountry = Country
Username = faxuser1
Password = LocalFax1
GuidPrintOn = {AEC1B37C-9AF2-11D0-ABF7-00C04FD91A4E}
GuidStoreInFolder = {92041A90-9AF2-11D0-ABF7-00C04FD91A4E}
ServiceName = Fax

Name = FaxRecipient
Number = 1532
Subject = This fax was used to configure user information
WindowCaptionClient = Fax Console
WindowCaptionSendWzrd = Send Fax Wizard
WindowCaptionCfgWzrd = Fax Configuration Wizard
WindowCaptionUserInfo = User Information
WindowCaptionAdminConsole = fxsadmin - [Fax (Local)]
EditSendWzrdName = To:
CheckboxSendWzrdDialAsEntered = Dial as entered
EditSendWzrdNumber = )
ListSendWzrdRecipients = To send to multiple recipients, type each recipient's information above, and then click Add to add that information to the list below.
ButtonSendWzrdRemove = Remove
ButtonSendWzrdAdd = Add
EditSendWzrdSubject = Subject line:
OptionSendWzrdNoReceipt = Don't notify
EditUserInfoName = +Full name
EditUserInfoFaxNumber = Fax number:
EditUserInfoEmail = +E-mail
EditUserInfoTitle = Title:
EditUserInfoCompany = Company:
EditUserInfoOffice = Office location:
EditUserInfoDepartment = Department:
EditUserInfoHomePhone = Home phone:
EditUserInfoWorkPhone = Work phone:
EditUserInfoBillingCode = Billing code:
ButtonUserInfoAddress = Address...
EditUserInfoStreet = Street:
EditUserInfoCity = City:
EditUserInfoState = State/Province:
EditUserInfoZip = ZIP/Postal code:
ComboboxUserInfoCountry = Country/Region:
CheckboxUserInfoThisOnly = Use the information for this transmission only
ButtonSendWzrdSenderInfo = Sender Info...
MenuClientUserInfo = Tools\User Information...
EditCfgWzrdName = Your full name:
ListCfgWzrdSendingDevices = Specify devices for sending faxes:
ButtonCfgWzrdUp = Up
ButtonCfgWzrdDown = Down
EditCfgWzrdAnswerAfter = Automatic answer after
EditCfgWzrdTSID = TSID:
StaticCfgWzrdNoDeviceSelected = If no device is selected
ListCfgWzrdReceivingDevices = Select devices used for receiving faxes:
EditCfgWzrdCSID = CSID:
CheckboxCfgWzrdPrintItOn = Print it on:
CheckboxCfgWzrdSaveInFolder = Store a copy in a folder:
ComboboxCfgWzrdPrintItOn = When a fax is received:
EditCfgWzrdSaveInFolder = When a fax is received:
StaticMsgBoxInternalErr = Configuration cannot be saved due to internal error.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxapi\faxapi.ini ===
[confgapi_u]
Dll_Path=confgapi_u.dll
Dll_Description=confgapi_u
Dll_Local_Cases=23
Dll_Server_Cases=23
Dll_Whis_Do_This_Set=1

[confgapi_a]
Dll_Path=confgapi_a.dll
Dll_Description=confgapi_a
Dll_Local_Cases=23
Dll_Server_Cases=23
Dll_Whis_Do_This_Set=1

[jobsapi_u]
Dll_Path=jobsapi_u.dll
Dll_Description=jobsapi_u
Dll_Local_Cases=34
Dll_Server_Cases=34
Dll_Whis_Do_This_Set=1

[jobsapi_a]
Dll_Path=jobsapi_a.dll
Dll_Description=jobsapi_a
Dll_Local_Cases=34
Dll_Server_Cases=34
Dll_Whis_Do_This_Set=1

[miscapi_u]
Dll_Path=miscapi_u.dll
Dll_Description=miscapi_u
Dll_Local_Cases=9
Dll_Server_Cases=9
Dll_Whis_Do_This_Set=1

[miscapi_a]
Dll_Path=miscapi_a.dll
Dll_Description=miscapi_a
Dll_Local_Cases=9
Dll_Server_Cases=9
Dll_Whis_Do_This_Set=1

[portsapi_u]
Dll_Path=portsapi_u.dll
Dll_Description=portsapi_u
Dll_Local_Cases=37
Dll_Server_Cases=37
Dll_Whis_Do_This_Set=1

[portsapi_a]
Dll_Path=portsapi_a.dll
Dll_Description=portsapi_a
Dll_Local_Cases=37
Dll_Server_Cases=37
Dll_Whis_Do_This_Set=1

[printapi_u]
Dll_Path=printapi_u.dll
Dll_Description=printapi_u
Dll_Local_Cases=57
Dll_Server_Cases=57
Dll_Whis_Do_This_Set=1

[printapi_a]
Dll_Path=printapi_a.dll
Dll_Description=printapi_a
Dll_Local_Cases=57
Dll_Server_Cases=57
Dll_Whis_Do_This_Set=1

[routeapi_u]
Dll_Path=routeapi_u.dll
Dll_Description=routeapi_u
Dll_Local_Cases=49
Dll_Server_Cases=49
Dll_Whis_Do_This_Set=1

[routeapi_a]
Dll_Path=routeapi_a.dll
Dll_Description=routeapi_a
Dll_Local_Cases=49
Dll_Server_Cases=49
Dll_Whis_Do_This_Set=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxdocs\printapi.txt ===
Volume in drive E is APPSnTST
 Volume Serial Number is A81E-EA21

 Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run

10/17/2000  03:56p      <DIR>          .
10/17/2000  03:56p      <DIR>          ..
10/16/2000  11:50a      <DIR>          bak
10/16/2000  02:30p                 106 build.log
04/23/2000  07:07p              13,676 confdent.cov
10/17/2000  02:18p              14,336 confgapi_a.dll
10/17/2000  02:18p             115,712 confgapi_a.pdb
10/17/2000  02:18p              19,456 confgapi_u.dll
10/17/2000  02:18p             123,904 confgapi_u.pdb
10/17/2000  03:38p                 854 coverpg.lnk
10/16/2000  12:38p               1,048 cpsrc.cmd
03/09/2000  01:01p              15,474 fax.tif
10/17/2000  02:18p              49,664 faxapi.exe
10/17/2000  02:34p               1,588 faxapi.ini
10/17/2000  03:55p               7,476 faxapi.log
10/17/2000  03:34p              44,544 faxapi.opt
10/17/2000  02:18p             369,664 faxapi.pdb
10/17/2000  02:19p              16,384 jobsapi_a.dll
10/17/2000  02:19p             115,712 jobsapi_a.pdb
10/17/2000  02:19p              21,504 jobsapi_u.dll
10/17/2000  02:19p             115,712 jobsapi_u.pdb
03/09/2000  01:01p             476,196 kodak.tif
10/17/2000  02:19p               6,144 miscapi_a.dll
10/17/2000  02:19p              99,328 miscapi_a.pdb
10/17/2000  02:19p               7,680 miscapi_u.dll
10/17/2000  02:19p              99,328 miscapi_u.pdb
10/17/2000  02:19p              16,896 portsapi_a.dll
10/17/2000  02:19p             115,712 portsapi_a.pdb
10/17/2000  02:19p              23,040 portsapi_u.dll
10/17/2000  02:19p             123,904 portsapi_u.pdb
10/17/2000  03:56p                   0 printapi.txt
10/17/2000  02:19p              18,944 printapi_a.dll
10/17/2000  02:19p             115,712 printapi_a.pdb
10/17/2000  02:19p              25,600 printapi_u.dll
10/17/2000  02:19p             123,904 printapi_u.pdb
10/17/2000  12:07p               4,608 routeapi.dll
10/17/2000  12:07p              74,752 routeapi.pdb
10/17/2000  02:19p              30,720 routeapi_a.dll
10/17/2000  02:19p             140,288 routeapi_a.pdb
10/17/2000  02:19p              41,472 routeapi_u.dll
10/17/2000  02:19p             140,288 routeapi_u.pdb
10/17/2000  10:28a      <DIR>          src
10/16/2000  11:31a               2,044 upd.cmd
              39 File(s)      2,733,374 bytes
               4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32\faxdocs\printapi.doc ===
Microsoft Word Document MSWordDoc Word.Document.8 Volume in drive E is APPSnTST Title Volume in drive E is APPSnTST Lior Shmueli Normal.dot Lior Shmueli Microsoft Word 9.0bjbjU  Volume in drive E is APPSnTST  Volume Serial Number is A81E-EA21  Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run 10/17/2000  03:56p      <DIR>          . 10/17/2000  03:56p      <DIR>          .. 10/16/2000  11:50a      <DIR>          bak 10/16/2000  02:30p                 106 build.log 04/23/2000  07:07p              13,676 confdent.cov 10/17/2000  02:18p              14,336 confgapi_a.dll 10/17/2000  02:18p             115,712 confgapi_a.pdb 10/17/2000  02:18p              19,456 confgapi_u.dll 10/17/2000  02:18p             123,904 confgapi_u.pdb 10/17/2000  03:38p                 854 coverpg.lnk 10/16/2000  12:38p               1,048 cpsrc.cmd 03/09/2000  01:01p              15,474 fax.tif 10/17/2000  02:18p              49,664 faxapi.exe 10/17/2000  02:34p               1,588 faxapi.ini 10/17/2000  03:55p               7,476 faxapi.log 10/17/2000  03:34p              44,544 faxapi.opt 10/17/2000  02:18p             369,664 faxapi.pdb 10/17/2000  02:19p              16,384 jobsapi_a.dll 10/17/2000  02:19p             115,712 jobsapi_a.pdb 10/17/2000  02:19p              21,504 jobsapi_u.dll 10/17/2000  02:19p             115,712 jobsapi_u.pdb 03/09/2000  01:01p             476,196 kodak.tif 10/17/2000  02:19p               6,144 miscapi_a.dll 10/17/2000  02:19p              99,328 miscapi_a.pdb 10/17/2000  02:19p               7,680 miscapi_u.dll 10/17/2000  02:19p              99,328 miscapi_u.pdb 10/17/2000  02:19p              16,896 portsapi_a.dll 10/17/2000  02:19p             115,712 portsapi_a.pdb 10/17/2000  02:19p              23,040 portsapi_u.dll 10/17/2000  02:19p             123,904 portsapi_u.pdb 10/17/2000  03:56p                   0 printapi.txt 10/17/2000  02:19p              18,944 printapi_a.dll 10/17/2000  02:19p             115,712 printapi_a.pdb 10/17/2000  02:19p              25,600 printapi_u.dll 10/17/2000  02:19p             123,904 printapi_u.pdb 10/17/2000  12:07p               4,608 routeapi.dll 10/17/2000  12:07p              74,752 routeapi.pdb 10/17/2000  02:19p              30,720 routeapi_a.dll 10/17/2000  02:19p             140,288 routeapi_a.pdb 10/17/2000  02:19p              41,472 routeapi_u.dll 10/17/2000  02:19p             140,288 routeapi_u.pdb 10/17/2000  10:28a      <DIR>          src 10/16/2000  11:31a               2,044 upd.cmd               39 File(s)      2,733,374 bytes                4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32_xml\faxdocs\printapi.txt ===
Volume in drive E is APPSnTST
 Volume Serial Number is A81E-EA21

 Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run

10/17/2000  03:56p      <DIR>          .
10/17/2000  03:56p      <DIR>          ..
10/16/2000  11:50a      <DIR>          bak
10/16/2000  02:30p                 106 build.log
04/23/2000  07:07p              13,676 confdent.cov
10/17/2000  02:18p              14,336 confgapi_a.dll
10/17/2000  02:18p             115,712 confgapi_a.pdb
10/17/2000  02:18p              19,456 confgapi_u.dll
10/17/2000  02:18p             123,904 confgapi_u.pdb
10/17/2000  03:38p                 854 coverpg.lnk
10/16/2000  12:38p               1,048 cpsrc.cmd
03/09/2000  01:01p              15,474 fax.tif
10/17/2000  02:18p              49,664 faxapi.exe
10/17/2000  02:34p               1,588 faxapi.ini
10/17/2000  03:55p               7,476 faxapi.log
10/17/2000  03:34p              44,544 faxapi.opt
10/17/2000  02:18p             369,664 faxapi.pdb
10/17/2000  02:19p              16,384 jobsapi_a.dll
10/17/2000  02:19p             115,712 jobsapi_a.pdb
10/17/2000  02:19p              21,504 jobsapi_u.dll
10/17/2000  02:19p             115,712 jobsapi_u.pdb
03/09/2000  01:01p             476,196 kodak.tif
10/17/2000  02:19p               6,144 miscapi_a.dll
10/17/2000  02:19p              99,328 miscapi_a.pdb
10/17/2000  02:19p               7,680 miscapi_u.dll
10/17/2000  02:19p              99,328 miscapi_u.pdb
10/17/2000  02:19p              16,896 portsapi_a.dll
10/17/2000  02:19p             115,712 portsapi_a.pdb
10/17/2000  02:19p              23,040 portsapi_u.dll
10/17/2000  02:19p             123,904 portsapi_u.pdb
10/17/2000  03:56p                   0 printapi.txt
10/17/2000  02:19p              18,944 printapi_a.dll
10/17/2000  02:19p             115,712 printapi_a.pdb
10/17/2000  02:19p              25,600 printapi_u.dll
10/17/2000  02:19p             123,904 printapi_u.pdb
10/17/2000  12:07p               4,608 routeapi.dll
10/17/2000  12:07p              74,752 routeapi.pdb
10/17/2000  02:19p              30,720 routeapi_a.dll
10/17/2000  02:19p             140,288 routeapi_a.pdb
10/17/2000  02:19p              41,472 routeapi_u.dll
10/17/2000  02:19p             140,288 routeapi_u.pdb
10/17/2000  10:28a      <DIR>          src
10/16/2000  11:31a               2,044 upd.cmd
              39 File(s)      2,733,374 bytes
               4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32_xml\faxdocs\printapi.doc ===
Microsoft Word Document MSWordDoc Word.Document.8 Volume in drive E is APPSnTST Title Volume in drive E is APPSnTST Lior Shmueli Normal.dot Lior Shmueli Microsoft Word 9.0bjbjU  Volume in drive E is APPSnTST  Volume Serial Number is A81E-EA21  Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run 10/17/2000  03:56p      <DIR>          . 10/17/2000  03:56p      <DIR>          .. 10/16/2000  11:50a      <DIR>          bak 10/16/2000  02:30p                 106 build.log 04/23/2000  07:07p              13,676 confdent.cov 10/17/2000  02:18p              14,336 confgapi_a.dll 10/17/2000  02:18p             115,712 confgapi_a.pdb 10/17/2000  02:18p              19,456 confgapi_u.dll 10/17/2000  02:18p             123,904 confgapi_u.pdb 10/17/2000  03:38p                 854 coverpg.lnk 10/16/2000  12:38p               1,048 cpsrc.cmd 03/09/2000  01:01p              15,474 fax.tif 10/17/2000  02:18p              49,664 faxapi.exe 10/17/2000  02:34p               1,588 faxapi.ini 10/17/2000  03:55p               7,476 faxapi.log 10/17/2000  03:34p              44,544 faxapi.opt 10/17/2000  02:18p             369,664 faxapi.pdb 10/17/2000  02:19p              16,384 jobsapi_a.dll 10/17/2000  02:19p             115,712 jobsapi_a.pdb 10/17/2000  02:19p              21,504 jobsapi_u.dll 10/17/2000  02:19p             115,712 jobsapi_u.pdb 03/09/2000  01:01p             476,196 kodak.tif 10/17/2000  02:19p               6,144 miscapi_a.dll 10/17/2000  02:19p              99,328 miscapi_a.pdb 10/17/2000  02:19p               7,680 miscapi_u.dll 10/17/2000  02:19p              99,328 miscapi_u.pdb 10/17/2000  02:19p              16,896 portsapi_a.dll 10/17/2000  02:19p             115,712 portsapi_a.pdb 10/17/2000  02:19p              23,040 portsapi_u.dll 10/17/2000  02:19p             123,904 portsapi_u.pdb 10/17/2000  03:56p                   0 printapi.txt 10/17/2000  02:19p              18,944 printapi_a.dll 10/17/2000  02:19p             115,712 printapi_a.pdb 10/17/2000  02:19p              25,600 printapi_u.dll 10/17/2000  02:19p             123,904 printapi_u.pdb 10/17/2000  12:07p               4,608 routeapi.dll 10/17/2000  12:07p              74,752 routeapi.pdb 10/17/2000  02:19p              30,720 routeapi_a.dll 10/17/2000  02:19p             140,288 routeapi_a.pdb 10/17/2000  02:19p              41,472 routeapi_u.dll 10/17/2000  02:19p             140,288 routeapi_u.pdb 10/17/2000  10:28a      <DIR>          src 10/16/2000  11:31a               2,044 upd.cmd               39 File(s)      2,733,374 bytes                4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32_xml\run\printapi.txt ===
Volume in drive E is APPSnTST
 Volume Serial Number is A81E-EA21

 Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run

10/17/2000  03:56p      <DIR>          .
10/17/2000  03:56p      <DIR>          ..
10/16/2000  11:50a      <DIR>          bak
10/16/2000  02:30p                 106 build.log
04/23/2000  07:07p              13,676 confdent.cov
10/17/2000  02:18p              14,336 confgapi_a.dll
10/17/2000  02:18p             115,712 confgapi_a.pdb
10/17/2000  02:18p              19,456 confgapi_u.dll
10/17/2000  02:18p             123,904 confgapi_u.pdb
10/17/2000  03:38p                 854 coverpg.lnk
10/16/2000  12:38p               1,048 cpsrc.cmd
03/09/2000  01:01p              15,474 fax.tif
10/17/2000  02:18p              49,664 faxapi.exe
10/17/2000  02:34p               1,588 faxapi.ini
10/17/2000  03:55p               7,476 faxapi.log
10/17/2000  03:34p              44,544 faxapi.opt
10/17/2000  02:18p             369,664 faxapi.pdb
10/17/2000  02:19p              16,384 jobsapi_a.dll
10/17/2000  02:19p             115,712 jobsapi_a.pdb
10/17/2000  02:19p              21,504 jobsapi_u.dll
10/17/2000  02:19p             115,712 jobsapi_u.pdb
03/09/2000  01:01p             476,196 kodak.tif
10/17/2000  02:19p               6,144 miscapi_a.dll
10/17/2000  02:19p              99,328 miscapi_a.pdb
10/17/2000  02:19p               7,680 miscapi_u.dll
10/17/2000  02:19p              99,328 miscapi_u.pdb
10/17/2000  02:19p              16,896 portsapi_a.dll
10/17/2000  02:19p             115,712 portsapi_a.pdb
10/17/2000  02:19p              23,040 portsapi_u.dll
10/17/2000  02:19p             123,904 portsapi_u.pdb
10/17/2000  03:56p                   0 printapi.txt
10/17/2000  02:19p              18,944 printapi_a.dll
10/17/2000  02:19p             115,712 printapi_a.pdb
10/17/2000  02:19p              25,600 printapi_u.dll
10/17/2000  02:19p             123,904 printapi_u.pdb
10/17/2000  12:07p               4,608 routeapi.dll
10/17/2000  12:07p              74,752 routeapi.pdb
10/17/2000  02:19p              30,720 routeapi_a.dll
10/17/2000  02:19p             140,288 routeapi_a.pdb
10/17/2000  02:19p              41,472 routeapi_u.dll
10/17/2000  02:19p             140,288 routeapi_u.pdb
10/17/2000  10:28a      <DIR>          src
10/16/2000  11:31a               2,044 upd.cmd
              39 File(s)      2,733,374 bytes
               4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32_xml\run\faxapi.ini ===
[global]
Whis_phone_num_1 = +972 (4) 5064
Whis_phone_num_2 = 5063
Whis_remote_server_name = 

[confgapi_u]
Dll_Path = confgapi_u.dll
Dll_Description = confgapi_u
Dll_Local_Cases = 23
Dll_Server_Cases = 23
Whis_Test_Mode = 0

[confgapi_a]
Dll_Path = confgapi_a.dll
Dll_Description = confgapi_a
Dll_Local_Cases = 23
Dll_Server_Cases = 23
Whis_Test_Mode = 0

[jobsapi_u]
Dll_Path = jobsapi_u.dll
Dll_Description = jobsapi_u
Dll_Local_Cases = 34
Dll_Server_Cases = 34
Whis_Test_Mode = 0

[jobsapi_a]
Dll_Path = jobsapi_a.dll
Dll_Description = jobsapi_a
Dll_Local_Cases = 34
Dll_Server_Cases = 34
Whis_Test_Mode = 0

[miscapi_u]
Dll_Path = miscapi_u.dll
Dll_Description = miscapi_u
Dll_Local_Cases = 9
Dll_Server_Cases = 9
Whis_Test_Mode = 0

[miscapi_a]
Dll_Path = miscapi_a.dll
Dll_Description = miscapi_a
Dll_Local_Cases = 9
Dll_Server_Cases = 9
Whis_Test_Mode = 0

[portsapi_u]
Dll_Path = portsapi_u.dll
Dll_Description = portsapi_u
Dll_Local_Cases = 37
Dll_Server_Cases = 37
Whis_Test_Mode = 0

[portsapi_a]
Dll_Path = portsapi_a.dll
Dll_Description = portsapi_a
Dll_Local_Cases = 37
Dll_Server_Cases = 37
Whis_Test_Mode = 0

[printapi_u]
Dll_Path = printapi_u.dll
Dll_Description = printapi_u
Dll_Local_Cases = 59
Dll_Server_Cases = 59
Whis_Test_Mode = 0

[printapi_a]
Dll_Path = printapi_a.dll
Dll_Description = printapi_a
Dll_Local_Cases = 59
Dll_Server_Cases = 59
Whis_Test_Mode = 0

[routeapi_u]
Dll_Path = routeapi_u.dll
Dll_Description = routeapi_u
Dll_Local_Cases = 49
Dll_Server_Cases = 49
Whis_Test_Mode = 1

[routeapi_a]
Dll_Path = routeapi_a.dll
Dll_Description = routeapi_a
Dll_Local_Cases = 49
Dll_Server_Cases = 49
Whis_Test_Mode = 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legwin32_whis_xml\faxdocs\printapi.txt ===
Volume in drive E is APPSnTST
 Volume Serial Number is A81E-EA21

 Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run

10/17/2000  03:56p      <DIR>          .
10/17/2000  03:56p      <DIR>          ..
10/16/2000  11:50a      <DIR>          bak
10/16/2000  02:30p                 106 build.log
04/23/2000  07:07p              13,676 confdent.cov
10/17/2000  02:18p              14,336 confgapi_a.dll
10/17/2000  02:18p             115,712 confgapi_a.pdb
10/17/2000  02:18p              19,456 confgapi_u.dll
10/17/2000  02:18p             123,904 confgapi_u.pdb
10/17/2000  03:38p                 854 coverpg.lnk
10/16/2000  12:38p               1,048 cpsrc.cmd
03/09/2000  01:01p              15,474 fax.tif
10/17/2000  02:18p              49,664 faxapi.exe
10/17/2000  02:34p               1,588 faxapi.ini
10/17/2000  03:55p               7,476 faxapi.log
10/17/2000  03:34p              44,544 faxapi.opt
10/17/2000  02:18p             369,664 faxapi.pdb
10/17/2000  02:19p              16,384 jobsapi_a.dll
10/17/2000  02:19p             115,712 jobsapi_a.pdb
10/17/2000  02:19p              21,504 jobsapi_u.dll
10/17/2000  02:19p             115,712 jobsapi_u.pdb
03/09/2000  01:01p             476,196 kodak.tif
10/17/2000  02:19p               6,144 miscapi_a.dll
10/17/2000  02:19p              99,328 miscapi_a.pdb
10/17/2000  02:19p               7,680 miscapi_u.dll
10/17/2000  02:19p              99,328 miscapi_u.pdb
10/17/2000  02:19p              16,896 portsapi_a.dll
10/17/2000  02:19p             115,712 portsapi_a.pdb
10/17/2000  02:19p              23,040 portsapi_u.dll
10/17/2000  02:19p             123,904 portsapi_u.pdb
10/17/2000  03:56p                   0 printapi.txt
10/17/2000  02:19p              18,944 printapi_a.dll
10/17/2000  02:19p             115,712 printapi_a.pdb
10/17/2000  02:19p              25,600 printapi_u.dll
10/17/2000  02:19p             123,904 printapi_u.pdb
10/17/2000  12:07p               4,608 routeapi.dll
10/17/2000  12:07p              74,752 routeapi.pdb
10/17/2000  02:19p              30,720 routeapi_a.dll
10/17/2000  02:19p             140,288 routeapi_a.pdb
10/17/2000  02:19p              41,472 routeapi_u.dll
10/17/2000  02:19p             140,288 routeapi_u.pdb
10/17/2000  10:28a      <DIR>          src
10/16/2000  11:31a               2,044 upd.cmd
              39 File(s)      2,733,374 bytes
               4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32_xml\run\printapi.doc ===
Microsoft Word Document MSWordDoc Word.Document.8 Volume in drive E is APPSnTST Title Volume in drive E is APPSnTST Lior Shmueli Normal.dot Lior Shmueli Microsoft Word 9.0bjbjU  Volume in drive E is APPSnTST  Volume Serial Number is A81E-EA21  Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run 10/17/2000  03:56p      <DIR>          . 10/17/2000  03:56p      <DIR>          .. 10/16/2000  11:50a      <DIR>          bak 10/16/2000  02:30p                 106 build.log 04/23/2000  07:07p              13,676 confdent.cov 10/17/2000  02:18p              14,336 confgapi_a.dll 10/17/2000  02:18p             115,712 confgapi_a.pdb 10/17/2000  02:18p              19,456 confgapi_u.dll 10/17/2000  02:18p             123,904 confgapi_u.pdb 10/17/2000  03:38p                 854 coverpg.lnk 10/16/2000  12:38p               1,048 cpsrc.cmd 03/09/2000  01:01p              15,474 fax.tif 10/17/2000  02:18p              49,664 faxapi.exe 10/17/2000  02:34p               1,588 faxapi.ini 10/17/2000  03:55p               7,476 faxapi.log 10/17/2000  03:34p              44,544 faxapi.opt 10/17/2000  02:18p             369,664 faxapi.pdb 10/17/2000  02:19p              16,384 jobsapi_a.dll 10/17/2000  02:19p             115,712 jobsapi_a.pdb 10/17/2000  02:19p              21,504 jobsapi_u.dll 10/17/2000  02:19p             115,712 jobsapi_u.pdb 03/09/2000  01:01p             476,196 kodak.tif 10/17/2000  02:19p               6,144 miscapi_a.dll 10/17/2000  02:19p              99,328 miscapi_a.pdb 10/17/2000  02:19p               7,680 miscapi_u.dll 10/17/2000  02:19p              99,328 miscapi_u.pdb 10/17/2000  02:19p              16,896 portsapi_a.dll 10/17/2000  02:19p             115,712 portsapi_a.pdb 10/17/2000  02:19p              23,040 portsapi_u.dll 10/17/2000  02:19p             123,904 portsapi_u.pdb 10/17/2000  03:56p                   0 printapi.txt 10/17/2000  02:19p              18,944 printapi_a.dll 10/17/2000  02:19p             115,712 printapi_a.pdb 10/17/2000  02:19p              25,600 printapi_u.dll 10/17/2000  02:19p             123,904 printapi_u.pdb 10/17/2000  12:07p               4,608 routeapi.dll 10/17/2000  12:07p              74,752 routeapi.pdb 10/17/2000  02:19p              30,720 routeapi_a.dll 10/17/2000  02:19p             140,288 routeapi_a.pdb 10/17/2000  02:19p              41,472 routeapi_u.dll 10/17/2000  02:19p             140,288 routeapi_u.pdb 10/17/2000  10:28a      <DIR>          src 10/16/2000  11:31a               2,044 upd.cmd               39 File(s)      2,733,374 bytes                4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legacywin32_xml\run\xml_case_manager.ppt ===
cHRM PLTE3 3333f33 ff3f3ffff 3ff33 L8IDATx 9nfYf kQff.n L,rr\ 0;0jZ2: RfHp3 ~.Y.P4 ^)>PI l?#30B (X'(a "i GF w\\\, @63C= `#99XX Av`L90 06351 q6(LD@Q  W333 8"DEE  " O0 AvC H vQQ)xE 2CR74  -D&f yY@c% t&HJw AZ!6CC@  :@]/P Yf`2` K!f1P 'O&^p 9!-1p2a b30\98Y !=#f> j1V`< K.n.y`* Z>FP= !F) fd xA%38[ r5/?( @w02h1 r>>-P\i .^.6VN ]NvV6` gmNPhs EEXyXE4D b<,bLL /CJbq }51Vq11H p &.& 5pC00 =v.P' n]`8qq ]@3&bL` B26;t b@k%E 0qQIP:3 .&QpY O&IFF )3h J AS$ G K#fHX AkID@ Zf``@ |1&&QPz >#$k0 @}@+A ZP\3B yQVhB rAmP0i H!$Q:3  $jD`i I(HZ! @SAU$0S P@j1j B{)LL )rA]2Ap D@}Oh) AK{eyxyD5 $(ukAZ Z>&Ap0  k"A3 0YY^Y hM-/h h#1D7 xi=hI./t RxxC, *xae d v<P;" ] gJK BBB|B` ^^^>X +D )[ ya=-Hq X;4qB 'T^!f 6n$K! t^!pvFu. AjiX[ Test Information Management Test Information Management The current situation: Application <- Manuel Testing <- ? Application <- Automatic Testing <- ? The XML-SQL solution Using latest technologies to transform raw information into hierarchical and organized schemas Using web based application to collect manual information.(not covered) Using web based applications to distribute information. How is it done  On the client (tester) side: Automated test: (test) Test Application -> XML log file (parse) XML log file -> DOM -> SQL Query (import) SQL Query -> Database record Manuel test: Results are reported directly to DB thru a Web application On the server (information consumer)side: Web application <- Database A Case Study: C API Test Application Information: 450 Cases * 2 Versions * N builds Old Version: Test reported to a huge text log file Log file was read to identify issues Old log files where stored to identify regressions New Version: Test reports to a XML log file A Parser transforms log file into a set of hierarchical elements and attributes (DOM).  Each test case is imported into a SQL DB as a record. A web application allows access, and performs analysis Case study: a test specific information schema Case Study: a test specific SQL Record A Test specific SQL record that describes a path from root to one terminal. Case study: a web interface Prn.dll C API Section name Build Valid case Case Name Passed Result Text Case Result Function id Test Information Management  Lior Shmueli C:\Program Files\Microsoft Office\Templates\Presentation Designs\Factory.pot Lior Shmueli Microsoft PowerPoint #)*)$*$$$$$$$$_ _______ _______ _______ _______ ___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<___<#)#)E++%$$$$$$ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_)))#**%++$$#$$___ ___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<)#*)$++%+%$$$$ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_))))$*%+%$$$EE_____ _______ _______ _______ _______ _______ ___<___<___<___<___<___<___<___<___<_______<___<___<___<___<___<___<___<___<___<___<___<___<___<___<)))#*$$$*$$$EE _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_< )#)$$$$ $$$$$h___ ___<___<_<_<___<_<_<___<_<_<_____<_<_______<___<_______<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_ ))$$$$#$$$$ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_ ___<_<_<_ _<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_< )#$#$ $$$$$$$n_ _______ _______ _______ _______ _______ _______<___<___<___<___<___<___<_______<_______<_______<___<___<___<___<___<___<___<___<___<___<___<_ $$$$$$ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_______ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_< $$$$$$h___ ___<___<___<___<___<___<___<___<___<_______________________<___<___<___<___<___<___<___<___<l <___<___<___ )$$$$$$$$$$$Eh _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<___ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_< <_<_<_<_<_< $$$$$$$$*%$$$h_____ _______ _______ _______ _______<_______<_______<_______<_______________________________________________<_______<_______ <_______<_ $$$$%*$++*E#DJ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_______________ _<_<_<_<_<_<_<_<_<_<_<_ <_<_<_<_< $$*$*+*++*DDDg___ ___<___<___<___<___<___<___<___<___________________________________<___<___<___<___<___<___ <___<___ $$++*+*+#C _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<___<_______ _<_<_<_<_<_<_<_<_<_<_<_<_< <_<_<_ #$$$++**C=CCDg_ _______ _______ _______ _______ ______________________________________________________________________________________________ $$+%+*D=" _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_______________ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ $$%+++ECC>CC=D___ _________________________________________________________________________________________ $+++++#D=CCD _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<___<_______ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_< $%*,2K##C>CD=g_____ _______ _______ _______ _______ ____________________________________________________________________________________________ $LR1+$$DCC"= ___<___<___ ___<___<___<___<___<___<_<_<___<___<_______________ _<___<___<___<_ _<___<___<_ %nLR$KKJ CD___ _______________________________________<_________________________________________________ _______ ELRnJEDE C>__<_ ___<___<___<___<___<___<___<___<___<_<_<_<_<_<_<___<_______ ___<___<___<_ $RSEhmgJ >_________ _______ _______ _______________________________________<___________________________________________________ $RLmmgmngC==CD__ _________________________________________<___<___<_______________ _____________________ $2*mg mlC==C___ _______ ___________ _______________________________________________________________________________________ gC=f__ _______ ___<___ _____<_______<_______<_______<_______<_<_<_<_<_<_<___<_______ _______<_______<_______<_ DKKgm_=g D=CC_____ _______ _______________ ___________________________________________________________________________________________ DKKgC=<_<`CC`D _________ _________ _____________________________________<_<_<_<___<___<_______________ _____________________ DDJmg<<=<C`==D___ ___________ _______________ _______________________________________<___<_______________________________________________ DDggf==<B<C=CD__ _<_<_<_<_<_<_<_<_<_<___<_______ "gJgC<<_===CC_________________ _________________________________________________________________________________________________________ =DggC<`<C< CD______________ _________________________________________________________<_<_<___<___<__________________________________e Cf=<<_<==CC_______________ ___________________________________________________________________________________________________________ =`<=<`CC=D__ _<_<_<_ _<_<_<_<_<_<_<_<___<___ C===<_=====_____________________________________________________________________________<_____________________________________________ =`C`<<DDCD ___<_<_<___ _<_<_<_ _<_<___ ___<_______ C==<=`C CDC___________________________________________________________________________<___<___<___________________________ "=f==<= _<___ _<_<_<_ _<_<_<_<_<_<_ >===`<C="=C ____________________________________________________________________________<_______________________________ "===<=== ___________ ___<_<_<___ ___<_<_<_<_<_<_ ==f== __________________________________________________________________________<_______________________________ ggg===C _____<___ _<___<_<_ _<_<_<_<_ CDggl>= ________ _____________________________________________________________________________________________________________ #gfggECC=Cm _______<___<___<___<_<_<_<_<_<_<_<_ #=DgJmmKCJJn ______ _______ _______ _______ _______________________________<_______ _______ _______ _______ _______ _______ ##CDgnEJmnnm ___<___<___<_<_<_<_<_<_<_<_<_ CgJgmEnJnJ ___________________________________________________________________________<_________________________________ CCfDmKmJnmn _____ ___________________<___<_<_<_<_<_<_ _<_<_<_ gJEnJnJ _______ _______ _______________________________________________________<_______ _______ _______ _______ #CDCDgDJmJmn ___________<___<___<___<_<_<_<_<_<_<_<_<_<_<_ "D##DCgCDJnJhJ _______ ___________________________________________________________________________________________________ ###DCfDfJJDmJm _______________<___<___<___<_<_<_<_<_<_<_<_<_<_ "##DCCgKJgJJK _______________________________________________<___<___ DDfJKDKKKnJ _______ ___<___<___<_<_<_<_<_<_<_<_<_ D##DCnD*K0QKJ ___________________________________________________________________________________________________ ###CCDJK$KRKKm _______________________________<___<_<_<_<_ D*##DDKK**0QKJ _______________________________________________ #D#DD)KE*KKKJn ___________<___<___<___<_<_<_<_ D*D#JDDKDEmKKJ _______ _______ _______________________________________________ _______ _______ _______________ _______ _____ *ED*J$KK+)KJKg _______________<___<___<___<_<_<_ _<_<_<_ *D**EJD0+KmJ _______________________________________________ _______ +*E1KKEK+KD _______ ___<___<_<_<_<_<_<_<_<_<_ _<_<_<_ +JK1KJK*2*mDlD _________________________________________________ _________________________________________________________ ______ K*E+KKKKKKnKgJ <_<_<_ _<_<_ $JE*KJnKKRRL __________ ______ _____ _______ ___<___ KE*+KKKnKtRt ___<__ <_<_<_ ___<_<_ _<_<_<_ $KK+QnKnKRtt ____________________ _____________________l _________ $KK2LKnsnt ___<___<_<_<_<_<_<_ 1L1RQoQon _______ _______ _______________<______ _______ LR12Qnnsn _______ ___<___<___ _____ _<___<___<_<_<_<_<_ 11R2nsnt ________________ ____________________________________________________________ _____________________________________ R121Rnnst ___________________________ _____ _______________<___<_<_<_<_<_ _<_<_<_ nLn2sn ___________________________________________________________________________________________________________<___<__________ KL#$tos _<_<_ ___________<___<_ _______<___<___<_<_<_<_<_<_<_<_ _________ ____________________________________________________________________________________________________________________________ __<_<_ _<_<___ _______________<___<___ ___________________<___<_<_<_<_<_<_ $#$ns _<___<______________________________________________________________________________________________________________________________ #LtnsnnmmmK _<_<_<_ _<_<_<_ _______ ___<___<_ _______<___<___<_<_<_ #ttsnsnCgmm _____ _<___ _____ _________ _____ _____ ____________________ $#$ttnnnCCe<m _<_<___<__ _______ #LRsnsD _______ _________ ______________ _____ _____ _______ ____________________ KtonD#CCCfD ___<_<_ <____ ___$#$$#KKD"DfCCD _____<___<_ _______ ______________ _____ ______ _______ ____________________$**+$$#D#DCCfJ _<_<_< <_<_< __<_<_<_<_ _*L2++$Kn#DgDDD _______<___ ___________________ ______________ _____________ ___________________________________ _____________________________________________+11+*KKnKD)DKE _<_<___<_______ _______<___<___<_<_<___ ___LR1RRLonDKEK$K_________________________________________________________________ ________________________________________ _____________________________________K21ntsKnD*KKK*______________<_<___<___________________ _____ _________ _____________________________ _________________________________________LKoRtLKnnoSRKK_______________________________________________ ___________________ _________________________________________________________________________KEKhLKnmnKRKEE______________<_<_<___<_______ _________ _____ _______________ _______<___________________hEKEKLhnhnLKED___________________________________________________________________ _________________________________________________________________________KL+hLnnhmo$EDD________<_<_<___<___<___________ ___________ ___________ _______ _________________________________ELLKnK mhnEKEg_______________________________________________________ _________ __________ _____ ______________________________________________________KoKhLnhh nnonD__<___<_<_<_<_<___<_______ _<___<___ _<___<___ _______<___<___<___<___KLLKnK mhmnnog_______________________________________________________ _______ ________ ___________________________________________________________nKnEonh gnmD<___<___<___<___________________ ___<___<___<_ ___<__ ___<___ _______________________<___<___<_tnoKnnnn nJgEg_______________________________________________________ _____ ______ ____________________________________________________________ onnoKngnnLEKE<_<___<_<_<___<_______ _<___<_<_<___<_ _<_<_<_ ___<_<_<___<_<_<___<_<_ snEnLnnhnoKJE_________________________________________________________ _____________________________________________________________ononnhng nRnEh<_<_<___<_<_<___________ ___<_<_<___ ___<_<_<___<_<_ ___<___<_<_<___<_<_<___<_onnngn nhKLKnD___________________________________________ _____________ _________ ______________________________________________nnKhm ngDggnDh<_<_<_<_<_<___<_<_ _<_<_ _<_<_<_<_<_ _<_<_< _<_<_ _<_<_<___ ___<_<_<_<_<_<_<_<_<_<_nnhnhmgngggDnE_________________________________________________ _______ _________________________________________________KhnDghhngmEmKg<_<_<_<_<_<_<_<_<_______ _<_<_<_<_ _<_<_ _<_<_<_ _<_<_<_<_____<_<_<_<_<_<_<_<_<_<_DhnhggJghEgghD___<___<___<___<_______________________<___<___ _______<___<_______<___<_______<___<___<___<___<__EnEngEhggngntg<_<_<_<_<_<_<_<_<_ ___<_ _<_<_ _<_<_<_<_ _<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_KghJDhKhhhnttD_____<_______<_______<_______<_______________<___ _______<_______________<_______<_______<_______<____EJEhghEEnn g<_<_<_<_<_<_<_ ___<_<_<_ _<_<_<_ _<_<_<_<_<_ _<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_gEgLEEFnhn ttm__<___<___<___<___<___<_______<___<___<___<___<___ ___<___<___<___<_______<___<___<___<___<___<___<___<__EmEgLiEEnttyto<_<_<_<_<_<_<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_ <_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_nDhKELEiKnotLn_<___<___<___<___<___<_______<___<___<___<___<___<___ __<___<___<___<___<___<___<___<___<___<___<___<___<___<EhKLFFKFEFKLhKnn<_<_<_<_<_<_<_<_<_<_<_<___<_<_<_<_<_<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_nDnEnLFKFEEEEK_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_ ___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<_<___<_<DhDKEFFEhL%FKEsn<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ <_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_hKgFLLLFEE+KEEo<___<___<___<___<___<___<___<___<___<_______ <___<___<___<___<___<___<___<___<___<___<___<DgEnEDF nhLKED<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_EgEDghLhnKLKE?_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<___ <_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<gggDgEEggn?FEE<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ _<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_ On-screen Show Lior Shmueli Times New Roman Times New Roman (Hebrew) Arial Arial Narrow Wingdings Lucida Console Factory Test Information Management Test Information Management  The XML-SQL solution  How is it done   A Case Study: C API Test Application  Case study: a test specific information schema Case Study: a test specific SQL Record Case study: a web interface Fonts Used Design Template Slide Titles Lior Shmueli
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legwin32_whis_xml\faxdocs\printapi.doc ===
Microsoft Word Document MSWordDoc Word.Document.8 Volume in drive E is APPSnTST Title Volume in drive E is APPSnTST Lior Shmueli Normal.dot Lior Shmueli Microsoft Word 9.0bjbjU  Volume in drive E is APPSnTST  Volume Serial Number is A81E-EA21  Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run 10/17/2000  03:56p      <DIR>          . 10/17/2000  03:56p      <DIR>          .. 10/16/2000  11:50a      <DIR>          bak 10/16/2000  02:30p                 106 build.log 04/23/2000  07:07p              13,676 confdent.cov 10/17/2000  02:18p              14,336 confgapi_a.dll 10/17/2000  02:18p             115,712 confgapi_a.pdb 10/17/2000  02:18p              19,456 confgapi_u.dll 10/17/2000  02:18p             123,904 confgapi_u.pdb 10/17/2000  03:38p                 854 coverpg.lnk 10/16/2000  12:38p               1,048 cpsrc.cmd 03/09/2000  01:01p              15,474 fax.tif 10/17/2000  02:18p              49,664 faxapi.exe 10/17/2000  02:34p               1,588 faxapi.ini 10/17/2000  03:55p               7,476 faxapi.log 10/17/2000  03:34p              44,544 faxapi.opt 10/17/2000  02:18p             369,664 faxapi.pdb 10/17/2000  02:19p              16,384 jobsapi_a.dll 10/17/2000  02:19p             115,712 jobsapi_a.pdb 10/17/2000  02:19p              21,504 jobsapi_u.dll 10/17/2000  02:19p             115,712 jobsapi_u.pdb 03/09/2000  01:01p             476,196 kodak.tif 10/17/2000  02:19p               6,144 miscapi_a.dll 10/17/2000  02:19p              99,328 miscapi_a.pdb 10/17/2000  02:19p               7,680 miscapi_u.dll 10/17/2000  02:19p              99,328 miscapi_u.pdb 10/17/2000  02:19p              16,896 portsapi_a.dll 10/17/2000  02:19p             115,712 portsapi_a.pdb 10/17/2000  02:19p              23,040 portsapi_u.dll 10/17/2000  02:19p             123,904 portsapi_u.pdb 10/17/2000  03:56p                   0 printapi.txt 10/17/2000  02:19p              18,944 printapi_a.dll 10/17/2000  02:19p             115,712 printapi_a.pdb 10/17/2000  02:19p              25,600 printapi_u.dll 10/17/2000  02:19p             123,904 printapi_u.pdb 10/17/2000  12:07p               4,608 routeapi.dll 10/17/2000  12:07p              74,752 routeapi.pdb 10/17/2000  02:19p              30,720 routeapi_a.dll 10/17/2000  02:19p             140,288 routeapi_a.pdb 10/17/2000  02:19p              41,472 routeapi_u.dll 10/17/2000  02:19p             140,288 routeapi_u.pdb 10/17/2000  10:28a      <DIR>          src 10/16/2000  11:31a               2,044 upd.cmd               39 File(s)      2,733,374 bytes                4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legwin32_whis_xml\run\printapi.txt ===
Volume in drive E is APPSnTST
 Volume Serial Number is A81E-EA21

 Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run

10/17/2000  03:56p      <DIR>          .
10/17/2000  03:56p      <DIR>          ..
10/16/2000  11:50a      <DIR>          bak
10/16/2000  02:30p                 106 build.log
04/23/2000  07:07p              13,676 confdent.cov
10/17/2000  02:18p              14,336 confgapi_a.dll
10/17/2000  02:18p             115,712 confgapi_a.pdb
10/17/2000  02:18p              19,456 confgapi_u.dll
10/17/2000  02:18p             123,904 confgapi_u.pdb
10/17/2000  03:38p                 854 coverpg.lnk
10/16/2000  12:38p               1,048 cpsrc.cmd
03/09/2000  01:01p              15,474 fax.tif
10/17/2000  02:18p              49,664 faxapi.exe
10/17/2000  02:34p               1,588 faxapi.ini
10/17/2000  03:55p               7,476 faxapi.log
10/17/2000  03:34p              44,544 faxapi.opt
10/17/2000  02:18p             369,664 faxapi.pdb
10/17/2000  02:19p              16,384 jobsapi_a.dll
10/17/2000  02:19p             115,712 jobsapi_a.pdb
10/17/2000  02:19p              21,504 jobsapi_u.dll
10/17/2000  02:19p             115,712 jobsapi_u.pdb
03/09/2000  01:01p             476,196 kodak.tif
10/17/2000  02:19p               6,144 miscapi_a.dll
10/17/2000  02:19p              99,328 miscapi_a.pdb
10/17/2000  02:19p               7,680 miscapi_u.dll
10/17/2000  02:19p              99,328 miscapi_u.pdb
10/17/2000  02:19p              16,896 portsapi_a.dll
10/17/2000  02:19p             115,712 portsapi_a.pdb
10/17/2000  02:19p              23,040 portsapi_u.dll
10/17/2000  02:19p             123,904 portsapi_u.pdb
10/17/2000  03:56p                   0 printapi.txt
10/17/2000  02:19p              18,944 printapi_a.dll
10/17/2000  02:19p             115,712 printapi_a.pdb
10/17/2000  02:19p              25,600 printapi_u.dll
10/17/2000  02:19p             123,904 printapi_u.pdb
10/17/2000  12:07p               4,608 routeapi.dll
10/17/2000  12:07p              74,752 routeapi.pdb
10/17/2000  02:19p              30,720 routeapi_a.dll
10/17/2000  02:19p             140,288 routeapi_a.pdb
10/17/2000  02:19p              41,472 routeapi_u.dll
10/17/2000  02:19p             140,288 routeapi_u.pdb
10/17/2000  10:28a      <DIR>          src
10/16/2000  11:31a               2,044 upd.cmd
              39 File(s)      2,733,374 bytes
               4 Dir(s)   1,165,549,568 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legwin32_whis_xml\run\faxapi.ini ===
[global]
Whis_phone_num_1 = +972 (4) 5064
Whis_phone_num_2 = 5063
Whis_remote_server_name = 

[confgapi_u]
Dll_Path = confgapi_u.dll
Dll_Description = confgapi_u
Dll_Local_Cases = 23
Dll_Server_Cases = 23
Whis_Test_Mode = 1

[confgapi_a]
Dll_Path = confgapi_a.dll
Dll_Description = confgapi_a
Dll_Local_Cases = 23
Dll_Server_Cases = 23
Whis_Test_Mode = 1

[jobsapi_u]
Dll_Path = jobsapi_u.dll
Dll_Description = jobsapi_u
Dll_Local_Cases = 34
Dll_Server_Cases = 34
Whis_Test_Mode = 1

[jobsapi_a]
Dll_Path = jobsapi_a.dll
Dll_Description = jobsapi_a
Dll_Local_Cases = 34
Dll_Server_Cases = 34
Whis_Test_Mode = 1

[miscapi_u]
Dll_Path = miscapi_u.dll
Dll_Description = miscapi_u
Dll_Local_Cases = 9
Dll_Server_Cases = 9
Whis_Test_Mode = 1

[miscapi_a]
Dll_Path = miscapi_a.dll
Dll_Description = miscapi_a
Dll_Local_Cases = 9
Dll_Server_Cases = 9
Whis_Test_Mode = 1

[portsapi_u]
Dll_Path = portsapi_u.dll
Dll_Description = portsapi_u
Dll_Local_Cases = 37
Dll_Server_Cases = 37
Whis_Test_Mode = 1

[portsapi_a]
Dll_Path = portsapi_a.dll
Dll_Description = portsapi_a
Dll_Local_Cases = 37
Dll_Server_Cases = 37
Whis_Test_Mode = 1

[printapi_u]
Dll_Path = printapi_u.dll
Dll_Description = printapi_u
Dll_Local_Cases = 59
Dll_Server_Cases = 59
Whis_Test_Mode = 1

[printapi_a]
Dll_Path = printapi_a.dll
Dll_Description = printapi_a
Dll_Local_Cases = 59
Dll_Server_Cases = 59
Whis_Test_Mode = 1

[routeapi_u]
Dll_Path = routeapi_u.dll
Dll_Description = routeapi_u
Dll_Local_Cases = 49
Dll_Server_Cases = 49
Whis_Test_Mode = 1

[routeapi_a]
Dll_Path = routeapi_a.dll
Dll_Description = routeapi_a
Dll_Local_Cases = 49
Dll_Server_Cases = 49
Whis_Test_Mode = 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legwin32_whis_xml\run\printapi.doc ===
Microsoft Word Document MSWordDoc Word.Document.8 Volume in drive E is APPSnTST Title Volume in drive E is APPSnTST Lior Shmueli Normal.dot Lior Shmueli Microsoft Word 9.0bjbjU  Volume in drive E is APPSnTST  Volume Serial Number is A81E-EA21  Directory of E:\nt\private\WhistlerFax\faxtest\src\W2KTests\run 10/17/2000  03:56p      <DIR>          . 10/17/2000  03:56p      <DIR>          .. 10/16/2000  11:50a      <DIR>          bak 10/16/2000  02:30p                 106 build.log 04/23/2000  07:07p              13,676 confdent.cov 10/17/2000  02:18p              14,336 confgapi_a.dll 10/17/2000  02:18p             115,712 confgapi_a.pdb 10/17/2000  02:18p              19,456 confgapi_u.dll 10/17/2000  02:18p             123,904 confgapi_u.pdb 10/17/2000  03:38p                 854 coverpg.lnk 10/16/2000  12:38p               1,048 cpsrc.cmd 03/09/2000  01:01p              15,474 fax.tif 10/17/2000  02:18p              49,664 faxapi.exe 10/17/2000  02:34p               1,588 faxapi.ini 10/17/2000  03:55p               7,476 faxapi.log 10/17/2000  03:34p              44,544 faxapi.opt 10/17/2000  02:18p             369,664 faxapi.pdb 10/17/2000  02:19p              16,384 jobsapi_a.dll 10/17/2000  02:19p             115,712 jobsapi_a.pdb 10/17/2000  02:19p              21,504 jobsapi_u.dll 10/17/2000  02:19p             115,712 jobsapi_u.pdb 03/09/2000  01:01p             476,196 kodak.tif 10/17/2000  02:19p               6,144 miscapi_a.dll 10/17/2000  02:19p              99,328 miscapi_a.pdb 10/17/2000  02:19p               7,680 miscapi_u.dll 10/17/2000  02:19p              99,328 miscapi_u.pdb 10/17/2000  02:19p              16,896 portsapi_a.dll 10/17/2000  02:19p             115,712 portsapi_a.pdb 10/17/2000  02:19p              23,040 portsapi_u.dll 10/17/2000  02:19p             123,904 portsapi_u.pd